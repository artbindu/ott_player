{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;;AAAA,IAAMA,SAAS,GAAG;EACd,MAAM,EAAE,CACJ;IACIC,KAAK,EAAE,yCAAyC;IAChDC,WAAW,EAAE;EACjB,CAAC,EACD;IACID,KAAK,EAAE,kDAAkD;IACzDC,WAAW,EAAE;EACjB,CAAC,EACD;IACID,KAAK,EAAE,6BAA6B;IACpCC,WAAW,EAAE;EACjB,CAAC,EACD;IACID,KAAK,EAAE,0DAA0D;IACjEC,WAAW,EAAE;EACjB,CAAC,EACD;IACID,KAAK,EAAE,iEAAiE;IACxEC,WAAW,EAAE;EACjB,CAAC,EACD;IACID,KAAK,EAAE,6DAA6D;IACpEC,WAAW,EAAE;EACjB,CAAC,EACD;IACID,KAAK,EAAE,iDAAiD;IACxDC,WAAW,EAAE;EACjB,CAAC,EACD;IACID,KAAK,EAAE,gBAAgB;IACvBC,WAAW,EAAE,kFAAkF;IAC/FC,UAAU,EAAE;MACRC,SAAS,EAAE;QACPC,KAAK,EAAE,2DAA2D;QAClEC,QAAQ,EAAE,CAAC;QACXC,gBAAgB,EAAE;UACd,iBAAiB,EAAE;QACvB;MACJ,CAAC;MACDC,QAAQ,EAAE;QACNH,KAAK,EAAE,0DAA0D;QACjEC,QAAQ,EAAE,CAAC;QACXC,gBAAgB,EAAE;UACd,iBAAiB,EAAE;QACvB;MACJ,CAAC;MACDE,QAAQ,EAAE;IACd;EACJ,CAAC,CACJ;EACDC,GAAG,EAAE,CACD;IACIT,KAAK,EAAE,iCAAiC;IACxCC,WAAW,EAAE;EACjB,CAAC,EACD;IAAED,KAAK,EAAE,qBAAqB;IAAEU,GAAG,EAAE;EAAuG,CAAC,EAC7I;IAAEV,KAAK,EAAE,WAAW;IAAEU,GAAG,EAAE;EAAuG,CAAC,EACnI;IAAEV,KAAK,EAAE,UAAU;IAAEU,GAAG,EAAE;EAAuG,CAAC,EAClI;IAAEV,KAAK,EAAE,kBAAkB;IAAEU,GAAG,EAAE;EAAsE,CAAC,EACzG;IAAEV,KAAK,EAAE,kBAAkB;IAAEU,GAAG,EAAE;EAAwE,CAAC,EAC3G;IAAEV,KAAK,EAAE,gBAAgB;IAAEU,GAAG,EAAE;EAAsF,CAAC,EACvH;IAAEV,KAAK,EAAE,yBAAyB;IAAEU,GAAG,EAAE;EAA4F,CAAC,EACtI;IAAEV,KAAK,EAAE,0BAA0B;IAAEU,GAAG,EAAE;EAA8F,CAAC,EACzI;IAAEV,KAAK,EAAE,kBAAkB;IAAEU,GAAG,EAAE;EAAoJ,CAAC,EACvL;IAAEV,KAAK,EAAE,kBAAkB;IAAEU,GAAG,EAAE;EAAuI,CAAC,EAC1K;IAAEV,KAAK,EAAE,qBAAqB;IAAEU,GAAG,EAAE;EAAmJ,CAAC;AAEjM,CAAC;AAED,+DAAeX,SAAS,E;;;;;;;;;;;ACvExB;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,QAAQ;AACnB;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiD;AACjD;AACA;AACA;AACA;AACA,cAAc,UAAU;AACxB,qBAAqB,sBAAsB;AAC3C;AACA;AACA,WAAW,kBAAkB;AAC7B,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA,QAAQ,0DAAU;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;;;;;;;;;;;;;;;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2DAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgD;AACV;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sDAAM;AACd;AACA;AACA;AACA,eAAe,2DAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,2DAAW;AAC9C,qBAAqB,2DAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAKkJ;;;;;;;;;;;;;;;;;AC7InJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyB;AACuB;AAChD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS,yDAAS;AAClB,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6B;;;;;;;;;;;;;;;;ACxC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACe;AACf,YAAY,0DAAU;AACtB;;;;;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACO;AACP,QAAQ,8DAAc;AACtB;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgD;AACM;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACe;AACf,SAAS,yDAAS;AAClB;AACA;AACA,2BAA2B,mEAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AChDyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACe;AACf,YAAY,uDAAO,KAAK,8DAAc,KAAK,2DAAW,KAAK,4DAAY;AACvE;;;;;;;;;;;;;ACrBqD;AACrD;AACA;AACA;AACA;AACA;AACA,4CAA4C,8DAAc;AAC1D,+DAAe,kCAAkC,EAAC;;;;;;;;;;;;;;;;ACPlD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyB;AACzB;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyB;AACqC;AAC9D;AACA;AACA,WAAW,kBAAkB;AAC7B;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB,SAAS,uEAAiB;AAC1B,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA,oBAAoB,aAAa;AACjC,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;AACA;AACA,wBAAwB,4CAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4B;AACiC;AACiB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,wBAAwB;AACnC,aAAa;AACb;AACe;AACf,iCAAiC,6DAAa;AAC9C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,oEAAgB;AAClC;AACA;AACA;AACA,+BAA+B,oEAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG,eAAe,QAAQ;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oEAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACrGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkD;AACK;AACvD;AACO,wBAAwB,2DAAM,CAAC,gEAAS;;;;;;;;;;;;;;;AClB/C;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACwD;AACY;AACV;AACD;AACT;AACqB;AACrE,kCAAkC,4DAAY;AAC9C;AACA;AACA;AACA;AACA;AACA,4CAA4C,6DAAa;AACzD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0DAAmB;AAC/B;AACA;AACA,aAAa;AACb,YAAY,wDAAiB;AAC7B;AACA;AACA,aAAa;AACb,YAAY,wDAAiB;AAC7B;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA,iBAAiB,uEAAiB;AAClC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8EAAsB;AAClC;AACA;AACA,8BAA8B,8EAAsB;AACpD;AACA;AACA,eAAe,gEAAa;AAC5B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA,YAAY,8EAAsB;AAClC;AACA;AACA;AACA,mBAAmB,8EAAsB;AACzC;AACA,eAAe,8EAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkC;;;;;;;;;;;;;;;;;;ACpJlC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;AACG;AACzD;AACA,QAAQ,eAAe,EAAE,2DAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACmC;AACpB;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAa;AAC5B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;AACtD;AACA,QAAQ,cAAc,EAAE,2DAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACkC;;;;;;;;;;;;;;;;;;;;;;ACzBlC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;AACE;AACY;AAC7B;AACmB;AACD;AACzD;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,4DAAY;AACnD;AACA;AACA;AACA;AACA;AACA,6BAA6B,mDAAI,EAAE;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,IAAI;AAClE,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA,mDAAmD,IAAI;AACvD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,gEAAS;AACrD;AACA,gCAAgC,4DAAa;AAC7C;AACA,gCAAgC,4DAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAa;AAC5B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,YAAY,uEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA,YAAY,uEAAiB;AAC7B;AACA;AACA,aAAa,uEAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACpKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACwD;AACjB;AACa;AACK;AACe;AACK;AAC7E;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,WAAW,8DAAU;AACrB;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,aAAa;AACxB,aAAa;AACb;AACA;AACA,WAAW,gEAAa;AACxB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,4DAAY;AAChD;AACA,eAAe,kBAAkB;AACjC,eAAe,QAAQ;AACvB,eAAe,wBAAwB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mDAAI;AAClC,6BAA6B,mDAAI,EAAE;AACnC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,yEAAyB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,8CAA8C,IAAI;AAClD,SAAS;AACT;AACA;AACA;AACA,qDAAqD,IAAI;AACzD,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,YAAY,sFAA0B;AACtC;AACA;AACA;AACA,8BAA8B,sFAA0B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf,QAAQ,sFAA0B;AAClC;AACA;AACA,4BAA4B,sFAA0B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AChNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;AACtD;AACA,QAAQ,kBAAkB,EAAE,2DAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACsC;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzBI;AACF;AACW;AACV;AACwB;AACZ;AACP;AACqB;AACU;AACT;AACqC;AACW;AACG;AACvC;AACe;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAAe,wBAAwB,EAAC;AACxC;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,4EAA2B;AACpE;AACA,SAAS,sDAAM,KAAK,uEAAiB;AACrC;AACA,sBAAsB,+EAA6B;AACnD;AACA;AACA;AACA;AACA;AACA,6CAA6C,yGAA0B;AACvE,8BAA8B,iFAA2B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kGAAuB,OAAO,2DAAW;AACzD,8BAA8B,+EAA6B;AAC3D,kCAAkC,qFAAgC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,yGAA0B;AAC/C;AACA,kCAAkC,iFAA2B;AAC7D;AACA;AACA;AACA;AACA;AACA,qBAAqB,sDAAM,IAAI,uFAAsB;AACrD,8BAA8B,+EAA6B;AAC3D,kCAAkC,+EAAyB;AAC3D;AACA;AACA;AACA;AACA;AACA,qBAAqB,mGAAuB;AAC5C,8BAA8B,+EAA6B;AAC3D,kCAAkC,0FAAwB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,+EAA6B;AAC3D,2BAA2B,2DAAW;AACtC;AACA;AACA,kCAAkC,+CAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yDAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oCAAoC;AAChE;AACA,wBAAwB,8EAA8E;AACtG;AACA;AACA;AACA,yBAAyB,uEAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,iEAA0B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,+EAA6B;AACjE;AACA;AACA,iCAAiC,gEAAY;AAC7C;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACnNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4B;AACyC;AACX;AACZ;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,aAAa,YAAY;AACzB;AACO;AACP,IAAI,4CAAG;AACP;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2DAAM,2BAA2B,uDAAe;AAC5D,YAAY,4CAAG;AACf;AACA;AACA,oBAAoB,2DAAM;AAC1B;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,8EAAiB;AACjD;AACA,YAAY,4CAAG;AACf;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA,oCAAoC,2DAAM;AAC1C;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA,0BAA0B,2DAAM;AAChC;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA,WAAW,2DAAM;AACjB;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,YAAY;AACvB;AACA,aAAa,SAAS;AACtB;AACe;AACf,IAAI,4CAAG;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;AC/IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4B;AACuC;AACW;AAC5B;AACe;AACnB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2DAAM,2BAA2B,uDAAe;AAC5D,YAAY,4CAAG;AACf,sBAAsB,qCAAqC;AAC3D;AACA,oBAAoB,2DAAM;AAC1B;AACA,YAAY,4CAAG;AACf,sBAAsB,qCAAqC;AAC3D;AACA;AACA,yBAAyB,4EAAe;AACxC,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX,kBAAkB,qCAAqC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA,oBAAoB,6BAA6B;AACjD;AACA;AACA;AACA;AACA,gBAAgB,8EAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qBAAqB;AAChC;AACA,aAAa,QAAQ;AACrB,YAAY,qBAAqB;AACjC;AACA;AACe;AACf,YAAY,iDAAiD;AAC7D,QAAQ,uEAAiB;AACzB,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA,aAAa;AACb;;;;;;;;;;;;;;;;;AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACwD;AACU;AAClE;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,YAAY;AACvB,aAAa;AACb;AACe;AACf,kDAAkD,0DAAU,IAAI,8DAAc;AAC9E,eAAe,iEAAU;AACzB;AACA;AACA;;;;;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0D;AACc;AACxE;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,YAAY;AACvB,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA,mBAAmB,2DAAM;AACzB;AACA;AACA;AACA,wBAAwB,mEAAY;AACpC;AACA;AACA,eAAe,mEAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2DAAM;AAClB;AACA;AACA;AACA,YAAY,2DAAM;AAClB;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC2C;AACqB;AACR;AACd;AACD;AACzC,+DAAe,+DAAwB,EAAC;AAC8B;;;;;;;;;;;;;;;;ACrBtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf,IAAI,4CAAG;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;ACpD4B;AACU;AAC+B;AACrE;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,aAAa;AACxB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA,QAAQ,4CAAG;AACX,KAAK;AACL;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA,QAAQ,4CAAG;AACX;AACA,KAAK;AACL,QAAQ,wEAAuB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wDAAK;AACb;AACA;;;;;;;;;;;;;;;;AChC8C;AAC9C;AACA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf;AACA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA,aAAa,uDAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+B;AACN;AACuB;AACY;AACE;AAC7B;AACgB;AACjD;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,gBAAgB;AAC3B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,0BAA0B;AACrC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sEAAgB;AAChC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,oBAAoB,KAAyC,4BAA4B;AAAA,EAIxE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS,uEAAiB;AAC1B;AACA;AACA,cAAc,uEAAiB;AAC/B;AACA;AACA,cAAc,uEAAiB;AAC/B;AACA;AACA,cAAc,uEAAiB;AAC/B;AACA;AACA,mBAAmB,sEAAgB;AACnC,kCAAkC,sEAAgB;AAClD;AACA;AACA;AACA,oBAAoB,wDAAe;AACnC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,wBAAwB,wDAAe;AACvC;AACA;AACA,SAAS;AACT;AACA;AACA,2BAA2B,4BAA4B;AACvD,SAAS;AACT;AACA;AACA;AACA,oBAAoB,wDAAe,GAAG,0CAA0C;AAChF;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,uBAAuB,mCAAmC;AAC1D,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,oBAAoB,wDAAe;AACnC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,iDAAiD,4BAA4B;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB,EAAE,+CAAM;AAC/C;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA,uBAAuB,uEAAiB,CAAC,2DAAW,sBAAsB,2DAAW;AACrF;AACA,UAAU,2DAAW;AACrB,oBAAoB,wDAAe;AACnC,qBAAqB,2DAAW;AAChC,sBAAsB,2DAAW;AACjC;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wDAAwD;AACnF;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,uBAAuB,uEAAiB,CAAC,2DAAW,sBAAsB,2DAAW;AACrF;AACA,UAAU,2DAAW;AACrB,oBAAoB,wDAAe;AACnC;AACA;AACA;AACA,KAAK;AACL,qCAAqC,mDAAI;AACzC,oDAAoD,4BAA4B;AAChF,qBAAqB,2DAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,kBAAkB,uEAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,mDAAI;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iDAAiD;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA,WAAW,eAAe;AAC1B;AACA;AACA;AACA,WAAW,eAAe;AAC1B;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACyZ;;;;;;;;;;;;;;;;;;AC5ZlV;AACO;AAC9E;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,YAAY;AACzB;AACA;AACO;AACP,+BAA+B,mEAAY;AAC3C,yBAAyB,2DAAM;AAC/B;AACA;AACA,oDAAoD;AACpD;AACA;AACA,kCAAkC,2DAAM;AACxC,4BAA4B,2DAAM;AAClC;AACA;AACA;AACA;AACA;AACA,8BAA8B,iEAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gEAAS;AACjC,0DAA0D;AAC1D,uBAAuB,2DAAM;AAC7B,qBAAqB,2DAAM;AAC3B;AACA;AACA;AACA;AACA;AACA,WAAW,2DAAM;AACjB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC3CqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACe;AACf;AACA;AACA,WAAW,8DAAc;AACzB;;;;;;;;;;;;ACzBA;AACA;AACA;AACA,+DAAe,cAAc,EAAC;;;;;;;;;;;;;;;;ACHuB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACe;AACf,WAAW,8DAAc;AACzB;AACA;AACA;;;;;;;;;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyB;AACqC;AACpB;AACmB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA,aAAa;AACb;AACe;AACf,QAAQ,uEAAiB,CAAC,sEAAY;AACtC,YAAY,wDAAQ;AACpB,YAAY,4CAAG;AACf;AACA;AACA;AACA,eAAe,sEAAY;AAC3B;AACA;AACA;AACA;AACA;AACA,gCAAgC,sEAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC5DA;AACA;AACA;AACA;AACA,aAAa;AACb;AACe;AACf;AACA;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uDAAO;AACpC,+DAAe,oBAAoB,EAAC;;;;;;;;;;;;;;;;AC5BpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgD;AAChD;AACA;AACA,WAAW,GAAG;AACd,aAAa;AACb;AACe;AACf,kBAAkB,2DAAW,yCAAyC,2DAAW;AACjF;;;;;;;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyB;AACuB;AACc;AAC9D;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,0BAA0B;AACvC;AACA;AACe;AACf;AACA;AACA;AACA,QAAQ,4CAAG,oCAAoC,WAAW,IAAI,QAAQ;AACtE;AACA;AACA,QAAQ,uEAAiB,CAAC,2DAAW;AACrC,YAAY,uEAAiB,CAAC,2DAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3CqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,8DAAc;AAC9D,+DAAe,uCAAuC,EAAC;;;;;;;;;;;;;;;;;;AChBvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyB;AACuB;AACC;AACjD,wBAAwB,2DAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf,YAAY,uCAAuC;AACnD,oBAAoB,wDAAe;AACnC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkD;AACF;AACV;AACwB;AACR;AACtD;AACA;AACe;AACf;AACA;AACA,SAAS,sDAAM;AACf,SAAS,uEAAiB,CAAC,2DAAW;AACtC,QAAQ,2DAAW;AACnB,sCAAsC,2DAAW;AACjD;AACA,6BAA6B,4DAAY;AACzC,qDAAqD,4DAAY;AACjE,kDAAkD,4DAAY;AAC9D;AACA;AACA;AACA;AACA,YAAY,kEAAc;AAC1B;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyB;AACuB;AAChD;AACA;AACA,WAAW,WAAW;AACtB,WAAW,cAAc;AACzB,aAAa;AACb;AACA;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,cAAc;AACzB;AACe;AACf;AACA;AACA;AACA,QAAQ,yDAAS;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;;;;;;;;;;;;;;;;AC9D8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACe;AACf,WAAW,uDAAO;AAClB;;;;;;;;;;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsE;AAC6B;AACnG;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACe;AACf,YAAY,+DAAe,IAAI,8DAAc,KAAK,4GAA0B;AAC5E;;;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,aAAa;AACb;AACe;AACf;AACA;;;;;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AAC7C;AACA;AACA;AACA,aAAa;AACb;AACe;AACf,WAAW,sDAAM;AACjB;;;;;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AAC7C;AACA;AACA;AACA;AACA,aAAa;AACb;AACe;AACf,WAAW,sDAAM;AACjB;;;;;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACuD;AACvD;AACA;AACA;AACA;AACA,aAAa;AACb;AACe;AACf,WAAW,gEAAgB;AAC3B;;;;;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqD;AACrD;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACe;AACf,wBAAwB,8DAAc;AACtC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC/BqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACe;AACf,WAAW,8DAAc;AACzB;;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8C;AACH;AACM;AACjD,4BAA4B,4DAAY;AACxC;AACA;AACA;AACA,uBAAuB,uDAAc;AACrC;AACA;AACA,0BAA0B,6DAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAAe,aAAa,EAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3B7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkC;AACN;AACqC;AAC7B;AACoB;AACJ;AACG;AACC;AACF;AACL;AACY;AACL;AACM;AACE;AACE;AACkB;AACJ;AAChF;AACA,sCAAsC,wDAAe;AACrD;AACA,sCAAsC,wDAAe;AACrD;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA,YAAY,8CAA8C;AAC1D;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,YAAY,uEAAiB;AAC7B,YAAY,4CAAG;AACf,2CAA2C,mEAAkB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA,gCAAgC,qJAAqJ;AACrL,gCAAgC,+EAA6B;AAC7D,gCAAgC,yDAAe;AAC/C,8BAA8B,sEAAoB;AAClD;AACA;AACA;AACA;AACA,yBAAyB,mDAAI;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,6DAAa;AACrD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,aAAa;AACb;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA,uBAAuB,wDAAe;AACtC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,6DAAkB;AACzD;AACA,iCAAiC,qEAAmB;AACpD;AACA;AACA;AACA;AACA;AACA,sCAAsC,4DAAiB;AACvD;AACA;AACA;AACA,qCAAqC,wDAAe;AACpD;AACA;AACA;AACA;AACA,SAAS,IAAI,qEAAqE;AAClF;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA,8BAA8B,iEAAkB;AAChD,oBAAoB,iBAAiB;AACrC;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA,6BAA6B,mDAAI;AACjC,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uCAAuC;AAC3D;AACA;AACA;AACA;AACA;AACA,oBAAoB,mCAAmC;AACvD;AACA;AACA;AACA;AACA;AACA,oBAAoB,0DAA0D,EAAE,+CAAM;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,iFAA2B;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,iFAA2B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,6DAAa;AACrD;AACA;AACA;AACA;AACA,SAAS,IAAI,uEAAuE;AACpF;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA,gBAAgB,kDAAkD;AAClE;AACA;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,wBAAwB;AACnC,WAAW,oBAAoB;AAC/B,WAAW,oBAAoB;AAC/B,aAAa;AACb;AACA;AACA;AACA;AACA,uBAAuB,qEAAe;AACtC;AACA;AACA,uBAAuB,wEAAkB;AACzC;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC7YA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4B;AAC8B;AACO;AACG;AACZ;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA,0BAA0B,oEAAe;AACzC,2BAA2B;AAC3B;AACA,SAAS;AACT;AACA;AACA;AACA,QAAQ,4CAAG;AACX,2CAA2C,EAAE,aAAa,YAAY;AACtE;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,gBAAgB,iDAAiD;AACjE,YAAY,uEAAiB;AAC7B;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sEAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA,8BAA8B,mEAAc;AAC5C,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,yBAAyB;AAC3E;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AChMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4B;AAC8B;AACU;AACN;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,gBAAgB;AAC/B,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA,gBAAgB,mBAAmB;AACnC;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sEAAqB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA,wCAAwC,wBAAwB;AAChE;AACA;AACA,YAAY,sEAAqB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,eAAe,gBAAgB;AAC/B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,oBAAoB,sEAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2EAAwB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B;AACA,WAAW,QAAQ;AACnB;AACA,aAAa;AACb;AACA;AACA;AACA,gBAAgB,mEAAc,qBAAqB,IAAI;AACvD;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,gBAAgB,mEAAc,qBAAqB,IAAI;AACvD;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgF;AAChF,+DAAe,yEAA8B,EAAC;;;;;;;;;;;;;;;;;;;;;;AChB9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkC;AACN;AACmB;AACkB;AACG;AACpC;AAChC;AACA;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,qBAAqB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mDAAI;AAC1B,YAAY,WAAW;AACvB,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB,WAAW,aAAa;AACxB;AACA,WAAW,SAAS;AACpB;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6BAA6B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sEAAqB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uEAAiB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,WAAW,SAAS;AACpB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6DAAS,cAAc,SAAS;AACxD;AACA;AACA;AACA;AACA,gBAAgB,sEAAqB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA,gBAAgB,wFAAwF,EAAE,+CAAM;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,eAAe,aAAa;AAC5B;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA,eAAe,kBAAkB;AACjC;AACA,iBAAiB;AACjB;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,gBAAgB,gCAAgC;AAChD;AACA,gBAAgB,gCAAgC,EAAE,+CAAM;AACxD;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA,iCAAiC,uEAAiB;AAClD;AACA;AACA;AACA;AACA;AACA,YAAY,uEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,aAAa;AAC5B;AACA,eAAe,gBAAgB;AAC/B;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AChVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqC;AACX;AAC1B;AACA;AACA;AACA;AACA;AACe;AACf;AACA,gBAAgB,6BAA6B,EAAE,+CAAM;AACrD,6BAA6B,6CAAI;AACjC,6BAA6B,6CAAI;AACjC;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,gBAAgB,yBAAyB,EAAE,+CAAM;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,gBAAgB,0BAA0B,EAAE,+CAAM;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6BAA6B,EAAE,+CAAM;AACrD,6BAA6B,6CAAI;AACjC,6BAA6B,6CAAI;AACjC;AACA;AACA;;;;;;;;;;;;;;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6D;AAC7D;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,mEAAc;AACpD;AACA,gCAAgC;AAChC;AACA;AACA;;;;;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkD;AAClD;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,YAAY,mHAAmH;AACzJ,4BAA4B,6DAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B;AACA,aAAa;AACb;AACe;AACf;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+B;AACqC;AACZ;AACxD;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA,gBAAgB,gCAAgC;AAChD,sCAAsC;AACtC;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,YAAY,uEAAiB;AAC7B,gBAAgB,KAAyC,4BAA4B;AAAA,EAExE;AACb,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA,YAAY,uEAAiB;AAC7B,gBAAgB,KAAyC,4BAA4B;AAAA,EAExE;AACb,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,eAAe,gEAAY;AAC3B,4BAA4B,uEAAiB;AAC7C;AACA;AACA;;;;;;;;;;;;;;;;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+B;AACL;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,6CAAI;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uCAAuC;AACvD;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AClHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6D;AAC7D;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B;AACA,WAAW,QAAQ;AACnB;AACA,aAAa;AACb;AACe;AACf,8BAA8B,mEAAc;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACnC4B;AACqB;AACgB;AACV;AACA;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,oFAAoF,8DAAU;AAC9F,oFAAoF,8DAAU;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,8BAA8B,6DAAa;AAC3C;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI,mEAAmE;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,uEAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,gEAAc;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uEAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,KAAK,GAAG,YAAY;AACrD;AACA;AACA;AACA;AACA;AACA,iCAAiC,KAAK;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,8CAA8C;AACpF,sCAAsC,UAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,IAAI;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjVkD;AAClD,+DAAe,0DAAe,EAAC;;;;;;;;;;;;;;;;;;ACD/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkC;AACwB;AACL;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,6BAA6B,4DAAY;AACxD;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA,wCAAwC;AACxC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6BAA6B,EAAE,+CAAM;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,mEAAc;AACxB,UAAU,mEAAc;AACxB;;;;;;;;;;;;;ACzJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiD;AACjD,+DAAe,yDAAe,EAAC;;;;;;;;;;;;;;;;;;;;;;;;;AChB/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqC;AACS;AACf;AACkB;AACO;AACe;AAChC;AACmB;AACN;AACe;AACnE;AACA;AACA;AACA;AACA;AACe,8BAA8B,4DAAY;AACzD;AACA;AACA,eAAe,4BAA4B;AAC3C;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,qCAAqC,mDAAI;AACzC;AACA;AACA;AACA;AACA,8BAA8B,6DAAa;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,yDAAQ;AAC/C,6CAA6C,2BAA2B;AACxE;AACA;AACA,yDAAyD,2CAA2C;AACpG;AACA;AACA;AACA,mCAAmC,2CAA2C;AAC9E,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,eAAe,4BAA4B;AAC3C;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,iEAAa;AACjD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,iEAAa;AAC/B;AACA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC,qBAAqB;AACrB;AACA;AACA;AACA,oBAAoB,eAAe;AACnC;AACA,kBAAkB,+CAAM;AACxB;AACA;AACA,kBAAkB,+CAAM;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+EAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,eAAe,QAAQ;AACvB,eAAe,oBAAoB;AACnC,iBAAiB;AACjB;AACA;AACA,2CAA2C,qEAAqE;AAChH;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB,eAAe,oBAAoB;AACnC,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC,sEAAqB;AACtD;AACA;AACA,gBAAgB,4BAA4B;AAC5C;AACA,oCAAoC,iEAAa;AACjD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA,mCAAmC,mDAAW;AAC9C;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B,qBAAqB;AACrB;AACA;AACA;AACA,mCAAmC,+EAAsB;AACzD;AACA;AACA;AACA,sBAAsB,iEAAa;AACnC;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,mDAAW;AAClD;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA,gCAAgC,sEAAqB;AACrD,YAAY,4CAAG,gCAAgC,YAAY;AAC3D,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,iBAAiB;AACjB;AACA;AACA,gBAAgB,0FAA0F,EAAE,+CAAM;AAClH,gBAAgB,sCAAsC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA,4CAA4C,yCAAyC;AACrF,gBAAgB,mGAAmG,EAAE,+CAAM;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,sEAAqB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,6DAAa;AACtD;AACA;AACA;AACA,oBAAoB,gDAAgD;AACpE;AACA;AACA;AACA,yEAAyE,sEAAqB;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB,EAAE,mDAAI;AACvB,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,4CAA4C,mCAAmC;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oBAAoB,kEAAkE;AACtF,oCAAoC,sEAAqB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4CAAG,iDAAiD,QAAQ;AAChF,4BAA4B,+CAA+C,EAAE,+CAAM;AACnF;AACA;AACA,oFAAoF,sEAAqB;AACzG;AACA,8CAA8C,mDAAI;AAClD;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,iCAAiC,sEAAqB;AACtD;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa;AACb;AACA;AACA;AACA;;;;;;;;;;;;;ACvhBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0D;AAC1D,+DAAe,8DAAmB,EAAC;;;;;;;;;;;;AChBnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB;AACA,UAAU,yBAAyB;AACnC;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,GAAG;AACpB;AACA,UAAU,0BAA0B;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAAe,0BAA0B,EAAC;;;;;;;;;;;;;;;;AC/C1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqC;AACS;AACf;AAC0B;AACC;AACJ;AACc;AACN;AACN;AACU;AACd;AACgB;AACI;AACxE;AACA,0BAA0B,+DAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACe,gCAAgC,wFAAwF;AACvI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iEAAa;AAC/B,cAAc,sEAA0B;AACxC;AACA,YAAY,4BAA4B;AACxC;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,wDAAwD;AACxE;AACA,gCAAgC,+DAAoB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,sEAAY;AAC/C;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,uBAAuB,GAAG;AAC1B;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA,8BAA8B,sEAAY;AAC1C;AACA;AACA,SAAS;AACT;AACA;AACA,8BAA8B,iFAAuB,wEAAwE,gEAAY,GAAG,SAAS;AACrJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kHAAkH,eAAe;AACjI;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oEAAiB;AAChD,gBAAgB,4CAAG;AACnB;AACA;AACA,YAAY,4CAAG;AACf,8GAA8G,eAAe;AAC7H,kBAAkB,kEAAa;AAC/B;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,YAAY,4CAAG;AACf;AACA,8GAA8G,eAAe;AAC7H;AACA;AACA;AACA,mBAAmB,aAAa;AAChC,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,GAAG;AACtB,mBAAmB,SAAS;AAC5B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mDAAW;AACrC;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,mBAAmB,GAAG;AACtB;AACA;AACA,qCAAqC,kEAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uEAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACO,2CAA2C,8DAA8D;AAChH,YAAY,gJAAgJ,EAAE,+CAAM;AACpK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC7SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+B;AACY;AACa;AACjB;AACiB;AACD;AACG;AAC1D;AACA;AACA;AACe,2BAA2B,4DAAY;AACtD;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,wDAAe;AACjD;AACA;AACA,SAAS;AACT,qCAAqC,6DAAa;AAClD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,sBAAsB,wDAAe;AACrC,sBAAsB,wDAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA,SAAS,IAAI,sCAAsC;AACnD;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4CAAG;AACvB;AACA;AACA;AACA;AACA;AACA,oBAAoB,4CAAG;AACvB;AACA;AACA;AACA;AACA,SAAS,IAAI,8DAA8D;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA,SAAS,IAAI,8DAA8D;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+DAA+D;AAC/E;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,6DAAa;AAC/C;AACA,kBAAkB,mDAAI;AACtB;AACA,oBAAoB,oBAAoB;AACxC,4BAA4B,gEAAY,GAAG,8FAA8F;AACzI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,gBAAgB,yDAAM;AACtB,mDAAmD,gEAAY,GAAG,YAAY,SAAS;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA,mDAAmD,gBAAgB;AACnE,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,oBAAoB,4CAAG;AACvB,iBAAiB;AACjB;AACA;AACA,2BAA2B,UAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,IAAI,+BAA+B;AAC5D;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,IAAI,+BAA+B;AAC5D;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA,gBAAgB,8BAA8B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,6DAAa;AAC3C;AACA,cAAc,mDAAI;AAClB;AACA,gBAAgB,oBAAoB;AACpC,wBAAwB,gEAAY,GAAG,iCAAiC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,qBAAqB;AACpE,aAAa;AACb;AACA,gBAAgB,4CAAG;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,gBAAgB,yDAAM;AACtB,kDAAkD,gEAAY,GAAG,YAAY,SAAS;AACtF;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,2CAA2C;AAC3C;AACA;;;;;;;;;;;;;;;;;;;;AChZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqC;AACwC;AACa;AAC/C;AACM;AACjD;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,aAAa;AAC5B,eAAe,QAAQ;AACvB;AACA;AACA,gBAAgB,mDAAmD,EAAE,+CAAM;AAC3E;AACA,gCAAgC,yDAAe;AAC/C;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA,+BAA+B,iFAA+B;AAC9D;AACA;AACA,+BAA+B,4DAAoB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,0CAA0C,wEAAgC;AAC1E,mBAAmB,sDAAY;AAC/B;AACA;;;;;;;;;;;;;;;;;;;ACxE+B;AAC8B;AACoB;AACA;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA,eAAe,SAAS;AACxB;AACA,kBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,6EAAwB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,6DAAa;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,oEAAiB;AACxD;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,wBAAwB,+BAA+B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF;AAClF;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,gBAAgB;AAC3B,aAAa;AACb;AACA;AACA,WAAW,mEAAc;AACzB;;;;;;;;;;;;;;;;ACvUiG;AACjG,+DAAe,0DAAsB,EAAC;AACO;;;;;;;;;;;;;;;;;;;;;;;ACFR;AACS;AACf;AACyB;AACU;AACd;AACgB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,aAAa;AACxB,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA,wBAAwB,gFAAuB,gEAAgE,gEAAY,GAAG,SAAS;AACvI;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA,+BAA+B,oEAAiB;AAChD,gBAAgB,4CAAG;AACnB;AACA;AACA,YAAY,4CAAG;AACf,kBAAkB,iEAAa;AAC/B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,kBAAkB,mDAAW;AAC7B;AACA;AACA,aAAa;AACb;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA,mBAAmB,aAAa;AAChC,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,GAAG;AACtB;AACA;AACA,iCAAiC,iEAAa;AAC9C,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACO,6CAA6C,8CAA8C;AAClG,YAAY,8KAA8K,EAAE,+CAAM;AAClM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4D;AACN;AACtD;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACe;AACf,yBAAyB,sDAAY;AACrC,mBAAmB,+CAAY;AAC/B;AACA,WAAW,mDAAW;AACtB;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqF;AACtD;AACiC;AACH;AACC;AACvB;AACe;AACI;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,SAAS;AACtB;AACA;AACA,yBAAyB,sDAAY;AACrC,2BAA2B,sDAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sDAAiB;AAChD,2BAA2B,sDAAiB;AAC5C;AACA,8BAA8B,+CAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mDAAY;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qBAAqB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB;AACA,WAAW,UAAU;AACrB;AACA;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,YAAY,yCAAyC;AACrD;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6DAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,mEAAc;AAClD,iDAAiD,sEAAY;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,GAAG;AAClB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sEAAY;AAChC;AACA;AACA;AACA;AACA,8BAA8B,6DAAa;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,YAAY,oEAAgB,2GAA2G,mDAAI;AAC3I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sEAAY;AAChC;AACA,6BAA6B,QAAQ,uGAAuG;AAC5I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;AC1U+C;AAChB;AACwC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,iBAAiB;AACjB;AACA;AACA;AACA,oBAAoB,sEAAqB;AACzC;AACA;AACA;AACA;AACA;AACA,gBAAgB,kFAAkF,EAAE,qDAAM;AAC1G,gBAAgB,iDAAiD;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA,yBAAyB,yCAAyC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB;AACA,iBAAiB;AACjB;AACA;AACA,gBAAgB,iDAAiD;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA,YAAY,sEAAqB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iBAAiB;AAC7C;AACA,wBAAwB,4CAAG;AAC3B;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,iBAAiB;AACjB;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,QAAQ;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB,yBAAyB;AACzB;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,YAAY,4CAAG;AACf,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yCAAyC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,aAAa;AACb;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC1WA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AACW;AACY;AAChB;AACM;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,4CAA4C,4DAAY;AACvE;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA,8BAA8B,6DAAa;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,UAAU;AAC7C;AACA;AACA,oCAAoC,+CAAU;AAC9C;AACA;AACA;AACA;AACA,oCAAoC,+CAAU;AAC9C;AACA;AACA;AACA,SAAS,IAAI,yDAAyD;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,0DAAU;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uEAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uEAAiB;AACvC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACld+B;AACgD;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf;AACA;AACA,KAAK;AACL,8CAA8C,yEAA6B;AAC3E;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,QAAQ,4CAAG;AACX;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACxCkD;AAClD;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6DAAS;AACjC,wBAAwB,6DAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACjCkD;AACQ;AACS;AACnE;AACA,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA,2BAA2B,6DAAS;AACpC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,4EAAiC,GAAG,OAAO,6DAAa;AACpH;;;;;;;;;;;;;;;AC3BA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4B;AACqC;AACL;AACL;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACe,kCAAkC,iEAAiE;AAClH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI,+DAA+D;AACxE;AACA;AACA;AACA;AACA;AACA,oDAAoD,6DAAa;AACjE;AACA;AACA;AACA,YAAY,4CAAG;AACf,SAAS;AACT;AACA,sCAAsC,iCAAiC;AACvE,qCAAqC,iCAAiC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0BAA0B,EAAE,qEAAsB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa,uEAAiB;AAC9B;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa,uEAAiB;AAC9B;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AChJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkC;AAC0B;AACc;AACb;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,oCAAoC,+CAAW;AAC9D;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,QAAQ,4CAAG,kFAAkF,+DAAoB;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uCAAuC;AAC3D,YAAY,4CAAG,iDAAiD,+DAAoB;AACpF;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,kBAAkB,wDAAoB;AACtC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,4EAA4E,sEAAqB;AACjG;AACA;AACA;AACA,2EAA2E,sEAAqB;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA,kBAAkB,wDAAoB;AACtC,qBAAqB,YAAY;AACjC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA,sBAAsB,wDAAoB;AAC1C;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA,YAAY,4CAAG,oCAAoC,iBAAiB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA,QAAQ,IAAyC;AACjD;AACA;AACA,IAAI;AAKC;AACL;;;;;;;;;;;;;ACxQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+D;AAC/D,+DAAe,iEAAqB,EAAC;;;;;;;;;;;;;AChBa;AAClD,+DAAe,0DAAe,EAAC;;;;;;;;;;;;;;;;;;ACDG;AACwC;AACb;AAC7D;AACA;AACA;AACA;AACe,8BAA8B,+CAAW;AACxD;AACA,eAAe,QAAQ;AACvB;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA,gFAAgF,WAAW,mBAAmB;AAC9G;AACA,kBAAkB,wDAAoB;AACtC;AACA,SAAS;AACT;AACA;AACA,2EAA2E,sEAAqB;AAChG;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,kBAAkB,wDAAoB;AACtC,qBAAqB,YAAY;AACjC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA,sBAAsB,wDAAoB;AAC1C;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA,QAAQ,IAAyC;AACjD;AACA;AACA,IAAI;AAWC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,KAAyC,4BAA4B;AAAA,EAQxE;;;;;;;;;;;;;;;;;ACvJD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,qCAAqC,kDAAgB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,CAAC,oDAAoD;;;;;;;;;;;;;;;;;;;;;;;AC/GrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyD;AACa;AACgB;AAChC;AACtD,+DAAe,4DAAiB,EAAC;AAC6F;;;;;;;;;;;;;;;;;ACpB9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmD;AACoB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,qBAAqB;AACpC;AACA;AACA,oBAAoB,sEAAqB;AACzC,6BAA6B,8BAA8B;AAC3D;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA,4CAA4C,yDAAc;AAC1D;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmD;AACnD,+DAAe,0DAAgB,EAAC;AACiD;;;;;;;;;;;;;;;;;;;;;ACjBjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqC;AACN;AACoB;AACiB;AACG;AACtB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA,gBAAgB,oEAAoE,EAAE,+CAAM;AAC5F;AACA,oCAAoC,yDAAe;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA,gCAAgC;AAChC,wCAAwC;AACxC,gBAAgB,uBAAuB,EAAE,+CAAM;AAC/C;AACA;AACA,YAAY,4CAAG;AACf,6DAA6D,QAAQ,GAAG,MAAM;AAC9E,YAAY,4CAAG,4BAA4B,uEAAuE;AAClH;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iGAAiG;AACjG;AACA;AACA;AACA;AACA,gBAAgB,4CAAG,cAAc,yBAAyB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4CAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,uEAAiB;AAC9B,oBAAoB,gCAAgC,EAAE,+CAAM;AAC5D,wBAAwB,sEAAqB;AAC7C,yCAAyC,sBAAsB;AAC/D;AACA;AACA,oBAAoB,4CAAG,2EAA2E,kBAAkB,GAAG,gBAAgB;AACvI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,4CAAG;AAC3C,YAAY,4CAAG,sBAAsB,YAAY;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB;AACA,eAAe,QAAQ;AACvB;AACA;AACA,kBAAkB,qEAAqE;AACvF;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,6CAA6C;AAClE;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4CAAG;AACvB;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4CAAG;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4CAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4CAAG;AAC/B;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,4CAAG;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,4CAAG;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4CAAG;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4CAAG;AAC/B;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,4CAAG;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,4CAAG;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4CAAG;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4CAAG;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C,gBAAgB,yDAAc;AAC9B;AACA;AACA;AACA;AACA,wBAAwB,4CAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,yDAAc;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,oBAAoB,4CAAG;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB;AACA,YAAY,yFAAyF,EAAE,+CAAM;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB;AACA,YAAY,yFAAyF,EAAE,+CAAM;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA,YAAY,8GAA8G,EAAE,+CAAM;AAClI;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sEAAqB;AACzC;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA,oBAAoB,sEAAqB;AACzC;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA,YAAY,8GAA8G,EAAE,+CAAM;AAClI;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA,oBAAoB,sEAAqB;AACzC;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA,oBAAoB,sEAAqB;AACzC;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,+BAA+B,GAAG,cAAc;AAC1E;AACA;AACA;AACA;AACA,2BAA2B,kCAAkC;AAC7D,+BAA+B,+BAA+B,GAAG,cAAc;AAC/E;AACA;AACA;AACA;AACA,uBAAuB,kCAAkC;AACzD,2BAA2B,+BAA+B,GAAG,cAAc;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC,sBAAsB,qBAAqB,QAAQ,4BAA4B;AAC/E,oBAAoB,6EAA6E;AACjG,KAAK;AACL;AACA;;;;;;;;;;;;;;;;ACx4BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0C;AACd;AACY;AACsC;AACb;AAC7B;AACsB;AACL;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,6EAAwB;AACvC,oCAAoC,mDAAI;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,YAAY,4CAAG,kBAAkB,YAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yDAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB,uEAAiB;AAClC,oDAAoD,wDAAqB;AACzE;AACA,oBAAoB,4CAAG;AACvB;AACA;AACA,oBAAoB,4CAAG;AACvB;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA,0CAA0C,wDAAqB;AAC/D;AACA;AACA,YAAY,yDAAM;AAClB;AACA;AACA,aAAa,uEAAiB;AAC9B,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA,8BAA8B,6DAAe;AAC7C;AACA;AACA;AACA,QAAQ,4CAAG;AACX,kBAAkB,+CAAU;AAC5B;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,YAAY,uEAAiB;AAC7B,YAAY,4CAAG;AACf;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4IAA4I,YAAY,6CAA6C;AACrM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChUqC;AACS;AACf;AAC2B;AACA;AACM;AACzB;AACiB;AACI;AACsB;AACxB;AACL;AACmC;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACe,4BAA4B,uIAAuI;AAClL,YAAY,+BAA+B;AAC3C;AACA,oCAAoC,8DAAa;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,wDAAe;AACrD;AACA;AACA;AACA;AACA;AACA,oCAAoC,wDAAe;AACnD;AACA,YAAY,kDAAkD,4BAA4B,8BAA8B;AACxH,+CAA+C,wDAAe;AAC9D;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA,KAAK,IAAI,yCAAyC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,oCAAoC,wDAAe;AACnD,4BAA4B,6BAA6B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG,sBAAsB,iBAAiB;AAClD,0CAA0C,gCAAgC;AAC1E,KAAK,IAAI,iEAAiE;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,8DAAa;AAChD;AACA;AACA;AACA,gBAAgB,8DAAa;AAC7B;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK,IAAI,iEAAiE;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,4BAA4B,iFAAmC;AAC/D;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,uBAAuB,kEAAc;AACrC;AACA;AACA;AACA;AACA,gCAAgC,8BAA8B,EAAE,+CAAM;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB,IAAI,2DAA2D;AACpF,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gEAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,8DAAa;AAC/D;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,wDAAe;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB,yDAAyD,cAAc;AACvE;AACA;AACA,gBAAgB,4CAAG;AACnB,yDAAyD,eAAe;AACxE;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,wCAAwC,8DAAa;AACrD;AACA;AACA,2BAA2B,uEAAqB;AAChD;AACA,SAAS;AACT,qFAAqF,wDAAe;AACpG,QAAQ,4CAAG;AACX,iCAAiC,gEAAY,GAAG;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4CAAG;AACvB;AACA;AACA;AACA,uCAAuC,mDAAW;AAClD;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,oBAAoB,4CAAG;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oEAAgB;AACpC;AACA;AACA,qBAAqB;AACrB,+BAA+B,mDAAI;AACnC;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,QAAQ,4DAAoB;AAC5B;AACA,uBAAuB,8CAA8C;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B;AACA,WAAW,gBAAgB;AAC3B;AACA,aAAa;AACb;AACA;AACA,2EAA2E,iEAAa;AACxF;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,iEAAa;AAC/D;;;;;;;;;;;;;;;;;;;;ACtaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqC;AACqB;AACY;AAC8C;AACrG;AACf;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iEAAa;AAC9B,YAAY,yDAAU;AACtB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,+BAA+B,gEAAoB;AACnD;AACA;AACA;AACA,qBAAqB,iEAAa;AAClC;AACA;AACA,gBAAgB,yDAAU,kBAAkB,YAAY;AACxD;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,0EAA0B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iCAAiC;AAChE;AACA;AACA;AACA,gBAAgB,kCAAkC,EAAE,+CAAM;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,kCAAkC,0EAA0B;AAC5D;AACA;AACA;AACA;AACA,mCAAmC,8CAA8C;AACjF;AACA;AACA,qBAAqB,gEAAiB;AACtC;AACA,iBAAiB;AACjB;AACA;AACA,YAAY;AACZ,YAAY;AACZ;;;;;;;;;;;;;AC/GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmD;AACnD,+DAAe,0DAAgB,EAAC;;;;;;;;;;;;;AChBhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgD;AAChD,+DAAe,qDAAkB,EAAC;;;;;;;;;;;;;;;;AChBlC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+B;AAC/B;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,gBAAgB;AAC3B,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,oBAAoB,6BAA6B;AACjD;AACA,gBAAgB,4CAAG;AACnB,0BAA0B,iCAAiC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,wCAAwC;AAC3E;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACuD;AACvD,+DAAe,4DAAkB,EAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;AChBlC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqC;AACQ;AACd;AACqC;AACR;AACK;AACb;AACM;AACC;AACE;AACxB;AAC+B;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACe;AACf,YAAY,0BAA0B;AACtC,YAAY,yEAAyE;AACrF,YAAY,iFAAiF,EAAE,+CAAM;AACrG;AACA;AACA,kCAAkC,8DAAa;AAC/C;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA,YAAY,0DAAsB;AAClC;AACA;AACA,iCAAiC,uEAAqB;AACtD,gCAAgC,uEAAqB;AACrD;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA,+BAA+B,0DAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,6DAAa;AAChD;AACA;AACA;AACA,mCAAmC,UAAU;AAC7C;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA,gDAAgD,oCAAoC;AACpF;AACA;AACA,mCAAmC,6DAAa;AAChD;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA,SAAS,IAAI,qEAAqE;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA,4EAA4E,gBAAgB;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,uEAAiB;AAC3D;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,yEAAuB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,yEAAuB;AAC1D;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA,gDAAgD,oCAAoC;AACpF;AACA;AACA,mCAAmC,6DAAa;AAChD;AACA;AACA,yBAAyB,aAAa;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kEAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,+CAAU;AAClD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,6DAAa;AACxD;AACA;AACA;AACA,mCAAmC,UAAU;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS,IAAI,yDAAyD;AACtE;AACA;AACA,uBAAuB,8BAA8B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,gCAAgC;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4CAAG;AACvB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,QAAQ,oDAAY;AACpB;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,4CAA4C,6DAAa;AACzD;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,kEAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4CAAG;AAC/B;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,gBAAgB;AAC3B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC2C;AAC3C,+DAAe,sDAAY,EAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChB5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqC;AACqB;AAC3B;AACmB;AACA;AACM;AACI;AACD;AACJ;AAC0B;AAC7B;AACP;AACoC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACe,wBAAwB,4KAA4K;AACnN,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA,8BAA8B,wDAAe;AAC7C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,8DAAa;AACrD;AACA,6HAA6H;AAC7H;AACA;AACA;AACA,gBAAgB,4CAAG,wBAAwB,YAAY;AACvD;AACA;AACA,oBAAoB,4CAAG,mCAAmC,YAAY;AACtE,wBAAwB,uDAAiB;AACzC;AACA;AACA;AACA;AACA;AACA,4BAA4B,4CAAG;AAC/B;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,4BAA4B;AAC5B;AACA,sGAAsG,QAAQ;AAC9G;AACA;AACA,+BAA+B,6DAAS;AACxC;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,8BAA8B,EAAE,+CAAM;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uDAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,oBAAoB,kBAAkB;AACtC,YAAY,4CAAG,0BAA0B,YAAY,mBAAmB,cAAc,SAAS,aAAa;AAC5G,yCAAyC,sCAAsC;AAC/E;AACA,wBAAwB;AACxB;AACA;AACA,6BAA6B,kFAA2B;AACxD;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,6BAA6B,aAAa;AAC1C;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,+BAA+B,qEAAiB;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK,IAAI,yDAAyD;AAClE;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA,QAAQ,wDAAgB;AACxB,uBAAuB,+CAA+C;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,gCAAgC,gBAAgB,gCAAgC;AACzF;AACA;AACA;AACA;AACA,iBAAiB,uDAAiB;AAClC,gBAAgB,4CAAG,kBAAkB,YAAY;AACjD;AACA,uCAAuC,mDAAW;AAClD;AACA;AACA,iBAAiB;AACjB;AACA;AACA,4BAA4B;AAC5B;AACA,sGAAsG,QAAQ;AAC9G;AACA,YAAY,4CAAG,kBAAkB,YAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kEAAc;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa,IAAI,yDAAyD;AAC1E,SAAS;AACT;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA;AACA;AACA,6BAA6B,+CAAU,qHAAqH,SAAS,wDAAa,eAAe;AACjM;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA,2BAA2B,wDAAe;AAC1C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,kBAAkB,iEAAkB;AACpC;AACA,mBAAmB,gEAAY,GAAG,qBAAqB,qBAAqB;AAC5E;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;;;ACrZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACwC;AACkC;AACD;AAC8C;AACvH;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,YAAY,yDAAU;AACtB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,+BAA+B,gEAAoB;AACnD;AACA;AACA;AACA;AACA,gBAAgB,yDAAU,kBAAkB,YAAY;AACxD;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,0EAA0B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iCAAiC;AAChE;AACA;AACA;AACA;AACA,gBAAgB,kCAAkC,EAAE,+CAAM;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,kCAAkC,0EAA0B;AAC5D;AACA;AACA;AACA;AACA,mCAAmC,8CAA8C;AACjF;AACA;AACA,qBAAqB,gEAAiB;AACtC;AACA,iBAAiB;AACjB;AACA;AACA,YAAY;AACZ,YAAY;AACZ;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA,QAAQ,wEAAmB;AAC3B;;;;;;;;;;;;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC2D;AAC3D,+DAAe,8DAAoB,EAAC;;;;;;;;;;;;;;;;;;;;;;;AChBpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqC;AACN;AACyB;AACyB;AACzB;AACM;AACN;AACE;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACe,gCAAgC,2EAA2E;AAC1H,IAAI,4CAAG;AACP,YAAY,qCAAqC;AACjD,YAAY,8DAA8D;AAC1E;AACA;AACA,0BAA0B,6DAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,gEAAY,GAAG,SAAS;AAClG;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,4BAA4B;AAC5B;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,mCAAmC,gEAAY,GAAG,SAAS;AAC3D;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,uBAAuB,oEAAe;AACtC,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uEAAkB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,YAAY,4CAAG;AACf,yCAAyC,qCAAqC;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,oBAAoB;AACpB;AACA,gBAAgB,gCAAgC,EAAE,+CAAM;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,gEAAY,GAAG,SAAS;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oEAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wDAAwD;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,YAAY,qEAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB;AACA;AACA,iDAAiD,oEAAiB;AAClE;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACtXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmE;AACjC;AACmB;AACT;AACyB;AACrE;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA,uEAAuE,oEAAiB;AACxF;AACA;AACA,0CAA0C,+CAAiB;AAC3D;AACA;AACA;AACA,sBAAsB,+CAAU;AAChC,yBAAyB,wDAAa;AACtC,aAAa;AACb;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wDAAK;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oEAAiB;AACjD;AACA;AACA;AACA,sBAAsB,+CAAU;AAChC,yBAAyB,wDAAa;AACtC,aAAa;AACb;AACA;AACA;;;;;;;;;;;;;;;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkC;AAClC;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACe;AACf,YAAY,qCAAqC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+BAA+B;AACxD;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4CAAG;AACvB,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,uDAAuD,aAAa;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,yBAAyB,gCAAgC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA,sCAAsC,gCAAgC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,iDAAiD,aAAa;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACxOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACuE;AACU;AACnB;AACR;AACE;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,kBAAkB;AAC7B,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf;AACA,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,gEAAoB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+CAA+C,EAAE,gEAAiB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,kBAAkB,iEAAkB;AACpC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oEAAqB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA,YAAY,mCAAmC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,uEAAiB;AAC1B,QAAQ,sDAAiB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACrMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACwC;AACN;AACoB;AACK;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACe,6BAA6B,2IAA2I;AACvL,YAAY,6BAA6B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yCAAyC,EAAE,+CAAM;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gEAAY,GAAG,SAAS;AACtD;AACA;AACA,sFAAsF,yDAAc;AACpG;AACA;AACA;AACA;AACA,gBAAgB,sBAAsB;AACtC;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6BAA6B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA,KAAK;AACL;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW;AACX,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA,YAAY,uBAAuB,EAAE,+CAAM;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,YAAY,8BAA8B,EAAE,+CAAM;AAClD;AACA,sBAAsB;AACtB;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,kBAAkB;AAC7B,aAAa;AACb;AACA;AACA;AACA,YAAY,4BAA4B,EAAE,+CAAM;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,aAAa;AACxB;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA,YAAY,yCAAyC,EAAE,+CAAM;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,aAAa;AACxB;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA,YAAY,yCAAyC,EAAE,+CAAM;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;AClbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf;AACA,YAAY,2BAA2B,EAAE,+CAAM;AAC/C,2BAA2B,4CAA4C;AACvE;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC2D;AACI;AAC/D;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACe,iCAAiC,mFAAmF;AACnI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gEAAY,GAAG,iDAAiD;AAC3F,2BAA2B,qEAAqB,kCAAkC,sBAAsB;AACxG,aAAa;AACb;;;;;;;;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACwC;AACmB;AACI;AAC/D;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACe,kCAAkC,kGAAkG;AACnJ;AACA;AACA;AACA;AACA,YAAY,8DAA8D;AAC1E;AACA,YAAY,2BAA2B,EAAE,+CAAM;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gEAAY,GAAG,8DAA8D;AACxG,2BAA2B,qEAAqB,kCAAkC,sBAAsB;AACxG,aAAa;AACb;;;;;;;;;;;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,8BAA8B;AACrD,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,mBAAmB;AACnB,mBAAmB;AACnB,mBAAmB;AACnB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,mBAAmB;AACnB,oBAAoB;AACpB,mBAAmB;AACnB;AACA;AACA,iCAAiC,YAAY;AAC7C;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,YAAY;AAC7C;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,qBAAqB;AAC9D;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,iBAAiB,qBAAqB;AACtC,iBAAiB,uBAAuB;AACxC,gBAAgB,qBAAqB;AACrC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,+DAAe,cAAc,EAAC;AAC9B;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnoCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC2C;AACA;AAC3C;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA,cAAc,0DAAY;AAC1B;AACA;AACA;AACA,oBAAoB,oDAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqD;AAC9C,0BAA0B,6DAAiB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkC;;;;;;;;;;;;;;;AClElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,yBAAyB;AACpC,aAAa;AACb;AACe;AACf,cAAc,KAAK,IAAI,OAAO;AAC9B;;;;;;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4C;AACL;AACvC;AACA;AACA,WAAW,GAAG;AACd,aAAa;AACb;AACe,8BAA8B,6BAA6B;AAC1E,QAAQ,2DAAY;AACpB;AACA;AACA;AACA,eAAe,oDAAU;AACzB;;;;;;;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0D;AACf;AACJ;AACI;AACJ;AACvC;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACe;AACf,8BAA8B,8DAAmB;AACjD,yBAAyB,oDAAU;AACnC,yBAAyB,oDAAU;AACnC,yBAAyB,sDAAY;AACrC,oBAAoB,oDAAU;AAC9B;;;;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC2C;AACA;AAC3C;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA,cAAc,0DAAY;AAC1B;AACA;AACA;AACA,oBAAoB,oDAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8D;AACnB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB;AACA;AACA,cAAc,0DAAY;AAC1B;AACA;AACA;AACA,oBAAoB,oDAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA,mCAAmC,2DAAiB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC2C;AACA;AAC3C;AACA;AACA;AACA;AACe;AACf;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA,cAAc,0DAAY;AAC1B;AACA;AACA;AACA,oBAAoB,oDAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;;;;;;;;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACe;AACf;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,kBAAkB,eAAe,IAAI,aAAa;AAClD;AACA;;;;;;;;;;;;;;;;ACzC2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA,cAAc,0DAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8D;AACrB;AACzC;AACA,WAAW,gBAAgB;AAC3B;AACe;AACf;AACA;AACA,uBAAuB,wDAAQ;AAC/B;AACA,kBAAkB,uEAAiB;AACnC;AACA,mCAAmC,wDAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,mBAAmB,wCAAwC;AAC3D;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,+BAA+B;AAC/B,kBAAkB;AAClB;AACA,+DAAe,QAAQ,EAAC;;;;;;;;;;;;;;;;;AChCxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyC;AACA;AACzC,+DAAe,wDAAQ,EAAC;AACD;;;;;;;;;;;;;;;;;;AChCvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoG;AAC/B;AAC5B;AACzC;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA,mCAAmC,wDAAI;AACvC;AACA,kCAAkC,4EAAY;AAC9C,yCAAyC,0FAA6B;AACtE;AACkC;AAClC,+DAAe,cAAc,EAAC;;;;;;;;;;;;;;;;;AC9B9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+E;AACiB;AAChG;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA,4BAA4B,gBAAgB,wFAAU,yBAAyB;AAC/E;AAC8C;AAC9C,+DAAe,oBAAoB,EAAC;;;;;;;;;;;;;;;;AC1BpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyD;AACzD;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA,uBAAuB,4DAAgB;AACvC;AACgC;AAChC,+DAAe,aAAa,EAAC;;;;;;;;;;;;;;;;;ACxB7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsE;AACV;AAC5D;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA,0CAA0C,qEAAU;AACpD,iCAAiC,wEAAiB;AAClD;AACkD;AAClD,+DAAe,kBAAkB,EAAC;;;;;;;;;;;;;;;;;AC1BlC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsE;AACZ;AAC1D;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA,yCAAyC,oEAAS;AAClD,iCAAiC,wEAAiB;AAClD;AACgD;AAChD,+DAAe,iBAAiB,EAAC;;;;;;;;;;;;;;;;;AC1BjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsE;AACV;AAC5D;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA,0CAA0C,qEAAU;AACpD,iCAAiC,wEAAiB;AAClD;AACkD;AAClD,+DAAe,kBAAkB,EAAC;;;;;;;;;;;;;;;;;AC1BlC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsE;AACT;AAC7D;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA,yCAAyC,uEAAS;AAClD,iCAAiC,wEAAiB;AAClD;AACgD;AAChD,+DAAe,iBAAiB,EAAC;;;;;;;;;;;;;;;;;AC1BjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0E;AACZ;AAC9D;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA,4CAA4C,uEAAU;AACtD,mCAAmC,0EAAmB;AACtD;AACsD;AACtD,+DAAe,oBAAoB,EAAC;;;;;;;;;;;;;;;;;AC1BpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0E;AACd;AAC5D;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA,2CAA2C,sEAAS;AACpD,mCAAmC,0EAAmB;AACtD;AACoD;AACpD,+DAAe,mBAAmB,EAAC;;;;;;;;;;;;;;;;;AC1BnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0E;AACZ;AAC9D;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA,4CAA4C,uEAAU;AACtD,mCAAmC,0EAAmB;AACtD;AACsD;AACtD,+DAAe,oBAAoB,EAAC;;;;;;;;;;;;;;;;;AC1BpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0E;AACX;AAC/D;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA,2CAA2C,yEAAS;AACpD,mCAAmC,0EAAmB;AACtD;AACoD;AACpD,+DAAe,mBAAmB,EAAC;;;;;;;;;;;;;;;;;AC1BnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoG;AACvD;AAC7C;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA,qCAAqC,0DAAM;AAC3C;AACA,yCAAyC,0FAA6B;AACtE;AACsC;AACtC,+DAAe,gBAAgB,EAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5BhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgE;AACU;AAC2I;AAC1L;AACY;AACQ;AAC/C,8EAAuB;AACvB,yDAAM;AACN,IAAI,mDAAM;AACV,IAAI,gDAAI;AACR,IAAI,sDAAU;AACd,IAAI,+CAAG;AACP,IAAI,+DAAkB;AACtB,IAAI,8DAAkB;AACtB,IAAI,8DAAiB;AACrB,IAAI,8DAAiB;AACrB,IAAI,4DAAgB;AACpB,IAAI,4DAAgB;AACpB,IAAI,2DAAe;AACnB,IAAI,2DAAe;AACnB;AACA,IAAI,yEAAkB;AACtB,IAAI,6CAAM;AACV;AACA,SAAS,KAAyC,4BAA4B;AAAA,EAE7E;AACD,+DAAe,yDAAM,EAAC;AACtB;AACA,IAAI,4DAAW,YAAY,yDAAM;AACjC;;;;;;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoC;AACpC;AACA,mBAAmB,qDAAM;AACzB,+DAAe,MAAM,EAAC;;;;;;;;;;;;;AClBtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkC;AAClC,+DAAe,mDAAM,EAAC;;;;;;;;;;;;;;;;;;;;;;AChBtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkC;AACN;AAC2B;AACU;AACZ;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uNAAuN,EAAE,+CAAM;AAC3O,QAAQ,uEAAiB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uEAAiB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uEAAiB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uEAAiB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uEAAiB;AAClD;AACA;AACA,2CAA2C,uEAAiB;AAC5D;AACA;AACA,QAAQ,uEAAiB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uEAAiB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+GAA+G,EAAE,+CAAM;AACnI,QAAQ,uEAAiB;AACzB;AACA;AACA,SAAS,uEAAiB;AAC1B;AACA;AACA,aAAa,uEAAiB;AAC9B,QAAQ,uEAAiB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uEAAiB;AACzB;AACA;AACA;AACA;AACA;AACA,qBAAqB,uEAAiB;AACtC;AACA;AACA,QAAQ,uEAAiB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,iEAAa;AACtB,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uEAAiB;AACzC;AACA;AACA,SAAS,iEAAa;AACtB,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uEAAiB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,uEAAiB;AAC/B,QAAQ,4CAAG;AACX;AACA;AACA,QAAQ,uEAAiB;AACzB;AACA;AACA;AACA,aAAa,iEAAa;AAC1B;AACA;AACA;AACA;AACA,gCAAgC,uEAAiB;AACjD;AACA;AACA,SAAS,uEAAiB;AAC1B;AACA;AACA;AACA,sBAAsB,gEAAY,GAAG,qBAAqB,eAAe;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AAC8E;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjT9E;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiG;AACmD;AAC7F;AACK;AACL;AACa;AAClC;AAC6C;AACE;AAC1B;AAC3B;AACgI;AACzD;AACpD;AACQ;AACQ;AACV;AACF;AACc;AACG;AACf;AACe;AACW;AACxB;AAC0C;AAC/C;AACR;AAC2D;AACQ;AAC7G;AACA,0BAA0B,gEAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,6DAAY;AACjC;AACA;AACA,eAAe,+CAAU;AACzB;AACA;AACA;AACA,eAAe,+CAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6CAAG;AAClB;AACA;AACA,QAAQ,6CAAG,oBAAoB,6CAAG;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6CAAG;AAClB;AACA;AACA,QAAQ,6CAAG,UAAU,6CAAG;AACxB;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA,QAAQ,sDAAW;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,4BAA4B;AAC5B;AACA,gBAAgB,6JAA6J,EAAE,uEAAuB;AACtM;AACA;AACA;AACA;AACA,mBAAmB,6CAAG;AACtB;AACA;AACA;AACA,qCAAqC,8DAAa;AAClD;AACA,yCAAyC,oFAA2B;AACpE,+BAA+B,yDAAe;AAC9C;AACA,qCAAqC,yDAAe;AACpD;AACA,mCAAmC,yDAAe;AAClD,gCAAgC,yDAAe;AAC/C,iCAAiC,yDAAe;AAChD,oCAAoC,yDAAe;AACnD;AACA;AACA,4BAA4B,4CAA4C;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,iBAAiB,kEAAY;AAC7B,gBAAgB,6CAAG;AACnB,+BAA+B,4EAAyB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6CAAG;AACnB,wBAAwB,4EAAyB;AACjD;AACA;AACA;AACA;AACA,oBAAoB,6CAAG;AACvB;AACA;AACA;AACA;AACA;AACA,4BAA4B,4EAAyB;AACrD;AACA;AACA,oBAAoB,6CAAG;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6CAAG;AACf;AACA;AACA;AACA;AACA,8BAA8B,6CAAG;AACjC,+BAA+B,6CAAG;AAClC,kCAAkC,yEAAkB;AACpD;AACA,+BAA+B,uEAAqB;AACpD;AACA,kCAAkC;AAClC,iBAAiB;AACjB,aAAa;AACb,YAAY,6CAAG;AACf;AACA;AACA;AACA,gBAAgB,6CAAG;AACnB;AACA;AACA;AACA;AACA;AACA,sCAAsC,yEAAkB;AACxD,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA,gBAAgB,6CAAG;AACnB;AACA;AACA;AACA,iBAAiB;AACjB;AACA,gBAAgB,+CAAM;AACtB,kCAAkC,+CAAM;AACxC;AACA,YAAY,+CAAM;AAClB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qDAA0B;AACtC;AACA,gBAAgB,6CAAG;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA,wBAAwB,qEAAqB;AAC7C,QAAQ,6CAAG;AACX,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,gBAAgB,mDAAmD;AACnE;AACA;AACA;AACA,QAAQ,kEAAkB;AAC1B;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,cAAc,2BAA2B;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kDAAQ;AACpB;AACA;AACA,8BAA8B,8DAAa;AAC3C,QAAQ,kDAAQ;AAChB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA,iBAAiB;AACjB;AACA,kCAAkC,kBAAkB,IAAI;AACxD;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA,qBAAqB,4DAAgB;AACrC;AACA;AACA;AACA;AACA;AACA,qBAAqB,8DAAS;AAC9B;AACA,gBAAgB,6CAAG;AACnB;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC,iBAAiB;AACjB;AACA;AACA,YAAY,wEAAiB;AAC7B;AACA;AACA,YAAY,wEAAiB;AAC7B;AACA;AACA,eAAe,8DAAe;AAC9B;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,gBAAgB,qZAAqZ;AACra;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,8DAAa;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,yFAA+B;AAChF;AACA,mCAAmC;AACnC,mCAAmC;AACnC;AACA;AACA;AACA,oBAAoB,6CAAG;AACvB;AACA;AACA;AACA;AACA,+BAA+B,wEAAqB,CAAC,8EAAqB;AAC1E;AACA;AACA;AACA;AACA;AACA,oBAAoB,6CAAG;AACvB;AACA;AACA;AACA;AACA,+BAA+B,gFAAuB;AACtD;AACA;AACA;AACA;AACA;AACA,2BAA2B,+EAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,kCAAkC,iEAAY,GAAG,oCAAoC;AACrF;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,kDAAQ;AAChD;AACA;AACA,8EAA8E,wEAAiB;AAC/F;AACA;AACA,oBAAoB,kDAAQ;AAC5B;AACA;AACA;AACA,oCAAoC,kDAAQ;AAC5C;AACA;AACA;AACA;AACA,kDAAkD,UAAU;AAC5D;AACA;AACA,sBAAsB,kFAAsC;AAC5D;AACA,gBAAgB,6CAAG;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,kCAAkC,kDAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,oBAAoB,kDAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0DAAM;AACtB;AACA,gBAAgB,6CAAG;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kDAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,kDAAQ;AACxB;AACA;AACA;AACA;AACA,qBAAqB,wEAAiB;AACtC;AACA;AACA,YAAY,6CAAG;AACf;AACA;AACA;AACA;AACA,8BAA8B,kDAAQ;AACtC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,mCAAmC,mDAAW;AAC9C;AACA;AACA,aAAa;AACb,YAAY,6CAAG;AACf;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,2FAA4B;AACjE;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,+BAA+B,sEAA6B;AAC5D;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA,qBAAqB,sDAAa;AAClC,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,+CAA+C,8DAAa;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4DAAmB;AACnC,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sDAAa;AAClC;AACA;AACA;AACA;AACA,qBAAqB,sDAAa;AAClC,0CAA0C,8DAAa;AACvD;AACA,gBAAgB,uDAAc;AAC9B;AACA,SAAS,IAAI,qEAAqE;AAClF;AACA;AACA;AACA;AACA,SAAS,IAAI,6CAA6C;AAC1D;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI,qEAAqE;AAClF;AACA;AACA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA,gBAAgB,kEAAa;AAC7B;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA,eAAe,kEAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA,gBAAgB,kEAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,0BAA0B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sCAAsC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC;AACA,eAAe,kBAAkB;AACjC,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8EAA8B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC;AACA,8BAA8B,kEAAY;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,8BAA8B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,wEAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wEAAiB;AAC7B;AACA;AACA;AACA;AACA,oCAAoC,+CAAU;AAC9C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wEAAiB;AAClC;AACA;AACA,sBAAsB,wEAAiB;AACvC;AACA;AACA,sBAAsB,wEAAiB;AACvC;AACA;AACA;AACA;AACA,sCAAsC,kEAAY;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,6CAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,uBAAuB,qDAAyB;AAChD;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,gBAAgB,4BAA4B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yBAAyB;AACxC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wCAAwC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F,QAAQ,0HAA0H;AAC5N;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wCAAwC;AACxD;AACA;AACA;AACA,0FAA0F,QAAQ,0FAA0F;AAC5L;AACA;AACA;AACA,eAAe,yBAAyB;AACxC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wCAAwC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F,QAAQ,0HAA0H;AAC5N;AACA;AACA;AACA,eAAe,yBAAyB;AACxC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wCAAwC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,gBAAgB,wCAAwC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yBAAyB;AACxC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wCAAwC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wCAAwC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wCAAwC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA,gBAAgB,wCAAwC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wCAAwC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA,gBAAgB,wCAAwC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA,mBAAmB,kEAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2DAAe;AAC9B;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kEAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mCAAmC;AACnD;AACA;AACA,YAAY,wEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uCAAuC;AACvD;AACA;AACA,YAAY,wEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,6CAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6CAAG;AACnB;AACA;AACA;AACA,aAAa,wEAAiB;AAC9B,YAAY,qDAAW;AACvB,gBAAgB,6CAAG;AACnB;AACA,aAAa;AACb,gBAAgB,6CAAG;AACnB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,gCAAgC,sDAAW;AAC3C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,wEAAiB;AAC9B;AACA;AACA;AACA;AACA,2CAA2C,wEAAiB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,YAAY,wEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,wEAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,8DAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,0BAA0B,qDAAqD;AAC/E;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,kEAAkE,qDAAqD;AACvH;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,wEAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,gBAAgB,8BAA8B;AAC9C;AACA;AACA;AACA;AACA;AACA,oBAAoB,wEAAiB;AACrC,oBAAoB,6CAAG,sDAAsD,MAAM;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iEAAiB;AACjC;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wEAAiB;AACtC;AACA;AACA;AACA;AACA;AACA,gBAAgB,2CAA2C;AAC3D,aAAa,wEAAiB;AAC9B,aAAa,wEAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,wEAAiB;AAC9B,aAAa,wEAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,6CAA6C,2BAA2B;AACxE;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,gBAAgB,mCAAmC;AACnD;AACA,YAAY,wEAAiB;AAC7B,6CAA6C;AAC7C;AACA;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA,aAAa,wEAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,iDAAiD,+BAA+B;AAChF;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,gBAAgB,uCAAuC;AACvD;AACA,YAAY,wEAAiB;AAC7B,iDAAiD;AACjD;AACA;AACA;AACA;AACA,aAAa,wEAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,oCAAoC,gBAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,YAAY,6CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,gBAAgB,yBAAyB;AACzC,oDAAoD,wEAAiB;AACrE;AACA;AACA,oDAAoD,kEAAsB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,2DAAe;AAChD;AACA;AACA;AACA;AACA;AACA,8BAA8B,kEAAY;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,QAAQ,0DAAM,CAAC,kDAAQ;AACvB,QAAQ,0DAAM;AACd,4CAA4C,kDAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6CAAG;AACf;AACA;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sDAAsD;AACtE;AACA,YAAY,wEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iEAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,eAAe,QAAQ;AACvB;AACA;AACA;AACA,+BAA+B,mDAAW;AAC1C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,QAAQ,6CAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAAe,MAAM,EAAC;;;;;;;;;;;;;;;;;;;;;;;ACx/EtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkC;AACqB;AACU;AACb;AACpD;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,UAAU;AACrB;AACA,WAAW,UAAU;AACrB;AACA,WAAW,QAAQ;AACnB;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI,yDAAyD;AAClE;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,UAAU;AACrB;AACA,WAAW,UAAU;AACrB;AACA,WAAW,QAAQ;AACnB;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP,+BAA+B,wDAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,YAAY,iEAAa;AACzB;AACA;AACA,KAAK,IAAI,2BAA2B;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,QAAQ;AACnB;AACA;AACA,aAAa;AACb;AACO;AACP,YAAY,yBAAyB,EAAE,+CAAM;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,uEAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACxKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACwE;AAC5C;AAC4C;AACZ;AAC5D;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,aAAa;AACb;AACe;AACf,IAAI,4CAAG;AACP,QAAQ,2EAAoB;AAC5B,QAAQ,4CAAG;AACX,eAAe,yEAA0B;AACzC;AACA,+BAA+B,kEAAiB;AAChD;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA,IAAI,4CAAG;AACP;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoD;AAClB;AAC6B;AACnC;AACkD;AAC/B;AACQ;AACF;AACY;AACR;AACD;AACD;AACI;AACb;AAC8C;AAChC;AACZ;AACwB;AACY;AAC7B;AACkB;AACM;AACgB;AACnC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,+BAA+B,4DAAY;AAC1D;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,gBAAgB,wEAAiB,CAAC,mDAAG;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX,8BAA8B,8DAAa;AAC3C;AACA;AACA;AACA;AACA,mBAAmB,0DAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mDAAG;AACX,YAAY,4CAAG;AACf,6BAA6B,uDAAW;AACxC;AACA;AACA;AACA,SAAS;AACT,QAAQ,6DAAa;AACrB;AACA,oBAAoB,gCAAgC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wEAAiB;AACjC;AACA,2BAA2B,qEAAc;AACzC;AACA;AACA,0CAA0C,0DAAqB;AAC/D,gBAAgB,4CAAG;AACnB;AACA,2BAA2B,0DAAqB;AAChD;AACA;AACA,4BAA4B,6BAA6B;AACzD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,0DAAqB;AAC3D;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA,gBAAgB,8BAA8B;AAC9C,gBAAgB,uEAAuE;AACvF;AACA;AACA,YAAY,4CAAG;AACf;AACA,uBAAuB,0DAAqB;AAC5C;AACA;AACA,wBAAwB,6BAA6B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mDAAG;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX,QAAQ,mEAAiB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC,iBAAiB,wEAAiB;AAClC,qCAAqC,oEAAoB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0DAAqB;AAC5C;AACA;AACA,wBAAwB,8BAA8B;AACtD;AACA,8BAA8B,0DAAqB;AACnD,4CAA4C,0DAAqB;AACjE;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0DAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA,sCAAsC,0DAAqB;AAC3D,YAAY,4CAAG;AACf;AACA;AACA,sCAAsC,0DAAqB;AAC3D,sCAAsC,0DAAqB;AAC3D,YAAY,4CAAG;AACf;AACA,eAAe,iFAA0B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gBAAgB;AAChC,0EAA0E,yBAAyB,YAAY,0EAAuB,6BAA6B;AACnK;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,YAAY,4CAAG;AACf,YAAY,4CAAG,mTAAmT,kEAAU;AAC5U;AACA,gBAAgB,wCAAwC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,6DAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4CAAG;AAC3B;AACA;AACA,wBAAwB,4CAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4CAAG;AACvB;AACA;AACA,wBAAwB,4CAAG;AAC3B,uEAAuE,IAAI,IAAI,kEAAU,MAAM;AAC/F,wBAAwB,4CAAG;AAC3B;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,8EAAuB;AACxG,iFAAiF,8EAAuB;AACxG;AACA;AACA;AACA,4BAA4B,4CAAG;AAC/B,4BAA4B,4CAAG,2CAA2C,kEAAU;AACpF;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,wEAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kGAAkG,EAAE,+CAAM;AAC1H;AACA;AACA;AACA,iCAAiC,oEAAmB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kCAAkC;AAC7D;AACA;AACA;AACA,gBAAgB,+BAA+B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qEAAqB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0BAA0B;AACtD,oBAAoB,oFAA4B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,mCAAmC,kFAA0B;AAC7D,oBAAoB,4CAAG;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4CAAG;AAC3B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,8EAAuB;AAC5D;AACA;AACA;AACA;AACA;AACA,oBAAoB,4CAAG;AACvB;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,+CAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA,sCAAsC,6DAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,wEAAiB;AAC9B;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC,mCAAmC,mFAAwB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC,oCAAoC,kFAAuB;AAC3D;AACA;AACA;AACA,oBAAoB,4CAAG;AACvB;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA,6BAA6B,4CAAG;AAChC;AACA;AACA;AACA;AACA;AACA,sCAAsC,6DAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,+CAAU;AACxE;AACA;AACA;AACA,mBAAmB,0DAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,0DAAqB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,0CAA0C,0DAAqB;AAC/D,sCAAsC,0DAAqB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,aAAa;AACb;AACA;AACA,YAAY,eAAe;AAC3B,yCAAyC,iEAAa;AACtD;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,aAAa;AACb;AACA;AACA,YAAY,eAAe;AAC3B,yCAAyC,iEAAa;AACtD;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,cAAc;AACzB,aAAa,cAAc;AAC3B;AACO;AACP;AACA,8CAA8C,8EAAuB;AACrE,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,cAAc;AACzB,aAAa,cAAc;AAC3B;AACA;AACO;AACP;AACA;AACA,oCAAoC,4CAAG;AACvC,QAAQ,4CAAG,0GAA0G,kEAAU;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,0BAA0B;AACrC,WAAW,cAAc;AACzB,aAAa,cAAc;AAC3B;AACA;AACO;AACP;AACA,YAAY,yBAAyB;AACrC;AACA;AACA;AACA,oCAAoC,4CAAG;AACvC,QAAQ,4CAAG,iGAAiG,kEAAU;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA,WAAW,oBAAoB;AAC/B;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,8EAAuB;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA,wCAAwC,8EAAuB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,QAAQ;AACnB;AACA;AACA;AACA,wBAAwB,mEAAY;AACpC;AACA,sBAAsB,wEAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC35BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4B;AACiB;AAC0B;AACf;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf;AACA;AACA,YAAY,+CAA+C;AAC3D;AACA;AACA;AACA,YAAY,oEAAe;AAC3B,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA,UAAU,4EAAsB;AAChC;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA,sBAAsB,2DAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4B;AAC4B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf,YAAY,+CAA+C;AAC3D;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,IAAI,4CAAG;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,IAAI,4CAAG;AACP;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,gCAAgC,oEAAe;AAC/C;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;;;;;;;;;;;;;;;ACrJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4D;AAC5D;AACA;AACA,WAAW,kBAAkB;AAC7B,aAAa;AACb;AACe;AACf,WAAW,kEAAiB;AAC5B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgH;AAC7E;AACmE;AACN;AAC9D;AACiB;AACvB;AACmC;AACR;AACZ;AACsB;AACL;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6BAA6B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,kBAAkB;AAC/B;AACA;AACA,YAAY,kBAAkB,EAAE,+CAAM;AACtC;AACA,YAAY,iEAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA,YAAY,gDAAgD;AAC5D;AACA;AACA;AACA;AACA;AACA,YAAY,iEAAa;AACzB,aAAa,wEAAiB;AAC9B;AACA;AACA;AACA,cAAc,wEAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,wEAAiB;AAC1B;AACA;AACA,SAAS,wEAAiB;AAC1B;AACA;AACA,YAAY,4IAA4I,EAAE,+CAAM;AAChK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mDAAmD;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2DAAO;AACnC,gDAAgD,0BAA0B,IAAI;AAC9E,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2DAAO;AACnC,gDAAgD,0BAA0B,IAAI;AAC9E,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,wCAAwC,4DAA4D;AAC1I;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,oBAAoB;AAC/B;AACA,YAAY,OAAO;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mBAAmB,EAAE,wEAAU;AAC/C,4BAA4B,iEAAa;AACzC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf,IAAI,4CAAG;AACP;AACA;AACA,gBAAgB,kBAAkB,EAAE,+CAAM;AAC1C;AACA;AACA,aAAa,wEAAiB;AAC9B;AACA;AACA,yBAAyB;AACzB,aAAa;AACb;AACA;AACA;AACA;AACA,wBAAwB,oCAAoC;AAC5D;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,+CAAmB;AACzC;AACA;AACA;AACA,YAAY,wEAAiB,CAAC,mDAAG;AACjC;AACA;AACA;AACA,gBAAgB,4BAA4B;AAC5C;AACA,QAAQ,4CAAG,wCAAwC,QAAQ;AAC3D,eAAe,WAAW,KAAK,sBAAsB;AACrD;AACA,mCAAmC,mEAAiB;AACpD,gCAAgC,4CAA4C;AAC5E;AACA;AACA;AACA,iBAAiB,wFAA+B;AAChD;AACA;AACA,gBAAgB,mDAAG;AACnB;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,uCAAuC;AAClD;AACA;AACO;AACP,kCAAkC,mDAAG;AACrC,SAAS,yHAAoC;AAC7C;AACA;AACA;AACA,6BAA6B,qFAAyB,CAAC,+EAAuB;AAC9E;AACA;AACA,gBAAgB,4CAAG;AACnB,aAAa;AACb;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA,oBAAoB,iBAAiB;AACrC,aAAa,iEAAa;AAC1B;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7aA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4D;AAC5D;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,aAAa;AACb;AACe;AACf,yBAAyB,kEAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkE;AACf;AACvB;AACqC;AACT;AACQ;AACJ;AACY;AACF;AACtE;AACA,YAAY;AACZ,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,YAAY,0BAA0B;AACtC,QAAQ,uEAAiB;AACzB;AACA;AACA,IAAI,4CAAG;AACP,eAAe,wEAAuB;AACtC;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B;AACA,WAAW,QAAQ;AACnB;AACA,aAAa;AACb;AACe;AACf,sBAAsB,4DAAuB;AAC7C;AACA;AACA;AACA,YAAY,kEAAkE;AAC9E,+BAA+B,kEAAiB;AAChD;AACA;AACA,QAAQ,wEAAiB;AACzB;AACA;AACA,QAAQ,4CAAG;AACX,gBAAgB,iCAAiC;AACjD;AACA;AACA;AACA,YAAY,uEAAsB;AAClC,cAAc,uEAAiB;AAC/B,gBAAgB,uEAAsB;AACtC;AACA;AACA;AACA;AACA,0BAA0B,8CAA8C;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,4CAAG;AACP,oCAAoC,oEAAmB;AACvD;AACA;AACA;AACA;AACA,kBAAkB,8CAA8C;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,aAAa;AACb;AACA;AACA,IAAI,4CAAG;AACP;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,+CAAmB;AACrC;AACA;;;;;;;;;;;;;;;;;;;;;;;AC5GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0C;AACS;AACqB;AACD;AAC/C;AACxB,+DAAe,0DAAgB,EAAC;AAC8C;;;;;;;;;;;;;;;;;;ACzB9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4B;AACqB;AACW;AAC5D;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf,gCAAgC,2DAAiB;AACjD,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX,cAAc,kEAAiB;AAC/B;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8F;AAC3C;AACvB;AACmC;AACE;AACY;AACE;AACrB;AAC1D;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACe;AACf,IAAI,4CAAG;AACP,YAAY,wBAAwB;AACpC;AACA,gCAAgC,6DAAa;AAC7C;AACA,SAAS,uEAAiB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,IAAI,mEAAU;AACd;AACA,8BAA8B,+CAAmB;AACjD,KAAK;AACL,IAAI,4EAAmB;AACvB,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA,8DAA8D,qEAAkB;AAChF;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,qEAAY;AAChB;AACA;AACA,4BAA4B,sEAAgB;AAC5C;AACA;AACA,QAAQ,4CAAG,2CAA2C,YAAY;AAClE;AACA,QAAQ,6EAAuB;AAC/B;AACA;AACA;AACA,gBAAgB,uEAAiB;AACjC,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iBAAiB,uEAAiB;AAClC,wBAAwB,oBAAoB;AAC5C;AACA,oBAAoB,4CAAG;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,IAAI,4CAAG;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gDAAgD,EAAE,qEAAgB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sCAAsC;AACtE;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA,0CAA0C,uEAAiB;AAC3D;AACA;AACA;AACA;AACA,yFAAyF,mBAAmB;AAC5G,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uEAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa;AACb;AACA;AACA;AACA,mBAAmB,+CAAmB;AACtC;AACA,oBAAoB,+CAAmB;AACvC,SAAS,uEAAiB;AAC1B,QAAQ,sEAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,WAAW,6BAA6B;AACxC,aAAa;AACb;AACA;AACA,IAAI,4CAAG;AACP;AACA;AACA;AACA;AACA;AACA,kBAAkB,+CAAmB;AACrC;AACA,IAAI,4CAAG;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACpPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiE;AACrC;AAC0C;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,aAAa;AACxB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA,kBAAkB,+CAAmB;AACrC;AACA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,aAAa;AACxB,aAAa;AACb;AACe;AACf,QAAQ,uEAAsB;AAC9B,QAAQ,4CAAG;AACX,iBAAiB;AACjB;AACA;AACA,QAAQ,4CAAG;AACX;AACA,iBAAiB;AACjB;AACA,IAAI,4CAAG;AACP;AACA;AACA;AACA;AACA,IAAI,uEAAsB;AAC1B;AACA;AACA,QAAQ,uEAAsB;AAC9B,iBAAiB;AACjB;AACA;AACA,6BAA6B,mDAAY;AACzC;AACA,kBAAkB,+CAAmB;AACrC,iBAAiB;AACjB;AACA;AAC6D;;;;;;;;;;;;;;;ACjF7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sDAAsD;;;;;;;;;;;;;;;;;ACtDvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiF;AAC5B;AACrD;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,gBAAgB;AAC3B,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,gBAAgB;AAC3B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2DAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2DAAiB;AACrC;AACA;AACA;AACA;AACA,aAAa,8EAAuB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2DAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2DAAiB;AAChD;AACA;AACA;AACA;AACA,qBAAqB,8EAAuB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;;;;;;;;;;;;;;;;;;;;AC5IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6F;AACvC;AACvB;AAC2B;AACC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACe;AACf,YAAY,6DAA6D;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,sBAAsB,uFAA0B;AAChD,+BAA+B;AAC/B,YAAY,4CAAG;AACf,YAAY,4CAAG,kCAAkC,iEAAU,QAAQ,KAAK,UAAU;AAClF;AACA;AACA;AACA,kCAAkC,+CAAmB,yDAAyD,iEAAU,QAAQ,MAAM,gDAAgD;AACtL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gEAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,+CAAmB,kCAAkC,UAAU,iCAAiC,iEAAU,QAAQ,MAAM,gDAAgD;AAC1M;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gEAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,+CAAmB,kCAAkC,UAAU,iCAAiC,iEAAU,QAAQ,MAAM,gDAAgD;AAC1M;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gEAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,sBAAsB,+CAAmB,+FAA+F,6BAA6B;AACrK;AACA,aAAa;AACb;;;;;;;;;;;;;;;;AClKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf;AACA;AACA;AACA,IAAI,4CAAG;AACP;AACA,0DAA0D;AAC1D;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA,IAAI,4CAAG;AACP;AACA;;;;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoD;AACpD;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf,QAAQ,8DAAU;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8DAAU;AAClB;AACA;AACA,QAAQ,8DAAU;AAClB;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqD;AACD;AACyB;AAC7E;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,eAAe,2DAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kCAAkC;AACjD,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,eAAe,uEAAiC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,gBAAgB,gBAAgB,QAAQ,sBAAsB,8DAAU,QAAQ;AAChF;;;;;;;;;;;;;;;;ACxGuE;AACvE;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,aAAa,mBAAmB;AAChC;AACA;AACe;AACf,0BAA0B,UAAU,UAAU,MAAM;AACpD;AACA;AACA;AACA;AACA;AACA,iBAAiB,0DAA0D;AAC3E,iCAAiC,iBAAiB,UAAU,aAAa;AACzE,YAAY,wEAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+B;AAC2B;AAC1D;AACA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,QAAQ,4CAAG;AACX;AACA;AACA,QAAQ,iEAAa;AACrB,QAAQ,4CAAG;AACX;AACA;AACA,QAAQ,iEAAa;AACrB,QAAQ,4CAAG;AACX;AACA;AACA,IAAI,4CAAG;AACP;AACA;;;;;;;;;;;;;;;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiF;AACjF;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B,WAAW,oBAAoB;AAC/B,aAAa;AACb;AACO;AACP;AACA,4CAA4C,8EAAuB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B,WAAW,oBAAoB;AAC/B,aAAa;AACb;AACO;AACP;AACA,4CAA4C,8EAAuB;AACnE;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiF;AACnB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA,gBAAgB,SAAS;AACzB;AACA,yCAAyC,2EAAuB;AAChE;AACA;AACA;AACA,uBAAuB,2EAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2EAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACvJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoF;AACrD;AACY;AACyB;AAChB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA,qCAAqC,2DAAgB;AACrD,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,cAAc;AAC3C;AACA,aAAa,uEAAiB;AAC9B;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,gBAAgB,4CAAG,mDAAmD,EAAE;AACxE,aAAa;AACb;AACA,2CAA2C;AAC3C,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,iBAAiB;AACjB;AACA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC;AACA,eAAe,YAAY;AAC3B;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA,mBAAmB,uDAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uDAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA,mBAAmB,uDAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uDAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,iBAAiB;AACjB;AACA;AACA,QAAQ,yDAAM;AACd,+CAA+C,QAAQ;AACvD;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA,iBAAiB;AACjB;AACA;AACA,gDAAgD;AAChD;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,aAAa;AACb;AACA;AACA,IAAI,4CAAG;AACP;AACA,cAAc,uDAAY;AAC1B,QAAQ,4CAAG;AACX;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC5WA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkE;AACZ;AACvB;AACqC;AACpE;AACA;AACA,+DAAe;AACf;AACA;AACA,eAAe,kBAAkB;AACjC,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,eAAe,kBAAkB;AACjC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL,CAAC,EAAC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA,QAAQ,uEAAiB;AACzB;AACA;AACA,IAAI,4CAAG;AACP;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,uEAAiB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA,IAAI,4CAAG;AACP;AACA,cAAc,wEAAY;AAC1B,QAAQ,4CAAG;AACX;AACA;AACA;AACA,kBAAkB,+CAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,4CAAG;AACP,YAAY,sBAAsB;AAClC;AACA,WAAW,wEAAY;AACvB;;;;;;;;;;;;;;;;;;;;;;;;ACnLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+B;AACkD;AACzB;AACF;AACF;AACc;AACE;AACS;AACxB;AACrD;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA,IAAI,8DAAe,YAAY,oCAAoC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,8BAA8B;AAC7C,eAAe,iBAAiB;AAChC;AACA;AACA;AACA,YAAY,uEAAiB,cAAc,sEAAgB;AAC3D,YAAY,4CAAG;AACf;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,8CAA8C,2DAAiB;AAC/D;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA,QAAQ,4CAAG,gCAAgC,kBAAkB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,8DAAU;AAC5C;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,4DAAa;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,8EAAuB;AACpE;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uEAAiC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uEAAiC;AAC7D;AACA;AACA;AACA;AACA;AACA,gCAAgC,qDAAqD;AACrF;AACA;AACA;AACA,sCAAsC,2DAAiB;AACvD;AACA,oCAAoC,8EAAuB;AAC3D;AACA;AACA;AACA;AACA,gCAAgC,4CAAG;AACnC;AACA;AACA;AACA;AACA;AACA,gCAAgC,qDAAqD;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,8EAAuB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,2BAA2B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,aAAa;AACb;AACA;AACA,gCAAgC,sBAAsB;AACtD;AACA;AACA,kBAAkB,2DAAiB;AACnC,KAAK;AACL;;;;;;;;;;;;;;;;ACnUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqE;AACrE;AACe;AACf;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,eAAe,4DAAa;AAC5B;AACA;AACA;AACA;AACA,eAAe;AACf,iBAAiB;AACjB;AACA;AACA,eAAe,4DAAa;AAC5B;AACA;;;;;;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,eAAe,gCAAgC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8DAAU;AAC/B;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,eAAe,gCAAgC;AAC/C,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yDAAyD;AACzE;AACA;AACA;AACA;AACA;AACA,wBAAwB,8DAAU;AAClC;AACA;AACA;AACA;AACA,wBAAwB,iCAAiC;AACzD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC,EAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxHF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6D;AACjC;AACY;AACyB;AAC7B;AACmB;AACV;AACiB;AACQ;AACU;AACb;AACL;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,2CAA2C,sDAAkB;AAC5E;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,kCAAkC,6DAAa;AAC/C;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC,QAAQ,qEAAe;AACvB,gBAAgB,wBAAwB,EAAE,gFAA2B;AACrE;AACA;AACA,uCAAuC,mDAAI;AAC3C,yCAAyC,mDAAI;AAC7C,SAAS;AACT;AACA,QAAQ,wEAAkB;AAC1B;AACA;AACA;AACA;AACA,0CAA0C,sEAAqB;AAC/D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA,gBAAgB,4CAAG;AACnB,gBAAgB,qEAAe;AAC/B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,IAAI,mDAAmD;AACxE;AACA;AACA,gBAAgB,yDAAM;AACtB;AACA;AACA,SAAS,IAAI,mDAAmD;AAChE;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC,eAAe,QAAQ;AACvB;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA,YAAY,4CAAG;AACf;AACA,YAAY,4CAAG;AACf;AACA;AACA,QAAQ,wEAAyB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,uCAAuC,uEAAkB;AACzD;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS,IAAI,mDAAmD;AAChE;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,kBAAkB;AAC7B,aAAa;AACb;AACA;AACA,QAAQ,uEAAiB;AACzB;AACA;AACA,SAAS,uEAAiB;AAC1B;AACA;AACA,cAAc,uEAAiB;AAC/B;AACA;AACA,cAAc,uEAAiB;AAC/B;AACA;AACA;AACA;AACA,aAAa,uEAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA,YAAY,uEAAiB;AAC7B,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA,cAAc,uEAAiB;AAC/B,YAAY,uEAAiB;AAC7B,YAAY,4CAAG;AACf;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+D;AACkD;AACc;AAC7F;AAC+B;AACnB;AACsE;AACH;AAC9C;AACM;AACkC;AAClD;AACN;AACT;AACJ;AACV;AACkD;AACf;AACe;AACb;AAC7B;AACiB;AACD;AACG;AACuB;AACjC;AACkC;AACnB;AACN;AACQ;AACQ;AACU;AACY;AACzB;AACH;AACF;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,4CAA4C,uDAAkB;AAC7E;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,kCAAkC,8DAAa;AAC/C;AACA,yCAAyC;AACzC;AACA;AACA,qDAAqD,kDAAe;AACpE,oCAAoC,sDAAe,yDAAyD,uCAAuC,iFAAiF;AACpO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,6DAAW,aAAa,8EAAwB;AACzE;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,eAAe,kBAAkB;AACjC,eAAe,QAAQ;AACvB;AACA;AACA,wBAAwB;AACxB;AACA,QAAQ,wEAAkB;AAC1B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,eAAe,0BAA0B;AACzC;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,8EAAwB;AACvC,oBAAoB,aAAa;AACjC;AACA,oBAAoB,0CAA0C,EAAE,iFAA2B;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,UAAU,oDAAI;AACnC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,UAAU,oDAAI;AACnC,iBAAiB;AACjB;AACA;AACA;AACA,wBAAwB,wEAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,EAAE,oDAAI;AAC/B;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,8DAAa;AAC9D;AACA,gBAAgB,uEAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,yBAAyB,IAAI,2DAA2D;AACxF;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa,IAAI,2DAA2D;AAC5E,SAAS;AACT;AACA;AACA;AACA,gBAAgB,gIAAgI;AAChJ;AACA,QAAQ,0DAAM;AACd;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,QAAQ,6CAAG;AACX,4BAA4B,oEAAc;AAC1C,QAAQ,6CAAG;AACX;AACA,wCAAwC,0DAA8B;AACtE,iCAAiC,iEAAY,GAAG,+BAA+B;AAC/E,mCAAmC,sDAAc;AACjD,wCAAwC,sDAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,8DAAa;AAClD;AACA,YAAY,uEAAiB;AAC7B;AACA,mFAAmF,WAAW,gGAAgG;AAC9L,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB;AACA;AACA;AACA,gBAAgB,oKAAoK;AACpL,gBAAgB,YAAY;AAC5B;AACA;AACA,8BAA8B,gDAAU;AACxC;AACA;AACA;AACA;AACA;AACA,+BAA+B,oFAAgC;AAC/D;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,sCAAsC,4DAAiB;AACvD;AACA;AACA,SAAS;AACT,gBAAgB,uCAAuC,EAAE,yEAAyB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,qEAAmB;AACnE;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS,IAAI,mDAAmD;AAChE,6BAA6B,iFAA0B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,mCAAmC,yEAAc;AACjD,YAAY,6FAAuC;AACnD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,YAAY,+FAAoC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,8BAA8B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS,IAAI,2BAA2B;AACxC,8CAA8C,sGAAmC;AACjF;AACA,+EAA+E,QAAQ;AACvF,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wEAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,oDAAoD,0DAAsB;AAC1E,mCAAmC,iFAAgB;AACnD,yBAAyB;AACzB,qBAAqB;AACrB;AACA,aAAa,IAAI,mDAAmD;AACpE,SAAS;AACT;AACA;AACA,wBAAwB;AACxB;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ,yDAAkB,GAAG,yBAAyB;AACtD;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,IAAI,0DAA0D;AACnF,iBAAiB;AACjB;AACA;AACA,4BAA4B,sDAAsD;AAClF;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA,4BAA4B,qCAAqC,EAAE,+CAAM;AACzE;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,sCAAsC,qDAAyB;AAC/D,wBAAwB,wGAA8C;AACtE;AACA;AACA;AACA;AACA;AACA,wCAAwC,+BAA+B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6CAAG;AAC3B;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA,mBAAmB,kBAAkB;AACrC;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+BAA+B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA,0CAA0C,sEAAqB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,kCAAkC,uBAAuB,UAAU,mBAAmB;AACtF,gCAAgC,sEAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,4DAAqB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,kDAAQ;AAC7D,mBAAmB,kDAAQ;AAC3B;AACA,aAAa,kDAAQ;AACrB,mBAAmB,kDAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,oBAAoB;AAC/B,WAAW,oBAAoB;AAC/B,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+EAAuB;AAC/C;AACA;AACA;AACA;AACA,wBAAwB,+EAAuB;AAC/C;AACA;AACA;AACA;AACA,wBAAwB,+EAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+EAAuB;AACnD,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,WAAW,UAAU;AACrB;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA,oDAAoD,2EAA2E;AAC/H;AACA;AACA,YAAY,6CAAG;AACf;AACA;AACA;AACA;AACA,YAAY,6CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iEAAiB;AAC7B;AACA;;;;;;;;;;;;;;;;ACn5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,iCAAiC,4DAAY;AACpD;;;;;;;;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyG;AAC9C;AACJ;AACG;AAC1D;AACA;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACe,2DAA2D,8EAA8E;AACxJ;AACA,8BAA8B,6DAAa;AAC3C;AACA;AACA,2BAA2B,wDAAe;AAC1C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,iEAAsB;AACvD;AACA;AACA,0BAA0B,gGAA6B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoF;AACpB;AACjC;AACiD;AACC;AAC3B;AACY;AAClE,8BAA8B,+DAAW;AACzC;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,aAAa;AACxB;AACO;AACP;AACA,QAAQ,4CAAG;AACX,QAAQ,qEAAe;AACvB;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB;AACA,WAAW,oBAAoB;AAC/B;AACA;AACO;AACP,QAAQ,qFAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA,mBAAmB,sEAAgB;AACnC;AACA,4BAA4B,wEAAwB;AACpD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf,WAAW,6EAAwB;AACnC;AACA;AACA,YAAY,4CAAG;AACf;AACA,SAAS;AACT,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;ACvIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqC;AACN;AACsE;AACjC;AACG;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf;AACA,SAAS,uEAAiB;AAC1B,oBAAoB,iEAAsB;AAC1C,oBAAoB,iEAAsB;AAC1C,aAAa,uEAAiB;AAC9B,YAAY,4CAAG;AACf;AACA;AACA,kBAAkB,uEAAiB;AACnC,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA,kBAAkB,uEAAiB;AACnC,YAAY,4CAAG;AACf,oBAAoB,oBAAoB;AACxC;AACA;AACA,kBAAkB,uEAAiB;AACnC,YAAY,4CAAG;AACf,oBAAoB,mBAAmB;AACvC;AACA;AACA,kBAAkB,uEAAiB;AACnC,YAAY,4CAAG;AACf,uCAAuC,0DAAe;AACtD,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA,kBAAkB,uEAAiB;AACnC,YAAY,4CAAG;AACf,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iEAAsB;AAClD;AACA,gBAAgB,0CAA0C;AAC1D,gCAAgC,iEAAsB;AACtD;AACA,gBAAgB,mBAAmB,EAAE,+CAAM;AAC3C;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA,2CAA2C,sEAAqB;AAChE;AACA;AACA;AACA,QAAQ,4CAAG,gBAAgB,UAAU;AACrC,mBAAmB,iBAAiB;AACpC;AACA;AACA,IAAI,4CAAG;AACP;AACA;;;;;;;;;;;;;;;;;;;;ACzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8E;AACiB;AACJ;AACpC;AACG;AAC1D;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf,gCAAgC,6DAAa;AAC7C;AACA,yBAAyB,wDAAe;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,sFAA6B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oFAA2B;AACzD;AACA;AACA,qBAAqB,4EAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI,mEAAmE;AAC5E;AACA;;;;;;;;;;;;;;;;;;;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyG;AAC3B;AACjC;AACd;AACwB;AACvD;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACe,qCAAqC,mFAAmF;AACvI,qCAAqC,wDAAe;AACpD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uFAAkC;AAC9D;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,aAAa,IAAI,yDAAyD;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4EAAsB;AAC1C,sCAAsC,+CAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI,yDAAyD;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI,yDAAyD;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA,oBAAoB,4CAAG;AACvB;AACA;AACA;AACA;AACA;AACA,yCAAyC,iBAAiB;AAC1D;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA,yCAAyC,iBAAiB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,kBAAkB;AAC3D,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4CAAG;AACvB;AACA,sCAAsC,+CAAU;AAChD;AACA;AACA;AACA;AACA;AACA,6CAA6C,0BAA0B;AACvE;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL,aAAa;AACb;;;;;;;;;;;;;;;;;;;;;ACtNsD;AACb;AACV;AACwB;AACG;AACJ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA,WAAW,gBAAgB;AAC3B;AACA;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB;AACA,aAAa,QAAQ;AACrB;AACA;AACe;AACf;AACA;AACA;AACA,aAAa,iDAAQ;AACrB;AACA;AACA,mCAAmC,6DAAa;AAChD;AACA,6BAA6B,wDAAe;AAC5C,+BAA+B,oCAAoC;AACnE;AACA,KAAK;AACL,6BAA6B,iDAAQ;AACrC;AACA;AACA;AACA,IAAI,4CAAG;AACP;AACA;AACA;AACA,oBAAoB,2DAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2DAAqB;AAC3C,sCAAsC,wDAAe;AACrD;AACA;AACA;AACA,kCAAkC,2DAAqB;AACvD;AACA;AACA;AACA,aAAa,IAAI,wCAAwC;AACzD;AACA;AACA;AACA,6BAA6B,eAAe;AAC5C,iBAAiB;AACjB;AACA,aAAa;AACb;AACA,2BAA2B,2DAAqB;AAChD;AACA,uCAAuC,kCAAkC;AACzE;AACA,aAAa;AACb;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,4BAA4B,wCAAwC;AACpE;AACA;AACA,wBAAwB,+CAAmB;AAC3C,wBAAwB,wDAAe;AACvC,mCAAmC,kCAAkC;AACrE;AACA,SAAS;AACT,sBAAsB;AACtB,iBAAiB,oCAAoC;AACrD;AACA;;;;;;;;;;;;;;;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0E;AACrC;AACQ;AACd;AACoB;AACK;AACe;AACH;AACV;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,oCAAoC,4DAAY;AAC/D;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,6DAAa;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oBAAoB,wDAAwD;AAC5E,oBAAoB,yDAAyD,EAAE,+CAAM;AACrF;AACA,4BAA4B,sEAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA;AACA,iBAAiB,sEAAoB;AACrC;AACA;AACA;AACA,oBAAoB,sEAAqB;AACzC;AACA;AACA;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4CAAG;AAC3B;AACA;AACA,wBAAwB,4CAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,0EAA2B;AAClE,kBAAkB,sEAAoB;AACtC,gBAAgB,sEAAqB;AACrC;AACA;AACA;AACA;AACA,oBAAoB,4CAAG;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,QAAQ;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI,mEAAmE;AAChF;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C,oBAAoB,aAAa;AACjC;AACA;AACA;AACA,uCAAuC,yDAAc;AACrD;AACA;AACA;AACA;AACA,wBAAwB,4CAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qBAAqB;AACjC;AACA;AACA;AACA,oBAAoB,iCAAiC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,eAAe,+CAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA,yCAAyC,6DAAa;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,6DAAa;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;AC5aA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA,+DAAe,mBAAmB,EAAC;;;;;;;;;;;;;AChCnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0D;AAC1D,+DAAe,8DAAmB,EAAC;;;;;;;;;;;;;AChBnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC2D;AAC3D;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA,YAAY,UAAU;AACtB;AACA,gBAAgB,eAAe;AAC/B,gCAAgC,sBAAsB;AACtD;AACA,oBAAoB,mEAAmB,0BAA0B,gBAAgB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,sDAAsD,iBAAiB,SAAS;AACjH;AACA;AACA;AACA;AACA;AACA,mCAAmC,yBAAyB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,8BAA8B;AACjE;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,+DAAe,0BAA0B,EAAC;;;;;;;;;;;;;;;;;;;;ACjF1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACwC;AACmB;AACD;AACG;AACY;AACzE;AACA;AACA;AACe,kCAAkC,4DAAY;AAC7D;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,wDAAe;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,6DAAa;AAC3C;AACA;AACA;AACA,uCAAuC,6DAAa;AACpD;AACA,0CAA0C,0EAA0B;AACpE,6CAA6C,+BAA+B;AAC5E;AACA;AACA;AACA,+CAA+C,6DAAa;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qCAAqC,EAAE,+CAAM;AACjE;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,SAAS,IAAI,mDAAmD;AAChE;AACA;AACA;AACA,0CAA0C,0EAA0B;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA,gBAAgB,4BAA4B;AAC5C,gBAAgB,yBAAyB;AACzC;AACA;AACA,wBAAwB,4BAA4B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,gDAAgD;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,wCAAwC,gDAAgD;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC5KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AACuB;AACpE;AACA,WAAW,kBAAkB;AAC7B,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,uEAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,+CAAU;AAC7C;AACA;AACA;AACA;AACA,mCAAmC,+CAAU;AAC7C;AACA;AACA;AACA,mCAAmC,+CAAU;AAC7C;AACA;AACA;AACA,mCAAmC,+CAAU;AAC7C;AACA;AACA;AACA,mCAAmC,+CAAU;AAC7C;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC9DkE;AACrB;AACuB;AACd;AAC/C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,aAAa;AACxB,WAAW,SAAS;AACpB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA,8BAA8B,0DAA0D,UAAU,gDAAgD;AAClJ;AACA;AACA;AACA;AACA;AACA,4BAA4B,sEAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uEAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,2DAAqB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,0BAA0B,+CAAU,mFAAmF,mBAAmB;AAC1I;AACA,SAAS;AACT,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;;;;AC1JwC;AACW;AACJ;AACH;AACW;AACH;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA,YAAY,iDAAiD;AAC7D,0BAA0B,6DAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,uBAAuB,2DAAgB;AACvC;AACA;AACA;AACA;AACA;AACA,cAAc,6DAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,mEAAc;AACvC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,4CAA4C,oBAAoB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mDAAW;AACxC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,QAAQ;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA,cAAc,iEAAY;AAC1B;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC1LyC;AACV;AAC/B;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACe;AACf,IAAI,4CAAG;AACP,mBAAmB,iDAAQ;AAC3B;AACA;AACA;AACA,IAAI,4CAAG;AACP;AACA,IAAI,4CAAG;AACP;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACrB+E;AACN;AACpC;AACN;AACyB;AACE;AACL;AACC;AACG;AACe;AACxE;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA,WAAW,aAAa;AACxB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA,eAAe,kBAAkB;AACjC,eAAe,aAAa;AAC5B;AACA;AACA,QAAQ,4CAAG;AACX,6BAA6B,2DAAgB;AAC7C;AACA;AACA,wCAAwC,6DAAa;AACrD,+CAA+C,6DAAa;AAC5D,2BAA2B,8DAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,QAAQ,4CAAG;AACX,gBAAgB,uCAAuC;AACvD;AACA,mBAAmB,8DAAe;AAClC;AACA,gBAAgB,mEAAmE;AACnF;AACA;AACA,qBAAqB,yDAAwB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB,uBAAuB,8DAAe;AACtC;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB,uBAAuB,8DAAe;AACtC;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA,YAAY,4CAAG;AACf,mBAAmB,8DAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8DAAe;AAC9B;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,6DAAa;AAChE;AACA,eAAe,8DAAe;AAC9B;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,eAAe,8DAAe;AAC9B;AACA;AACA,QAAQ,4CAAG;AACX;AACA,+CAA+C,6DAAa;AAC5D;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qBAAqB;AAC1D;AACA;AACA;AACA;AACA,4CAA4C,6DAAa;AACzD;AACA,oBAAoB,kCAAkC,EAAE,+CAAM;AAC9D;AACA,mCAAmC,0EAAmB;AACtD,uCAAuC,eAAe;AACtD;AACA,4BAA4B,sBAAsB;AAClD,oBAAoB,yEAA0B;AAC9C;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0CAA0C,EAAE,+CAAM;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,6DAAa;AACpD;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,QAAQ,kEAAS;AACjB;AACA;AACA,SAAS;AACT,QAAQ,iEAAQ;AAChB,QAAQ,gEAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0CAA0C,EAAE,+CAAM;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,KAAyC,4BAA4B;AAAA,EAQxE;;;;;;;;;;;;;AClTqD;AACtD,+DAAe,4DAAiB,EAAC;;;;;;;;;;;;;;;;ACDU;AAC6E;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,gBAAgB,OAAO;AACvB,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,aAAa;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sDAAc;AAC1C,4BAA4B,sDAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA,YAAY,KAAyC,4BAA4B;AAAA,EAIxE;AACT;AACA;AACA,6BAA6B,4BAA4B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,oDAAY;AAC1D;AACA;AACA;AACA;AACA,yDAAyD,8DAAsB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,0CAA0C,qDAAa;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,gBAAgB,OAAO;AACvB,oBAAoB,YAAY;AAChC;AACA,eAAe,gBAAgB;AAC/B;AACA,kBAAkB,OAAO;AACzB,gBAAgB,OAAO;AACvB,gBAAgB,YAAY;AAC5B,eAAe,QAAQ;AACvB;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA,gBAAgB,sDAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oDAAY;AAC3C;AACA;AACA;AACA;AACA,6BAA6B,4BAA4B;AACzD;AACA;AACA,oBAAoB,+DAAuB;AAC3C,wBAAwB,sDAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,oDAAY;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sDAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sDAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,oDAAY;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,oBAAoB,sDAAc;AAClC;AACA;AACA;AACA,qCAAqC,qDAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,8DAAsB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qDAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sDAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACrWA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,aAAa;AACxB,aAAa;AACb;AACe;AACf;AACA;AACA,yBAAyB,6BAA6B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACpIwC;AAC+B;AACvE;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA,YAAY,KAAyC,4BAA4B;AAAA,EAGxE;AACT,QAAQ,yDAAU,iBAAiB,YAAY;AAC/C;AACA;AACA;AACA,YAAY,KAAyC,4BAA4B;AAAA,EAGxE;AACT;AACA;AACA,qCAAqC,sBAAsB;AAC3D;AACA;AACA,qCAAqC,2BAA2B;AAChE;AACA,uBAAuB,oEAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/C0D;AAC1D,+DAAe,8DAAmB,EAAC;;;;;;;;;;;;;;;;;ACDM;AACV;AAC/B;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACe;AACf,IAAI,4CAAG;AACP,mBAAmB,iDAAQ;AAC3B;AACA;AACA;AACA,IAAI,4CAAG;AACP;AACA,IAAI,4CAAG;AACP;AACA;;;;;;;;;;;;;;;;;;;;;ACrB0D;AACP;AACpB;AACyB;AACH;AACD;AACpD;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA,eAAe,kBAAkB;AACjC;AACA;AACA,QAAQ,4CAAG;AACX,gBAAgB,sBAAsB,EAAE,kEAAY;AACpD,6BAA6B,2DAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA,mBAAmB,8DAAe;AAClC;AACA,gBAAgB,uCAAuC;AACvD,gBAAgB,mEAAmE;AACnF;AACA;AACA,qBAAqB,2DAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB,uBAAuB,8DAAe;AACtC;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB,uBAAuB,8DAAe;AACtC;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA,YAAY,4CAAG;AACf,mBAAmB,8DAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8DAAe;AAC9B;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,8DAAe;AAC9B;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,eAAe,8DAAe;AAC9B;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA,gBAAgB,+BAA+B;AAC/C;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA,wBAAwB,qBAAqB;AAC7C;AACA,oBAAoB,8DAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+BAA+B;AAC/C;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,KAAyC,4BAA4B;AAAA,EAQxE;;;;;;;;;;;;;ACzMD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyC;AACzC,+DAAe,qDAAW,EAAC;AACI;;;;;;;;;;;;;;;;;;;ACjB/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+D;AACV;AACY;AACX;AACtD;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,gBAAgB;AAC3B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4DAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gCAAgC;AAC9D;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4DAAiB;AACzC;AACA;AACA,6BAA6B,+BAA+B;AAC5D;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,yBAAyB;AAC9C;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACe,sCAAsC,4DAAY;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yBAAyB;AACxC;AACA;AACA,wBAAwB,8BAA8B;AACtD,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yBAAyB;AACxC;AACA;AACA;AACA,wBAAwB,6BAA6B;AACrD,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yBAAyB;AACxC;AACA;AACA,wBAAwB,8BAA8B;AACtD,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,uEAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,uEAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,uEAAiB;AAChC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,wCAAwC,oBAAoB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,uCAAuC,oBAAoB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,wCAAwC,oBAAoB;AAC5D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,wBAAwB,8BAA8B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,wBAAwB,8BAA8B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,wBAAwB,6BAA6B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,8BAA8B;AAC1D,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA,4BAA4B,8BAA8B;AAC1D,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6BAA6B;AACzD,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,8BAA8B;AAC1D,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,8BAA8B;AAClE,gCAAgC,qBAAqB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,6BAA6B;AACjE,gCAAgC,qBAAqB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,8BAA8B;AAClE,gCAAgC,qBAAqB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA,QAAQ,sEAAgB,0BAA0B,aAAa;AAC/D;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B;AACA;AACA,oBAAoB,uBAAuB;AAC3C,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,WAAW;AACtB;AACA;AACA,oBAAoB,uBAAuB;AAC3C,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B;AACA;AACA,oBAAoB,wBAAwB;AAC5C,gBAAgB,cAAc;AAC9B;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACtpB0D;AACH;AACF;AACjB;AACgB;AACG;AACvD;AACA;AACA;AACA;AACA;AACe,8BAA8B,4DAAY;AACzD;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,8BAA8B,6DAAa;AAC3C;AACA;AACA;AACA,uBAAuB,mDAAI;AAC3B;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,6DAAa;AAC/C;AACA;AACA;AACA;AACA,gBAAgB,sDAAsD;AACtE;AACA,8BAA8B,6DAAa;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,8BAA8B,wDAAe;AAC7C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0GAA0G,mEAAwB;AAClI;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA,2FAA2F,iEAAa;AACxG,qFAAqF,mEAAwB;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,8CAA8C;AACnF;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA,yCAAyC,8CAA8C;AACvF;AACA;AACA;AACA;AACA;AACA,2BAA2B,mDAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACxJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkC;AACQ;AACd;AACiG;AAC9E;AACP;AACa;AACY;AACZ;AACD;AACH;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,0BAA0B,4DAAY;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,+CAAM;AAC9F;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,gBAAgB,qCAAqC,EAAE,+CAAM;AAC7D,gBAAgB,UAAU;AAC1B;AACA;AACA,YAAY,KAAyC,4BAA4B;AAAA,EAIxE;AACT;AACA;AACA;AACA,wBAAwB,mCAAmC;AAC3D;AACA;AACA;AACA;AACA,gEAAgE,QAAQ;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uEAAiB;AACtC,4CAA4C,kEAAuB;AACnE;AACA;AACA,wBAAwB,4CAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uEAAiB;AACtC,6CAA6C,kEAAuB;AACpE;AACA;AACA,wBAAwB,4CAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,wDAAe;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uEAAiB;AACtC,6CAA6C,kEAAuB;AACpE;AACA;AACA,wBAAwB,4CAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,wDAAe;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA,4BAA4B,mCAAmC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG,wCAAwC,YAAY,kBAAkB,aAAa;AAClG;AACA;AACA,+BAA+B,yDAAe;AAC9C;AACA;AACA;AACA,mCAAmC,6DAAS;AAC5C;AACA;AACA;AACA;AACA,yFAAyF,mEAAwB;AACjH;AACA,aAAa;AACb;AACA,qCAAqC,+CAAU,qCAAqC,YAAY,iCAAiC,mBAAmB;AACpJ;AACA;AACA;AACA;AACA;AACA,gBAAgB,uEAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,wDAAe;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,gBAAgB,uEAAiB;AACjC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qDAAqD;AAC/E;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA,QAAQ,4CAAG;AACX;AACA,wBAAwB,mCAAmC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG,aAAa,YAAY;AACxC;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG,iDAAiD,YAAY;AAC5E,8BAA8B,SAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX,wDAAwD,QAAQ;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,eAAe,aAAa;AAC5B;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA,gBAAgB,sFAAsF;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,eAAe,qBAAqB;AACpC;AACA;AACA,eAAe,kBAAkB;AACjC;AACA,2BAA2B,iGAAiG;AAC5H;AACA;AACA;AACA;AACA;AACA,iCAAiC,6DAAS,+EAA+E,mBAAmB;AAC5I;AACA;AACA;AACA,sCAAsC,YAAY;AAClD;AACA;AACA;AACA;AACA,2CAA2C,wDAAe;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,wDAAe;AAC1D;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,eAAe,qBAAqB;AACpC;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA,gBAAgB,sFAAsF;AACtG;AACA;AACA;AACA;AACA,iCAAiC,6DAAS,yEAAyE,mBAAmB;AACtI;AACA;AACA;AACA;AACA;AACA,gBAAgB,qCAAqC,EAAE,+CAAM;AAC7D;AACA;AACA;AACA;AACA,2CAA2C,wDAAe;AAC1D;AACA;AACA;AACA;AACA,2CAA2C,wDAAe;AAC1D;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA,eAAe,uEAAiB;AAChC;AACA,cAAc,uDAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,aAAa;AAC9B;AACA;AACA,eAAe,uEAAiB;AAChC;AACA,cAAc,sDAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,aAAa;AAC9B;AACA;AACA,YAAY,uEAAiB;AAC7B;AACA;AACA,eAAe,uDAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,2BAA2B,uEAAiB;AAC5C;AACA;AACA,4BAA4B,kEAAuB;AACnD;AACA;AACA,mBAAmB,gEAAY,CAAC,uDAAY;AAC5C;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,2BAA2B,uEAAiB;AAC5C;AACA;AACA,4BAA4B,kEAAuB;AACnD;AACA;AACA,mBAAmB,gEAAY,CAAC,sDAAW,gBAAgB,QAAQ;AACnE,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,0BAA0B,uEAAiB;AAC3C;AACA;AACA,4BAA4B,kEAAuB;AACnD;AACA;AACA,0BAA0B,uDAAY;AACtC;AACA;AACA;AACA,2BAA2B,gEAAY,wBAAwB,kBAAkB;AACjF,iBAAiB;AACjB;AACA,mCAAmC,gEAAY,UAAU,QAAQ;AACjE;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB,iBAAiB;AACjC,YAAY,uEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC,YAAY,uEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC,YAAY,uEAAiB;AAC7B;AACA;AACA,gBAAgB,+CAA+C,EAAE,+CAAM;AACvE;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC,YAAY,uEAAiB;AAC7B;AACA;AACA,gBAAgB,+CAA+C,EAAE,+CAAM;AACvE;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB,iBAAiB;AACjC,YAAY,uEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC,YAAY,uEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mCAAmC;AAC3D;AACA,iBAAiB,uEAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAyC,4BAA4B;AAAA,EAExE;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6DAAS;AACtC;AACA,aAAa;AACb;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qCAAqC,EAAE,+CAAM;AAC7D;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,kEAAuB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,wDAAe;AAClE;AACA,wCAAwC,kEAAuB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,wDAAe;AAClE;AACA;AACA;AACA;AACA;AACA,yCAAyC,6DAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,6DAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,wDAAe;AAClE;AACA;AACA;AACA;AACA,0CAA0C,qDAAqD;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,6CAA6C;AAC9D,iBAAiB,6CAA6C;AAC9D,gBAAgB,6CAA6C;AAC7D;AACA;AACA;AACA,aAAa;AACb;;;;;;;;;;;;;;;;;;;;ACpmCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4B;AACmB;AACkB;AACX;AACR;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC;AACA,kEAAkE;AAClE,gBAAgB,kBAAkB;AAClC,gBAAgB,wCAAwC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,4DAAiB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gCAAgC;AACxD,uCAAuC,uDAAc;AACrD;AACA,iBAAiB,uEAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAG,yFAAyF,QAAQ,sBAAsB,kBAAkB,OAAO,uBAAuB;AAC1L;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,iBAAiB;AACjB;AACA;AACA,eAAe,6DAAS,0BAA0B,IAAI;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC1NA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsC;AACJ;AACJ;AACgB;AACqB;AACJ;AAC/D,+DAAe,iDAAQ,EAAC;AACA;AACwF;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvBhH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0C;AACd;AAC6E;AAC1D;AACM;AACF;AACN;AACgG;AACvF;AACxB;AACiB;AACkB;AACjE,8BAA8B,+DAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,uBAAuB,4DAAY;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA,gBAAgB,0CAA0C;AAC1D;AACA;AACA;AACA;AACA;AACA,uCAAuC,4DAAiB;AACxD;AACA;AACA;AACA,+BAA+B,+CAAM;AACrC;AACA,SAAS;AACT;AACA;AACA,8BAA8B,+CAAU,6FAA6F,mCAAmC,iDAAa,GAAG;AACxL;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+CAAU,6FAA6F,mCAAmC,iDAAa,GAAG;AACjL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA,eAAe,6DAAS;AACxB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA,eAAe,wDAAgB;AAC/B;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA,eAAe,6DAAS;AACxB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA,eAAe,sDAAc;AAC7B;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA,yCAAyC,yDAAoB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA,yCAAyC,yDAAoB;AAC7D;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,eAAe,8DAAsB;AACrC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,eAAe,uDAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8DAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,QAAQ,4DAAQ;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,QAAQ,4DAAQ;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,QAAQ,4DAAQ;AAChB;AACA,eAAe,6DAAS,2BAA2B,IAAI;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA,eAAe,kHAA2B;AAC1C;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yDAAoB;AAC/C;AACA;AACA,mCAAmC,gEAAc;AACjD;AACA;AACA;AACA;AACA,mCAAmC,+DAAa;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4CAAG,uCAAuC,kBAAkB,QAAQ,uBAAuB;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC5bA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0C;AACK;AACkB;AACsB;AACjD;AACtC;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA,gBAAgB,uEAAiB;AACjC;AACA;AACA;AACA;AACA,0CAA0C,mDAAU;AACpD;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,0BAA0B,+CAAU,kFAAkF,mBAAmB;AACzI;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI;AACb;AACA;AACA,sBAAsB,+CAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,aAAa,uEAAiB,oBAAoB,uEAAiB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,+CAAU,mFAAmF,mBAAmB;AAC1I;AACA,SAAS,IAAI;AACb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,eAAe,sDAAc;AAC7B;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,iBAAiB;AACjB;AACA;AACA,eAAe,6DAAS,2BAA2B,IAAI;AACvD;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA,iBAAiB;AACjB;AACA;AACA,eAAe,+DAAuB;AACtC;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,aAAa;AAC5B;AACA,iBAAiB;AACjB;AACA;AACA,eAAe,0DAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;;;;;;;;;;;;;;;AClOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4B;AAC8B;AACoB;AAC3B;AACnD,uCAAuC,+DAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,0DAA0D,UAAU,yGAAyG;AAC/L;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA,4BAA4B,4BAA4B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,sBAAsB;AACrC,eAAe,YAAY;AAC3B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kCAAkC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8EAAuB;AAC/C;AACA;AACA;AACA;AACA,oBAAoB,4CAAG;AACvB;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA,oCAAoC,qBAAqB;AACzD;AACA;AACA,yCAAyC,6BAA6B;AACtE;AACA,gCAAgC,8EAAuB;AACvD;AACA;AACA;AACA;AACA,gCAAgC,4CAAG;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,kCAAkC;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,eAAe,mEAAwB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAAe,cAAc,EAAC;;;;;;;;;;;;;;;;ACxW9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+B;AAC/B;AACA;AACA;AACA;AACe;AACf;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA,QAAQ,4CAAG;AACX;AACA;;;;;;;;;;;;;;;AC/JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oDAAoD;;;;;;;;;;;;;;;;;;AC7BrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4B;AAC8B;AACX;AAC/C;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+BAA+B;AACnD;AACA,qCAAqC,mEAAc;AACnD;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wDAAoB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,QAAQ,4CAAG,mBAAmB,2BAA2B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,oBAAoB,2BAA2B;AAC/C;AACA,iCAAiC,mEAAc;AAC/C;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,4BAA4B,+BAA+B;AAC3D;AACA,6CAA6C,mEAAc;AAC3D;AACA,oBAAoB,4CAAG,mCAAmC,yBAAyB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,wDAAoB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAG,mBAAmB,2BAA2B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG,mBAAmB,uBAAuB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC5KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0C;AACd;AAC8B;AACL;AACN;AACY;AAC3D;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,gBAAgB;AAC3B,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mEAAmB,uBAAuB,wDAAoB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,gBAAgB;AAC3B,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+CAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mEAAc,gBAAgB,IAAI;AACpE;AACA,kBAAkB,+CAAU;AAC5B;AACA;AACA,sBAAsB,mEAAmB,mDAAmD,wDAAoB;AAChH;AACA,gBAAgB,gEAAY;AAC5B;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA,2CAA2C,uBAAuB;AAClE;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,+CAA+C,uBAAuB;AACtE;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,2BAA2B,mEAAmB,0CAA0C,wDAAoB;AAC5G;AACA,wBAAwB,gEAAY;AACpC;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;AChMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiE;AACjE;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP,QAAQ,uEAAiB;AACzB;AACA;AACA,YAAY,8CAA8C;AAC1D;AACA;AACA;AACA;AACA;AACA,2BAA2B,aAAa,GAAG,iBAAiB;AAC5D;AACA;AACA,2BAA2B,aAAa;AACxC;AACA,eAAe,iBAAiB,KAAK,WAAW,KAAK,eAAe;AACpE,cAAc,mBAAmB,KAAK,cAAc;AACpD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChD2E;AAC/B;AACkB;AACG;AACX;AACtD;AACO;AACP;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA,yBAAyB,sEAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sEAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA,qBAAqB,sEAAqB;AAC1C;AACA;AACO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,uBAAuB,6DAAS;AAChC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,aAAa;AACxB;AACA,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,WAAW,kEAAY;AACvB;AACA,2BAA2B,uEAAiB;AAC5C;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB;AACA,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB;AACA,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,YAAY,iEAAiE;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,YAAY,yGAAyG;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,oBAAoB;AAC/B,WAAW,oBAAoB;AAC/B,WAAW,oBAAoB;AAC/B;AACO;AACP,YAAY,uDAAuD;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8EAAuB;AAC/C;AACA;AACA;AACA;AACA,wBAAwB,8EAAuB;AAC/C;AACA;AACA;AACA;AACA,wBAAwB,8EAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,8EAAuB;AACnD,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,4BAA4B,kEAAY;AACxC;AACA,0BAA0B,uEAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,8CAA8C;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,gBAAgB;AAC3B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yCAAyC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yCAAyC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,8CAA8C;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,8CAA8C;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,qCAAqC;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,qCAAqC;AAC/E;AACA;AACA;AACA,qDAAqD,gDAAgD;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,gDAAgD;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yCAAyC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,mCAAmC,SAAS;AAC5C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxhBqE;AACS;AACS;AAC7B;AACjC;AACsB;AACG;AACY;AACZ;AACA;AACyB;AACf;AACmB;AAC/E;AACA;AACA;AACA,WAAW;AACX;AACe,uCAAuC,4DAAY;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,8DAAa;AAC3C,YAAY,uEAAiB,CAAC,6EAAY;AAC1C,sBAAsB,+CAAU;AAChC;AACA,QAAQ,4CAAG;AACX,gCAAgC,6EAAY;AAC5C;AACA,sBAAsB,uEAAiB;AACvC;AACA,kBAAkB;AAClB,gBAAgB;AAChB;AACA;AACA,oCAAoC,6EAA0B;AAC9D;AACA,QAAQ,qEAAY;AACpB;AACA;AACA,SAAS;AACT,QAAQ,sEAAa;AACrB;AACA;AACA,SAAS;AACT,QAAQ,sEAAa;AACrB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,8DAAa;AAC1D;AACA,YAAY,4CAAG;AACf,YAAY,0EAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACO;AACP;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA,8BAA8B,8DAAa;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,mBAAmB,+DAAe;AAClC;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA,iCAAiC,+CAAiB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+DAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qEAAiB;AAC3C;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gEAAY,GAAG,iBAAiB;AAC9D;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4CAAG,uBAAuB,iBAAiB;AAC/D,kCAAkC,2DAAM;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,+CAAiB;AAC3C,0BAA0B,+CAAiB;AAC3C;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA,0BAA0B,+CAAiB;AAC3C,0BAA0B,+CAAiB;AAC3C;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAA4C;AAC5D;AACA,YAAY,4CAAG;AACf,+CAA+C,6EAA2B;AAC1E;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA,gBAAgB,4BAA4B;AAC5C,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA,oBAAoB,4CAAG;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;;;;;;;;;;;;;;;;;;;AC/cA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0G;AAC9E;AAC2B;AACvD;AACA;AACA,WAAW,kBAAkB;AAC7B,aAAa;AACb;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,QAAQ;AACnB;AACe;AACf,IAAI,4CAAG;AACP;AACA,QAAQ,4CAAG;AACX;AACA;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA,IAAI,4CAAG;AACP,+BAA+B,6DAAa;AAC5C;AACA;AACA,QAAQ,6EAAoB;AAC5B;AACA;AACA,SAAS;AACT;AACA,IAAI,8EAAqB;AACzB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,QAAQ;AACnB;AACO;AACP,mCAAmC,6DAAa;AAChD;AACA,IAAI,qEAAY;AAChB,QAAQ,4CAAG;AACX;AACA,mCAAmC,6DAAa;AAChD;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0F;AACiB;AAC/E;AACwB;AACG;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,6DAAa;AAC3E;AACA;AACA;AACA;AACA,wCAAwC,6DAAa;AACrD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,wCAAwC,6DAAa;AACrD;AACA;AACA;AACA,qDAAqD,6DAAa;AAClE;AACA;AACA;AACA,qDAAqD,6DAAa;AAClE;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI,mEAAmE;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA,sBAAsB,8FAAoC;AAC1D;AACA;AACA;AACA;AACA,oBAAoB,sCAAsC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA,iCAAiC,wDAAe;AAChD;AACA;AACA;AACA,+BAA+B,wDAAe;AAC9C;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,kCAAkC,wDAAe;AACjD,IAAI,qEAAY;AAChB,QAAQ,4CAAG;AACX;AACA,KAAK;AACL,IAAI,sEAAa;AACjB,QAAQ,4CAAG;AACX;AACA,KAAK;AACL,IAAI,sEAAa;AACjB,QAAQ,4CAAG;AACX;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACxQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;;;;;;;;;;;;;;;;;;;ACtBP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqE;AACX;AACb;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,wBAAwB,gEAAS;AACjC;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,YAAY;AACvB,aAAa,YAAY;AACzB;AACA;AACA;AACA,kBAAkB,sDAAc;AAChC,UAAU,2DAAM,CAAC,2DAAM;AACvB,UAAU,2DAAM,CAAC,2DAAM,oBAAoB,2DAAM;AACjD;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,oBAAoB;AAC/B,aAAa;AACb;AACA;AACA,2BAA2B,2DAAM;AACjC;AAC4C;;;;;;;;;;;;;;;;;;AChE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyD;AACD;AACgC;AACxF;AACA;AACA,WAAW,YAAY;AACvB,aAAa;AACb;AACO;AACP,sBAAsB,2DAAM;AAC5B,gBAAgB,mEAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iEAAU,CAAC,4DAAa;AAC5C,WAAW,iEAAU;AACrB;;;;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqD;AACH;AAClD;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8DAAe;AACzC;AACA;AACA;AACA;AACA,wBAAwB,2DAAM;AAC9B;AACA;AACA;AACA;AACA;AACA,0BAA0B,8DAAe;AACzC;AACA;AACA;AACA;AACA,wBAAwB,2DAAM;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6D;AAC7D;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACe;AACf;AACA;AACA;AACA,mBAAmB,2DAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2DAAM;AACzB;AACA;AACA;AACA;AACA;AACA,qBAAqB,2DAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+B;AACY;AACkB;AAC7D;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,UAAU;AACrB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,yDAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2DAAM;AAC5B;AACA,eAAe,2DAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2DAAM;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA,gCAAgC,qBAAqB;AACrD;AACA,kBAAkB,2DAAM;AACxB;AACA,wBAAwB,2DAAM;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2DAAM;AAC5B;AACA;AACA;AACA;AACA,YAAY,2DAAM;AAClB,YAAY,2DAAM;AAClB,YAAY,2DAAM;AAClB,YAAY,2DAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA,kBAAkB,2DAAM;AACxB;AACA,iBAAiB,2DAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA,kBAAkB,2DAAM;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACkH;;;;;;;;;;;;;;;;;;;;AChOlH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC2D;AAC3D;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA,iBAAiB,uDAAa;AAC9B;AACA;AACA;AACA,WAAW,uDAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA,kBAAkB,yDAAe;AACjC;AACA,qBAAqB,uDAAa;AAClC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA,WAAW,uDAAa;AACxB;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA,iBAAiB,uDAAa;AAC9B;AACA;AACA;AACA,iBAAiB,uDAAa;AAC9B;AACA;AACA;AACA,WAAW,uDAAa;AACxB;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA,WAAW,uDAAa;AACxB;AACwD;;;;;;;;;;;;;;;;;;;;ACtFxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+B;AAC+B;AACH;AACF;AACzD;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,aAAa,oBAAoB;AACjC;AACA;AACe;AACf;AACA,iBAAiB,uDAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uDAAa;AACvC;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA,qBAAqB,mEAAe;AACpC;AACA;AACA,6BAA6B,sBAAsB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB;AACA,aAAa;AACb;AACO;AACP;AACA,QAAQ,4CAAG;AACX;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA,0BAA0B,mEAAe;AACzC,WAAW,iEAAU;AACrB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+B;AACY;AAC2D;AAClC;AACiB;AACxC;AACJ;AACc;AACe;AACT;AAC7D;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,aAAa,cAAc,gBAAgB;AAC3C;AACA;AACA,wBAAwB,uDAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,sBAAsB;AACtB;AACA;AACA,sBAAsB,2DAAM;AAC5B;AACA;AACA;AACA;AACA;AACA,eAAe,2DAAM;AACrB;AACA,kBAAkB,2DAAM;AACxB;AACA;AACA;AACA,eAAe,2DAAM;AACrB;AACA,kBAAkB,2DAAM;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2DAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,2DAAM;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,2DAAM;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA,iBAAiB,8CAAO;AACxB;AACA;AACA;AACA,iBAAiB,uDAAa;AAC9B;AACA;AACA;AACA;AACA;AACA,eAAe,2DAAM;AACrB;AACA;AACA,eAAe,2DAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA,iBAAiB,uDAAa;AAC9B;AACA;AACA;AACA;AACA,kBAAkB,2DAAM;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2DAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA,kBAAkB,+CAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA,qBAAqB,uDAAa;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2DAAM;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,2DAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2DAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA,iBAAiB,8CAAO;AACxB;AACA;AACA;AACA,iBAAiB,uDAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2DAAM;AACrB;AACA;AACA,eAAe,2DAAM;AACrB;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,aAAa;AACb;AACA,sBAAsB,uBAAuB;AAC7C;AACA,IAAI,yDAAM;AACV,WAAW,sDAAS,SAAS,2DAAM;AACnC,IAAI,iEAAU,aAAa,2DAAM;AACjC;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,gBAAgB;AAC3B,aAAa,YAAY;AACzB;AACA;AACA,QAAQ,uEAAiB;AACzB;AACA;AACA,wBAAwB,uDAAa;AACrC;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA,oCAAoC,2DAAM;AAC1C,WAAW,2DAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2DAAM;AAC1B;AACA,qBAAqB,sDAAc;AACnC;AACA,uBAAuB,2DAAM;AAC7B;AACA,uBAAuB,2DAAM;AAC7B;AACA;AACA;AACA;AACA,oBAAoB,2DAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2DAAM;AACtB;AACA;AACA,uBAAuB,sDAAc;AACrC,gBAAgB,2DAAM;AACtB;AACA;AACA;AACA;AACA,mBAAmB,2DAAM;AACzB;AACA,mBAAmB,2DAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,qBAAqB,8CAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA,8BAA8B;AAC9B,oBAAoB,wCAAwC,EAAE,+EAAwB;AACtF,oCAAoC;AACpC,oBAAoB,+BAA+B,EAAE,+EAAwB;AAC7E,iCAAiC;AACjC,8BAA8B,2DAAM;AACpC,2BAA2B;AAC3B,0CAA0C,2DAAM;AAChD,2BAA2B;AAC3B,kCAAkC,2DAAM;AACxC,2BAA2B;AAC3B,uBAAuB,2DAAM;AAC7B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA,iBAAiB,qDAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uDAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,iBAAiB,uDAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,iBAAiB,qDAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACwM;;;;;;;;;;;;;;;;;ACzcxM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,gBAAgB;AAC3B;AACA,WAAW,YAAY;AACvB,WAAW,gBAAgB;AAC3B;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0CAA0C;AAC1D;AACA;AACA;AACA;AACA;AACA,gBAAgB,gDAAgD;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oBAAoB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,yBAAyB,aAAa;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;;;;;;;;;;;;;ACvPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkE;AAClE;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,gBAAgB;AAC3B,aAAa;AACb;AACA;AACA;AACA,gBAAgB,6CAA6C;AAC7D;AACA,yCAAyC,iEAA0B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAAe,oBAAoB,EAAC;;;;;;;;;;;;;;;;;AC3CF;AACmB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sBAAsB;AAC/C;AACA;AACA;AACA,yBAAyB,6DAAS;AAClC;AACA,0DAA0D,sBAAsB;AAChF;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACrMqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,cAAc;AACd;AACO;AACP,QAAQ,sEAAgB;AACxB;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,YAAY;AACZ;AACe;AACf;AACA;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkC;AACwC;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf,iDAAiD,sEAAqB;AACtE;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;;;;;;;;;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;;;;;;;;;;;;;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoE;AACF;AAClE;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf;AACA;AACA;AACA,gCAAgC,uEAAkB;AAClD,yBAAyB,wEAAmB;AAC5C;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACuE;AACvE;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB,YAAY;AACZ;AACe;AACf;AACA;AACA;AACA,aAAa,uEAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uEAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uEAAiB;AACtC,qBAAqB,uEAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,uEAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA,kBAAkB,uEAAiB;AACnC;AACA;AACA,2BAA2B,uEAAiB;AAC5C;AACA;AACA,sCAAsC,wCAAwC;AAC9E,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;;;;;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACwI;AACnG;AACrC,+DAAe,kDAAU,EAAC;AAC6F;;;;;;;;;;;;;;;;;;;;;AClBvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqC;AACqC;AACqB;AAC/C;AACmB;AACb;AACtD;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACe;AACf;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA,gBAAgB,sFAAsF;AACtG;AACA;AACA;AACA;AACA;AACA,cAAc,mEAA0B;AACxC;AACA;AACA,cAAc,mEAA0B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,+BAA+B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,iEAAW;AAC7C,gCAAgC,uEAAiB;AACjD;AACA,cAAc,iEAAW;AACzB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,eAAe,6DAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA,eAAe,uEAAuB;AACtC;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mEAAa;AAC5B;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA,kCAAkC,wEAAkB;AACpD,eAAe,mEAAa;AAC5B;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;;;;;;;;;;;;;;;;AC5RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0E;AAC1E;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa;AACb;AACe;AACf;AACA,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uEAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4E;AACxB;AACpD;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,kBAAkB;AAC7B,WAAW,UAAU;AACrB,aAAa;AACb;AACe;AACf;AACA;AACA;AACA,qBAAqB,iEAAW;AAChC,qBAAqB,iEAAW;AAChC,YAAY,kEAAkE;AAC9E;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qEAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iEAAwB;AAC1C;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mBAAmB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC5GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqC;AACqC;AACR;AAClB;AACM;AACvC;AACf;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sFAAsF;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,mEAA0B;AACxC;AACA;AACA;AACA,kBAAkB,mEAA0B;AAC5C;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uEAAiB;AAC7C;AACA,oBAAoB,2DAA2D;AAC/E;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,4BAA4B,6DAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,4BAA4B;AAC5C;AACA;AACA,yBAAyB,wEAAkB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,4CAA4C;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;;;;;;;;;;;;;;;;;;;;;;AClOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC2C;AACN;AACY;AACyB;AAC1B;AACgC;AAC1B;AACtD;AACA;AACA;AACA;AACA;AACe;AACf;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA,gBAAgB,mJAAmJ;AACnK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,mEAA0B;AACxC;AACA;AACA,cAAc,mEAA0B;AACxC;AACA;AACA;AACA;AACA;AACA,4BAA4B,uEAAiB;AAC7C;AACA,oBAAoB,2DAA2D;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,eAAe,6DAAc;AAC7B;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,mDAAmD;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uEAAiB,uBAAuB,uEAAiB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,gDAAgD;AACvH;AACA;AACA;AACA;AACA;AACA,kCAAkC,uEAAiB;AACnD;AACA;AACA;AACA;AACA,yDAAyD,iEAAwB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,YAAY,uEAAiB;AAC7B,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,YAAY,uEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,QAAQ,yDAAM;AACd;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B,oCAAoC,mEAA2B;AAC/D;AACA;AACA;AACA;AACA,YAAY,uEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA,YAAY,uEAAiB;AAC7B;AACA;AACA;AACA,oCAAoC,mEAA2B;AAC/D;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,kDAAkD;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,+CAAM;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AChcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+E;AACN;AACzE;AACA;AACA;AACA;AACA;AACA,WAAW,+BAA+B;AAC1C;AACA,aAAa;AACb;AACe;AACf;AACA;AACA,wBAAwB,qBAAqB;AAC7C,iCAAiC,mEAAiB;AAClD;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C,iCAAiC,mEAAiB;AAClD;AACA;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA,gCAAgC,6EAA6B;AAC7D;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACwC;AACuC;AACD;AACR;AACG;AAC1D;AACf;AACA;AACA,4BAA4B,yEAAwB;AACpD;AACA,QAAQ,4CAAG;AACX,eAAe,6EAA6B;AAC5C;AACA,YAAY,0FAA0F;AACtG;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX,eAAe,6EAA6B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX,eAAe,6EAA6B;AAC5C;AACA;AACA;AACA,UAAU,mEAAiB;AAC3B,UAAU,mEAAiB;AAC3B;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA,eAAe,6EAA6B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,wBAAwB;AAC1E,uBAAuB,mEAAiB;AACxC;AACA;AACA;AACA,kDAAkD,wBAAwB;AAC1E,uBAAuB,mEAAiB;AACxC;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA,gCAAgC,6EAA4B;AAC5D;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACwC;AACqC;AAC7E;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,aAAa;AACxB;AACA;AACA,WAAW,aAAa;AACxB;AACA,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uEAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,4CAAG;AACP;AACA;;;;;;;;;;;;;;;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6E;AAC7E;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,gBAAgB;AAC3B,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uEAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uEAAiB;AAC9C;AACA;AACA;AACA;AACA,gCAAgC,uEAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uEAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0E;AAC1E,+DAAe,sEAA2B,EAAC;;;;;;;;;;;;;;;;;;AChB3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACwC;AACqC;AAC7E;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA,YAAY,uEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4CAAG,2BAA2B,aAAa;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4CAAG,2BAA2B,aAAa;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4CAAG,2BAA2B,aAAa;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACO;AACP;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA;AACA,oBAAoB,4CAAG,2BAA2B,gBAAgB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4CAAG,2BAA2B,gBAAgB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4CAAG,2BAA2B,gBAAgB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8C;AACU;AAChB;AACY;AACyB;AACG;AACO;AAC+B;AACxC;AAC7B;AACmB;AACb;AACA;AACwB;AACiB;AAChG;AACA;AACA;AACA;AACA;AACe;AACf;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2LAA2L;AAC3M;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,sEAAqB;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,oEAA0B;AACxC;AACA;AACA,cAAc,oEAA0B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uEAAiB;AAC7C;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,iEAAW;AAC7C;AACA,kDAAkD,iEAAW;AAC7D;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,eAAe,6DAAc;AAC7B;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,eAAe,wEAAuB;AACtC;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,mEAAa;AAC3B;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mEAAa;AAC5B;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,wEAAkB;AACpD,eAAe,mEAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,QAAQ,yDAAM;AACd;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,gBAAgB,sBAAsB;AACtC,oCAAoC,oEAA2B;AAC/D,gCAAgC,iEAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,kCAAkC,iEAAW;AAC7C;AACA;AACA;AACA;AACA;AACA,mCAAmC,wEAAkB;AACrD;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,wEAAkB;AACjC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,gCAAgC,+CAAY;AAC5C;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0EAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA,oBAAoB,iEAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oEAA2B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wEAAkB;AACjD;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uEAAiB;AAC7B,oBAAoB;AACpB;AACA,oCAAoC,iEAAW;AAC/C,8BAA8B,+EAAyB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA,oCAAoC;AACpC,gBAAgB,wCAAwC,EAAE,+CAAM;AAChE;AACA;AACA;AACA,+CAA+C,8EAA6B;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD,2CAA2C,uFAAqC;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B,WAAW,gBAAgB;AAC3B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,kBAAkB;AAC7B,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA,oBAAoB,2BAA2B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,qBAAqB,uEAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,kBAAkB;AAC7B,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wEAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wEAAkB;AACnC;AACA;AACA,4CAA4C,4BAA4B;AACxE;AACA;AACA,YAAY,mEAAa;AACzB,4BAA4B,wEAAkB;AAC9C,gBAAgB,mEAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,iEAAW;AAChD;AACA;AACA,gBAAgB,yDAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC5qBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACwE;AACxE;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,aAAa;AACb;AACA;AACA;AACA,sBAAsB,sEAAgB;AACtC;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,kBAAkB;AAC7B,WAAW,kBAAkB;AAC7B,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,kBAAkB;AAC7B,WAAW,kBAAkB;AAC7B,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,kBAAkB;AAC7B,aAAa;AACb;AACO;AACP;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;;;;;;;;;;;;;;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP,WAAW,+CAAM;AACjB;;;;;;;;;;;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkC;AACgC;AACb;AACQ;AACQ;AACE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP;AACA,gCAAgC,6DAAS;AACzC,gGAAgG,6DAAS;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,gBAAgB;AAC3B,aAAa,QAAQ;AACrB;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sEAAgB;AAC/C;AACA;AACA,6BAA6B,sEAAgB;AAC7C;AACA;AACA,6BAA6B,uEAAiB;AAC9C;AACA;AACA;AACA;AACA,YAAY,iEAAa,CAAC,iEAA0B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6DAAS;AAC7B,oBAAoB,iEAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACzJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0E;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,iBAAiB,sEAAqB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,sEAAqB;AAC3F;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACrIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkC;AACgC;AACb;AACW;AACH;AACQ;AACE;AACX;AACkC;AACnC;AACT;AAClD;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,gBAAgB;AAC3B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,QAAQ,sEAAgB;AACxB;AACA;AACA,YAAY,oGAAoG;AAChH;AACA,QAAQ,sEAAgB;AACxB,wBAAwB,+BAA+B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAgB;AACxB,wBAAwB,kCAAkC;AAC1D;AACA,QAAQ,sEAAgB;AACxB,wBAAwB,6BAA6B;AACrD;AACA,QAAQ,sEAAgB;AACxB,wBAAwB,+BAA+B;AACvD;AACA;AACA,wBAAwB,wCAAwC;AAChE;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,SAAS,uEAAiB;AAC1B,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA,iBAAiB,uEAAiB;AAClC;AACA;AACA;AACA,oCAAoC,sEAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA,gCAAgC,sCAAsC;AACtE;AACA;AACA,gBAAgB,oCAAoC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kEAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+DAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,6DAAS;AACvB;AACA,aAAa;AACb;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,eAAe,iEAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kEAAoB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,uEAAiB;AAC9B;AACA;AACA,aAAa,uEAAiB;AAC9B;AACA;AACA,aAAa,uEAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iEAAa;AACjC,oCAAoC,mEAAc;AAClD;AACA;AACA;AACA;AACA;AACA,wBAAwB,4CAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uDAAuD;AAC7E;AACA;AACA;AACA,aAAa,uEAAiB;AAC9B,YAAY,uEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iEAA0B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA,IAAI,mEAAoB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,gBAAgB;AAC3B,aAAa;AACb;AACA;AACA;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA,6BAA6B,qFAA6B;AAC1D;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,gBAAgB;AAC3B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACjbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACuE;AACvE;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,kBAAkB;AAC7B,aAAa;AACb;AACe;AACf;AACA;AACA;AACA,QAAQ,uEAAiB;AACzB;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACwC;AACN;AACmB;AACkB;AACG;AACN;AACF;AAClB;AACY;AACoB;AACZ;AACK;AAC9B;AACO;AAClD;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,WAAW,gBAAgB;AAC3B,aAAa;AACb;AACe;AACf,YAAY,qDAAqD;AACjE,QAAQ,uEAAiB;AACzB;AACA,6BAA6B,6DAAS;AACtC;AACA,iBAAiB,uEAAiB;AAClC,SAAS;AACT,gDAAgD,uEAAiB,mBAAmB,uEAAiB;AACrG,cAAc,6DAAc;AAC5B;AACA,6BAA6B,uEAAiB;AAC9C;AACA;AACA;AACA,aAAa,uEAAiB;AAC9B;AACA;AACA;AACA,qCAAqC,oEAAmB;AACxD,iBAAiB,uEAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,4CAAG;AACnC;AACA;AACA,uDAAuD,6DAAc;AACrE;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,oBAAoB,iCAAiC;AACrD,gBAAgB,0BAA0B;AAC1C,aAAa,uEAAiB;AAC9B,gCAAgC,gCAAgC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,WAAW;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,QAAQ;AAClE;AACA,4BAA4B,gFAAgF;AAC5G;AACA;AACA;AACA;AACA,mDAAmD,gCAAgC;AACnF;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA,YAAY,qDAAqD;AACjE;AACA;AACA,aAAa,2BAA2B,uEAAqB,aAAa;AAC1E;AACA,wBAAwB,+DAAe;AACvC,kCAAkC,2EAA0B;AAC5D;AACA;AACA,YAAY,mEAAmE;AAC/E,YAAY,sBAAsB;AAClC,yCAAyC,oEAAwB;AACjE;AACA;AACA;AACA;AACA,KAAK;AACL,wCAAwC,kEAAuB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2DAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,+CAAM;AACxB;AACA;AACA,YAAY,kEAAkE,EAAE,8EAA6B;AAC7G,gBAAgB,sEAAqB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA,mCAAmC,sEAAqB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,cAAc,uEAAiB;AAC/B;AACA;AACA;AACA,aAAa,uBAAuB;AACpC;;;;;;;;;;;;;;;;;;;;;;;;;;;AClSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkC;AACe;AACQ;AACc;AACpB;AACuB;AACf;AACE;AACS;AACL;AACP;AACR;AAClD,yBAAyB,+DAAW;AACpC;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf;AACA;AACA,mCAAmC,mEAAyB;AAC5D;AACA;AACA;AACA,YAAY,sCAAsC;AAClD,uBAAuB,uEAAiB;AACxC;AACA;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA,+BAA+B,+DAAe;AAC9C,gBAAgB,yCAAyC;AACzD;AACA,YAAY,uEAAiB;AAC7B,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAA4C;AAC5D,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+BAA+B,EAAE,mEAAmB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,sEAAqB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,wEAAyB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,SAAS,uEAAiB;AAC1B;AACA,6BAA6B,sEAAqB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA,iCAAiC,sEAAqB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA,2BAA2B,gEAAY,sCAAsC,uEAAiB;AAC9F,2BAA2B,2DAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,uEAAiB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,uEAAiB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B;AACA,WAAW,QAAQ;AACnB;AACA,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA;AACA,gBAAgB,kCAAkC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wDAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gEAAS;AAC3C;AACA;AACA;AACA,wBAAwB,4CAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,0CAA0C;AAC3E,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC9QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC2D;AAC6E;AACxI;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf;AACA,YAAY,yLAAyL;AACrM;AACA;AACA;AACA;AACA,0CAA0C,aAAa;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B,kCAAkC,gDAAuB;AACzD;AACA;AACA,gBAAgB,cAAc;AAC9B,kCAAkC,gDAAuB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gEAAY,GAAG;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gDAA2B;AACzD,kBAAkB,gDAA2B;AAC7C,kBAAkB,gDAA2B;AAC7C;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC,sCAAsC,gDAAuB;AAC7D;AACA;AACA,oBAAoB,cAAc;AAClC,sCAAsC,gDAAuB;AAC7D;AACA;AACA,sCAAsC,gDAA2B;AACjE;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACnGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkC;AACmB;AACM;AACwB;AACrB;AACM;AAClB;AAClD;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,aAAa;AACb;AACA,6BAA6B,4FAA4F;AACzH;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,yCAAyC,6DAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA,yBAAyB;AACzB;AACA,yBAAyB;AACzB;AACA;AACA;AACA,eAAe,2EAAqB;AACpC;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iCAAiC;AAC3D;AACA;AACA,0BAA0B,gCAAgC;AAC1D;AACA;AACA,0BAA0B,mCAAmC;AAC7D;AACA;AACA,0BAA0B,iCAAiC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gEAAY,GAAG;AAC7C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,oCAAoC,uEAAwB;AAC5D;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA,uCAAuC,8DAAe;AACtD;AACA;AACA;AACA;AACA;AACA,mBAAmB,4BAA4B;AAC/C;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6DAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gGAAkC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC3OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyD;AACzD;AACA,WAAW,gBAAgB;AAC3B,WAAW,gBAAgB;AAC3B,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA,wBAAwB,wBAAwB;AAChD;AACA,2BAA2B,4DAAU;AACrC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;;;;;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;AACtD,+DAAe,4DAAiB,EAAC;;;;;;;;;;;;;;;;;;;;;;;;AChBjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0E;AACrC;AACkB;AACE;AACyB;AACrC;AACA;AACQ;AACyF;AAC9I;AACA;AACA,WAAW,UAAU;AACrB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kCAAkC;AACtD;AACA;AACA;AACA;AACA;AACA,oDAAoD,mDAAW;AAC/D;AACA;AACA,sDAAsD,mDAAW;AACjE;AACA;AACA;AACA,0DAA0D,oDAAY;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,6DAAqB;AACrE;AACA;AACA,wBAAwB,uEAAiB;AACzC,wDAAwD,mDAAW;AACnE;AACA;AACA,0DAA0D,mDAAW;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,mDAAW;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,+FAA8C;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uEAAiB;AACzC,0CAA0C,mDAAW;AACrD;AACA;AACA,4CAA4C,mDAAW;AACvD;AACA;AACA;AACA,wBAAwB,uEAAiB;AACzC,2DAA2D,mDAAW;AACtE;AACA;AACA,6DAA6D,mDAAW;AACxE;AACA;AACA;AACA,+DAA+D,wDAAgB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,wDAAgB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,4DAAoB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,8DAAsB;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA,uBAAuB,mDAAW;AAClC,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mDAAe;AAC3C;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mDAAe;AAC3C;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,mDAAe;AAC3C;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,mDAAe;AAC3C;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,mDAAe;AAC3C;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,mDAAe;AAC3C;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,mDAAe;AAC3C;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,2DAAuB;AACnD;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,2DAAuB;AACnD;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,mDAAe;AAC3C;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,qDAAiB;AAC7C;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,qDAAiB;AAC7C;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,gDAAY;AACxC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gDAAY;AACxC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,2DAAuB;AACnD;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,mDAAe;AAC3C;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,iDAAa;AACzC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,iDAAa;AACzC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mDAAe;AAC3C;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,iDAAa;AACzC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,gDAAY;AACxC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC;;;;;;;;;;;;;;;ACxWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACe;AACf;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqC;AAC4B;AAC3B;AACtC;AACA,WAAW,UAAU;AACrB,aAAa;AACb;AACA;AACA;AACA;AACA,oBAAoB,sCAAsC;AAC1D;AACA;AACA;AACA;AACA;AACA,kDAAkD,mDAAW;AAC7D;AACA,wBAAwB,4CAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,UAAU;AACxB;AACA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iEAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACe;AACf;AACA;AACA,cAAc,sBAAsB;AACpC;;;;;;;;;;;;;;;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACuD;AACvD;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACe;AACf;AACA,oBAAoB,YAAY;AAChC,sBAAsB;AACtB;AACA;AACA;AACA,uBAAuB,mDAAW;AAClC,oBAAoB,+BAA+B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mDAAe;AAC3C;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+BAA+B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mDAAW;AAClC,oBAAoB,+BAA+B;AACnD;AACA;AACA;AACA;AACA;AACA,4BAA4B,mDAAe;AAC3C;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,mDAAe;AAC3C;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACpGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;AACtD;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACe;AACf;AACA;AACA,uBAAuB,mDAAW;AAClC,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA;AACA,4BAA4B,kDAAc;AAC1C;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqC;AACoB;AACS;AACe;AACjF;AACA;AACA,WAAW,UAAU;AACrB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;AACA,0DAA0D,oDAAY;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,+EAAsC;AAC3F;AACA;AACA;AACA;AACA;AACA,sCAAsC,mDAAW;AACjD;AACA;AACA;AACA;AACA,2EAA2E,8DAAsB;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,8DAA8D;AAC5E;AACA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA,uBAAuB,mDAAW;AAClC,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iDAAa;AACzC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,iDAAa;AACzC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,iDAAa;AACzC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,iDAAa;AACzC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,iDAAa;AACzC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,iDAAa;AACzC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,iDAAa;AACzC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,iDAAa;AACzC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,iDAAa;AACzC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,iDAAa;AACzC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA,cAAc,sBAAsB;AACpC;;;;;;;;;;;;;;;;;;;;;AC/KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgF;AAC3C;AACoB;AACZ;AACQ;AACc;AACnE;AACA,WAAW,UAAU;AACrB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2BAA2B;AAC/C;AACA;AACA;AACA;AACA,0DAA0D,oDAAY;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,6FAA6C;AAC1G;AACA;AACA;AACA;AACA;AACA,+DAA+D,wDAAgB;AAC/E;AACA;AACA;AACA;AACA;AACA,6EAA6E,4DAAoB;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,8DAAsB;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,0EAA0E;AACpF;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA,uBAAuB,mDAAW;AAClC,oBAAoB,qCAAqC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iDAAa;AACzC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,iDAAa;AACzC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,gDAAY;AACxC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA,cAAc,sBAAsB;AACpC;;;;;;;;;;;;;;;;;;;;;;ACxIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0E;AACrC;AACoB;AACZ;AACA;AACQ;AACgF;AACrI;AACA,WAAW,UAAU;AACrB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mCAAmC;AACvD;AACA;AACA;AACA;AACA,0DAA0D,oDAAY;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,mDAAW;AAChE;AACA;AACA,+DAA+D,wDAAgB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,wDAAgB;AAC/E;AACA;AACA;AACA;AACA;AACA,uEAAuE,4DAAoB;AAC3F;AACA;AACA;AACA;AACA;AACA,2EAA2E,8DAAsB;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uEAAiB;AACzC,wDAAwD,mDAAW;AACnE;AACA;AACA,0DAA0D,mDAAW;AACrE;AACA;AACA;AACA,wBAAwB,uEAAiB;AACzC,2DAA2D,mDAAW;AACtE;AACA;AACA,6DAA6D,mDAAW;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA,uBAAuB,mDAAW;AAClC,oBAAoB,6CAA6C;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mDAAe;AAC3C;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gDAAY;AACxC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,2DAAuB;AACnD;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,mDAAe;AAC3C;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iDAAa;AACzC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,iDAAa;AACzC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mDAAe;AAC3C;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mDAAe;AAC3C;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,iDAAa;AACzC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,gDAAY;AACxC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,0BAA0B,4CAAQ;AAClC;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA,cAAc,sBAAsB;AACpC;;;;;;;;;;;;;;;;;AC9NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmD;AACkD;AACrG;AACA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACe;AACf;AACA;AACA,uBAAuB,mDAAW;AAClC;AACA,oBAAoB,gCAAgC;AACpD;AACA;AACA;AACA,iEAAiE,2DAAmB;AACpF;AACA;AACA;AACA;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA;AACA,4BAA4B,mDAAe;AAC3C;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,iDAAa;AACzC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,kDAAc;AAC1C;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,gDAAY;AACxC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,iDAAa;AACzC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,gDAAY;AACxC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,mDAAe;AAC3C;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,mDAAe;AAC3C;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,mDAAe;AAC3C;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8D;AACjB;AACF;AAC3C;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACe;AACf,iCAAiC,wDAAgB;AACjD;AACA;AACA;AACA,oBAAoB,gCAAgC;AACpD;AACA;AACA;AACA,yDAAyD,uDAAe;AACxE;AACA;AACA;AACA;AACA;AACA,gBAAgB,gEAAY,SAAS,MAAM;AAC3C;AACA;;;;;;;;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0E;AACZ;AACjB;AACe;AACO;AACnE;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACe;AACf,wCAAwC,wDAAgB;AACxD;AACA;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA,iCAAiC,4DAA2B;AAC5D;AACA;AACA;AACA,gBAAgB,gEAAY,GAAG;AAC/B;AACA;AACA,KAAK;AACL,uBAAuB,mDAAW;AAClC,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA,oBAAoB,uEAAiB;AACrC,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iDAAa;AACzC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,gDAAY;AACxC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gDAAY;AACxC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;AACtD;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACe;AACf;AACA;AACA,uBAAuB,mDAAW;AAClC,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kDAAc;AAC1C;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kDAAc;AAC1C;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqC;AACuB;AACY;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,YAAY,0CAA0C,IAAI;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,wCAAwC,YAAY,2CAA2C,IAAI;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,YAAY,2BAA2B,IAAI;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,YAAY,mDAAmD,IAAI;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,wCAAwC,YAAY,oCAAoC,IAAI;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,aAAa;AACb;AACA;AACA,SAAS,sEAAgB;AACzB,wCAAwC,YAAY;AACpD;AACA;AACA;AACA;AACA,wCAAwC,YAAY,0CAA0C,IAAI;AAClG;AACA;AACA,gCAAgC,sEAAgB;AAChD,mBAAmB,sEAAgB;AACnC,mBAAmB,sEAAgB;AACnC,mBAAmB,sEAAgB;AACnC,mBAAmB,sEAAgB;AACnC,mBAAmB,sEAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA,wCAAwC,YAAY,0CAA0C,IAAI;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA,gBAAgB,4DAAa;AAC7B;AACA;AACA,wCAAwC,YAAY,oCAAoC,IAAI;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,eAAe;AAC1B;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB;AACA;AACA,4BAA4B,0BAA0B;AACtD;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoM;;;;;;;;;;;;;;;;;;;;ACvSpM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6D;AACU;AACpC;AACsC;AACM;AAC/E;AACA;AACA,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACe;AACf;AACA,QAAQ,uEAAiB;AACzB;AACA;AACA,8BAA8B,sFAAmC;AACjE,gBAAgB,mDAAU;AAC1B;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,yBAAyB;AACjE,oCAAoC,2DAA2D;AAC/F;AACA;AACA;AACA;AACA;AACA,gCAAgC,uEAAiB;AACjD;AACA;AACA;AACA;AACA;AACA,4CAA4C,oBAAoB;AAChE;AACA,uEAAuE,4FAAsC;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,YAAY,gEAAiB;AAC7B;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+B;AACgC;AACL;AACf;AACkB;AACK;AACE;AACG;AACf;AACG;AACM;AACZ;AACM;AACG;AACpB;AACgB;AACD;AACkB;AAC3B;AACI;AACe;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,aAAa;AACb;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,QAAQ;AACvB,gBAAgB;AAChB;AACA;AACA,iCAAiC,kEAAc;AAC/C;AACA,4BAA4B,kEAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4CAAG;AACvB;AACA;AACA,+BAA+B,4DAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4CAAG;AACvB;AACA;AACA,+BAA+B,4DAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA,gBAAgB,6FAA6F;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iEAAa,CAAC,iEAA0B;AACrD,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAyC,4BAA4B;AAAA,EAExE;AACT,gBAAgB,wBAAwB,EAAE,kEAAc;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI,+BAA+B;AAC5C,yCAAyC,wEAA2B;AACpE,sBAAsB,2DAAW;AACjC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ,yDAAM;AACd,+CAA+C,sEAAgB;AAC/D;AACA,0BAA0B,iFAAiC;AAC3D,6BAA6B,sEAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA,kBAAkB,uEAAiB;AACnC,kBAAkB,uEAAiB;AACnC,kBAAkB,uEAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uEAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA,kCAAkC,8DAAmB;AACrD;AACA;AACA;AACA;AACA,aAAa;AACb,mCAAmC,gEAAY,GAAG;AAClD;AACA,gCAAgC,SAAS;AACzC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,gCAAgC,wBAAwB;AACxD;AACA;AACA,iCAAiC;AACjC,qBAAqB;AACrB;AACA,wCAAwC,sCAAsC;AAC9E,0DAA0D;AAC1D;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wEAAqB;AACrD;AACA;AACA;AACA,YAAY,uEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sEAAgB;AACzC;AACA;AACA;AACA,gBAAgB,+BAA+B,EAAE,kEAAc;AAC/D;AACA;AACA,yCAAyC,mEAAmB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,uBAAuB,gEAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uEAAiB;AAC1C;AACA;AACA,yBAAyB,uEAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uEAAiB;AAC1C;AACA;AACA,yBAAyB,uEAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sEAAqB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sEAAqB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,uEAAiB;AACnC;AACA,QAAQ,sEAAgB;AACxB;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,sBAAsB;AACjC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,+DAAS,SAAS,2DAAM,qBAAqB,iEAAU;AAClE;AACA,IAAI,2DAAM;AACV;AACA,+DAAe,2BAA2B,EAAC;;;;;;;;;;;;;;;;;ACjgB3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkE;AAClE;AACA,WAAW,QAAQ;AACnB,WAAW,kBAAkB;AAC7B,aAAa;AACb;AACO;AACP;AACA;AACA,uBAAuB;AACvB;AACA;AACA,oBAAoB,sEAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,UAAU;AAChC;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP;AACA,yCAAyC,EAAE;AAC3C,yBAAyB,sEAAgB;AACzC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0D;AACK;AAC/D,+DAAe,sDAA2B,EAAC;AACN;;;;;;;;;;;;;;;;AClBrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkE;AAClE;AACA;AACA,WAAW,SAAS;AACpB;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sEAAgB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8BAA8B;AACtD;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;AACD;AACM;AACe;AAC1E;AACA,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,yBAAyB,2DAAM;AAC/B,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA;AACA,wBAAwB,4DAAa;AACrC,qBAAqB,mFAA8B;AACnD,uBAAuB,iEAAU;AACjC;AACA;AACA;AACA;AACA,oBAAoB,GAAG;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+C;AAChB;AACY;AAC4B;AACS;AACpB;AAC5D;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA,gBAAgB,2DAA2D;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yBAAyB;AAC7C;AACA,8BAA8B,wEAAkB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,4BAA4B,2CAA2C;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,sBAAsB;AACtC,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sEAAqB;AACpC,wBAAwB,oBAAoB;AAC5C;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,yEAA0B;AACnD;AACA,oCAAoC,sBAAsB,kBAAkB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA,mBAAmB,wEAAkB;AACrC;AACA,0CAA0C,QAAQ;AAClD;AACA,mCAAmC,sEAAqB;AACxD,oBAAoB,+BAA+B;AACnD,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,QAAQ,yDAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA,eAAe,wEAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sBAAsB;AACtC,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iCAAiC,+CAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACnaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+B;AACwC;AACO;AAClB;AACS;AACb;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA,gBAAgB,kEAAkE;AAClF;AACA;AACA,gIAAgI,sEAAqB;AACrJ;AACA;AACA;AACA;AACA,8BAA8B,wEAAkB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,sEAAqB;AAC9D;AACA;AACA;AACA,YAAY,+EAAyB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,uBAAuB,wEAAkB;AACzC,YAAY,wEAAkB;AAC9B;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA,2BAA2B,wEAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4CAAG;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA,QAAQ,0EAAqB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA,YAAY,oEAAe;AAC3B;AACA;AACA;;;;;;;;;;;;;;;;AC5JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+D;AAC/D;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACe;AACf;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,wEAAkB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,UAAU;AACrB,WAAW,GAAG;AACd,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B,mBAAmB,iBAAiB;AACpC;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,0BAA0B,YAAY;AACtC;AACyE;;;;;;;;;;;;;;;;;ACjCzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+B;AAC2B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACe;AACf;AACA;AACA;AACA,YAAY,iEAAa;AACzB,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iEAAa;AACjC,oBAAoB,4CAAG;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iEAAa;AACrC,wBAAwB,4CAAG;AAC3B,yCAAyC,iBAAiB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACe;AACf;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+B;AAC6C;AAC5E;AACA,WAAW,gBAAgB;AAC3B,aAAa;AACb;AACe;AACf,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,0EAA6B;AAClE;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,qCAAqC,0EAA6B;AAClE;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,aAAa;AACb;;;;;;;;;;;;;;;;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+B;AAC+C;AAC9E;AACA,WAAW,gBAAgB;AAC3B,aAAa;AACb;AACe;AACf,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,2EAA8B;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,2EAA8B;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoE;AACpE;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,uBAAuB;AAClC,WAAW,kBAAkB;AAC7B,aAAa;AACb;AACO;AACP,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,uEAAiB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,aAAa;AACxB,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACjJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AACd;AACsB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,gBAAgB;AAC3B,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kEAAkB;AAC1C;AACA,kBAAkB,+CAAU;AAC5B;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA,IAAI,4CAAG;AACP;AACA;AACA;;;;;;;;;;;;;;AChIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkE;AACE;AACpE,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,+BAA+B,IAAI,IAAI;AACvC;AACA;AACA;AACA;AACA;AACA,aAAa,uEAAiB,WAAW,uEAAiB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,6BAA6B,IAAI,IAAI;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,aAAa;AAC1B;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA,QAAQ,sEAAgB;AACxB;AACA;AACA,yDAAyD,MAAM;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sEAAgB;AACpC;AACA;AACA;AACA,gCAAgC,oBAAoB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,+DAAe,SAAS,EAAC;;;;;;;;;;;;;;;AC7LzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;AACY;AACE;AACpE,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B;AACA,aAAa;AACb;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C,gBAAgB,mBAAmB;AACnC,YAAY,sEAAgB,WAAW,uEAAiB;AACxD,wBAAwB,gEAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,+BAA+B,IAAI,IAAI;AACvC;AACA;AACA;AACA;AACA;AACA,aAAa,uEAAiB,WAAW,uEAAiB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,aAAa;AAC1B;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA,QAAQ,sEAAgB;AACxB;AACA;AACA,yDAAyD,MAAM;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,4BAA4B,sDAAsD;AAClF;AACA;AACA;AACA;AACA,+DAAe,SAAS,EAAC;;;;;;;;;;;;;;;;ACzJzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,QAAQ;AACnB;AACA,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA,WAAW,sEAAgB;AAC3B;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkE;AACV;AACxD;AACA;AACA,WAAW,gBAAgB;AAC3B;AACA,aAAa;AACb;AACe;AACf;AACA,oBAAoB,qBAAqB;AACzC,YAAY,sEAAgB;AAC5B,6BAA6B,kEAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4C;AACJ;AACxC;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf;AACA;AACA;AACA,sBAAsB,2DAAY;AAClC;AACA;AACA,0BAA0B,sDAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,gBAAgB;AAC3B,aAAa;AACb;AACA;AACA,YAAY,sBAAsB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA,mCAAmC,4BAA4B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,aAAa;AACb;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC1JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;AACV;AACJ;AACxC;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf;AACA;AACA;AACA,sBAAsB,2DAAY;AAClC;AACA,oBAAoB,sBAAsB;AAC1C,0BAA0B,sDAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,YAAY,sBAAsB;AAClC;AACA,WAAW,gEAAU;AACrB;;;;;;;;;;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkE;AACnB;AAC/C;AACA;AACA,cAAc,OAAO;AACrB,YAAY,OAAO;AACnB,gBAAgB,eAAe;AAC/B,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAgB;AACxB;AACA;AACA;AACA,SAAS,sEAAgB,sBAAsB,sEAAgB;AAC/D;AACA;AACA;AACA;AACA,SAAS,sEAAgB,sBAAsB,sEAAgB;AAC/D;AACA;AACA;AACA,kBAAkB,4DAAc;AAChC,gBAAgB,4DAAc;AAC9B;AACA;AACA;AACA,aAAa;AACb;;;;;;;;;;;;;;;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkE;AAClE;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf;AACA,QAAQ,sEAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+B;AACmC;AAClE;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,QAAQ,sEAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;;;;;;;;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkD;AACQ;AACQ;AACd;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,cAAc;AACzB,WAAW,gBAAgB;AAC3B,WAAW,gBAAgB;AAC3B,aAAa;AACb;AACO;AACP;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oCAAoC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iEAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sEAAgB;AAChC,8BAA8B,6DAAS;AACvC;AACA,oCAAoC,gCAAgC;AACpE;AACA,6BAA6B,sEAAgB;AAC7C,gCAAgC,sEAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sEAAgB;AAChC,+BAA+B,6DAAS;AACxC;AACA,oCAAoC,gCAAgC;AACpE;AACA,6BAA6B,sEAAgB;AAC7C,gCAAgC,sEAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA,oBAAoB,oCAAoC;AACxD;AACA,YAAY,8DAAU;AACtB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC9HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkE;AACE;AAC7B;AACvC;AACA;AACA,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf;AACA;AACA;AACA,kBAAkB,sEAAgB,cAAc,yDAAS;AACzD,qBAAqB,sEAAgB;AACrC,UAAU,yDAAS;AACnB;AACA,sBAAsB,sEAAgB,YAAY,yDAAS;AAC3D,QAAQ,uEAAiB;AACzB,SAAS,uEAAiB,eAAe,uEAAiB;AAC1D;AACA;AACA,gBAAgB,uEAAiB;AACjC,aAAa;AACb;;;;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6D;AAC3B;AACQ;AAC1C;AACA;AACA,WAAW,aAAa;AACxB,WAAW,QAAQ;AACnB;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kDAAY;AACpC,yBAAyB,kDAAY;AACrC;AACA;AACA;AACA;AACA;AACA,YAAY,kEAAY;AACxB;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA,YAAY,kEAAY;AACxB;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;;;;;;;;;;;;;;;;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6D;AAC3B;AACQ;AAC1C;AACA;AACA,WAAW,aAAa;AACxB,WAAW,QAAQ;AACnB;AACe;AACf;AACA;AACA;AACA;AACA;AACA,0BAA0B,kDAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kEAAY;AACpB;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA,YAAY,kEAAY;AACxB;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;;;;;;;;;;;;;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6D;AAC3B;AACQ;AAC1C;AACA,WAAW,aAAa;AACxB,WAAW,QAAQ;AACnB;AACe;AACf;AACA;AACA;AACA;AACA;AACA,4BAA4B,kDAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kEAAY;AACpB;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;;;;;;;;;;;;;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6D;AAC3B;AACQ;AAC1C;AACA,WAAW,aAAa;AACxB,WAAW,QAAQ;AACnB;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kDAAY;AACpC,yBAAyB,kDAAY;AACrC;AACA;AACA;AACA;AACA;AACA,YAAY,kEAAY;AACxB;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA,YAAY,kEAAY;AACxB;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;;;;;;;;;;;;;;;;;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6D;AAC3B;AACQ;AAC1C;AACA,WAAW,aAAa;AACxB,WAAW,QAAQ;AACnB;AACe;AACf;AACA;AACA;AACA;AACA;AACA,yBAAyB,kDAAY;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kEAAY;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA,0BAA0B,kDAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kEAAY;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA,yBAAyB,kDAAY;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kEAAY;AACpB;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA,0BAA0B,kDAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kEAAY;AACpB;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6D;AACQ;AACV;AACL;AACiC;AAC9C;AACK;AACI;AACT;AACE;AACsB;AACL;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA,QAAQ,sEAAgB;AACxB,8BAA8B,qEAAmB;AACjD;AACA;AACA;AACA,QAAQ,sEAAgB;AACxB,wCAAwC,qEAAmB;AAC3D;AACA;AACA;AACA,QAAQ,sEAAgB;AACxB;AACA;AACA;AACA,iCAAiC,qEAAmB;AACpD;AACA,uCAAuC,uEAAsB;AAC7D;AACA,iBAAiB,sEAAgB;AACjC;AACA,uCAAuC,uEAAsB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,qEAAmB;AAC5D;AACA,+CAA+C,uEAAsB;AACrE;AACA,yBAAyB,sEAAgB;AACzC;AACA,+CAA+C,uEAAsB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAgB;AACxB;AACA;AACA;AACA;AACA,QAAQ,sEAAgB;AACxB;AACA;AACA;AACA;AACA,QAAQ,sEAAgB;AACxB,QAAQ,4DAAa;AACrB;AACA;AACA,QAAQ,kEAAY;AACpB;AACA;AACA;AACA;AACA,QAAQ,sEAAgB;AACxB;AACA;AACA;AACA;AACA,QAAQ,sEAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAgB;AACxB,QAAQ,yDAAW;AACnB;AACA;AACA;AACA,QAAQ,sEAAgB;AACxB;AACA;AACA;AACA;AACA,6BAA6B,sEAAgB;AAC7C;AACA;AACA,QAAQ,sEAAgB;AACxB,QAAQ,0DAAY;AACpB;AACA;AACA;AACA,QAAQ,sEAAgB;AACxB,QAAQ,yDAAW;AACnB;AACA;AACA;AACA,QAAQ,sEAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAgB;AACxB;AACA;AACA;AACA;AACA,QAAQ,sEAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,kEAAY;AAChB;AACA;AACA;AACA,QAAQ,sEAAgB;AACxB,wCAAwC,qEAAmB;AAC3D;AACA;AACA;AACA,QAAQ,sEAAgB;AACxB,QAAQ,8DAAe;AACvB;AACA;AACA;AACA,QAAQ,sEAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,gBAAgB;AAC3B,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB;AACA,eAAe,iBAAiB;AAChC,eAAe,SAAS;AACxB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA,wBAAwB,kBAAkB,EAAE,kEAAoB;AAChE,oBAAoB,sEAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8DAAkB;AACvC;AACA;AACA;AACA,qBAAqB,yDAAa;AAClC;AACA;AACA;AACA,mDAAmD,sEAAgB;AACnE;AACA;AACA;AACA,iCAAiC,gEAAY,GAAG,SAAS,kEAAoB;AAC7E;AACA;AACA;AACA;AACA;AACA,2BAA2B,gEAAY,GAAG;AAC1C;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,gBAAgB;AAC3B,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB,WAAW;AACX,aAAa;AACb;AACe,2EAA2E,uCAAuC;AACjI,iBAAiB,gEAAoB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sBAAsB,EAAE,kEAAoB;AAC5D,YAAY,sEAAgB;AAC5B,kDAAkD,qEAAmB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC/bA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,aAAa;AACb;AACe;AACf;AACA,QAAQ,sEAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO,EAAE,MAAM;AACxC,oBAAoB,OAAO,EAAE,MAAM;AACnC,oBAAoB,OAAO,EAAE,MAAM;AACnC,mBAAmB,OAAO,EAAE,MAAM;AAClC;;;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACuD;AACvD,+DAAe,0DAAoB,EAAC;;;;;;;;;;;;;;;;;ACpBpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACuD;AACV;AAC7C;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf,YAAY,uGAAuG;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iBAAiB;AAC7B,YAAY,aAAa,EAAE,gEAAiB;AAC5C,oBAAoB,2DAAa;AACjC;AACA;AACA,KAAK;AACL,aAAa;AACb;;;;;;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsC;AACqE;AACxE;AACnC;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA,YAAY,OAAO;AACnB;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACe;AACf,uBAAuB,uDAAS;AAChC;AACA;AACA,gBAAgB,iBAAiB;AACjC,YAAY,gGAA2B;AACvC,YAAY,0FAAqB;AACjC;AACA,oBAAoB,sDAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACuE;AAC+B;AACtG;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACe;AACf;AACA;AACA,aAAa,uDAAiB;AAC9B,SAAS,uEAAiB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,uDAAiB;AAC9B,SAAS,uEAAiB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,qDAAe;AAC5B,SAAS,uEAAiB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,sDAAgB;AAC7B,SAAS,uEAAiB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACuD;AACvD,+DAAe,0DAAoB,EAAC;;;;;;;;;;;;;;;;;;;;;;ACpBpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqD;AACI;AACY;AACE;AAChB;AACL;AACe;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB,WAAW,gBAAgB;AAC3B,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,aAAa;AACb;AACe;AACf,YAAY,wEAAwE;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa,EAAE,gEAAiB;AAC5C;AACA,gBAAgB,gEAAU;AAC1B;AACA;AACA;AACA,QAAQ,8DAAQ;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD,+CAA+C;AAC/C,+CAA+C;AAC/C,8CAA8C;AAC9C,8CAA8C;AAC9C,+CAA+C;AAC/C;AACA;AACA,qBAAqB,8DAAkB;AACvC;AACA;AACA,qBAAqB,yDAAa;AAClC;AACA;AACA;AACA,oDAAoD,sEAAgB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA,QAAQ,sEAAgB;AACxB,wBAAwB,0DAAoB;AAC5C,aAAa,uEAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAgB;AACxB,wBAAwB,0DAAoB;AAC5C,aAAa,uEAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC1MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsC;AACH;AACnC;AACA;AACA;AACA;AACe;AACf,uBAAuB,uDAAS;AAChC;AACA;AACA,oBAAoB,sDAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkD;AACgB;AACV;AACX;AAC+B;AACR;AAC0C;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uDAAW;AAChC,2BAA2B,yDAAa;AACxC,4BAA4B,0DAAc;AAC1C,+BAA+B,wDAAY;AAC3C,yBAAyB,2DAAa;AACtC;AACA;AACA,wBAAwB,4BAA4B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mEAAqB;AACpD;AACA,qBAAqB;AACrB;AACA;AACA;AACA,QAAQ,uEAAwB;AAChC;AACA;AACA,wBAAwB,6BAA6B;AACrD;AACA;AACA;AACA;AACA,sCAAsC,mEAAqB;AAC3D;AACA,wBAAwB,sEAAgB;AACxC,sCAAsC,6DAAS;AAC/C;AACA,0CAA0C,gEAAY,GAAG;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kEAAoB;AAC9C;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA,6BAA6B,gEAAoB;AACjD,uCAAuC,gEAAY,GAAG,aAAa,kEAAoB;AACvF;AACA,6CAA6C,sEAAgB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AC3JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,GAAG,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE;AACjE;AACA,kCAAkC,GAAG,QAAQ,EAAE,MAAM,EAAE;AACvD;AACA,qCAAqC,GAAG,QAAQ,EAAE,MAAM,EAAE,KAAK,GAAG;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,IAAI,WAAW,IAAI;AACtD;AACA,uCAAuC,EAAE,WAAW,EAAE,WAAW,EAAE,WAAW,EAAE;AAChF;AACA;AACA;AAC4O;;;;;;;;;;;;;;;;;;;AClC5O;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+B;AAC8B;AACH;AACF;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B;AACe;AACf;AACA;AACA;AACA;AACA;AACA,uCAAuC,mEAAc;AACrD;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA,oBAAoB,iEAAa;AACjC,oBAAoB,4CAAG;AACvB;AACA;AACA;AACA;AACA,iCAAiC,gEAAY,GAAG;AAChD;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA,8CAA8C;AAC9C;AACA;;;;;;;;;;;;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgJ;AAChJ;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,QAAQ,6DAAuB;AAC/B;AACA;AACA,aAAa,sDAAgB;AAC7B,mCAAmC,sDAAgB;AACnD;AACA,aAAa,yDAAmB;AAChC,mCAAmC,yDAAmB;AACtD;AACA,aAAa,uDAAiB;AAC9B;AACA;AACA,aAAa,qDAAe;AAC5B;AACA;AACA,aAAa,oDAAc;AAC3B,mCAAmC,oDAAc;AACjD;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA,oBAAoB,uDAAiB;AACrC;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA,oBAAoB,qDAAe;AACnC;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA,oBAAoB,6DAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAAe,SAAS,EAAC;;;;;;;;;;;;;;;;;;;;;;;;AC3HzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoE;AACpE;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,iBAAiB;AAC5B,aAAa;AACb;AACO;AACP,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA,iBAAiB,uEAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,aAAa;AACb;AACO;AACP;AACA;;;;;;;;;;;;;;;;;ACrJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkE;AACH;AAC/D;AACA;AACA,WAAW,gBAAgB;AAC3B;AACA,WAAW,QAAQ;AACnB;AACA,aAAa;AACb;AACe;AACf;AACA,+BAA+B,qBAAqB;AACpD,YAAY,yDAAiB;AAC7B,6BAA6B,yDAAiB;AAC9C;AACA;AACA;AACA,iBAAiB,sEAAgB;AACjC;AACA;AACA;AACA,mBAAmB,sEAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkE;AACpB;AAC9C;AACA;AACA,WAAW,gBAAgB;AAC3B;AACA,WAAW,QAAQ;AACnB;AACA,aAAa;AACb;AACe;AACf;AACA,+BAA+B,qBAAqB;AACpD;AACA,YAAY,2DAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA,mBAAmB,sEAAgB;AACnC;AACA;AACA;AACA;AACA;AACA,iBAAiB,sEAAgB;AACjC;AACA;AACA;AACA,mBAAmB,sEAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0D;AAC1D;AACA,WAAW,QAAQ;AACnB,WAAW,gBAAgB;AAC3B,aAAa;AACb;AACe;AACf;AACA;AACA,yBAAyB,EAAE,OAAO,EAAE,OAAO,EAAE;AAC7C;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC,4BAA4B,kEAAmB;AAC/C;AACA;AACA;;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA,gCAAgC,eAAe;AAC/C,qBAAqB,IAAI,0BAA0B,eAAe;AAClE;AACA,KAAK,IAAI;AACT;;;;;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC2D;AAC3D;AACA;AACA,WAAW,iCAAiC;AAC5C,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA;AACA,kDAAkD,gEAAY;AAC9D;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,mBAAmB;AACnB,gCAAgC,oBAAoB,IAAI,oBAAoB,GAAG;AAC/E,kBAAkB,iCAAiC,EAAE;AACrD,iBAAiB,sBAAsB,EAAE;AACzC,gBAAgB,oCAAoC,sBAAsB,aAAa;AACvF,uBAAuB,+BAA+B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACrKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6D;AACQ;AACrE;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,gBAAgB;AAC3B,WAAW,gBAAgB;AAC3B,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA,QAAQ,iEAAa;AACrB;AACA;AACA;AACA,4BAA4B,yBAAyB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sEAAgB;AACpC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,kCAAkC,iEAAa;AAC/C;AACA;AACA;AACA;AACA;AACA,oCAAoC,iEAAa;AACjD;AACA;AACA,4BAA4B,gCAAgC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gCAAgC;AACxD;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqD;AACrD,+DAAe,4DAAgB,EAAC;;;;;;;;;;;;;;;;;ACpBhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqE;AACI;AACzE;AACA;AACA,WAAW,wBAAwB;AACnC,YAAY;AACZ;AACe;AACf,oBAAoB,0EAA0B;AAC9C;AACA;AACA;AACA,gCAAgC,2BAA2B;AAC3D;AACA,0CAA0C;AAC1C;AACA,2BAA2B,sEAAgB;AAC3C,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE,2BAA2B,sEAAgB;AAC3C;AACA;AACA,gEAAgE;AAChE;AACA;AACA,2BAA2B,sEAAgB;AAC3C,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,KAAK;AACL,aAAa;AACb;;;;;;;;;;;;;;;;;;;;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AACI;AACF;AACI;AACA;AACpB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY;AACZ;AACe;AACf,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,iCAAiC,+DAAuB;AACxD,wBAAwB,6DAAc;AACtC,sBAAsB,2DAAY;AAClC,mBAAmB,8DAAgB;AACnC,oBAAoB,sBAAsB;AAC1C,0BAA0B,4DAAa;AACvC;AACA,4BAA4B,oDAAM;AAClC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqE;AACR;AACD;AAC5D;AACA;AACA,cAAc,OAAO;AACrB,YAAY,OAAO;AACnB,gBAAgB,YAAY;AAC5B;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,kBAAkB;AAC7B,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,kBAAkB;AAC7B,aAAa;AACb;AACe;AACf,YAAY,wCAAwC;AACpD;AACA;AACA;AACA,oBAAoB;AACpB,yBAAyB;AACzB,0BAA0B;AAC1B,mCAAmC;AACnC,sCAAsC;AACtC,gCAAgC;AAChC;AACA;AACA;AACA,kBAAkB,mEAAoB;AACtC;AACA;AACA;AACA;AACA;AACA,mDAAmD,iBAAiB;AACpE;AACA,YAAY,kBAAkB;AAC9B,uBAAuB,sEAAgB;AACvC;AACA;AACA;AACA,IAAI,oEAAoB;AACxB;AACA,KAAK;AACL;AACA;AACA,aAAa;AACb;;;;;;;;;;;;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0D;AAC1D,+DAAe,0DAAuB,EAAC;;;;;;;;;;;;;;;;;;;;;ACpBvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqD;AACR;AACE;AACI;AACE;AACX;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA;AACA,iCAAiC,+DAAuB;AACxD,sBAAsB,2DAAY;AAClC;AACA;AACA,0BAA0B,4DAAa;AACvC;AACA,8BAA8B,0DAAW;AACzC;AACA,oBAAoB,8DAAQ;AAC5B,oBAAoB,gEAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6D;AACQ;AACrE;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,4BAA4B;AACvC;AACe;AACf,QAAQ,sEAAgB;AACxB;AACA;AACA;AACA,QAAQ,sEAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iEAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iEAAa;AACjC;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAgB;AACxB;AACA;AACA;AACA,QAAQ,iEAAa;AACrB;AACA;AACA;;;;;;;;;;;;;;;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyD;AACzD;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf,YAAY,sBAAsB;AAClC;AACA,WAAW,gEAAU;AACrB;;;;;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+C;AAC/C;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,YAAY,OAAO;AACnB,iBAAiB,OAAO;AACxB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,4DAAc;AAChC,gBAAgB,4DAAc;AAC9B;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,cAAc,OAAO;AACrB,YAAY,OAAO;AACnB,eAAe,iBAAiB;AAChC,gBAAgB,eAAe;AAC/B,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uBAAuB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACnGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkE;AAClE;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf;AACA,QAAQ,sEAAgB,mBAAmB,sEAAgB;AAC3D,sBAAsB,sEAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkE;AAClE;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sEAAgB;AAC3B;AACA;AACA;AACA;AACyI;;;;;;;;;;;;;;;;;;;;;;;;;;AChHzI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoE;AACrC;AACN;AACwC;AAChC;AACiB;AACK;AACN;AACG;AACuB;AACZ;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,6DAAa;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mDAAI;AACvB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,iBAAiB;AACjB;AACA;AACA,eAAe,8EAAwB;AACvC;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,gBAAgB,kGAAkG,EAAE,+CAAM;AAC1H,4CAA4C,wDAAe;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0CAA0C;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,sEAAoB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sEAAoB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mEAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gEAAY,GAAG;AACvC,0BAA0B,oEAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,YAAY,4CAAG;AACf,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf,YAAY,4CAAG;AACf,wGAAwG,MAAM;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0FAA0F,EAAE,+CAAM;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA,YAAY,kBAAkB,EAAE,+CAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,aAAa;AACb;AACA;AACA,YAAY,qFAAqF;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA,gCAAgC,mIAAmI;AACnK,YAAY,kBAAkB,EAAE,+CAAM;AACtC,YAAY,mDAAmD;AAC/D,YAAY,oEAAoE;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sEAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,kBAAkB;AAC7B,aAAa;AACb;AACA;AACA,YAAY,wCAAwC,EAAE,+CAAM;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW,sEAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA,kCAAkC,WAAW,KAAK,cAAc,KAAK,SAAS;AAC9E;AACA;AACA;AACA,yDAAyD,YAAY;AACrE;AACA;AACA;AACA;AACA,iCAAiC,UAAU;AAC3C;AACA;AACA;AACA,6DAA6D,YAAY;AACzE;AACA;AACA;AACA;AACA,sDAAsD,YAAY;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,aAAa;AACb;AACA;AACA;AACA,WAAW,gEAAY;AACvB;AACA;AACA;AACA,sBAAsB,oEAAmB;AACzC;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;ACpqBA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmD;AACpC;AACf;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,4DAAU;AACrB;;;;;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACuD;AACvD;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA,gBAAgB,cAAc;AAC9B,+BAA+B,gEAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,oBAAoB;AAC/B,aAAa;AACb;AACe;AACf;AACA;AACA;AACA,YAAY,wCAAwC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,aAAa;AACb;;;;;;;;;;;;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACwC;AACxC,+DAAe,kDAAa,EAAC;;;;;;;;;;;;;;;;;;;ACpB7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkD;AACR;AACa;AACX;AAC5C;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,oBAAoB;AAC/B,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf;AACA;AACA;AACA,cAAc,mEAAc;AAC5B;AACA;AACA;AACA,eAAe,0DAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,oBAAoB,gDAAgD;AAC7E;AACA;AACA,eAAe,0DAAO;AACtB;AACA,mDAAmD,kBAAkB,OAAO,6DAAS,iBAAiB;AACtG;AACA;AACA;AACA;AACA;AACA,SAAS,oBAAoB,gDAAgD;AAC7E;AACA;AACA;AACA,eAAe,0DAAO;AACtB;AACA,mDAAmD,kBAAkB,OAAO,6DAAS,6CAA6C;AAClI;AACA;AACA;AACA;AACA;AACA,SAAS,oBAAoB,gDAAgD;AAC7E;AACA,0BAA0B,0DAAO;AACjC;AACA,+CAA+C,kBAAkB,OAAO,6DAAS,iBAAiB;AAClG;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,0BAA0B,0DAAO;AACjC;AACA,+CAA+C,kBAAkB,OAAO,6DAAS,sBAAsB;AACvG;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,qBAAqB,2DAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;ACvG0C;AACS;AACc;AACV;AACc;AACA;AACrE;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,aAAa;AACb;AACO;AACP;AACA;AACA,yCAAyC,6DAAa;AACtD;AACA;AACA,8GAA8G,gBAAgB;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,GAAG;AACtB;AACA;AACA;AACA,gBAAgB,0EAAqB;AACrC;AACA;AACA,YAAY,0EAAqB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,GAAG;AACtB;AACA;AACA;AACA;AACA;AACA,yDAAyD,QAAQ;AACjE;AACA;AACA;AACA;AACA,gEAAgE,QAAQ;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,QAAQ;AACpE;AACA;AACA;AACA;AACA,sEAAsE,QAAQ;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uEAAiB,CAAC,2DAAW;AACnD,gCAAgC,2DAAW;AAC3C;AACA,8BAA8B,+CAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACrJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyE;AACvB;AACG;AACrD;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,kBAAkB;AAC7B;AACA,WAAW,kBAAkB;AAC7B;AACA,WAAW,kBAAkB;AAC7B;AACA,WAAW,QAAQ;AACnB,WAAW,oBAAoB;AAC/B,aAAa;AACb;AACe;AACf;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,qDAAqD,2DAAM;AAC3D,oBAAoB,uEAAqB;AACzC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,sBAAsB,gEAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkC;AACS;AACL;AACV;AACkB;AACO;AACX;AACwB;AACnD;AACf,YAAY,oBAAoB;AAChC;AACA;AACA;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iDAAQ;AAChC;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA;AACA;AACA,gBAAgB,4CAAG;AACnB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,wBAAwB,4CAAG;AAC3B;AACA;AACA;AACA,oBAAoB,4CAAG;AACvB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,yDAAQ;AAC7C,yBAAyB;AACzB;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA,2CAA2C,+CAAM;AACjD,qDAAqD,+CAAM;AAC3D;AACA,0BAA0B,0DAAO;AACjC;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,0BAA0B,0DAAO;AACjC;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,+BAA+B,gEAAY;AAC3C;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,+BAA+B,gEAAY;AAC3C;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB;AACzB;AACA,iBAAiB;AACjB,kCAAkC,mDAAW;AAC7C;AACA;AACA,qBAAqB;AACrB,2BAA2B,gEAAY,GAAG;AAC1C;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAyC;AACjD;AACA;AACA,IAAI;AASG;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAyC;AACjD;AACA;AACA,IAAI;AASG;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa;AACb;AACA;AACA;AACA,eAAe,gEAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa;AACb;AACA;AACA;AACA,+CAA+C,gEAAS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAS;AACxB;AACA;AACA,eAAe,gEAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AChUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsC;AACiC;AACP;AACT;AACF;AACU;AACX;AACA;AACS;AAC7D;AACA;AACA,WAAW,QAAQ;AACnB;AACA,aAAa;AACb;AACA,6BAAe,oCAAU;AACzB,2BAA2B,2EAAsB,GAAG,8CAA8C,gGAAgG,yEAA0B;AAC5N,2BAA2B,4DAAsB;AACjD,0BAA0B,2DAAqB;AAC/C,oCAAoC,2DAA+B;AACnE,4BAA4B,wDAAuB;AACnD,4BAA4B,wDAAuB;AACnD;AACA;AACA,oBAAoB,6DAA6D;AACjF;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,gBAAgB,6DAA6D;AAC7E;AACA,yBAAyB;AACzB,0BAA0B;AAC1B,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,YAAY,iDAAQ;AACpB,SAAS,iDAAQ;AACjB,YAAY,iDAAQ;AACpB;;;;;;;;;;;;;;;;;;;;;;;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiD;AACe;AACnB;AACU;AACX;AACyB;AACX;AACJ;AACS;AACE;AACjE;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP;AACA;AACA,eAAe,gEAAiB;AAChC;AACA;AACA,UAAU,mEAAc;AACxB;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA,gDAAgD,kBAAkB,OAAO,6DAAS,iBAAiB;AACnG;AACA;AACA;AACA;AACA,0BAA0B,0EAAqB;AAC/C;AACA,YAAY,gEAAgB;AAC5B,mBAAmB,uEAAsB;AACzC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,YAAY,4DAAQ;AACpB;AACA;AACA;AACA,uBAAuB,0DAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,aAAa;AACb;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACe,iCAAiC,iFAAiF;AACjI;AACA;AACA,UAAU,4EAAyB;AACnC;AACA,eAAe,aAAa;AAC5B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA,oBAAoB,kEAAmB;AACvC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,uBAAuB,GAAG;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,+CAAiB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;;;;;ACxMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACuG;AACL;AACR;AACzB;AACK;AACD;AACT;AAC5D;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACe,2CAA2C,gCAAgC;AAC1F;AACA;AACA,gBAAgB,kCAAkC;AAClD,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,0EAAqB;AACnD;AACA;AACA;AACA;AACA,6BAA6B,uEAAW;AACxC;AACA;AACA,8BAA8B,oFAAuB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,kBAAkB,2EAAqB;AACvC,wBAAwB;AACxB;AACA;AACA,oCAAoC,2EAAc;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,mCAAmC,oEAAmB;AACtD;AACA,gCAAgC,qCAAqC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA,0BAA0B,iFAAmB;AAC7C;AACA;AACA,0BAA0B,gFAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6EAAgB;AACxC;AACA;AACA,wBAAwB,8EAAgB;AACxC;AACA,gCAAgC,uEAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AC1JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgE;AACnB;AACU;AACX;AACyB;AACX;AACJ;AACS;AACE;AACjE;AACA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACe,mCAAmC,6CAA6C;AAC/F;AACA;AACA,UAAU,4EAAyB;AACnC;AACA,eAAe,aAAa;AAC5B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B,2BAA2B,kEAAmB;AAC9C;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,mBAAmB,gEAAiB;AACpC;AACA;AACA,cAAc,mEAAc;AAC5B;AACA;AACA;AACA;AACA,oDAAoD,kBAAkB,OAAO,6DAAS,iBAAiB;AACvG;AACA;AACA;AACA;AACA,8BAA8B,0EAAqB;AACnD;AACA;AACA,gBAAgB,gEAAgB;AAChC,uBAAuB,sEAAsB;AAC7C;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,gBAAgB,4DAAQ;AACxB;AACA;AACA;AACA;AACA;AACA,yBAAyB,0DAAO;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,yBAAyB,0DAAO;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,iBAAiB;AACjB;AACA;;;;;;;;;;;;;;;;;;;;ACzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyF;AACvB;AACI;AACD;AAC+B;AACpG;AACA;AACA;AACA,WAAW,+BAA+B;AAC1C,WAAW,SAAS;AACpB;AACA,WAAW,QAAQ;AACnB;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,YAAY,UAAU;AACtB,YAAY,qBAAqB;AACjC;AACA;AACA,qBAAqB,gEAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gFAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,6EAAgB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2EAAqB;AAC5C,sBAAsB,wFAA+B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,+BAA+B;AAC1C,WAAW,SAAS;AACpB;AACA,WAAW,QAAQ;AACnB;AACA;AACA,aAAa;AACb;AACA;AACA,YAAY,kCAAkC;AAC9C,YAAY,sBAAsB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gEAAS;AACjC;AACA;AACA;AACA;AACA;AACA,sBAAsB,8EAAqB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACe,mCAAmC,gCAAgC;AAClF;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,kCAAkC;AAClD,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,0EAAqB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC5L8C;AACS;AACX;AACc;AAC1D;AACA;AACA,WAAW,aAAa;AACxB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP;AACA,uBAAuB,kEAAmB;AAC1C;AACA;AACA;AACA;AACA,UAAU,mEAAc;AACxB;AACA;AACA;AACA;AACA,gDAAgD,kBAAkB,OAAO,6DAAS,mBAAmB;AACrG;AACA;AACA;AACA;AACA,WAAW,8DAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP;AACA,YAAY,6CAA6C;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oCAAoC;AAC1D,6BAA6B,yCAAyC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4B;AACoD;AAC/B;AACjD;AACA;AACA,WAAW,YAAY;AACvB,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oEAAO;AAC5B;AACA,2BAA2B,oDAAS;AACpC,0BAA0B,oDAAS;AACnC;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,gFAAmB;AAC5C;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,uBAAuB;AACvB;AACA,aAAa;AACb;;;;;;;;;;;;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0C;AAC1C,+DAAe,kDAAe,EAAC;;;;;;;;;;;;;;;ACpB/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,aAAa;AACb;AACe;AACf;AACA;;;;;;;;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4E;AAC6E;AACnG;AACN;AAChD;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,YAAY;AACvB;AACA,aAAa;AACb;AACe;AACf;AACA,UAAU,6DAAc;AACxB;AACA,iBAAiB,4DAAa;AAC9B;AACA;AACA,yBAAyB,4DAAa;AACtC,mBAAmB,4DAAa;AAChC;AACA,qBAAqB,4DAAa;AAClC,qBAAqB,kFAAqB;AAC1C,qBAAqB,4DAAa;AAClC,qBAAqB,4DAAa;AAClC,qBAAqB,kFAAqB;AAC1C,qBAAqB,4DAAa;AAClC,eAAe,4DAAa;AAC5B,KAAK;AACL,WAAW,gEAAiB,2BAA2B,4DAAa;AACpE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgE;AAC8B;AACxB;AACtE;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA,WAAW,sEAAS,SAAS,2DAAM;AACnC,IAAI,2DAAM;AACV,IAAI,2DAAM;AACV,IAAI,2DAAM;AACV,IAAI,2DAAM;AACV,IAAI,2DAAM;AACV;AACA,IAAI,gEAAS;AACb;AACA,IAAI,2DAAM;AACV;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,YAAY;AACvB,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA,WAAW,sEAAS,SAAS,2DAAM;AACnC,IAAI,2DAAM;AACV,IAAI,2DAAM;AACV,IAAI,2DAAM;AACV,IAAI,2DAAM;AACV,IAAI,2DAAM;AACV;AACA,IAAI,gEAAS;AACb;AACA,IAAI,2DAAM;AACV;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA,WAAW,sEAAS,SAAS,2DAAM,IAAI,2DAAM,cAAc,2DAAM,iBAAiB,2DAAM,iBAAiB,2DAAM,cAAc,2DAAM;AACnI;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,YAAY;AACvB,WAAW,YAAY;AACvB;AACA,aAAa;AACb;AACA;AACA,WAAW,sEAAS,SAAS,2DAAM,IAAI,2DAAM,cAAc,2DAAM,iBAAiB,2DAAM,iBAAiB,2DAAM,cAAc,2DAAM;AACnI;AACA;AACA,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA;AACA,WAAW,sEAAS,SAAS,2DAAM;AACnC;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,gBAAgB;AAC3B,aAAa;AACb;AACA;AACA,oBAAoB,2DAAM,KAAK,gEAAS,8CAA8C,4DAAS;AAC/F,WAAW,sEAAS;AACpB;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,WAAW,sEAAS,SAAS,2DAAM,IAAI,gEAAS,cAAc,2DAAM;AACpE;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,WAAW,sEAAS,SAAS,2DAAM,eAAe,2DAAM;AACxD;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,gBAAgB;AAChB,WAAW,sEAAS;AACpB;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA,WAAW,sEAAS,SAAS,2DAAM,IAAI,2DAAM;AAC7C;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,WAAW,sEAAS;AACpB;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,WAAW,sEAAS,SAAS,2DAAM,kBAAkB,2DAAM,4DAA4D,iEAAU;AACjI;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,WAAW,sEAAS,SAAS,gEAAS;AACtC;AACA;AACA,WAAW,YAAY;AACvB,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sEAAS,SAAS,2DAAM,kFAAkF,2DAAM,wBAAwB,2DAAM;AACzJ;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sEAAS,SAAS,2DAAM,IAAI,gEAAS,YAAY,gEAAS;AACrE;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,WAAW,sEAAS,SAAS,2DAAM,KAAK,2DAAM;AAC9C;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,WAAW,sEAAS,SAAS,2DAAM,KAAK,2DAAM;AAC9C;AACA;AACA;AACA,uBAAuB,2DAAM;AAC7B;AACA;AACA,WAAW,YAAY;AACvB,WAAW,YAAY;AACvB,WAAW,YAAY;AACvB,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA,WAAW,sEAAS,SAAS,2DAAM;AACnC,IAAI,2DAAM;AACV;AACA;AACA,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA;AACA,eAAe,sEAAS;AACxB;AACA,kBAAkB,2DAAM;AACxB,oBAAoB,2DAAM;AAC1B;AACA,YAAY,2DAAM;AAClB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,uBAAuB,2DAAM;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sEAAS;AACpB;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW,sEAAS;AACpB;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,WAAW,sEAAS,SAAS,2DAAM;AACnC;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,WAAW,sEAAS,SAAS,2DAAM,CAAC,2DAAM;AAC1C;AACA,IAAI,2DAAM;AACV;AACA;AACA;AACA;AACA,IAAI,2DAAM;AACV,IAAI,2DAAM;AACV;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,WAAW,sEAAS,SAAS,2DAAM;AACnC;AACoW;;;;;;;;;;;;;;;;;;AC9TpW;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACuF;AAClC;AACqF;AAC1I;AACA,WAAW,YAAY;AACvB,WAAW,YAAY;AACvB,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA;AACA,WAAW,kFAAqB;AAChC;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,YAAY;AACvB,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,gBAAgB;AAC3B,IAAI;AACJ,aAAa;AACb;AACe;AACf,iBAAiB,kFAAqB;AACtC;AACA,QAAQ,sEAAS;AACjB,QAAQ,sEAAS;AACjB,QAAQ,sEAAS;AACjB,QAAQ,sEAAS;AACjB;AACA,gBAAgB,sEAAS;AACzB,iBAAiB,4DAAa;AAC9B,iBAAiB,kFAAqB;AACtC,iBAAiB,kFAAqB;AACtC,iBAAiB,4DAAa;AAC9B,iBAAiB,4DAAa,aAAa;AAC3C,iBAAiB,kFAAqB;AACtC,iBAAiB,4DAAa;AAC9B,iBAAiB,kFAAqB;AACtC,iBAAiB,4DAAa;AAC9B,iBAAiB,kFAAqB;AACtC,iBAAiB,4DAAa,gBAAgB;AAC9C;AACA;AACA,iBAAiB,4DAAa;AAC9B,WAAW,2DAAM;AACjB;;;;;;;;;;;;;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACuF;AACzB;AAC/C;AACf;AACA;AACA,mBAAmB,sEAAS,gBAAgB,4DAAa,QAAQ,4DAAa;AAC9E;AACA,WAAW,kFAAqB;AAChC;;;;;;;;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4E;AACjB;AAC8F;AACnG;AACtD;AACA;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,YAAY;AACvB,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA,gBAAgB,iEAAU;AAC1B,gBAAgB,iEAAU;AAC1B;AACA,iBAAiB,4DAAa;AAC9B;AACA;AACA,qBAAqB,4DAAa;AAClC,eAAe,4DAAa;AAC5B;AACA;AACA,qBAAqB,4DAAa;AAClC,qBAAqB,kFAAqB;AAC1C,qBAAqB,4DAAa;AAClC,qBAAqB,4DAAa;AAClC,qBAAqB,kFAAqB;AAC1C,qBAAqB,4DAAa;AAClC,eAAe,4DAAa;AAC5B;AACA,WAAW,gEAAiB,2BAA2B,4DAAa;AACpE;;;;;;;;;;;;;;;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqD;AACM;AAC3D;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf,0DAA0D;AAC1D;AACA;AACA;AACA;AACA,WAAW,iEAAU,CAAC,2DAAM;AAC5B;;;;;;;;;;;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqE;AACR;AAC7D;AACA,WAAW,YAAY;AACvB,aAAa;AACb;AACe;AACf,iBAAiB,2EAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA,mBAAmB,2DAAM;AACzB,uBAAuB,2DAAM;AAC7B;AACA;AACA,mBAAmB,2DAAM;AACzB,uBAAuB,2DAAM;AAC7B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqE;AAChB;AACrD;AACA,WAAW,YAAY;AACvB,aAAa;AACb;AACe;AACf,iBAAiB,2EAAc;AAC/B;AACA;AACA;AACA;AACA,kBAAkB,2DAAM;AACxB,cAAc,2DAAM;AACpB;AACA;;;;;;;;;;;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACuE;AAC6E;AAC/F;AACS;AAChB;AAC9C;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,YAAY;AACZ;AACe;AACf,2BAA2B,0EAAa;AACxC;AACA;AACA;AACA;AACA,oBAAoB,mEAAM;AAC1B,wBAAwB,0EAAa;AACrC;AACA;AACA;AACA,wBAAwB,0EAAa;AACrC,2BAA2B,0EAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4DAAa;AACjC;AACA,wBAAwB,2EAAc;AACtC,uBAAuB,4DAAa;AACpC,oBAAoB,kFAAqB;AACzC,2BAA2B,0EAAa;AACxC,2BAA2B,0EAAa;AACxC,2BAA2B,0EAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,0BAA0B,0EAAa;AACvC;AACA;AACA;AACA,QAAQ,qEAAsB;AAC9B;AACA;AACA,oBAAoB,2DAAM;AAC1B;AACA;AACA;AACA,wBAAwB,4DAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2DAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA,WAAW,4EAAe,cAAc;AACxC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4B;AACkB;AACa;AACY;AAC7B;AACwB;AACX;AACc;AACE;AACb;AACD;AAChB;AACY;AACP;AAC9C,6BAAe,oCAAU;AACzB,iCAAiC,oEAA0B;AAC3D,0BAA0B,4DAAqB;AAC/C;AACA;AACA;AACA,2BAA2B,2EAAsB;AACjD;AACA;AACA;AACA;AACA;AACA,oBAAoB,mDAAmD;AACvE;AACA;AACA,gCAAgC;AAChC;AACA;AACA,iCAAiC,yDAAQ;AACzC;AACA,aAAa;AACb,qBAAqB;AACrB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,aAAa;AAChC,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,qBAAqB;AACrB;AACA;AACA,wBAAwB,4DAAmB;AAC3C;AACA,SAAS;AACT;AACA;AACA,oBAAoB,UAAU;AAC9B,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kEAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,8CAA8C;AAClE,8BAA8B,qDAAY;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,oBAAoB,UAAU;AAC9B,wBAAwB,4DAAmB;AAC3C;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,0BAA0B,mEAAkB;AAC5C;AACA,uBAAuB,0DAAO;AAC9B;AACA,0BAA0B,mEAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,uBAAuB,0DAAO;AAC9B;AACA,0BAA0B,mEAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iCAAiC;AACjC;AACA;AACA,oBAAoB,0EAAqB;AACzC;AACA;AACA,kEAAkE,WAAW,sBAAsB;AACnG;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA,oBAAoB,gDAAgD;AACpE,0BAA0B,mEAAkB;AAC5C,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,gEAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kEAAmB;AACzC;AACA;AACA;AACA;AACA;AACA,wBAAwB,4CAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,SAAS;AAChG;AACA,6BAA6B,oEAAO;AACpC,+CAA+C,gEAAS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gEAAS;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F,SAAS;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;;;AC/UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiD;AACT;AACE;AACa;AACX;AACyB;AACZ;AACkB;AAC3E;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,kBAAkB,OAAO,6DAAS,SAAS;AAC3F;AACA;AACA;AACA;AACA;AACA,UAAU,mEAAc;AACxB;AACA,uBAAuB,0DAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,kBAAkB,kEAAkB;AACpC;AACA,iBAAiB;AACjB;AACA;AACA,IAAI,0EAAqB;AACzB;AACA;AACA,kDAAkD,WAAW,sBAAsB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,4CAA4C;AAC7E,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2DAA2D,yCAAyC,IAAI;AACxH;AACA;AACA;AACA;AACA;AACA,+BAA+B,oDAAsB;AACrD;AACA;AACA;AACA;AACA,wBAAwB,qEAAqE;AAC7F,+BAA+B,oDAAsB;AACrD;AACA;AACA;AACA,oBAAoB,KAAyC,4BAA4B;AAAA,EAExE;AACjB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kEAAkB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA,gBAAgB,0EAAqB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,uBAAuB,GAAG;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,+CAAiB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,+DAAe,qBAAqB,EAAC;;;;;;;;;;;;;;;;;AChOrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmD;AACnD;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,4DAAU;AACrB;AACmD;;;;;;;;;;;;;;;ACnCnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,6BAA6B;AACxC,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yCAAyC;AAC7D;AACA;AACA;AACA;AACA;AACA,sBAAsB,kBAAkB,GAAG,kBAAkB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,uBAAuB;AAClC,aAAa;AACb;AACe;AACf,uCAAuC,MAAM,cAAc,MAAM,GAAG,IAAI;AACxE;;;;;;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiD;AACmB;AACrD;AACf;AACA;AACA,+CAA+C,sEAAqB;AACpE;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,uBAAuB,GAAG;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,+CAAiB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,iDAAiD,6EAA6E;AAC9H;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0C;AACyB;AACnE;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,SAAS;AACpB;AACA;AACe;AACf;AACA,0BAA0B,uEAAe;AACzC;AACA,sBAAsB,+CAAU;AAChC;AACA,0BAA0B,uEAAe;AACzC;AACA,sBAAsB,+CAAU;AAChC;AACA;AACA;AACA,0BAA0B,uEAAe;AACzC;AACA,sBAAsB,+CAAU;AAChC;AACA,0BAA0B,uEAAe;AACzC;AACA,sBAAsB,+CAAU;AAChC;AACA;AACA;;;;;;;;;;;;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACuD;AACb;AACM;AACqB;AACrE;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,6DAAc;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA,uBAAuB,0DAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,uBAAuB,0DAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,uBAAuB,0DAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,gBAAgB,gEAAiB;AACjC;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,aAAa;AACb;AACe,kCAAkC,sBAAsB;AACvE;AACA;AACA;AACA,UAAU,wEAAwB;AAClC;AACA;;;;;;;;;;;;;;;;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4B;AACwE;AACpG;AACA;AACA,WAAW,YAAY;AACvB;AACA,WAAW,SAAS;AACpB;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,kBAAkB;AAC7B,aAAa;AACb;AACe;AACf,2BAA2B,uFAA0B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gFAAmB;AAC1C;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4B;AAC+B;AACJ;AACvD;AACA;AACA,WAAW,YAAY;AACvB,aAAa;AACb;AACO;AACP,iBAAiB,oEAAO;AACxB,gCAAgC,gEAAS;AACzC;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,OAAO;AACrE;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,yDAAyD;AAChI;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,6BAA6B;AACxC,WAAW,aAAa;AACxB,WAAW,SAAS;AACpB,aAAa;AACb;AACO,2CAA2C,4BAA4B;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,6BAA6B;AACxC,WAAW,aAAa;AACxB,WAAW,SAAS;AACpB,aAAa;AACb;AACO;AACP,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;;;;;;;;;;;;;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,2BAA2B;AACtC,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqC;AACE;AACvC;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uCAAuC;AACnD,YAAY,uCAAuC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,uDAAuD;AACvD,uBAAuB,uDAAS,kBAAkB,wDAAU;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,+DAAe,mBAAmB,EAAC;;;;;;;;;;;;;;;ACxDnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,WAAW,GAAG;AACd,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,WAAW,GAAG;AACd,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,yBAAyB,MAAM,IAAI,MAAM;AACzC;AACA;AACA;AACA,oBAAoB,MAAM,IAAI,MAAM,IAAI,MAAM,KAAK,MAAM;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,GAAG;AACd,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB;AACA;AACe;AACf,QAAQ,KACU,EAAE;AAAA,EAEf;AACL;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACO;AACP,YAAY,iEAAiB,QAAQ,MAAM;AAC3C;AACA;AACA,gDAAgD,MAAM,uBAAuB,GAAG,OAAO,SAAS;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd;AACA;AACA;AACO;AACP;AACA;;;;;;;;;;;;;;;;;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,wBAAwB;AACxB;AACA;AACA;AACA,CAAC;AACD,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,aAAa;AACb;AACO;AACP;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA,qFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,wBAAwB;AACnC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiJ;;;;;;;;;;;;;;;;AC1OjJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,aAAa,SAAS;AACtB;AACA;AACe;AACf,WAAW,uEAAwB;AACnC;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,UAAU;AACrB;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;ACnDyC;AACiB;AAC1D;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACe;AACf;AACA,sBAAsB,qDAAW;AACjC,eAAe,qDAAW;AAC1B;AACA;AACA,cAAc,gEAAqB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;AC5B2C;AAC3C;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0DAAY,WAAW,oBAAoB;AAC3D;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACuD;AACvD;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB;AACA;AACA,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA,YAAY,iEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,KAAyC,4BAA4B;AAAA,EAExE;AACjB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,UAAU;AACrB;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf;AACA,6CAA6C;AAC7C;;;;;;;;;;;;;;ACxB+B;AACI;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,kDAAQ;AACZ;AACA;AACA,SAAS,gDAAM;AACf,kBAAkB,qBAAM;AACxB;AACA;AACA;AACA;AACA,+DAAe,WAAW,EAAC;;;;;;;;;;;;;;;ACnB3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,aAAa;AACb;AACe;AACf;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;;;;;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmC;AACnC;AACA,iDAAiD,kDAAQ;AACzD,+DAAe,MAAM,EAAC;;;;;;;;;;;;;;;AClBtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa;AACb;AACe;AACf;AACA;;;;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa;AACb;AACe;AACf;AACA;;;;;;;;;;;;ACzBA;AACA;AACA;AACA,+DAAe;AACf,qCAAqC,EAAC;;;;;;;;;;;;ACJtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAAe,cAAc,EAAC;;;;;;;;;;;;AC5M9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAAe,cAAc,EAAC;;;;;;;;;;;;;;;;;ACxC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyF;AACzF,+DAAe,kDAAiB,EAAC;AACkB;;;;;;;;;;;;;;;;;;;;ACjBnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;AACE;AACF;AACA;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,QAAQ,iEAAiB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gEAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,qBAAqB,+DAAc;AACnC;AACA;AACA,qBAAqB,+DAAc;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,mBAAmB,OAAO;AAC1B;AACA,sBAAsB,QAAQ;AAC9B,WAAW,8BAA8B;AACzC,aAAa;AACb;AACA;AACA,SAAS,iEAAiB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,mBAAmB,OAAO;AAC1B;AACA,yBAAyB,QAAQ;AACjC,cAAc,kBAAkB;AAChC,WAAW,8BAA8B;AACzC,aAAa;AACb;AACA;AACA,QAAQ,iEAAiB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAAe,iBAAiB,EAAC;AACkB;;;;;;;;;;;;;;;;;;ACzHnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC2C;AACe;AAChC;AAC1B;AACA;AACA;AACA;AACA;AACe,qBAAqB,sDAAY;AAChD;AACA;AACA,qBAAqB,6CAAI;AACzB,oBAAoB,6CAAI;AACxB,oBAAoB,6CAAI;AACxB,qBAAqB,6CAAI;AACzB,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gEAAqB;AAC7C;AACA,yEAAyE,WAAW;AACpF;AACA;AACA;AACA;AACA;AACA,gCAAgC,gEAAqB;AACrD,iEAAiE,UAAU;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,6CAAI;AAC1B;AACA;AACA;AACA,sBAAsB,6CAAI;AAC1B;AACA;AACA;AACA,sBAAsB,6CAAI;AAC1B;AACA;AACA;AACA,sBAAsB,6CAAI;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,6CAAI;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC3I0C;AAC1C;AACA;AACA;AACA;AACA;AACA,oCAAoC,kDAAe;AAC5C,0BAA0B,iBAAiB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,+DAAe,qBAAqB,EAAC;;;;;;;;;;;;;;;ACnCrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAAe,sCAAY;;;;;;;;;;;;ACvB3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,gBAAgB;AAC3B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAAe;AACf;AACA;AACA,kBAAkB,EAAC;;;;;;;;;;;;;;;AC9CnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,+DAAe,kEAAkE,EAAC;AAC1D;;;;;;;;;;;;ACxBxB,+DAAe;AACf;AACA;AACA;AACA,KAAK,EAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACJN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,aAAa;AACb;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,aAAa;AACb;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA,yBAAyB,YAAY;AACrC;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C,sBAAsB,oDAAoD;AAC1E;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,aAAa;AACb;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB,oBAAoB,eAAe;AACnC;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB,oBAAoB,eAAe;AACnC;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,uBAAuB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,gBAAgB;AAC3B,aAAa;AACb;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,eAAe;AAC1B,aAAa;AACb;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA,4BAA4B,8BAA8B;AAC1D;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,eAAe;AAC1B,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA,4BAA4B,8BAA8B;AAC1D;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0BAA0B;AACtD;AACA,kCAAkC,+CAA+C;AACjF;AACA;AACA;AACA;AACA,8BAA8B,kCAAkC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AAC6d;;;;;;;;;;;;;;;;;AC9e7d;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgD;AACtB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,uBAAuB;AACvB,IAAI,IAAI,wBAAwB;AAChC;AACA;AACA,kCAAkC;AAClC;AACA;AACA,uBAAuB;AACvB,IAAI,IAAI,wBAAwB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA,gBAAgB,KAAyC,4BAA4B;AAAA,EAGxE;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAI,wBAAwB;AACpC;AACA,eAAe,UAAU;AACzB;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI,yDAAyD;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,mBAAmB,6CAAI;AACvB;AACA;AACA,4BAA4B,6DAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,gCAAgC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,UAAU;AACrB;AACA,WAAW,QAAQ;AACnB;AACA,aAAa,QAAQ;AACrB;AACO;AACP;AACA;AACA;AACA,KAAK,IAAI,iCAAiC;AAC1C;AACA;AACA,KAAK;AACL;AACA;AACA,+DAAe,eAAe,EAAC;;;;;;;;;;;;;;;;;;;;;ACzR/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4B;AACc;AACc;AACG;AACO;AAClE;AACA;AACe;AACf;AACA;AACA,SAAS,iEAAiB;AAC1B,YAAY,iEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA,4BAA4B,wBAAwB;AACpD;AACA;AACA;AACA;AACA;AACA,IAAI,4CAAG;AACP;AACA;AACA;AACA,wBAAwB,gEAAqB;AAC7C,6BAA6B,iEAAiB;AAC9C;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,YAAY,iEAAiB;AAC7B,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL,wBAAwB;AACxB;AACA;AACA;AACA,wBAAwB,iEAAiB;AACzC,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf,sBAAsB,sDAAY,gCAAgC,6DAAiB;AACnF;AACA,YAAY,iEAAiB;AAC7B,sBAAsB,sDAAY,gCAAgC,6DAAiB;AACnF;AACA;AACA,+BAA+B,iEAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iEAAiB;AAChD;AACA,oCAAoC,gEAAqB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,gEAAqB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf,sBAAsB,sDAAY,iBAAiB,6DAAiB;AACpE;AACA;AACA,YAAY,4CAAG;AACf,sBAAsB,sDAAY,iBAAiB,6DAAiB;AACpE;AACA,gCAAgC,sDAAY;AAC5C;AACA;AACA,QAAQ,4CAAG;AACX,kBAAkB,sDAAY,iBAAiB,6DAAiB;AAChE,KAAK;AACL;AACA;AACA;AACA,YAAY;AACZ;AACO;AACP,mBAAmB,qDAAW;AAC9B,SAAS,iEAAiB;AAC1B,SAAS,iEAAiB;AAC1B;;;;;;;;;;;;;;;;;;;;;;ACvLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyD;AACS;AAC1C;AACxB,+DAAe,4CAAG,EAAC;AAC6D;;;;;;;;;;;;;;;;ACnBhF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6B;;;;;;;;;;;;;;;;;;;;ACjE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4B;AAC0B;AACE;AACG;AACO;AAClE;AACe;AACf;AACA;AACA;AACA,sBAAsB,iEAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2BAA2B;AAC3C,gBAAgB,yDAAyD;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sDAAY,kBAAkB,6DAAiB;AAC1E,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sDAAY,kBAAkB,6DAAiB;AAC1E,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa,iEAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gEAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sDAAY,kBAAkB,6DAAiB;AACtE;AACA;AACA;AACA,uBAAuB,sDAAY,kBAAkB,6DAAiB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,gEAAqB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,gEAAqB;AAC9D;AACA;AACA;AACA,iCAAiC,gEAAgB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iEAAiB;AACzC,mCAAmC,sDAAY,kBAAkB,6DAAiB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,+BAA+B,sDAAY,kBAAkB,6DAAiB;AAC9E;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACzMgD;AACO;AAC3B;AAC5B;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACe;AACf,YAAY,wDAAwD;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iEAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kDAAK;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,wBAAwB,6DAAc;AACtC;AACA;;;;;;;;;;;;;;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf;AACA;AACA,KAAK;AACL;;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,+DAAe;AACf;AACA,gBAAgB,EAAC;;;;;;;;;;;;;;;;;ACzCjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqC;AACQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,sBAAsB;AACtB,sBAAsB;AACtB;AACA;AACA;AACA,YAAY,WAAW,IAAI,YAAY;AACvC;AACA;AACA;AACA,YAAY,WAAW,IAAI,YAAY,IAAI,WAAW;AACtD;AACA;AACA,YAAY,WAAW,IAAI,WAAW;AACtC;AACA;AACA;AACe;AACf;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,iBAAiB;AACjB;AACA;AACA,eAAe,uDAAS;AACxB;AACA;AACA;AACA,eAAe,GAAG;AAClB,iBAAiB;AACjB;AACA;AACA,eAAe,2DAAa;AAC5B;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AChLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyB;AACK;AACW;AACzC,8BAA8B,qDAAW,wBAAwB,qDAAW;AAC5E,8BAA8B,qDAAW,wBAAwB,qDAAW;AAC5E;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,mBAAmB;AACnB,oBAAoB;AACpB,qBAAqB;AACrB;AACA,wBAAwB;AACxB;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,aAAa,YAAY;AACzB;AACA;AACA;AACA,IAAI,mDAAM;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACuJ;;;;;;;;;;;;;ACjXvJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0B;AAC1B;AACA;AACA;AACA,eAAe,GAAG;AAClB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,SAAS,EAAE,6CAAI;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA,+DAAe,WAAW,EAAC;;;;;;;;;;;;;;;;;;;;AClD3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyB;AACK;AACJ;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gCAAgC;AACnD;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN,uBAAuB;AACvB;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4CAAG;AACvB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mDAAM;AAClB;AACA,mBAAmB,6CAAI;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA,iDAAiD,QAAQ;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,mBAAmB,6CAAI;AACvB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;;ACzSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqD;AACd;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,gEAAgB;AAC7B;AACA;AACA;AACA,QAAQ,gEAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gEAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gEAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,gEAAgB;AAC7B;AACA;AACA;AACA;AACA,YAAY,wDAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,aAAa,QAAQ;AACrB;AACA;AACA;AACA,QAAQ,gEAAgB;AACxB;AACA;AACA,QAAQ,gEAAgB;AACxB;AACA;AACA;AACA,QAAQ,gEAAgB;AACxB;AACA;AACA,QAAQ,gEAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA,QAAQ,gEAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,uBAAuB;AAClC,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6D;;;;;;;;;;;;;;;;AClU7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACe;AACf,SAAS,2DAAa;AACtB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACe;AACf;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AClFA;AACA;AACA;AACA,WAAW,UAAU;AACrB,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrBA,+DAAe;EACXY,cAAc,EAAE,gBAAgB;EAChCC,QAAQ,EAAE;IACNC,OAAO,EAAE,SAAS;IAClBC,MAAM,EAAE,QAAQ;IAChBC,SAAS,EAAE,YAAY;IACvBC,OAAO,EAAE,cAAc;IACvBC,IAAI,EAAE;EACV,CAAC;EACDC,QAAQ,EAAE;IACNC,WAAW,EAAE,UAAU;IACvBC,WAAW,EAAE,eAAe;IAC5BC,QAAQ,EAAE;EACd,CAAC;EACDC,QAAQ,EAAE;IACNH,WAAW,EAAE,QAAQ;IACrBI,MAAM,EAAE;EACZ,CAAC;EACDC,OAAO,EAAE;IACLC,aAAa,EAAE,gBAAgB;IAC/BC,eAAe,EAAE,eAAe;IAChCC,YAAY,EAAE,YAAY;IAC1BC,YAAY,EAAE,YAAY;IAC1BC,kBAAkB,EAAE,0BAA0B;IAC9CC,kBAAkB,EAAE;EACxB,CAAC;EACDC,SAAS,EAAE;AACf,CAAC,E;;;;;;;;;;;AC3BD,IAAMC,SAAS,GAAG;EAChB;EACAC,aAAa,EAAE,aAAa;EAC5BC,KAAK,EAAE,OAAO;EACdC,OAAO,EAAE,SAAS;EAClBC,eAAe,EAAE,uBAAuB;EAExC;EACAC,eAAe,EAAE,WAAW;EAC5BC,eAAe,EAAE,WAAW;EAC5BZ,eAAe,EAAE;AACnB,CAAC;AAED,+DAAeM,SAAS,E;;;;;;;;;;;ACbxB,IAAMO,QAAQ,GAAG;EACbC,OAAO,EAAE,SAAS;EAClBC,MAAM,EAAE,QAAQ;EAChBC,OAAO,EAAE,SAAS;EAClBC,MAAM,EAAE,QAAQ;EAChBC,SAAS,EAAE,WAAW;EACtBC,OAAO,EAAE,SAAS;EAClBC,OAAO,EAAE;AACb,CAAC;AAED,+DAAeP,QAAQ,E;;;;;;;;;;;;;;;ACVwB;;;;;;;;;;;;;;;;ACA/C;;AAEA,IAAMS,eAAe,GAAG;EACpBC,aAAa,EAAE,eAAe;EAC9BC,WAAW,EAAE,aAAa;EAC1BC,qBAAqB,EAAE,uBAAuB;EAC9CC,WAAW,EAAE;AACjB,CAAC;AAED,IAAMC,aAAa,GAAG;EAClBC,gBAAgB,EAAE,qBAAqB;EAEvCC,cAAc,EAAE,qBAAqB,GACvB,mBAAmB,GACnB,qBAAqB,GACrB,oCAAoC,GACpC,sBAAsB,GACtB,uBAAuB,GACvB,sCAAsC,GACtC,mBAAmB,GACnB,4BAA4B,GAC5B,4BAA4B,GAC5B,+BAA+B,GAC/B,kBAAkB,GAClB,mBAAmB,GACnB,6BAA6B,GAC7B,mBAAmB,GACnB,0BAA0B,GAC1B,4BAA4B,GAC5B,+BAA+B,GAC/B,4BAA4B,GAC5B,2BAA2B,GAC3B,sBAAsB,GACtB,4BAA4B,GAC5B,2BAA2B;EAEzCC,wBAAwB,EAAE,yBAAyB,GACrC,yBAAyB,GACzB,oBAAoB,GACpB,WAAW,GACX,4BAA4B,GAC5B,gBAAgB,GAChB,kBAAkB,GAClB,yBAAyB,GACzB,kBAAkB,GAClB,yBAAyB,GACzB,6BAA6B,GAC7B,kCAAkC,GAClC,0BAA0B,GAC1B,kCAAkC;EAEhDC,cAAc,EAAE,qBAAqB,GACvB,sBAAsB,GACtB,iBAAiB,GACjB;AAClB,CAAC;;;;;;;;;;;;ACvDD;;AAEA,IAAMC,YAAY,GAAG;EACjB;EACAC,mBAAmB,EAAE,mBAAmB;EAAE;EAC1CzB,KAAK,EAAE,OAAO;EAAG;EACjBC,OAAO,EAAE,SAAS;EAAE;EACpBC,eAAe,EAAE,gBAAgB;EAAE;EACnCwB,IAAI,EAAE,MAAM;EAAE;EACdC,KAAK,EAAE,OAAO;EAAE;EAChBhB,OAAO,EAAE,SAAS;EAAE;EACpBiB,MAAM,EAAE,QAAQ;EAAE;;EAElB;EACAC,gBAAgB,EAAE,4BAA4B;EAAE;EAChDC,gBAAgB,EAAE,4BAA4B;EAAE;EAChDC,eAAe,EAAE,2BAA2B;EAAE;EAC9CC,kBAAkB,EAAE,kBAAkB;EAAE;EACxCC,kBAAkB,EAAE,kBAAkB;EAAE;EACxCC,iBAAiB,EAAE,iBAAiB;EAAE;;EAEtC;EACAC,kBAAkB,EAAE,2BAA2B;EAAE;EACjDC,kBAAkB,EAAE,2BAA2B;EAAE;EACjDC,wBAAwB,EAAE,0BAA0B;EAAE;EACtDC,yBAAyB,EAAE,2BAA2B;EAAE;;EAExD;EACAC,YAAY,EAAE,cAAc;EAAE;EAC9BC,WAAW,EAAE,qBAAqB;EAAE;EACpCC,WAAW,EAAE,aAAa;EAAE;;EAE5B;EACAC,YAAY,EAAE,cAAc;EAAE;EAC9BC,WAAW,EAAE,aAAa;EAAE;EAC5BC,eAAe,EAAE,iBAAiB;EAAE;;EAEpC;EACAC,aAAa,EAAE,cAAc,CAAC;AAClC,CAAC;AAED,+DAAerB,YAAY,E;;;;;;;;;;;ACzC3B;;AAEA,IAAMsB,WAAW,GAAG;EAChBlC,OAAO,EAAE,SAAS;EAClBN,OAAO,EAAE,SAAS;EAClBC,MAAM,EAAE,QAAQ;EAChBC,OAAO,EAAE,SAAS;EAClBC,MAAM,EAAE,QAAQ;EAChBC,SAAS,EAAE,WAAW;EACtBqC,QAAQ,EAAE,UAAU;EACpBpC,OAAO,EAAE,SAAS;EAClBqC,KAAK,EAAE,OAAO;EACdC,SAAS,EAAE;AACf,CAAC;AAED,+DAAeH,WAAW,E;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACf1B;AACiC;AAEe;AACD;AACsB;AACvB;AACN;AAExCI,iDAAQ,CAACE,SAAS,GAAG,MAAM,CAAC,CAAC;AAC7BF,iDAAQ,CAACG,QAAQ,GAAG,MAAM,CAAC,CAAC;AAAA,IAEtBC,aAAa;EACf,SAAAA,cAAYC,WAAW,EAAuC;IAAA,IAArCC,YAAY,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;IAAA,IAAEG,SAAS,GAAAH,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAI;IAAAI,eAAA,OAAAP,aAAA;IACxD,IAAI,CAACQ,GAAG,eAAAC,MAAA,CAAeb,iDAAQ,CAACc,OAAO,CAAE;IACzC,IAAI,CAACC,MAAM,GAAG,IAAId,qDAAM,CAAC,IAAI,CAACW,GAAG,CAAC;IAClC,IAAI,CAACI,QAAQ,GAAGpE,wDAAS,KAAIA,wDAAS,aAATA,wDAAS,uBAATA,mEAAkB;IAC/C;IACA,IAAI,CAACyD,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACC,YAAY,GAAGA,YAAY;IAChC,IAAI,CAACI,SAAS,GAAGA,SAAS;IAC1B;IACA,IAAI,CAACO,MAAM,GAAG,IAAI;IAClB,IAAI,CAACC,WAAW,GAAG,IAAIC,WAAW,CAAC,CAAC;EACxC;EAAC,OAAAC,YAAA,CAAAhB,aAAA;IAAAiB,GAAA;IAAAC,KAAA,EAED,SAAAC,UAAUA,CAAA,EAAG;MACT,IAAI,CAAC,IAAI,CAACjB,YAAY,CAACkB,YAAY,EAAE;QACjC,MAAM,IAAIC,KAAK,CAAC,+CAA+C,CAAC;MACpE;MACA,IAAI,CAACR,MAAM,GAAG,IAAIjB,iDAAQ,CAAC,IAAI,CAACM,YAAY,CAAC;IACjD;EAAC;IAAAe,GAAA;IAAAC,KAAA,EAED,SAAAI,IAAIA,CAAA,EAAG;MAAA,IAAAC,KAAA;MACH,IAAI,CAAC,IAAI,CAACV,MAAM,EAAE;QACd,MAAM,IAAIQ,KAAK,CAAC,kDAAkD,CAAC;MACvE;MACA,IAAI,CAACG,UAAU,CAAC,CAAC;MACjB,IAAMC,WAAW,GAAG;QAChBvG,GAAG,EAAE,IAAI,CAAC+E,WAAW;QACrByB,SAAS,EAAE,MAAM;QACjBC,QAAQ,EAAE;MACd,CAAC;MACD,IAAI,IAAI,CAACrB,SAAS,EAAE;QAChBmB,WAAW,CAAC/G,UAAU,GAAG,IAAI,CAACkH,YAAY,CAAC,IAAI,CAACtB,SAAS,CAAC;MAC9D;MACA,IAAI;QACA,IAAMuB,UAAU,GAAG,IAAI,CAAChB,MAAM,CAACiB,SAAS,CAACL,WAAW,CAAC;QACrD,IAAII,UAAU,IAAI,OAAOA,UAAU,SAAM,KAAK,UAAU,EAAE;UACtDA,UAAU,SAAM,CAAC,UAACE,KAAK,EAAK;YACxBR,KAAI,CAACZ,MAAM,CAACoB,KAAK,CAAC,sBAAsB,EAAEA,KAAK,CAAC;UACpD,CAAC,CAAC;QACN;MACJ,CAAC,CAAC,OAAOA,KAAK,EAAE;QACZ,IAAI,CAACpB,MAAM,CAACoB,KAAK,CAAC,sBAAsB,EAAEA,KAAK,CAAC;MACpD;IACJ;EAAC;IAAAd,GAAA;IAAAC,KAAA,EAED,SAAAU,YAAYA,CAACtB,SAAS,EAAE;MACpB,IAAM5F,UAAU,GAAG,CAAC,CAAC;MAErB,IAAI4F,SAAS,CAACtF,QAAQ,EAAE;QACpB;QACA,IAAMgH,WAAW,GAAG1B,SAAS,CAACtF,QAAQ;QACtC,IAAAiH,kBAAA,GAAmBD,WAAW,CAACE,KAAK,CAAC,GAAG,CAAC;UAAAC,mBAAA,GAAAC,cAAA,CAAAH,kBAAA;UAAlCI,GAAG,GAAAF,mBAAA;UAAElB,GAAG,GAAAkB,mBAAA;QACfzH,UAAU,CAACM,QAAQ,GAAG;UAClBsH,cAAc,EAAE,CAACD,GAAG,CAAC;UACrBE,YAAY,EAAE,CAACtB,GAAG;QACtB,CAAC;MACL;MAEA,IAAIX,SAAS,CAACkC,QAAQ,EAAE;QACpB;QACA9H,UAAU,CAAC8H,QAAQ,GAAG;UAClBC,gBAAgB,EAAEnC,SAAS,CAACkC,QAAQ,CAACC,gBAAgB;UACrDC,oBAAoB,EAAEpC,SAAS,CAACkC,QAAQ,CAACE,oBAAoB;UAC7DC,kBAAkB,EAAErC,SAAS,CAACkC,QAAQ,CAACG,kBAAkB,IAAI,CAAC;QAClE,CAAC;MACL;MAEA,IAAIrC,SAAS,CAACsC,SAAS,EAAE;QACrB;QACAlI,UAAU,CAACkI,SAAS,GAAG;UACnBH,gBAAgB,EAAEnC,SAAS,CAACsC,SAAS,CAACH,gBAAgB;UACtDE,kBAAkB,EAAErC,SAAS,CAACsC,SAAS,CAACD,kBAAkB,IAAI,CAAC;QACnE,CAAC;MACL;MAEA,IAAIrC,SAAS,CAACuC,QAAQ,EAAE;QACpB;QACAnI,UAAU,CAACmI,QAAQ,GAAG;UAClBJ,gBAAgB,EAAEnC,SAAS,CAACuC,QAAQ,CAACJ,gBAAgB;UACrDC,oBAAoB,EAAEpC,SAAS,CAACuC,QAAQ,CAACH,oBAAoB;UAC7DC,kBAAkB,EAAErC,SAAS,CAACuC,QAAQ,CAACF,kBAAkB,IAAI,CAAC;QAClE,CAAC;MACL;MACA;MACA,OAAOjI,UAAU;IACrB;;IAEA;EAAA;IAAAuG,GAAA;IAAAC,KAAA,EACA,SAAA4B,uBAAuBA,CAACC,KAAK,EAAE;MAC3B,IAAI,CAACpC,MAAM,CAACqC,IAAI,CAAC,gBAAgB,GAAGD,KAAK,CAAC;MAC1C,IAAI,CAACE,aAAa,CAAC,IAAIC,WAAW,CAAC,IAAI,CAACtC,QAAQ,CAACnE,aAAa,EAAE;QAAE0G,MAAM,EAAEJ;MAAM,CAAC,CAAC,CAAC;MACnF,QAAQA,KAAK;QACT,KAAKvD,2DAAW,CAACxC,OAAO;UACpB,IAAI,CAAC2D,MAAM,CAACyC,KAAK,CAAC,oCAAoC,CAAC;UACvD;QACJ,KAAK5D,2DAAW,CAACvC,MAAM;UACnB,IAAI,CAAC0D,MAAM,CAACyC,KAAK,CAAC,kDAAkD,CAAC;UACrE;QACJ,KAAK5D,2DAAW,CAACtC,OAAO;UACpB,IAAI,CAACyD,MAAM,CAACyC,KAAK,CAAC,iCAAiC,CAAC;UACpD;QACJ,KAAK5D,2DAAW,CAACrC,MAAM;UACnB,IAAI,CAACwD,MAAM,CAACyC,KAAK,CAAC,gCAAgC,CAAC;UACnD;QACJ,KAAK5D,2DAAW,CAACpC,SAAS;UACtB,IAAI,CAACuD,MAAM,CAACyC,KAAK,CAAC,+CAA+C,CAAC;UAClE;QACJ,KAAK5D,2DAAW,CAACC,QAAQ;UACrB,IAAI,CAACkB,MAAM,CAACyC,KAAK,CAAC,sBAAsB,CAAC;UACzC;QACJ,KAAK5D,2DAAW,CAACnC,OAAO;UACpB,IAAI,CAACsD,MAAM,CAACyC,KAAK,CAAC,mDAAmD,CAAC;UACtE;QACJ,KAAK5D,2DAAW,CAAClC,OAAO;UACpB,IAAI,CAACqD,MAAM,CAACyC,KAAK,CAAC,+BAA+B,CAAC;UAClD;QACJ,KAAK5D,2DAAW,CAACE,KAAK;UAClB,IAAI,CAACiB,MAAM,CAACyC,KAAK,CAAC,gDAAgD,CAAC;UACnE;QACJ,KAAK5D,2DAAW,CAACG,SAAS;UACtB,IAAI,CAACgB,MAAM,CAACyC,KAAK,CAAC,+CAA+C,CAAC;UAClE;QACJ;UACI,IAAI,CAACzC,MAAM,CAACyC,KAAK,CAAC,gBAAgB,EAAEL,KAAK,CAAC;UAC1C;MACR;IACJ;EAAC;IAAA9B,GAAA;IAAAC,KAAA,EAED,SAAAmC,WAAWA,CAACtB,KAAK,EAAE;MAAE;MACjB,IAAI,CAACpB,MAAM,CAACoB,KAAK,CAAC,iBAAiB,EAAEA,KAAK,CAAC;MAC3C,IAAI,CAACkB,aAAa,CAAC,IAAIC,WAAW,CAAC,IAAI,CAACtC,QAAQ,CAAClE,KAAK,EAAE;QAAEyG,MAAM,EAAEpB;MAAM,CAAC,CAAC,CAAC;MAC3E;MACA,IAAIA,KAAK,IAAIA,KAAK,CAACuB,IAAI,EAAE;QACrB,QAAQvB,KAAK,CAACuB,IAAI;UACd,KAAK9F,+DAAe,CAACC,aAAa;YAC9B,IAAI,CAACkD,MAAM,CAACoB,KAAK,CAAC,yBAAyB,EAAEA,KAAK,CAACwB,OAAO,CAAC;YAC3D;UACJ,KAAK/F,+DAAe,CAACE,WAAW;YAC5B,IAAI,CAACiD,MAAM,CAACoB,KAAK,CAAC,uBAAuB,EAAEA,KAAK,CAACwB,OAAO,CAAC;YACzD;UACJ,KAAK/F,+DAAe,CAACG,qBAAqB;YACtC,IAAI,CAACgD,MAAM,CAACoB,KAAK,CAAC,qBAAqB,EAAEA,KAAK,CAACwB,OAAO,CAAC;YACvD;UACJ,KAAK/F,+DAAe,CAACI,WAAW;YAC5B,IAAI,CAAC+C,MAAM,CAACoB,KAAK,CAAC,sBAAsB,EAAEA,KAAK,CAACwB,OAAO,CAAC;UAC5D;YACI,IAAI,CAAC5C,MAAM,CAACoB,KAAK,CAAC,gBAAgB,EAAEA,KAAK,CAACwB,OAAO,CAAC;QAC1D;MACJ,CAAC,MAAM;QACH,IAAI,CAAC5C,MAAM,CAACoB,KAAK,CAAC,gBAAgB,GAAGA,KAAK,CAACwB,OAAO,CAAC;MACvD;IACJ;EAAC;IAAAtC,GAAA;IAAAC,KAAA,EAED,SAAAsC,aAAaA,CAACC,OAAO,EAAE;MACnB,IAAI,CAACR,aAAa,CAAC,IAAIC,WAAW,CAAC,IAAI,CAACtC,QAAQ,CAACjE,OAAO,EAAE;QAAEwG,MAAM,EAAEM;MAAQ,CAAC,CAAC,CAAC;IACnF;EAAC;IAAAxC,GAAA;IAAAC,KAAA,EAED,SAAAwC,oBAAoBA,CAACC,GAAG,EAAE;MACtB;MACA,IAAI,CAACV,aAAa,CAAC,IAAIC,WAAW,CAAC,IAAI,CAACtC,QAAQ,CAAChE,eAAe,EAAE;QAAEuG,MAAM,EAAEQ;MAAI,CAAC,CAAC,CAAC;IACvF;EAAC;IAAA1C,GAAA;IAAAC,KAAA,EAED,SAAA0C,UAAUA,CAAA,EAAG;MACT,IAAI,CAACjD,MAAM,CAACkD,IAAI,CAAC,wBAAwB,CAAC;IAC9C;EAAC;IAAA5C,GAAA;IAAAC,KAAA,EACD,SAAA4C,WAAWA,CAAA,EAAG;MACV,IAAI,CAACnD,MAAM,CAACkD,IAAI,CAAC,yBAAyB,CAAC;IAC/C;EAAC;IAAA5C,GAAA;IAAAC,KAAA,EACD,SAAA6C,aAAaA,CAAA,EAAG;MACZ,IAAI,CAACpD,MAAM,CAACqC,IAAI,CAAC,wBAAwB,CAAC;IAC9C;EAAC;IAAA/B,GAAA;IAAAC,KAAA,EACD,SAAA8C,YAAYA,CAAA,EAAG;MACX,IAAI,CAACrD,MAAM,CAACkD,IAAI,CAAC,eAAe,CAAC;IACrC;EAAC;IAAA5C,GAAA;IAAAC,KAAA,EACD,SAAA+C,iBAAiBA,CAACC,GAAG,EAAE;MACnB,IAAI,CAACvD,MAAM,CAACkD,IAAI,CAAC,gBAAgB,EAAEM,IAAI,CAACC,SAAS,CAACF,GAAG,CAAC,CAAC;MACvD,IAAI,CAACjB,aAAa,CAAC,IAAIC,WAAW,CAAC,IAAI,CAACtC,QAAQ,CAAC/D,eAAe,EAAE;QAAEsG,MAAM,EAAEe,GAAG,IAAIA,GAAG,CAAC9D,MAAM,GAAG8D,GAAG,CAAC,CAAC,CAAC,CAACG,eAAe,GAAG;MAAK,CAAC,CAAC,CAAC;IACrI;EAAC;IAAApD,GAAA;IAAAC,KAAA,EACD,SAAAoD,iBAAiBA,CAACJ,GAAG,EAAE;MACnB,IAAI,CAACvD,MAAM,CAACkD,IAAI,CAAC,gBAAgB,EAAE3F,2DAAY,CAACM,gBAAgB,EAAE2F,IAAI,CAACC,SAAS,CAACF,GAAG,CAAC,CAAC;MACtF,IAAI,CAACjB,aAAa,CAAC,IAAIC,WAAW,CAAC,IAAI,CAACtC,QAAQ,CAAC9D,eAAe,EAAE;QAAEqG,MAAM,EAAEe,GAAG,IAAIA,GAAG,CAAC9D,MAAM,GAAG8D,GAAG,CAAC,CAAC,CAAC,CAACG,eAAe,GAAG;MAAK,CAAC,CAAC,CAAC;IACrI;EAAC;IAAApD,GAAA;IAAAC,KAAA,EACD,SAAAqD,gBAAgBA,CAACL,GAAG,EAAE;MAClB;MACA,IAAI,CAACjB,aAAa,CAAC,IAAIC,WAAW,CAAC,IAAI,CAACtC,QAAQ,CAAC9D,eAAe,EAAE;QAAEqG,MAAM,EAAEe,GAAG,IAAIA,GAAG,CAAC9D,MAAM,GAAG8D,GAAG,CAAC,CAAC,CAAC,CAACG,eAAe,GAAG;MAAK,CAAC,CAAC,CAAC;IACrI;EAAC;IAAApD,GAAA;IAAAC,KAAA,EACD,SAAAsD,sBAAsBA,CAACb,GAAG,EAAE;MACxB,IAAI,CAAChD,MAAM,CAACkD,IAAI,CAAC,iBAAiB,EAAEM,IAAI,CAACC,SAAS,CAACT,GAAG,CAAC,CAAC;MACxD;IACJ;EAAC;IAAA1C,GAAA;IAAAC,KAAA,EACD,SAAAuD,sBAAsBA,CAACd,GAAG,EAAE;MACxB,IAAI,CAAChD,MAAM,CAACkD,IAAI,CAAC,qBAAqB,EAAE3F,2DAAY,CAACS,kBAAkB,EAAEwF,IAAI,CAACC,SAAS,CAACT,GAAG,CAAC,CAAC;MAC7F;IACJ;EAAC;IAAA1C,GAAA;IAAAC,KAAA,EACD,SAAAwD,qBAAqBA,CAACf,GAAG,EAAE;MACvB,IAAI,CAAChD,MAAM,CAACkD,IAAI,CAAC,oBAAoB,EAAEM,IAAI,CAACC,SAAS,CAACT,GAAG,CAAC,CAAC;MAC3D;IACJ;EAAC;IAAA1C,GAAA;IAAAC,KAAA,EACD,SAAAyD,+BAA+BA,CAAChB,GAAG,EAAE;MACjC,IAAI,CAAChD,MAAM,CAACkD,IAAI,CAAC,gCAAgC,EAAEM,IAAI,CAACC,SAAS,CAACT,GAAG,CAAC,CAAC;IAC3E;EAAC;IAAA1C,GAAA;IAAAC,KAAA,EACD,SAAA0D,+BAA+BA,CAACjB,GAAG,EAAE;MACjC,IAAI,CAAChD,MAAM,CAACkD,IAAI,CAAC,gCAAgC,EAAEM,IAAI,CAACC,SAAS,CAACT,GAAG,CAAC,CAAC;IAC3E;EAAC;IAAA1C,GAAA;IAAAC,KAAA,EACD,SAAA2D,aAAaA,CAAClB,GAAG,EAAE;MACf,IAAI,CAAChD,MAAM,CAACkD,IAAI,CAAC,eAAe,EAAEM,IAAI,CAACC,SAAS,CAACT,GAAG,CAAC,CAAC;IAC1D;EAAC;IAAA1C,GAAA;IAAAC,KAAA,EACD,SAAA4D,kBAAkBA,CAACnB,GAAG,EAAE;MACpB,IAAI,CAAChD,MAAM,CAACkD,IAAI,CAAC,eAAe,EAAEM,IAAI,CAACC,SAAS,CAACT,GAAG,CAAC,CAAC;IAC1D;EAAC;IAAA1C,GAAA;IAAAC,KAAA,EAED,SAAA+B,aAAaA,CAAC8B,KAAK,EAAE;MACjB,IAAI,IAAI,CAAClE,MAAM,IAAImE,MAAM,CAACC,MAAM,CAAC,IAAI,CAACrE,QAAQ,CAAC,CAACsE,QAAQ,CAACH,KAAK,CAACzB,IAAI,CAAC,EAAE;QAClE,IAAI,CAACxC,WAAW,CAACmC,aAAa,CAAC8B,KAAK,CAAC;MACzC;IACJ;EAAC;IAAA9D,GAAA;IAAAC,KAAA,EAED,SAAAiE,gBAAgBA,CAACC,SAAS,EAAEC,QAAQ,EAAE;MAClC,IAAI,IAAI,CAACxE,MAAM,EAAE;QACb,IAAImE,MAAM,CAACC,MAAM,CAAC,IAAI,CAACrE,QAAQ,CAAC,CAACsE,QAAQ,CAACE,SAAS,CAAC,EAAE;UAClD,IAAI,CAACtE,WAAW,CAACqE,gBAAgB,CAACC,SAAS,EAAEC,QAAQ,CAAC;QAC1D,CAAC,MAAM;UACH,IAAI,CAACxE,MAAM,CAACsE,gBAAgB,CAACC,SAAS,EAAEC,QAAQ,CAAC;QACrD;MACJ;IACJ;EAAC;IAAApE,GAAA;IAAAC,KAAA,EAED,SAAAoE,mBAAmBA,CAACF,SAAS,EAAEC,QAAQ,EAAE;MACrC,IAAI,IAAI,CAACxE,MAAM,EAAE;QACb,IAAImE,MAAM,CAACC,MAAM,CAAC,IAAI,CAACrE,QAAQ,CAAC,CAACsE,QAAQ,CAACE,SAAS,CAAC,EAAE;UAClD,IAAI,CAACtE,WAAW,CAACwE,mBAAmB,CAACF,SAAS,EAAEC,QAAQ,CAAC;QAC7D,CAAC,MAAM;UACH,IAAI,CAACxE,MAAM,CAACyE,mBAAmB,CAACF,SAAS,EAAEC,QAAQ,CAAC;QACxD;MACJ;IACJ;EAAC;IAAApE,GAAA;IAAAC,KAAA,EAED,SAAAM,UAAUA,CAAA,EAAG;MACT;MACA,IAAI,CAAC2D,gBAAgB,CAACjH,2DAAY,CAACC,mBAAmB,EAAE,IAAI,CAAC2E,uBAAuB,CAACyC,IAAI,CAAC,IAAI,CAAC,CAAC;MAChG,IAAI,CAACJ,gBAAgB,CAACjH,2DAAY,CAACxB,KAAK,EAAE,IAAI,CAAC2G,WAAW,CAACkC,IAAI,CAAC,IAAI,CAAC,CAAC;MACtE,IAAI,CAACJ,gBAAgB,CAACjH,2DAAY,CAACvB,OAAO,EAAE,IAAI,CAAC6G,aAAa,CAAC+B,IAAI,CAAC,IAAI,CAAC,CAAC;MAC1E,IAAI,CAACJ,gBAAgB,CAACjH,2DAAY,CAACtB,eAAe,EAAE,IAAI,CAAC8G,oBAAoB,CAAC6B,IAAI,CAAC,IAAI,CAAC,CAAC;MACzF,IAAI,CAACJ,gBAAgB,CAACjH,2DAAY,CAACE,IAAI,EAAE,IAAI,CAACwF,UAAU,CAAC2B,IAAI,CAAC,IAAI,CAAC,CAAC;MACpE,IAAI,CAACJ,gBAAgB,CAACjH,2DAAY,CAACG,KAAK,EAAE,IAAI,CAACyF,WAAW,CAACyB,IAAI,CAAC,IAAI,CAAC,CAAC;MACtE,IAAI,CAACJ,gBAAgB,CAACjH,2DAAY,CAACb,OAAO,EAAE,IAAI,CAAC0G,aAAa,CAACwB,IAAI,CAAC,IAAI,CAAC,CAAC;MAC1E,IAAI,CAACJ,gBAAgB,CAACjH,2DAAY,CAACI,MAAM,EAAE,IAAI,CAAC0F,YAAY,CAACuB,IAAI,CAAC,IAAI,CAAC,CAAC;MACxE;MACA,IAAI,CAACJ,gBAAgB,CAACjH,2DAAY,CAACK,gBAAgB,EAAE,IAAI,CAAC0F,iBAAiB,CAACsB,IAAI,CAAC,IAAI,CAAC,CAAC;MACvF,IAAI,CAACJ,gBAAgB,CAACjH,2DAAY,CAACM,gBAAgB,EAAE,IAAI,CAAC8F,iBAAiB,CAACiB,IAAI,CAAC,IAAI,CAAC,CAAC;MACvF,IAAI,CAACJ,gBAAgB,CAACjH,2DAAY,CAACO,eAAe,EAAE,IAAI,CAAC8F,gBAAgB,CAACgB,IAAI,CAAC,IAAI,CAAC,CAAC;MACrF,IAAI,CAACJ,gBAAgB,CAACjH,2DAAY,CAACQ,kBAAkB,EAAE,IAAI,CAAC8F,sBAAsB,CAACe,IAAI,CAAC,IAAI,CAAC,CAAC;MAC9F,IAAI,CAACJ,gBAAgB,CAACjH,2DAAY,CAACS,kBAAkB,EAAE,IAAI,CAAC8F,sBAAsB,CAACc,IAAI,CAAC,IAAI,CAAC,CAAC;MAC9F,IAAI,CAACJ,gBAAgB,CAACjH,2DAAY,CAACU,iBAAiB,EAAE,IAAI,CAAC8F,qBAAqB,CAACa,IAAI,CAAC,IAAI,CAAC,CAAC;MAC5F;MACA,IAAI,CAACJ,gBAAgB,CAACjH,2DAAY,CAACW,kBAAkB,EAAE,IAAI,CAAC8F,+BAA+B,CAACY,IAAI,CAAC,IAAI,CAAC,CAAC;MACvG,IAAI,CAACJ,gBAAgB,CAACjH,2DAAY,CAACY,kBAAkB,EAAE,IAAI,CAAC8F,+BAA+B,CAACW,IAAI,CAAC,IAAI,CAAC,CAAC;MACvG;MACA,IAAI,CAACJ,gBAAgB,CAACjH,2DAAY,CAACgB,WAAW,EAAE,IAAI,CAAC2F,aAAa,CAACU,IAAI,CAAC,IAAI,CAAC,CAAC;MAC9E;MACA;MACA,IAAI,CAACJ,gBAAgB,CAACjH,2DAAY,CAACqB,aAAa,EAAE,IAAI,CAACuF,kBAAkB,CAACS,IAAI,CAAC,IAAI,CAAC,CAAC;IACzF;EAAC;IAAAtE,GAAA;IAAAC,KAAA,EAED,SAAAsE,aAAaA,CAAA,EAAG;MACZ;MACA,IAAI,CAACF,mBAAmB,CAACpH,2DAAY,CAACC,mBAAmB,EAAE,IAAI,CAAC2E,uBAAuB,CAACyC,IAAI,CAAC,IAAI,CAAC,CAAC;MACnG,IAAI,CAACD,mBAAmB,CAACpH,2DAAY,CAACxB,KAAK,EAAE,IAAI,CAAC2G,WAAW,CAACkC,IAAI,CAAC,IAAI,CAAC,CAAC;MACzE,IAAI,CAACD,mBAAmB,CAACpH,2DAAY,CAACvB,OAAO,EAAE,IAAI,CAAC6G,aAAa,CAAC+B,IAAI,CAAC,IAAI,CAAC,CAAC;MAC7E,IAAI,CAACD,mBAAmB,CAACpH,2DAAY,CAACtB,eAAe,EAAE,IAAI,CAAC8G,oBAAoB,CAAC6B,IAAI,CAAC,IAAI,CAAC,CAAC;MAC5F,IAAI,CAACD,mBAAmB,CAACpH,2DAAY,CAACE,IAAI,EAAE,IAAI,CAACwF,UAAU,CAAC2B,IAAI,CAAC,IAAI,CAAC,CAAC;MACvE,IAAI,CAACD,mBAAmB,CAACpH,2DAAY,CAACG,KAAK,EAAE,IAAI,CAACyF,WAAW,CAACyB,IAAI,CAAC,IAAI,CAAC,CAAC;MACzE,IAAI,CAACD,mBAAmB,CAACpH,2DAAY,CAACb,OAAO,EAAE,IAAI,CAAC0G,aAAa,CAACwB,IAAI,CAAC,IAAI,CAAC,CAAC;MAC7E,IAAI,CAACD,mBAAmB,CAACpH,2DAAY,CAACI,MAAM,EAAE,IAAI,CAAC0F,YAAY,CAACuB,IAAI,CAAC,IAAI,CAAC,CAAC;MAC3E;MACA,IAAI,CAACD,mBAAmB,CAACpH,2DAAY,CAACK,gBAAgB,EAAE,IAAI,CAAC0F,iBAAiB,CAACsB,IAAI,CAAC,IAAI,CAAC,CAAC;MAC1F,IAAI,CAACD,mBAAmB,CAACpH,2DAAY,CAACM,gBAAgB,EAAE,IAAI,CAAC8F,iBAAiB,CAACiB,IAAI,CAAC,IAAI,CAAC,CAAC;MAC1F,IAAI,CAACD,mBAAmB,CAACpH,2DAAY,CAACO,eAAe,EAAE,IAAI,CAAC8F,gBAAgB,CAACgB,IAAI,CAAC,IAAI,CAAC,CAAC;MACxF,IAAI,CAACD,mBAAmB,CAACpH,2DAAY,CAACQ,kBAAkB,EAAE,IAAI,CAAC8F,sBAAsB,CAACe,IAAI,CAAC,IAAI,CAAC,CAAC;MACjG,IAAI,CAACD,mBAAmB,CAACpH,2DAAY,CAACS,kBAAkB,EAAE,IAAI,CAAC8F,sBAAsB,CAACc,IAAI,CAAC,IAAI,CAAC,CAAC;MACjG,IAAI,CAACD,mBAAmB,CAACpH,2DAAY,CAACU,iBAAiB,EAAE,IAAI,CAAC8F,qBAAqB,CAACa,IAAI,CAAC,IAAI,CAAC,CAAC;MAC/F;MACA,IAAI,CAACD,mBAAmB,CAACpH,2DAAY,CAACW,kBAAkB,EAAE,IAAI,CAAC8F,+BAA+B,CAACY,IAAI,CAAC,IAAI,CAAC,CAAC;MAC1G,IAAI,CAACD,mBAAmB,CAACpH,2DAAY,CAACY,kBAAkB,EAAE,IAAI,CAAC8F,+BAA+B,CAACW,IAAI,CAAC,IAAI,CAAC,CAAC;MAC1G;MACA,IAAI,CAACD,mBAAmB,CAACpH,2DAAY,CAACgB,WAAW,EAAE,IAAI,CAAC2F,aAAa,CAACU,IAAI,CAAC,IAAI,CAAC,CAAC;MACjF;MACA;MACA,IAAI,CAACD,mBAAmB,CAACpH,2DAAY,CAACqB,aAAa,EAAE,IAAI,CAACuF,kBAAkB,CAACS,IAAI,CAAC,IAAI,CAAC,CAAC;IAC5F;;IAEA;EAAA;IAAAtE,GAAA;IAAAC,KAAA,EACA,SAAAuE,UAAUA,CAAA,EAAG;MACT,mBAAAhF,MAAA,CAAmBb,iDAAQ,CAACc,OAAO;IACvC;EAAC;IAAAO,GAAA;IAAAC,KAAA,EAED,SAAAwE,IAAIA,CAAA,EAAG;MACH,IAAI,IAAI,CAAC7E,MAAM,EAAE;QACb,IAAI,CAACA,MAAM,CAAC6E,IAAI,CAAC,CAAC;MACtB;IACJ;EAAC;IAAAzE,GAAA;IAAAC,KAAA,EAED,SAAAyE,KAAKA,CAAA,EAAG;MACJ,IAAI,IAAI,CAAC9E,MAAM,EAAE;QACb,IAAI,CAACA,MAAM,CAAC8E,KAAK,CAAC,CAAC;MACvB;IACJ;EAAC;IAAA1E,GAAA;IAAAC,KAAA,EAED,SAAA0E,MAAMA,CAAA,EAAG;MACL,IAAI,IAAI,CAAC/E,MAAM,EAAE;QACb,IAAI,CAACA,MAAM,CAAC6E,IAAI,CAAC,CAAC;MACtB;IACJ;EAAC;IAAAzE,GAAA;IAAAC,KAAA,EAED,SAAA2E,IAAIA,CAAA,EAAG;MACH,IAAI,IAAI,CAAChF,MAAM,EAAE;QACb,IAAI,CAACA,MAAM,CAACgF,IAAI,CAAC,CAAC;MACtB;IACJ;EAAC;IAAA5E,GAAA;IAAAC,KAAA,EAED,SAAA4E,IAAIA,CAACC,QAAQ,EAAE;MACX,IAAI,IAAI,CAAClF,MAAM,EAAE;QACb,OAAO,IAAI,CAACA,MAAM,CAACmF,MAAM,CAACD,QAAQ,CAAC;MACvC;IACJ;EAAC;IAAA9E,GAAA;IAAAC,KAAA,EAED,SAAA6E,QAAQA,CAAA,EAAG;MACP,IAAI,IAAI,CAAClF,MAAM,EAAE;QACb,OAAO,IAAI,CAACA,MAAM,CAACoF,WAAW,CAAC,CAAC;MACpC;MACA,OAAO,IAAI;IACf;EAAC;IAAAhF,GAAA;IAAAC,KAAA,EAED,SAAAgF,MAAMA,CAAA,EAAG;MACL,IAAI,IAAI,CAACrF,MAAM,EAAE;QACb,OAAO,IAAI,CAACA,MAAM,CAACsF,SAAS,CAAC,CAAC;MAClC;IACJ;EAAC;IAAAlF,GAAA;IAAAC,KAAA,EAED,SAAAkF,IAAIA,CAAA,EAAG;MACH,IAAI,IAAI,CAACvF,MAAM,EAAE;QACb,IAAI,CAACA,MAAM,CAACuF,IAAI,CAAC,CAAC;MACtB;IACJ;EAAC;IAAAnF,GAAA;IAAAC,KAAA,EAED,SAAAmF,MAAMA,CAAA,EAAG;MACL,IAAI,IAAI,CAACxF,MAAM,EAAE;QACb,IAAI,CAACA,MAAM,CAACyF,MAAM,CAAC,CAAC;MACxB;IACJ;EAAC;IAAArF,GAAA;IAAAC,KAAA,EAED,SAAAqF,QAAQA,CAAA,EAAG;MACP,IAAI,IAAI,CAAC1F,MAAM,EAAE;QACb,OAAO,IAAI,CAACA,MAAM,CAAC0F,QAAQ,CAAC,CAAC;MACjC;IACJ;EAAC;IAAAtF,GAAA;IAAAC,KAAA,EAED,SAAAsF,MAAMA,CAAA,EAAG;MACL,IAAI,IAAI,CAAC3F,MAAM,EAAE;QACb,OAAO,IAAI,CAACA,MAAM,CAAC2F,MAAM,CAAC,CAAC;MAC/B;IACJ;EAAC;IAAAvF,GAAA;IAAAC,KAAA,EAED,SAAAuF,WAAWA,CAAA,EAAG;MACV,IAAI,IAAI,CAAC5F,MAAM,EAAE;QACb,OAAO,IAAI,CAACA,MAAM,CAAC4F,WAAW,CAAC,CAAC;MACpC;IACJ;EAAC;IAAAxF,GAAA;IAAAC,KAAA,EAED,SAAAwF,SAASA,CAAA,EAAe;MAAA,IAAdR,MAAM,GAAA/F,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,GAAG;MAClB,IAAI,IAAI,CAACU,MAAM,EAAE;QACb,OAAO,IAAI,CAACA,MAAM,CAAC6F,SAAS,CAACR,MAAM,IAAIA,MAAM,GAAG,CAAC,GAAGA,MAAM,GAAG,CAAC,GAAGA,MAAM,CAAC;MAC5E;IACJ;EAAC;IAAAjF,GAAA;IAAAC,KAAA,EAED,SAAAyF,gBAAgBA,CAAA,EAAG;MACf,IAAI,IAAI,CAAC9F,MAAM,EAAE;QACb,OAAO,IAAI,CAACA,MAAM,CAAC8F,gBAAgB,CAAC,CAAC;MACzC;MACA,OAAO,IAAI;IACf;EAAC;IAAA1F,GAAA;IAAAC,KAAA,EAED,SAAA0F,eAAeA,CAAA,EAAW;MAAA,IAAVC,IAAI,GAAA1G,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;MACpB,IAAI,IAAI,CAACU,MAAM,EAAE;QACb,IAAI,CAACA,MAAM,CAAC+F,eAAe,CAACC,IAAI,CAAC;MACrC,CAAC,MAAM,IAAG,CAAC,IAAI,CAAChG,MAAM,CAACiG,yBAAyB,CAAC,CAAC,EAAE;QAChD,IAAI,CAACnG,MAAM,CAACqC,IAAI,CAAC,oDAAoD,CAAC;MAC1E;IACJ;EAAC;IAAA/B,GAAA;IAAAC,KAAA,EAED,SAAA6F,aAAaA,CAACpD,GAAG,EAAE;MACf,IAAI,IAAI,CAAC9C,MAAM,IAAI8C,GAAG,IAAIA,GAAG,CAACqD,EAAE,EAAE;QAC9B,IAAI,CAACrG,MAAM,CAACkD,IAAI,CAAC,gCAAgC,EAAEM,IAAI,CAACC,SAAS,CAACT,GAAG,CAAC,CAAC;QACvE,IAAMsD,WAAW,GAAG,IAAI,CAACpG,MAAM,CAACqG,uBAAuB,CAAC,CAAC;QACzD,IAAI,CAACvG,MAAM,CAACkD,IAAI,CAAC,uBAAuB,EAAEM,IAAI,CAACC,SAAS,CAAC6C,WAAW,CAAC,CAAC;QAEtE,IAAI,CAACpG,MAAM,CAACkG,aAAa,CAACE,WAAW,CAAC,CAAC,CAAC,CAACD,EAAE,CAAC;MAChD;IACJ;EAAC;IAAA/F,GAAA;IAAAC,KAAA,EAED,SAAAiG,kBAAkBA,CAACxD,GAAG,EAAE;MACpB,IAAG,IAAI,CAAC9C,MAAM,IAAI8C,GAAG,IAAIA,GAAG,CAACqD,EAAE,EAAE;QAC7B,IAAI,CAACrG,MAAM,CAACkD,IAAI,CAAC,2CAA2C,EAAEM,IAAI,CAACC,SAAS,CAACT,GAAG,CAAC,CAAC;QAElF,IAAI,CAAC9C,MAAM,CAACsG,kBAAkB,CAACxD,GAAG,CAACqD,EAAE,CAAC;MAC1C;IACJ;EAAC;IAAA/F,GAAA;IAAAC,KAAA,EAED,SAAAkG,aAAaA,CAACzD,GAAG,EAAE;MACf,IAAG,IAAI,CAAC9C,MAAM,IAAI8C,GAAG,IAAIA,GAAG,CAACqD,EAAE,EAAE;QAC7B,IAAI,CAACrG,MAAM,CAACkD,IAAI,CAAC,gCAAgC,EAAEM,IAAI,CAACC,SAAS,CAACT,GAAG,CAAC,CAAC;QACvE,IAAI,CAAC9C,MAAM,CAACuG,aAAa,CAACzD,GAAG,CAACqD,EAAE,CAAC;MACrC;IACJ;EAAC;IAAA/F,GAAA;IAAAC,KAAA,EAED,SAAAmG,kBAAkBA,CAAC1D,GAAG,EAAE;MACpB,IAAG,IAAI,CAAC9C,MAAM,IAAI8C,GAAG,IAAIA,GAAG,CAACqD,EAAE,EAAE;QAC7B,IAAI,CAACrG,MAAM,CAACkD,IAAI,CAAC,2CAA2C,EAAEM,IAAI,CAACC,SAAS,CAACT,GAAG,CAAC,CAAC;QAClF,IAAI,CAAC9C,MAAM,CAACwG,kBAAkB,CAAC1D,GAAG,CAACqD,EAAE,CAAC;MAC1C;IACJ;EAAC;IAAA/F,GAAA;IAAAC,KAAA,EAED,SAAAoG,WAAWA,CAAC3D,GAAG,EAAE;MACb,IAAG,IAAI,CAAC9C,MAAM,IAAI8C,GAAG,IAAIA,GAAG,CAACqD,EAAE,EAAE;QAC7B,IAAI,CAACnG,MAAM,CAAC0G,YAAY,CAAC5D,GAAG,CAACqD,EAAE,CAAC;MACpC;IACJ;EAAC;IAAA/F,GAAA;IAAAC,KAAA,EAED,SAAAsG,kBAAkBA,CAAA,EAAG;MACjB,IAAI,IAAI,CAAC3G,MAAM,EAAE;QACb,OAAO,IAAI,CAACA,MAAM,CAAC2G,kBAAkB,CAAC,CAAC;MAC3C;MACA,OAAO,IAAI;IACf;EAAC;IAAAvG,GAAA;IAAAC,KAAA,EAED,SAAAuG,kBAAkBA,CAAA,EAAG;MACjB,IAAI,IAAI,CAAC5G,MAAM,EAAE;QACb,OAAO,IAAI,CAACA,MAAM,CAAC4G,kBAAkB,CAAC,CAAC;MAC3C;MACA,OAAO,IAAI;IACf;EAAC;IAAAxG,GAAA;IAAAC,KAAA,EAED,SAAAwG,eAAeA,CAAA,EAAG;MACd,IAAI,IAAI,CAAC7G,MAAM,EAAE;QACb,OAAO,IAAI,CAACA,MAAM,CAAC6G,eAAe,CAAC,CAAC;MACxC;MACA,OAAO,IAAI;IACf;EAAC;IAAAzG,GAAA;IAAAC,KAAA,EAED,SAAAyG,QAAQA,CAAA,EAAG;MACP,IAAI,IAAI,CAAC9G,MAAM,EAAE;QACb,OAAO,IAAI,CAACA,MAAM,CAAC+G,gBAAgB,CAAC,CAAC;MACzC;MACA,OAAO,IAAI;IACf;EAAC;IAAA3G,GAAA;IAAAC,KAAA,EAED,SAAA2G,QAAQA,CAAA,EAAG;MACP,IAAI,IAAI,CAAChH,MAAM,EAAE;QACb,OAAO,IAAI,CAACA,MAAM,CAACgH,QAAQ,CAAC,CAAC;MACjC;MACA,OAAO,IAAI;IACf;EAAC;IAAA5G,GAAA;IAAAC,KAAA,EAED,SAAA4G,eAAeA,CAAA,EAAG;MACd,IAAI,IAAI,CAACjH,MAAM,EAAE;QACb,OAAO,IAAI,CAACA,MAAM,CAACiH,eAAe,CAAC,CAAC;MACxC;MACA,OAAO,IAAI;IACf;EAAC;IAAA7G,GAAA;IAAAC,KAAA,EAED,SAAA6G,mBAAmBA,CAAA,EAAG;MAClB,IAAI,IAAI,CAAClH,MAAM,EAAE;QACb,OAAO,IAAI,CAACA,MAAM,CAACkH,mBAAmB,CAAC,CAAC;MAC5C;MACA,OAAO,IAAI;IACf;EAAC;IAAA9G,GAAA;IAAAC,KAAA,EAED,SAAA8G,gBAAgBA,CAAA,EAAG;MACf,IAAI,IAAI,CAACnH,MAAM,EAAE;QACb,OAAO,IAAI,CAACA,MAAM,CAACmH,gBAAgB,CAAC,CAAC;MACzC;MACA,OAAO,IAAI;IACf;EAAC;IAAA/G,GAAA;IAAAC,KAAA,EAED,SAAA+G,OAAOA,CAAA,EAAG;MACN,IAAI,IAAI,CAACpH,MAAM,EAAE;QACb,IAAI,CAACA,MAAM,CAACoH,OAAO,CAAC,CAAC;QACrB,IAAI,CAACpH,MAAM,GAAG,IAAI;MACtB;IACJ;EAAC;IAAAI,GAAA;IAAAC,KAAA,EAED,SAAAgH,MAAMA,CAACC,OAAO,EAAE;MACZ,IAAI,IAAI,CAACtH,MAAM,EAAE;QACb,OAAO,IAAI,CAACA,MAAM,CAACqH,MAAM,CAACC,OAAO,CAAC;MACtC;IACJ;EAAC;AAAA;AAGL,+DAAenI,aAAa,E;;;;;;;;;;;;;;;;;;AC/fc;AAAA,IACpCH,MAAM;EACV,SAAAA,OAAA,EAAsB;IAAA,IAAVW,GAAG,GAAAL,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,EAAE;IAAAI,eAAA,OAAAV,MAAA;IAClB,IAAI,CAACW,GAAG,OAAAC,MAAA,CAAOD,GAAG,OAAI;EACxB;EAAC,OAAAQ,YAAA,CAAAnB,MAAA;IAAAoB,GAAA;IAAAC,KAAA,EAED,SAAAa,KAAKA,CAAA,EAAU;MAAA,SAAAsG,IAAA,GAAAlI,SAAA,CAAAC,MAAA,EAANkI,IAAI,OAAAC,KAAA,CAAAF,IAAA,GAAAG,IAAA,MAAAA,IAAA,GAAAH,IAAA,EAAAG,IAAA;QAAJF,IAAI,CAAAE,IAAA,IAAArI,SAAA,CAAAqI,IAAA;MAAA;MACX,IAAI,CAACC,GAAG,CAAC5I,MAAM,CAAC6I,KAAK,CAAC3G,KAAK,EAAEuG,IAAI,CAAC;IACpC;EAAC;IAAArH,GAAA;IAAAC,KAAA,EACD,SAAA8B,IAAIA,CAAA,EAAU;MAAA,SAAA2F,KAAA,GAAAxI,SAAA,CAAAC,MAAA,EAANkI,IAAI,OAAAC,KAAA,CAAAI,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;QAAJN,IAAI,CAAAM,KAAA,IAAAzI,SAAA,CAAAyI,KAAA;MAAA;MACV,IAAI,CAACH,GAAG,CAAC5I,MAAM,CAAC6I,KAAK,CAAC1F,IAAI,EAAEsF,IAAI,CAAC;IACnC;EAAC;IAAArH,GAAA;IAAAC,KAAA,EACD,SAAA2C,IAAIA,CAAA,EAAU;MAAA,SAAAgF,KAAA,GAAA1I,SAAA,CAAAC,MAAA,EAANkI,IAAI,OAAAC,KAAA,CAAAM,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;QAAJR,IAAI,CAAAQ,KAAA,IAAA3I,SAAA,CAAA2I,KAAA;MAAA;MACV,IAAI,CAACL,GAAG,CAAC5I,MAAM,CAAC6I,KAAK,CAAC7E,IAAI,EAAEyE,IAAI,CAAC;IACnC;EAAC;IAAArH,GAAA;IAAAC,KAAA,EACD,SAAAkC,KAAKA,CAAA,EAAU;MAAA,SAAA2F,KAAA,GAAA5I,SAAA,CAAAC,MAAA,EAANkI,IAAI,OAAAC,KAAA,CAAAQ,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;QAAJV,IAAI,CAAAU,KAAA,IAAA7I,SAAA,CAAA6I,KAAA;MAAA;MACX,IAAI,CAACP,GAAG,CAAC5I,MAAM,CAAC6I,KAAK,CAACtF,KAAK,EAAEkF,IAAI,CAAC;IACpC;EAAC;IAAArH,GAAA;IAAAC,KAAA,EAED,SAAAuH,GAAGA,CAACnF,IAAI,EAAW;MACjB,IAAIzD,MAAM,CAACoJ,QAAQ,CAAC3F,IAAI,CAAC,GAAGzD,MAAM,CAACoJ,QAAQ,CAACb,wDAAS,CAAC7L,SAAS,CAAC,EAAE;MAAO,SAAA2M,KAAA,GAAA/I,SAAA,CAAAC,MAAA,EAD9DkI,IAAI,OAAAC,KAAA,CAAAW,KAAA,OAAAA,KAAA,WAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;QAAJb,IAAI,CAAAa,KAAA,QAAAhJ,SAAA,CAAAgJ,KAAA;MAAA;MAEf,IAAMC,GAAG,GAAG,IAAI,CAAC5I,GAAG,IAAI8H,IAAI,CAAC,CAAC,CAAC,IAAIA,IAAI,CAAC,CAAC,CAAC,CAAClI,MAAM,GAAGkI,IAAI,CAAC,CAAC,CAAC,CAACe,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC;MAC3E,QAAQ/F,IAAI;QACV,KAAKzD,MAAM,CAAC6I,KAAK,CAAC3G,KAAK;UACrBuH,OAAO,CAACvH,KAAK,CAACqH,GAAG,CAAC;UAClB;QACF,KAAKvJ,MAAM,CAAC6I,KAAK,CAAC1F,IAAI;UACpBsG,OAAO,CAACtG,IAAI,CAACoG,GAAG,CAAC;UACjB;QACF,KAAKvJ,MAAM,CAAC6I,KAAK,CAAC7E,IAAI;UACpByF,OAAO,CAACzF,IAAI,CAACuF,GAAG,CAAC;UACjB;QACF,KAAKvJ,MAAM,CAAC6I,KAAK,CAACtF,KAAK;UACrBkG,OAAO,CAAClG,KAAK,CAACgG,GAAG,CAAC;UAClB;QACF;UACEE,OAAO,CAACb,GAAG,CAACW,GAAG,CAAC;MACpB;IACF;EAAC;AAAA;AAGHvJ,MAAM,CAAC6I,KAAK,GAAG;EACba,IAAI,EAAE,MAAM;EACZxH,KAAK,EAAE,OAAO;EACdiB,IAAI,EAAE,MAAM;EACZa,IAAI,EAAE,MAAM;EACZT,KAAK,EAAE;AACT,CAAC;AAEDvD,MAAM,CAACoJ,QAAQ,GAAG;EAChBM,IAAI,EAAE,CAAC;EACPxH,KAAK,EAAE,CAAC;EACRiB,IAAI,EAAE,CAAC;EACPa,IAAI,EAAE,CAAC;EACPT,KAAK,EAAE;AACT,CAAC;AAED,+DAAevD,MAAM,E;;;;;;;;;;;;;;;;;;ACzDqB;AAAA,IAEpC2J,KAAK;EAAA,SAAAA,MAAA;IAAAjJ,eAAA,OAAAiJ,KAAA;EAAA;EAAA,OAAAxI,YAAA,CAAAwI,KAAA;IAAAvI,GAAA;IAAAC,KAAA,EACP,SAAOuI,UAAUA,CAACC,OAAO,EAAE;MACvB,OAAO;QACHvO,cAAc,EAAEuO,OAAO,CAACC,cAAc,CAACvB,wDAAS,CAACjN,cAAc,CAAC;QAEhEyO,WAAW,EAAKF,OAAO,CAACC,cAAc,CAACvB,wDAAS,CAAChN,QAAQ,CAACC,OAAO,CAAC;QAClEwO,UAAU,EAAMH,OAAO,CAACC,cAAc,CAACvB,wDAAS,CAAChN,QAAQ,CAACE,MAAM,CAAC;QACjEwO,aAAa,EAAGJ,OAAO,CAACC,cAAc,CAACvB,wDAAS,CAAChN,QAAQ,CAACG,SAAS,CAAC;QACpEwO,WAAW,EAAKL,OAAO,CAACC,cAAc,CAACvB,wDAAS,CAAChN,QAAQ,CAACI,OAAO,CAAC;QAClEwO,QAAQ,EAAQN,OAAO,CAACC,cAAc,CAACvB,wDAAS,CAAChN,QAAQ,CAACK,IAAI,CAAC;QAE/DwO,aAAa,EAAGP,OAAO,CAACC,cAAc,CAACvB,wDAAS,CAAC1M,QAAQ,CAACC,WAAW,CAAC;QACtEuO,SAAS,EAAOR,OAAO,CAACS,aAAa,CAAC/B,wDAAS,CAAC1M,QAAQ,CAACE,WAAW,CAAC;QACrEwO,OAAO,EAASV,OAAO,CAACS,aAAa,CAAC/B,wDAAS,CAAC1M,QAAQ,CAACG,QAAQ,CAAC;QAElEwO,UAAU,EAAMX,OAAO,CAACC,cAAc,CAACvB,wDAAS,CAACtM,QAAQ,CAACH,WAAW,CAAC;QACtE2O,UAAU,EAAMZ,OAAO,CAACC,cAAc,CAACvB,wDAAS,CAACtM,QAAQ,CAACC,MAAM,CAAC;QAEjEwO,cAAc,EAAEb,OAAO,CAACC,cAAc,CAACvB,wDAAS,CAACpM,OAAO,CAACC,aAAa,CAAC;QACvEC,eAAe,EAACwN,OAAO,CAACC,cAAc,CAACvB,wDAAS,CAACpM,OAAO,CAACE,eAAe,CAAC;QAEzEC,YAAY,EAAIuN,OAAO,CAACC,cAAc,CAACvB,wDAAS,CAACpM,OAAO,CAACG,YAAY,CAAC;QACtEC,YAAY,EAAIsN,OAAO,CAACC,cAAc,CAACvB,wDAAS,CAACpM,OAAO,CAACI,YAAY,CAAC;QACtEoO,qBAAqB,EAAEd,OAAO,CAACC,cAAc,CAACvB,wDAAS,CAACpM,OAAO,CAACK,kBAAkB,CAAC;QACnFoO,qBAAqB,EAAEf,OAAO,CAACC,cAAc,CAACvB,wDAAS,CAACpM,OAAO,CAACM,kBAAkB;MACtF,CAAC;IACL;EAAC;IAAA2E,GAAA;IAAAC,KAAA,EAED,SAAOwJ,UAAUA,CAACC,OAAO,EAAE;MACvB,IAAMC,GAAG,GAAGC,IAAI,CAACC,KAAK,CAACH,OAAO,GAAG,IAAI,CAAC;MACtC,IAAMI,IAAI,GAAGF,IAAI,CAACC,KAAK,CAAEH,OAAO,GAAG,IAAI,GAAI,EAAE,CAAC;MAC9C,IAAMK,IAAI,GAAGH,IAAI,CAACC,KAAK,CAACH,OAAO,GAAG,EAAE,CAAC;MACrC,OAAO,CAACC,GAAG,EAAEG,IAAI,EAAEC,IAAI,CAAC,CACnBC,GAAG,CAAC,UAACC,CAAC;QAAA,OAAKA,CAAC,GAAG,EAAE,GAAG,GAAG,GAAGA,CAAC,GAAGA,CAAC;MAAA,EAAC,CAChC7B,IAAI,CAAC,GAAG,CAAC;IAClB;EAAC;IAAApI,GAAA;IAAAC,KAAA,EAED,SAAOiK,cAAcA,CAACC,WAAW,EAAEzD,QAAQ,EAAE;MACzC,OAAO0D,MAAM,CAAC,CAAED,WAAW,GAAGzD,QAAQ,GAAI,GAAG,EAAE2D,OAAO,CAAC,CAAC,CAAC,CAAC;IAC9D;EAAC;IAAArK,GAAA;IAAAC,KAAA,EAED,SAAOqK,oBAAoBA,CAAA,EAA+B;MAAA,IAA9BC,cAAc,GAAArL,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;MAAA,IAAEwH,QAAQ,GAAAxH,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;MACpD,OAAQmL,cAAc,GAAG,GAAG,GAAI7D,QAAQ;IAC5C;EAAC;IAAA1G,GAAA;IAAAC,KAAA,EAED,SAAOuK,gBAAgBA,CAACC,OAAO,EAAE;MAC7B,IAAIA,OAAO,IAAI,OAAO,EAAE,OAAO,OAAO;MACtC,IAAIA,OAAO,IAAI,OAAO,EAAE,OAAO,MAAM;MACrC,IAAIA,OAAO,IAAI,OAAO,EAAE,OAAO,MAAM;MACrC,IAAIA,OAAO,IAAI,MAAM,EAAE,OAAO,MAAM;MACpC,IAAIA,OAAO,IAAI,MAAM,EAAE,OAAO,MAAM;MACpC,OAAO,MAAM;IACjB;EAAC;IAAAzK,GAAA;IAAAC,KAAA,EAED,SAAOyK,aAAaA,CAACD,OAAO,EAAE;MAC1B,UAAAjL,MAAA,CAAU,CAACiL,OAAO,GAAG,OAAO,EAAEJ,OAAO,CAAC,CAAC,CAAC;IAC5C;EAAC;IAAArK,GAAA;IAAAC,KAAA,EACD,SAAO0K,aAAaA,CAACF,OAAO,EAAE;MAC1B,UAAAjL,MAAA,CAAU,CAACiL,OAAO,GAAG,IAAI,EAAEJ,OAAO,CAAC,CAAC,CAAC;IACzC;EAAC;IAAArK,GAAA;IAAAC,KAAA,EACD,SAAO2K,QAAQA,CAAA,EAAG;MACd,OAAO,gCAAgC,CAACC,IAAI,CAACC,SAAS,CAACC,SAAS,CAAC;IACrE;EAAC;AAAA;AAGL,+DAAexC,KAAK,E;;;;;;UCnEpB;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA,E;;;;;WCPA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA,CAAC,I;;;;;WCPD,8CAA8C,yD;;;;;WCA9C;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D,E;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACN0B;AACkB;AACC;AACX;AACQ;AACA;AACN;AACI;AAAA,IAElC0C,GAAG;EACL,SAAAA,IAAA,EAAc;IAAA3L,eAAA,OAAA2L,GAAA;IACV,IAAI,CAAC1L,GAAG,QAAQ;IAChB,IAAI,CAACG,MAAM,GAAG,IAAId,qDAAM,CAAC,IAAI,CAACW,GAAG,CAAC;IAClC,IAAI,CAAC2L,WAAW,GAAGC,QAAQ,CAACzC,cAAc,CAAC,cAAc,CAAC;IAC1D,IAAI,CAAC0C,mBAAmB,CAAC,CAAC;IAC1B,IAAI,CAACC,kBAAkB,CAACL,yDAAS,CAACM,IAAI,CAAC,CAAC,CAAC,CAAC;EAC9C;EAAC,OAAAvL,YAAA,CAAAkL,GAAA;IAAAjL,GAAA;IAAAC,KAAA,EAED,SAAAoL,kBAAkBA,CAAA,EAA4B;MAAA,IAA3BE,kBAAkB,GAAArM,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAI;MACxC,IAAI,CAACsM,MAAM,GAAGD,kBAAkB,GAAGA,kBAAkB,GAAG,IAAI,CAACC,MAAM;MACnE,IAAI,CAACxM,WAAW,GAAG,IAAI,CAACwM,MAAM,CAAChS,WAAW;MAC1C,IAAI,CAAC6F,SAAS,GAAG,IAAI,CAACmM,MAAM,CAAC/R,UAAU,IAAI,IAAI;MAC/C,IAAI,CAACwF,YAAY,GAAG;QAChBkB,YAAY,EAAEgL,QAAQ,CAACzC,cAAc,CAAC,OAAO;MACjD,CAAC;;MAED;MACA,IAAI,CAAC+C,QAAQ,GAAG,IAAInP,sDAAc,CAAC,IAAI,CAAC0C,WAAW,EAAE,IAAI,CAACC,YAAY,EAAE,IAAI,CAACI,SAAS,CAAC;MACvF;MACA,IAAI,CAACqM,SAAS,GAAGnD,oDAAK,CAACC,UAAU,CAAC2C,QAAQ,CAAC;MAC3C,IAAI,CAACQ,gBAAgB,CAAC,IAAI,CAACF,QAAQ,CAACjH,UAAU,CAAC,CAAC,CAAC;MACjD;MACA,IAAI,CAACiH,QAAQ,CAACvL,UAAU,CAAC,CAAC;MAC1B,IAAI,CAACuL,QAAQ,CAACpL,IAAI,CAAC,CAAC;MAEpB,IAAI,CAACE,UAAU,CAAC,CAAC;IACrB;EAAC;IAAAP,GAAA;IAAAC,KAAA,EAED,SAAA0L,gBAAgBA,CAACC,aAAa,EAAE;MAC5B,IAAI,CAACF,SAAS,CAACxR,cAAc,CAAC2R,WAAW,GAAGD,aAAa;MACzD,IAAME,iBAAiB,GAAG,IAAI,CAACJ,SAAS,CAACxR,cAAc,CAAC6R,OAAO,CAAC,GAAG,CAAC;MACpE,IAAID,iBAAiB,EAAE;QACnBA,iBAAiB,CAACE,IAAI,GAAG,kFAAkF;QAC3GF,iBAAiB,CAACvS,KAAK,GAAG,6BAA6B;MAC3D;IACJ;EAAC;IAAAyG,GAAA;IAAAC,KAAA,EAED,SAAAmL,mBAAmBA,CAAA,EAAG;MAAA,IAAA9K,KAAA;MAClB;MACA,IAAI,CAAC4K,WAAW,CAACe,SAAS,GAAG,EAAE;MAC/B,IAAM3S,SAAS,GAAGiP,oDAAK,CAACqC,QAAQ,CAAC,CAAC,GAAGI,yDAAS,CAAChR,GAAG,GAAGgR,yDAAS,CAACM,IAAI;MAEnEhS,SAAS,CAAC4S,OAAO,CAAC,UAACC,KAAK,EAAEC,KAAK,EAAK;QAChC,IAAMC,MAAM,GAAGlB,QAAQ,CAACmB,aAAa,CAAC,QAAQ,CAAC;QAC/CD,MAAM,CAACpM,KAAK,WAAAT,MAAA,CAAW4M,KAAK,CAAE;QAC9BC,MAAM,CAAChF,IAAI,aAAA7H,MAAA,CAAa2M,KAAK,CAAC5S,KAAK,IAAI4S,KAAK,CAAC3S,WAAW,CAAE;QAC1D,IAAI4S,KAAK,KAAK,CAAC,EAAEC,MAAM,CAACE,QAAQ,GAAG,IAAI,CAAC,CAAC;QACzCjM,KAAI,CAAC4K,WAAW,CAACsB,WAAW,CAACH,MAAM,CAAC;MACxC,CAAC,CAAC;IACN;EAAC;IAAArM,GAAA;IAAAC,KAAA,EAED,SAAAM,UAAUA,CAAA,EAAG;MAAA,IAAAkM,MAAA;MACT;MACA,IAAI,CAACf,SAAS,CAAC/C,WAAW,CAACzE,gBAAgB,CAAC,OAAO,EAAE;QAAA,OAAMuI,MAAI,CAACC,aAAa,CAAC,CAAC;MAAA,EAAC;MAChF,IAAI,CAAChB,SAAS,CAAC9C,UAAU,CAAC1E,gBAAgB,CAAC,OAAO,EAAE;QAAA,OAAMuI,MAAI,CAACE,MAAM,CAAC,CAAC;MAAA,EAAC;MACxE,IAAI,CAACjB,SAAS,CAAC7C,aAAa,CAAC3E,gBAAgB,CAAC,OAAO,EAAE;QAAA,OAAMuI,MAAI,CAACG,eAAe,CAAC,CAAC;MAAA,EAAC;MACpF,IAAI,CAAClB,SAAS,CAAC5C,WAAW,CAAC5E,gBAAgB,CAAC,OAAO,EAAE;QAAA,OAAMuI,MAAI,CAACI,WAAW,CAAC,CAAC;MAAA,EAAC;MAC9E,IAAI,CAACnB,SAAS,CAAC3C,QAAQ,CAAC7E,gBAAgB,CAAC,OAAO,EAAE;QAAA,OAAMuI,MAAI,CAACK,YAAY,CAAC,CAAC;MAAA,EAAC;MAC5E,IAAI,CAACpB,SAAS,CAACpC,cAAc,CAACpF,gBAAgB,CAAC,QAAQ,EAAE;QAAA,OAAMuI,MAAI,CAACM,mBAAmB,CAAC,CAAC;MAAA,EAAC;MAC1F;MACA,IAAI,CAACrB,SAAS,CAACtC,UAAU,CAAClF,gBAAgB,CAAC,OAAO,EAAE;QAAA,OAAMuI,MAAI,CAACO,YAAY,CAAC,CAAC;MAAA,EAAC;MAC9E,IAAI,CAACtB,SAAS,CAACrC,UAAU,CAACnF,gBAAgB,CAAC,OAAO,EAAE;QAAA,OAAMuI,MAAI,CAACQ,UAAU,CAAC,CAAC;MAAA,EAAC;MAC5E;MACA,IAAI,CAACvB,SAAS,CAACxQ,YAAY,CAACgJ,gBAAgB,CAAC,QAAQ,EAAE;QAAA,OAAMuI,MAAI,CAACS,eAAe,CAAC,CAAC;MAAA,EAAC;MACpF,IAAI,CAACxB,SAAS,CAACvQ,YAAY,CAAC+I,gBAAgB,CAAC,QAAQ,EAAE;QAAA,OAAMuI,MAAI,CAACU,eAAe,CAAC,CAAC;MAAA,EAAC;MACpF,IAAI,CAACzB,SAAS,CAACnC,qBAAqB,CAACrF,gBAAgB,CAAC,QAAQ,EAAE;QAAA,OAAMuI,MAAI,CAACW,qBAAqB,CAAC,CAAC;MAAA,EAAC;MACnG,IAAI,CAAC1B,SAAS,CAAClC,qBAAqB,CAACtF,gBAAgB,CAAC,QAAQ,EAAE;QAAA,OAAMuI,MAAI,CAACY,qBAAqB,CAAC,CAAC;MAAA,EAAC;MACnG,IAAI,CAAC3B,SAAS,CAACzQ,eAAe,CAACiJ,gBAAgB,CAAC,QAAQ,EAAE;QAAA,OAAMuI,MAAI,CAACa,mBAAmB,CAAC,CAAC;MAAA,EAAC;MAC3F;MACA,IAAI,CAAC5B,SAAS,CAAC1C,aAAa,CAAC9E,gBAAgB,CAAC,OAAO,EAAE;QAAA,OAAMuI,MAAI,CAACc,SAAS,CAAC,CAAC;MAAA,EAAC;MAC9E;MACA,IAAI,CAACrC,WAAW,CAAChH,gBAAgB,CAAC,QAAQ,EAAE;QAAA,OAAMuI,MAAI,CAACe,WAAW,CAAC,CAAC;MAAA,EAAC;;MAErE;MACA,IAAI,CAAC/B,QAAQ,CAAC5L,WAAW,CAACqE,gBAAgB,CAAC3I,wDAAS,CAACI,eAAe,EAAE,UAACmI,KAAK;QAAA,OAAK2I,MAAI,CAACgB,cAAc,CAAC3J,KAAK,CAAC5B,MAAM,CAAC;MAAA,EAAC;MACnH,IAAI,CAACuJ,QAAQ,CAAC5L,WAAW,CAACqE,gBAAgB,CAAC3I,wDAAS,CAACK,eAAe,EAAE,UAACkI,KAAK;QAAA,OAAK2I,MAAI,CAACiB,eAAe,CAACvG,wDAAS,CAACpM,OAAO,CAACM,kBAAkB,EAAEyI,KAAK,CAAC5B,MAAM,CAAC;MAAA,EAAC;MAC1J,IAAI,CAACuJ,QAAQ,CAAC5L,WAAW,CAACqE,gBAAgB,CAAC3I,wDAAS,CAACM,eAAe,EAAE,UAACiI,KAAK;QAAA,OAAK2I,MAAI,CAACiB,eAAe,CAACvG,wDAAS,CAACpM,OAAO,CAACK,kBAAkB,EAAE0I,KAAK,CAAC5B,MAAM,CAAC;MAAA,EAAC;MAC1J,IAAI,CAACuJ,QAAQ,CAAC5L,WAAW,CAACqE,gBAAgB,CAAC3I,wDAAS,CAACN,eAAe,EAAE,UAAC6I,KAAK;QAAA,OAAK2I,MAAI,CAACiB,eAAe,CAACvG,wDAAS,CAACpM,OAAO,CAACE,eAAe,EAAE6I,KAAK,CAAC5B,MAAM,CAAC;MAAA,EAAC;MAEvJ,IAAI,CAACuJ,QAAQ,CAAC5L,WAAW,CAACqE,gBAAgB,CAAC3I,wDAAS,CAACC,aAAa,EAAE,UAACsI,KAAK;QAAA,OAAK2I,MAAI,CAACkB,UAAU,CAAC7J,KAAK,CAAC5B,MAAM,CAAC;MAAA,EAAC;MAC7G,IAAI,CAACuJ,QAAQ,CAAC5L,WAAW,CAACqE,gBAAgB,CAAC3I,wDAAS,CAACE,KAAK,EAAE,UAACqI,KAAK,EAAK;QACnEuE,OAAO,CAACvH,KAAK,CAAC,kCAAkC,EAAEgD,KAAK,CAAC;MAC5D,CAAC,CAAC;MACF,IAAI,CAAC2H,QAAQ,CAAC5L,WAAW,CAACqE,gBAAgB,CAAC3I,wDAAS,CAACG,OAAO,EAAE,UAACoI,KAAK,EAAK;QACrEuE,OAAO,CAACtG,IAAI,CAAC,oCAAoC,EAAE+B,KAAK,CAAC;MAC7D,CAAC,CAAC;IACN;EAAC;IAAA9D,GAAA;IAAAC,KAAA,EAED,SAAA2N,OAAOA,CAAA,EAAG;MACN,IAAG,IAAI,CAAChO,MAAM,EAAE;QACZ,IAAI,CAACA,MAAM,CAACgO,OAAO,CAAC,CAAC;MACzB;IACJ;EAAC;IAAA5N,GAAA;IAAAC,KAAA,EAED,SAAA2M,eAAeA,CAAA,EAAG;MACd,IAAI,CAACnB,QAAQ,CAACnG,QAAQ,CAAC,CAAC,GAAG,IAAI,CAACmG,QAAQ,CAAChH,IAAI,CAAC,CAAC,GAAG,IAAI,CAACgH,QAAQ,CAAC/G,KAAK,CAAC,CAAC;MACvE,IAAI,CAACmJ,kBAAkB,CAAC1G,wDAAS,CAAChN,QAAQ,CAACG,SAAS,CAAC;IACzD;EAAC;IAAA0F,GAAA;IAAAC,KAAA,EAED,SAAA+M,YAAYA,CAAA,EAAG;MACX,IAAI,CAACvB,QAAQ,CAAChG,SAAS,CAACqI,UAAU,CAAC,IAAI,CAACpC,SAAS,CAACtC,UAAU,CAACnJ,KAAK,CAAC,CAAC;MACpE,IAAI,CAAC4N,kBAAkB,CAAC1G,wDAAS,CAACtM,QAAQ,CAACC,MAAM,CAAC;IACtD;EAAC;IAAAkF,GAAA;IAAAC,KAAA,EAED,SAAAgN,UAAUA,CAAA,EAAG;MACT,IAAI,CAACxB,QAAQ,CAAClG,MAAM,CAAC,CAAC,GAAG,IAAI,CAACkG,QAAQ,CAACrG,MAAM,CAAC,CAAC,GAAG,IAAI,CAACqG,QAAQ,CAACtG,IAAI,CAAC,CAAC;MACtE,IAAI,CAAC0I,kBAAkB,CAAC1G,wDAAS,CAACtM,QAAQ,CAACC,MAAM,CAAC;IACtD;EAAC;IAAAkF,GAAA;IAAAC,KAAA,EAED,SAAAyM,aAAaA,CAAA,EAAG;MACZ,IAAI,CAACjB,QAAQ,CAAC5G,IAAI,CAAC,CAAC,CAAC;MACrB,IAAI,CAAC6G,SAAS,CAAC1C,aAAa,CAAC/I,KAAK,GAAG,CAAC;MACtC;MACA,IAAI,CAACyL,SAAS,CAAC1C,aAAa,CAAC+E,KAAK,CAACC,WAAW,CAAC,YAAY,EAAE,IAAI,CAAC;MAClE,IAAI,CAACvC,QAAQ,CAAChH,IAAI,CAAC,CAAC;MACpB,IAAI,CAACoJ,kBAAkB,CAAC1G,wDAAS,CAAChN,QAAQ,CAACG,SAAS,CAAC;IACzD;EAAC;IAAA0F,GAAA;IAAAC,KAAA,EAED,SAAA0M,MAAMA,CAAA,EAAG;MACL,IAAMxC,WAAW,GAAG,IAAI,CAACsB,QAAQ,CAAC3G,QAAQ,CAAC,CAAC;MAC5C,IAAI,CAAC2G,QAAQ,CAAC5G,IAAI,CAAC+E,IAAI,CAACqE,GAAG,CAAC,CAAC,EAAE9D,WAAW,GAAG,EAAE,CAAC,CAAC;IACrD;EAAC;IAAAnK,GAAA;IAAAC,KAAA,EAED,SAAA4M,WAAWA,CAAA,EAAG;MACV,IAAM1C,WAAW,GAAG,IAAI,CAACsB,QAAQ,CAAC3G,QAAQ,CAAC,CAAC;MAC5C,IAAM4B,QAAQ,GAAG,IAAI,CAAC+E,QAAQ,CAAC/E,QAAQ,CAAC,CAAC;MACzC,IAAI,CAAC+E,QAAQ,CAAC5G,IAAI,CAAC+E,IAAI,CAACsE,GAAG,CAACxH,QAAQ,EAAEyD,WAAW,GAAG,EAAE,CAAC,CAAC;IAC5D;EAAC;IAAAnK,GAAA;IAAAC,KAAA,EAED,SAAA6M,YAAYA,CAAA,EAAG;MACX,IAAI,CAACrB,QAAQ,CAAC7G,IAAI,CAAC,CAAC;MACpB,IAAI,CAACiJ,kBAAkB,CAAC1G,wDAAS,CAAChN,QAAQ,CAACG,SAAS,CAAC;IACzD;EAAC;IAAA0F,GAAA;IAAAC,KAAA,EAED,SAAA8M,mBAAmBA,CAAA,EAAG;MAClB,IAAMoB,KAAK,GAAG,IAAI,CAACzC,SAAS,CAACpC,cAAc,CAACrJ,KAAK,GAAG6N,UAAU,CAAC,IAAI,CAACpC,SAAS,CAACpC,cAAc,CAACrJ,KAAK,CAAC,GAAG,CAAC;MACvG,IAAI,CAACwL,QAAQ,CAAC9F,eAAe,CAACwI,KAAK,CAAC;IACxC;EAAC;IAAAnO,GAAA;IAAAC,KAAA,EAED,SAAAiN,eAAeA,CAAA,EAAG;MACd,IAAI,CAACxN,MAAM,CAACkD,IAAI,iCAAApD,MAAA,CAAiC,IAAI,CAACkM,SAAS,CAACxQ,YAAY,CAAC+E,KAAK,CAAE,CAAC;MACrF;MACA,IAAI,CAACwL,QAAQ,CAAC3F,aAAa,CAAC;QAACC,EAAE,EAAE,IAAI,CAAC2F,SAAS,CAACxQ,YAAY,CAAC+E;MAAK,CAAC,CAAC;IACxE;EAAC;IAAAD,GAAA;IAAAC,KAAA,EAED,SAAAmN,qBAAqBA,CAAA,EAAG;MACpB,IAAI,CAAC1N,MAAM,CAACkD,IAAI,wCAAApD,MAAA,CAAwC,IAAI,CAACkM,SAAS,CAACnC,qBAAqB,CAACtJ,KAAK,CAAE,CAAC;MACrG,IAAI,CAACL,MAAM,CAACsG,kBAAkB,CAAC;QAACH,EAAE,EAAE,IAAI,CAAC2F,SAAS,CAACnC,qBAAqB,CAACtJ;MAAK,CAAC,CAAC;IACpF;EAAC;IAAAD,GAAA;IAAAC,KAAA,EAED,SAAAkN,eAAeA,CAAA,EAAG;MACd,IAAI,CAACzN,MAAM,CAACkD,IAAI,6BAAApD,MAAA,CAA6B,IAAI,CAACkM,SAAS,CAACvQ,YAAY,CAAC8E,KAAK,CAAE,CAAC;MACjF;MACA,IAAI,CAACwL,QAAQ,CAACtF,aAAa,CAAC;QAACJ,EAAE,EAAE,IAAI,CAAC2F,SAAS,CAACvQ,YAAY,CAAC8E;MAAK,CAAC,CAAC;IACxE;EAAC;IAAAD,GAAA;IAAAC,KAAA,EAED,SAAAoN,qBAAqBA,CAAA,EAAG;MACpB,IAAI,CAAC3N,MAAM,CAACkD,IAAI,wCAAApD,MAAA,CAAwC,IAAI,CAACkM,SAAS,CAAClC,qBAAqB,CAACvJ,KAAK,CAAE,CAAC;MACrG,IAAI,CAACL,MAAM,CAACwG,kBAAkB,CAAC;QAACL,EAAE,EAAE,IAAI,CAAC2F,SAAS,CAAClC,qBAAqB,CAACvJ;MAAK,CAAC,CAAC;IACpF;EAAC;IAAAD,GAAA;IAAAC,KAAA,EAED,SAAAqN,mBAAmBA,CAAA,EAAG;MAClB,IAAI,CAAC5N,MAAM,CAACkD,IAAI,gCAAApD,MAAA,CAAgC,IAAI,CAACkM,SAAS,CAACzQ,eAAe,CAACgF,KAAK,CAAE,CAAC;MACvF;MACA,IAAI,CAACwL,QAAQ,CAACpF,WAAW,CAAC;QAACN,EAAE,EAAE,IAAI,CAAC2F,SAAS,CAACzQ,eAAe,CAACgF;MAAK,CAAC,CAAC;IACzE;EAAC;IAAAD,GAAA;IAAAC,KAAA,EAGD,SAAAwN,cAAcA,CAAA,EAAqC;MAAA,IAApC/K,GAAG,GAAAxD,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG;QAAE4F,QAAQ,EAAE,CAAC;QAAE4B,QAAQ,EAAE;MAAE,CAAC;MAC7C,IAAIhE,GAAG,IAAIA,GAAG,CAACoC,QAAQ,KAAK1F,SAAS,IAAIsD,GAAG,CAACgE,QAAQ,KAAKtH,SAAS,EAAE;QACjE,IAAI,CAACsM,SAAS,CAACzC,SAAS,CAAC4C,WAAW,GAAGtD,oDAAK,CAACkB,UAAU,CAAC/G,GAAG,CAACoC,QAAQ,CAAC;QACrE,IAAI,CAAC4G,SAAS,CAACvC,OAAO,CAAC0C,WAAW,GAAGtD,oDAAK,CAACkB,UAAU,CAAC/G,GAAG,CAACgE,QAAQ,CAAC;QAEnE,IAAIhE,GAAG,CAACgE,QAAQ,GAAG,CAAC,EAAE;UAClB,IAAM0H,eAAe,GAAG7F,oDAAK,CAAC2B,cAAc,CAACxH,GAAG,CAACoC,QAAQ,EAAEpC,GAAG,CAACgE,QAAQ,CAAC;UACxE,IAAI,CAACgF,SAAS,CAAC1C,aAAa,CAAC/I,KAAK,GAAGmO,eAAe;UACpD;UACA,IAAI,CAAC1C,SAAS,CAAC1C,aAAa,CAAC+E,KAAK,CAACC,WAAW,CAAC,YAAY,EAAEI,eAAe,GAAG,GAAG,CAAC;QACvF;MACJ;IACJ;EAAC;IAAApO,GAAA;IAAAC,KAAA,EAED,SAAAsN,SAASA,CAAA,EAAG;MACR,IAAM7G,QAAQ,GAAG,IAAI,CAAC+E,QAAQ,CAAC/E,QAAQ,CAAC,CAAC;MACzC,IAAIA,QAAQ,GAAG,CAAC,EAAE;QACd,IAAM2H,QAAQ,GAAG9F,oDAAK,CAAC+B,oBAAoB,CAAC,IAAI,CAACoB,SAAS,CAAC1C,aAAa,CAAC/I,KAAK,EAAEyG,QAAQ,CAAC;QACzF,IAAI,CAAC+E,QAAQ,CAAC5G,IAAI,CAACwJ,QAAQ,CAAC;MAChC;IACJ;EAAC;IAAArO,GAAA;IAAAC,KAAA,EAED,SAAA0N,UAAUA,CAAC7L,KAAK,EAAE;MACd,IAAI,CAACpC,MAAM,CAACkD,IAAI,CAAC,0BAA0B,EAAEd,KAAK,CAAC;MACnD,QAAQA,KAAK;QACT,KAAKhG,uDAAQ,CAACC,OAAO;QACrB,KAAKD,uDAAQ,CAACK,SAAS;UACnB;UACA;QACJ,KAAKL,uDAAQ,CAACE,MAAM;UAChB;UACA;QACJ,KAAKF,uDAAQ,CAACG,OAAO;QACrB,KAAKH,uDAAQ,CAACI,MAAM;UAChB,IAAI,CAAC2R,kBAAkB,CAAC1G,wDAAS,CAAChN,QAAQ,CAACG,SAAS,CAAC;UACrD;QACJ,KAAKwB,uDAAQ,CAACM,OAAO;UACjB,IAAI,CAACyR,kBAAkB,CAAC1G,wDAAS,CAAChN,QAAQ,CAACG,SAAS,CAAC;UACrD;QACJ,KAAKwB,uDAAQ,CAACO,OAAO;UACjB,IAAI,CAACqP,SAAS,CAAC1C,aAAa,CAAC/I,KAAK,GAAG,CAAC;UACtC;UACA,IAAI,CAACyL,SAAS,CAAC1C,aAAa,CAAC+E,KAAK,CAACC,WAAW,CAAC,YAAY,EAAE,IAAI,CAAC;UAClE,IAAI,CAACtC,SAAS,CAACzC,SAAS,CAAC4C,WAAW,GAAG,OAAO;UAC9C,IAAI,CAACH,SAAS,CAACvC,OAAO,CAAC0C,WAAW,GAAG,OAAO;UAC5C,IAAI,CAACgC,kBAAkB,CAAC1G,wDAAS,CAAChN,QAAQ,CAACG,SAAS,CAAC;UACrD;QACJ;UACI,IAAI,CAACoF,MAAM,CAACoB,KAAK,CAAC,6BAA6B,EAAEgB,KAAK,CAAC;UACvD;MACR;IACJ;EAAC;IAAA9B,GAAA;IAAAC,KAAA,EAED,SAAAyN,eAAeA,CAACY,YAAY,EAAEC,SAAS,EAAE;MACrC,IAAIC,cAAc,GAAG,IAAI;MACzB,QAAQF,YAAY;QAChB,KAAKnH,wDAAS,CAACpM,OAAO,CAACG,YAAY;UAC/BsT,cAAc,GAAG,IAAI,CAAC9C,SAAS,CAACxQ,YAAY;UAC5C;QACJ,KAAKiM,wDAAS,CAACpM,OAAO,CAACI,YAAY;UAC/BqT,cAAc,GAAG,IAAI,CAAC9C,SAAS,CAACvQ,YAAY;UAC5C;QACJ,KAAKgM,wDAAS,CAACpM,OAAO,CAACK,kBAAkB;UACrCoT,cAAc,GAAG,IAAI,CAAC9C,SAAS,CAACnC,qBAAqB;UACrD;QACJ,KAAKpC,wDAAS,CAACpM,OAAO,CAACM,kBAAkB;UACrCmT,cAAc,GAAG,IAAI,CAAC9C,SAAS,CAAClC,qBAAqB;UACrD;QACJ,KAAKrC,wDAAS,CAACpM,OAAO,CAACE,eAAe;UAClCuT,cAAc,GAAG,IAAI,CAAC9C,SAAS,CAACzQ,eAAe;UAC/C;QACJ;UACI;MACR;MAEA,IAAGuT,cAAc,EAAE;QACf,IAAID,SAAS,IAAIA,SAAS,CAACpP,MAAM,EAAE;UAC/BqP,cAAc,CAACC,MAAM,GAAG,KAAK;UAC7BD,cAAc,CAACvC,SAAS,GAAG,EAAE;UAC7BsC,SAAS,CAACrC,OAAO,CAAC,UAACwC,KAAK,EAAEtC,KAAK,EAAK;YAChC,IAAMC,MAAM,GAAGlB,QAAQ,CAACmB,aAAa,CAAC,QAAQ,CAAC;YAC/CD,MAAM,CAACpM,KAAK,GAAGyO,KAAK,CAAC3I,EAAE;YACvBsG,MAAM,CAAChF,IAAI,MAAA7H,MAAA,CAAM+I,oDAAK,CAACmC,aAAa,CAACgE,KAAK,CAACjE,OAAO,CAAC,SAAAjL,MAAA,CAAMkP,KAAK,CAACC,KAAK,CAAE;YACtEH,cAAc,CAAChC,WAAW,CAACH,MAAM,CAAC;UACtC,CAAC,CAAC;QACN,CAAC,MAAM;UACHmC,cAAc,CAACC,MAAM,GAAG,IAAI;UAC5BD,cAAc,CAACvC,SAAS,GAAG,EAAE;UAC7B,IAAMI,MAAM,GAAGlB,QAAQ,CAACmB,aAAa,CAAC,QAAQ,CAAC;UAC/CD,MAAM,CAAChF,IAAI,kBAAkB;UAC7BmH,cAAc,CAAChC,WAAW,CAACH,MAAM,CAAC;UAClC,IAAI,CAAC3M,MAAM,CAACoB,KAAK,CAAC,yBAAyB,CAAC;QAChD;MACJ,CAAC,MAAM;QACH,IAAI,CAACpB,MAAM,CAACoB,KAAK,CAAC,kCAAkC,EAAEwN,YAAY,CAAC;MACvE;IACJ;EAAC;IAAAtO,GAAA;IAAAC,KAAA,EAED,SAAA4N,kBAAkBA,CAACe,UAAU,EAAE;MAC3B,QAAQA,UAAU;QACd,KAAKzH,wDAAS,CAAChN,QAAQ,CAACG,SAAS;UAC7B,IAAI,CAACoR,SAAS,CAAC7C,aAAa,CAACK,aAAa,CAAC,GAAG,CAAC,CAAC2F,SAAS,CAACC,MAAM,CAAC,IAAI,CAACrD,QAAQ,CAACnG,QAAQ,CAAC,CAAC,GAAG,UAAU,GAAG,SAAS,CAAC;UACnH,IAAI,CAACoG,SAAS,CAAC7C,aAAa,CAACK,aAAa,CAAC,GAAG,CAAC,CAAC2F,SAAS,CAACE,GAAG,CAAC,IAAI,CAACtD,QAAQ,CAACnG,QAAQ,CAAC,CAAC,GAAG,SAAS,GAAG,UAAU,CAAC;UAChH;QACJ,KAAK6B,wDAAS,CAACtM,QAAQ,CAACC,MAAM;UAC1B,IAAI,CAAC4Q,SAAS,CAACrC,UAAU,CAACH,aAAa,CAAC,GAAG,CAAC,CAAC2F,SAAS,CAACC,MAAM,CAAC,IAAI,CAACrD,QAAQ,CAAClG,MAAM,CAAC,CAAC,GAAG,cAAc,GAAG,gBAAgB,CAAC;UACzH,IAAI,CAACmG,SAAS,CAACrC,UAAU,CAACH,aAAa,CAAC,GAAG,CAAC,CAAC2F,SAAS,CAACE,GAAG,CAAC,IAAI,CAACtD,QAAQ,CAAClG,MAAM,CAAC,CAAC,GAAG,gBAAgB,GAAG,cAAc,CAAC;UACtH;QACJ;UACI;MACR;IACJ;EAAC;IAAAvF,GAAA;IAAAC,KAAA,EAED,SAAAuN,WAAWA,CAAA,EAAG;MAAA,IAAAwB,MAAA;MACV,IAAMC,aAAa,GAAG,IAAI,CAAC/D,WAAW,CAACjL,KAAK;MAC5C,IAAI,CAACgP,aAAa,EAAE;MAEpB,IAAAC,oBAAA,GAAyBD,aAAa,CAAChO,KAAK,CAAC,GAAG,CAAC;QAAAkO,qBAAA,GAAAhO,cAAA,CAAA+N,oBAAA;QAA1C7M,IAAI,GAAA8M,qBAAA;QAAEC,QAAQ,GAAAD,qBAAA;MACrB,IAAM/C,KAAK,GAAGiD,QAAQ,CAACD,QAAQ,EAAE,EAAE,CAAC;MACpC,IAAM9V,SAAS,GAAGiP,oDAAK,CAACqC,QAAQ,CAAC,CAAC,GAAGI,yDAAS,CAAChR,GAAG,GAAGgR,yDAAS,CAACM,IAAI;MACnE,IAAI,CAACE,MAAM,GAAGlS,SAAS,CAAC8S,KAAK,CAAC;MAE9B,IAAI,CAAC,IAAI,CAACZ,MAAM,EAAE;QACdnD,OAAO,CAACtG,IAAI,CAAC,8BAA8B,EAAEM,IAAI,CAAC;QAClD;MACJ;MACA,IAAG,IAAI,CAACzC,MAAM,EAAE;QACZ,IAAI,CAACA,MAAM,CAACgF,IAAI,CAAC,CAAC;QAClB,IAAI,CAACgJ,OAAO,CAAC,CAAC;MAClB;MACA0B,UAAU,CAAC,YAAM;QACbN,MAAI,CAAC3D,kBAAkB,CAAC,CAAC;MAC7B,CAAC,EAAE,IAAI,CAAC;IACZ;EAAC;AAAA;AAGLF,QAAQ,CAACjH,gBAAgB,CAAC,kBAAkB,EAAE,YAAM;EAChD,IAAI+G,GAAG,CAAC,CAAC;;EAET;EACA,IAAMsE,aAAa,GAAGpE,QAAQ,CAACzC,cAAc,CAAC,gBAAgB,CAAC;EAC/D,IAAM8G,SAAS,GAAGrE,QAAQ,CAACjC,aAAa,CAAC,YAAY,CAAC;EAEtDuG,kBAAkB,CAACF,aAAa,EAAEC,SAAS,CAAC;;EAE5C;EACA,IAAME,cAAc,GAAGvE,QAAQ,CAACzC,cAAc,CAAC,UAAU,CAAC;EAC1D,IAAMiH,OAAO,GAAGxE,QAAQ,CAACzC,cAAc,CAAC,kBAAkB,CAAC;EAE3DkH,oBAAoB,CAACF,cAAc,EAAEC,OAAO,CAAC;;EAE7C;EACA,IAAME,WAAW,GAAG1E,QAAQ,CAAC2E,gBAAgB,CAAC,cAAc,CAAC;EAE7DD,WAAW,CAAC3D,OAAO,CAAC,UAAA6D,IAAI,EAAI;IACxBA,IAAI,CAAC7L,gBAAgB,CAAC,OAAO,EAAE,YAAM;MACjC,IAAM8L,SAAS,GAAGD,IAAI,CAACE,OAAO,CAACC,OAAO,KAAK,MAAM;MACjD,IAAIF,SAAS,EAAE;QACXD,IAAI,CAACI,SAAS,GAAG,6BAA6B;QAC9CJ,IAAI,CAACE,OAAO,CAACC,OAAO,GAAG,OAAO;MAClC,CAAC,MAAM;QACHH,IAAI,CAACI,SAAS,GAAG,uBAAuB;QACxCJ,IAAI,CAACE,OAAO,CAACC,OAAO,GAAG,MAAM;MACjC;IACJ,CAAC,CAAC;EACN,CAAC,CAAC;AACN,CAAC,CAAC;AAEF,SAASN,oBAAoBA,CAACF,cAAc,EAAEC,OAAO,EAAE;EACnD,SAASS,aAAaA,CAAA,EAAG;IACrB,IAAMnQ,KAAK,GAAGyP,cAAc,CAACzP,KAAK;IAClC,IAAMoQ,UAAU,GAAGpQ,KAAK,GAAG,GAAG;IAC9B0P,OAAO,CAAC9D,WAAW,GAAGwE,UAAU;;IAEhC;IACAX,cAAc,CAAC3B,KAAK,CAACC,WAAW,CAAC,YAAY,EAAEqC,UAAU,CAAC;;IAE1D;IACA,IAAMC,UAAU,GAAGZ,cAAc,CAACa,qBAAqB,CAAC,CAAC;IACzD,IAAMC,WAAW,GAAGF,UAAU,CAACG,KAAK;IACpC,IAAMC,aAAa,GAAIzQ,KAAK,GAAG,GAAG,GAAIuQ,WAAW;IACjDb,OAAO,CAAC5B,KAAK,CAAC4C,IAAI,GAAGD,aAAa,GAAG,IAAI;EAC7C;EAEAhB,cAAc,CAACxL,gBAAgB,CAAC,OAAO,EAAE,YAAM;IAC3CkM,aAAa,CAAC,CAAC;IACfT,OAAO,CAAC5B,KAAK,CAAC6C,OAAO,GAAG,GAAG;EAC/B,CAAC,CAAC;EAEFlB,cAAc,CAACxL,gBAAgB,CAAC,WAAW,EAAE,YAAM;IAC/CkM,aAAa,CAAC,CAAC;IACfT,OAAO,CAAC5B,KAAK,CAAC6C,OAAO,GAAG,GAAG;EAC/B,CAAC,CAAC;EAEFlB,cAAc,CAACxL,gBAAgB,CAAC,UAAU,EAAE,YAAM;IAC9CyL,OAAO,CAAC5B,KAAK,CAAC6C,OAAO,GAAG,GAAG;EAC/B,CAAC,CAAC;;EAEF;EACAR,aAAa,CAAC,CAAC;AACnB;AAEA,SAASX,kBAAkBA,CAACF,aAAa,EAAEC,SAAS,EAAE;EAClDD,aAAa,CAACrL,gBAAgB,CAAC,OAAO,EAAE,YAAM;IAC1CsL,SAAS,CAACX,SAAS,CAACgC,MAAM,CAAC,aAAa,CAAC;EAC7C,CAAC,CAAC;AACN,C","sources":["webpack://ott_media_player/./config/assetInfo.js","webpack://ott_media_player/./css/style.css?ea78","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/add_class_name.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/add_text_track.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/browser_compatibility_types.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/browser_detection.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/browser_version.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/can_patch_isobmff.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/can_rely_on_request_media_key_system_access.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/can_rely_on_video_visibility_and_size.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/can_reuse_media_keys.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/can_seek_directly_after_loaded_metadata.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/change_source_buffer_type.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/clear_element_src.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/eme/close_session.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/eme/constants.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/eme/custom_key_system_access.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/eme/custom_media_keys/ie11_media_keys.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/eme/custom_media_keys/moz_media_keys_constructor.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/eme/custom_media_keys/ms_media_keys_constructor.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/eme/custom_media_keys/old_webkit_media_keys.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/eme/custom_media_keys/webkit_media_keys.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/eme/custom_media_keys/webkit_media_keys_constructor.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/eme/eme-api-implementation.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/eme/generate_key_request.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/eme/get_init_data.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/eme/get_uuid_kid_from_keystatus_kid.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/eme/get_webkit_fairplay_initdata.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/eme/index.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/eme/load_session.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/eme/set_media_keys.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/enable_audio_track.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/event_listeners.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/generate_init_data.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/get_start_date.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/has_issues_with_high_media_source_duration.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/has_mse_in_worker.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/has_worker_api.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/is_codec_supported.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/is_debug_mode_enabled.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/is_seeking_approximate.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/is_vtt_cue.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/make_vtt_cue.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/may_media_element_fail_on_undecipherable_data.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/on_height_width_change.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/patch_webkit_source_buffer.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/remove_cue.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/should_await_set_media_keys.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/should_favour_custom_safari_EME.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/should_reload_media_source_on_decipherability_update.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/should_renew_media_key_system_access.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/should_unset_media_keys.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/should_validate_metadata.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/should_wait_for_data_before_loaded.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/compat/should_wait_for_have_enough_data.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/config.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/adaptive/adaptive_representation_selector.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/adaptive/buffer_based_chooser.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/adaptive/guess_based_chooser.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/adaptive/index.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/adaptive/network_analyzer.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/adaptive/utils/bandwidth_estimator.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/adaptive/utils/ewma.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/adaptive/utils/filter_by_bitrate.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/adaptive/utils/filter_by_resolution.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/adaptive/utils/get_buffer_levels.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/adaptive/utils/last_estimate_storage.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/adaptive/utils/pending_requests_store.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/adaptive/utils/representation_score_calculator.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/adaptive/utils/select_optimal_representation.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/cmcd/cmcd_data_builder.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/cmcd/index.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/fetchers/cdn_prioritizer.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/fetchers/manifest/index.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/fetchers/manifest/manifest_fetcher.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/fetchers/segment/index.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/fetchers/segment/initialization_segment_cache.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/fetchers/segment/prioritized_segment_fetcher.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/fetchers/segment/segment_fetcher.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/fetchers/segment/segment_queue.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/fetchers/segment/segment_queue_creator.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/fetchers/segment/task_prioritizer.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/fetchers/thumbnails/index.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/fetchers/thumbnails/thumbnail_fetcher.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/fetchers/utils/error_selector.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/fetchers/utils/schedule_request.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/main/common/FreezeResolver.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/main/common/content_time_boundaries_observer.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/main/common/create_content_time_boundaries_observer.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/main/common/get_buffered_data_per_media_buffer.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/main/common/get_thumbnail_data.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/main/common/synchronize_sinks_on_observation.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/segment_sinks/garbage_collector.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/segment_sinks/implementations/audio_video/audio_video_segment_sink.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/segment_sinks/implementations/audio_video/index.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/segment_sinks/implementations/text/index.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/segment_sinks/implementations/text/text_segment_sink.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/segment_sinks/implementations/types.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/segment_sinks/index.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/segment_sinks/inventory/buffered_history.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/segment_sinks/inventory/index.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/segment_sinks/inventory/segment_inventory.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/segment_sinks/inventory/utils.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/segment_sinks/segment_sinks_store.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/stream/adaptation/adaptation_stream.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/stream/adaptation/get_representations_switch_strategy.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/stream/adaptation/index.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/stream/index.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/stream/orchestrator/get_time_ranges_for_content.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/stream/orchestrator/index.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/stream/orchestrator/stream_orchestrator.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/stream/period/index.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/stream/period/period_stream.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/stream/period/utils/get_adaptation_switch_strategy.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/stream/representation/index.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/stream/representation/representation_stream.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/stream/representation/utils/append_segment_to_buffer.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/stream/representation/utils/check_for_discontinuity.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/stream/representation/utils/get_buffer_status.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/stream/representation/utils/get_needed_segments.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/stream/representation/utils/get_segment_priority.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/stream/representation/utils/push_init_segment.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/core/stream/representation/utils/push_media_segment.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/default_config.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/errors/custom_loader_error.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/errors/encrypted_media_error.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/errors/error_codes.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/errors/error_message.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/errors/format_error.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/errors/is_known_error.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/errors/media_error.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/errors/network_error.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/errors/other_error.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/errors/source_buffer_error.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/errors/worker_initialization_error.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/features/add_features.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/features/features_object.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/features/index.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/features/list/dash.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/features/list/directfile.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/features/list/eme.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/features/list/html_sami_parser.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/features/list/html_srt_parser.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/features/list/html_ttml_parser.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/features/list/html_vtt_parser.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/features/list/native_sami_parser.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/features/list/native_srt_parser.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/features/list/native_ttml_parser.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/features/list/native_vtt_parser.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/features/list/smooth.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/index.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/log.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/api/index.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/api/option_utils.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/api/public_api.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/api/utils.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/decrypt/clear_on_stop.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/decrypt/content_decryptor.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/decrypt/create_or_load_session.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/decrypt/create_session.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/decrypt/dispose_decryption_resources.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/decrypt/find_key_system.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/decrypt/get_key_system_configuration.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/decrypt/get_media_keys.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/decrypt/index.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/decrypt/init_media_keys.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/decrypt/session_events_listener.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/decrypt/set_server_certificate.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/decrypt/types.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/decrypt/utils/are_init_values_compatible.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/decrypt/utils/check_key_statuses.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/decrypt/utils/clean_old_loaded_sessions.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/decrypt/utils/clean_old_stored_persistent_info.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/decrypt/utils/get_drm_system_id.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/decrypt/utils/init_data_values_container.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/decrypt/utils/is_compatible_codec_supported.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/decrypt/utils/is_session_usable.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/decrypt/utils/key_id_comparison.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/decrypt/utils/key_session_record.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/decrypt/utils/loaded_sessions_store.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/decrypt/utils/media_keys_attacher.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/decrypt/utils/persistent_sessions_store.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/decrypt/utils/serializable_bytes.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/decrypt/utils/server_certificate_store.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/init/directfile_content_initializer.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/init/media_source_content_initializer.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/init/types.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/init/utils/create_core_playback_observer.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/init/utils/create_media_source.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/init/utils/get_initial_time.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/init/utils/get_loaded_reference.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/init/utils/initial_seek_and_play.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/init/utils/initialize_content_decryption.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/init/utils/main_thread_text_displayer_interface.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/init/utils/rebuffering_controller.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/init/utils/stream_events_emitter/are_same_stream_events.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/init/utils/stream_events_emitter/index.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/init/utils/stream_events_emitter/refresh_scheduled_events_list.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/init/utils/stream_events_emitter/stream_events_emitter.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/init/utils/throw_on_media_error.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/init/utils/update_manifest_codec_support.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/render_thumbnail.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/text_displayer/html/html_parsers.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/text_displayer/html/html_text_displayer.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/text_displayer/html/index.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/text_displayer/html/text_track_cues_store.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/text_displayer/html/update_proportional_elements.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/text_displayer/html/utils.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/text_displayer/manual_time_ranges.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/text_displayer/native/index.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/text_displayer/native/native_parsers.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/text_displayer/native/native_text_displayer.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/tracks_store/index.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/tracks_store/media_element_tracks_store.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/tracks_store/track_dispatcher.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/main_thread/tracks_store/tracks_store.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/manifest/classes/adaptation.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/manifest/classes/codec_support_cache.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/manifest/classes/index.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/manifest/classes/manifest.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/manifest/classes/period.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/manifest/classes/representation.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/manifest/classes/representation_index/static.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/manifest/classes/types.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/manifest/classes/update_period_in_place.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/manifest/classes/update_periods.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/manifest/classes/utils.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/manifest/utils.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/mse/main_media_source_interface.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/mse/utils/end_of_stream.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/mse/utils/media_source_duration_updater.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/containers/isobmff/constants.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/containers/isobmff/create_box.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/containers/isobmff/drm/playready.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/containers/isobmff/extract_complete_chunks.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/containers/isobmff/find_complete_box.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/containers/isobmff/get_box.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/containers/isobmff/read.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/containers/isobmff/take_pssh_out.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/containers/isobmff/utils.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/containers/matroska/utils.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/common/attach_trickmode_track.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/common/content_protection_parser.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/common/convert_supplemental_codecs.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/common/flatten_overlapping_periods.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/common/get_clock_offset.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/common/get_hdr_information.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/common/get_http_utc-timing_url.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/common/get_minimum_and_maximum_positions.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/common/get_periods_time_infos.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/common/index.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/common/indexes/base.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/common/indexes/get_init_segment.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/common/indexes/get_segments_from_timeline.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/common/indexes/list.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/common/indexes/template.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/common/indexes/timeline/construct_timeline_from_elements.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/common/indexes/timeline/construct_timeline_from_previous_timeline.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/common/indexes/timeline/convert_element_to_index_segment.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/common/indexes/timeline/find_first_common_start_time.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/common/indexes/timeline/index.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/common/indexes/timeline/parse_s_element.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/common/indexes/timeline/timeline_representation_index.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/common/indexes/tokens.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/common/indexes/utils.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/common/infer_adaptation_type.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/common/manifest_bounds_calculator.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/common/parse_adaptation_sets.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/common/parse_availability_start_time.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/common/parse_mpd.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/common/parse_periods.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/common/parse_representation_index.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/common/parse_representations.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/common/resolve_base_urls.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/native-parser/index.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/native-parser/node_parsers/AdaptationSet.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/native-parser/node_parsers/BaseURL.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/native-parser/node_parsers/ContentComponent.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/native-parser/node_parsers/ContentProtection.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/native-parser/node_parsers/EventStream.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/native-parser/node_parsers/Initialization.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/native-parser/node_parsers/MPD.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/native-parser/node_parsers/Period.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/native-parser/node_parsers/Representation.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/native-parser/node_parsers/SegmentBase.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/native-parser/node_parsers/SegmentList.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/native-parser/node_parsers/SegmentTemplate.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/native-parser/node_parsers/SegmentTimeline.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/native-parser/node_parsers/SegmentURL.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/native-parser/node_parsers/utils.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/dash/native-parser/parse_from_document.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/smooth/create_parser.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/smooth/get_codecs.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/smooth/index.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/smooth/parse_C_nodes.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/smooth/parse_protection_node.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/smooth/representation_index.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/smooth/shared_smooth_segment_timeline.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/smooth/utils/add_segment_infos.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/smooth/utils/parseBoolean.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/smooth/utils/reduceChildren.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/smooth/utils/tokens.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/utils/check_manifest_ids.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/utils/clear_timeline_from_position.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/utils/get_first_time_from_adaptation.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/utils/get_last_time_from_adaptation.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/utils/get_maximum_positions.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/utils/get_minimum_position.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/utils/index_helpers.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/manifest/utils/update_segment_timeline.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/sami/html.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/sami/native.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/srt/find_end_of_cue_block.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/srt/get_cue_blocks.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/srt/html.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/srt/native.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/srt/parse_cue.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/srt/parse_timestamp.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/ttml/get_parameters.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/ttml/get_styling.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/ttml/get_time_delimiters.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/ttml/html/apply_default_ttml_paragraph_style.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/ttml/html/apply_extent.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/ttml/html/apply_font_size.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/ttml/html/apply_line_height.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/ttml/html/apply_origin.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/ttml/html/apply_padding.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/ttml/html/create_element.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/ttml/html/generate_css_test_outline.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/ttml/html/index.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/ttml/html/parse_cue.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/ttml/html/parse_ttml_to_div.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/ttml/html/ttml_color_to_css_color.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/ttml/native/index.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/ttml/native/parse_cue.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/ttml/native/parse_ttml_to_vtt.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/ttml/parse_ttml.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/ttml/regexps.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/ttml/resolve_styles_inheritance.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/ttml/time_parsing.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/ttml/xml_utils.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/webvtt/get_cue_blocks.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/webvtt/get_style_blocks.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/webvtt/html/convert_payload_to_html.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/webvtt/html/create_default_style_elements.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/webvtt/html/create_style_attribute.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/webvtt/html/create_styled_element.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/webvtt/html/index.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/webvtt/html/parse_style_block.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/webvtt/html/parse_webvtt_to_div.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/webvtt/html/to_html.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/webvtt/native/index.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/webvtt/native/parse_vtt_to_cues.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/webvtt/native/set_settings_on_cue.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/webvtt/native/to_native_cue.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/webvtt/parse_cue_block.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/webvtt/parse_timestamp.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/parsers/texttracks/webvtt/utils.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/playback_observer/media_element_playback_observer.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/playback_observer/utils/generate_read_only_observer.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/playback_observer/utils/observation_position.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/transports/dash/construct_segment_url.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/transports/dash/get_events_out_of_emsgs.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/transports/dash/index.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/transports/dash/init_segment_loader.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/transports/dash/integrity_checks.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/transports/dash/load_chunked_segment_data.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/transports/dash/manifest_parser.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/transports/dash/pipelines.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/transports/dash/segment_loader.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/transports/dash/segment_parser.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/transports/dash/text_loader.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/transports/dash/text_parser.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/transports/dash/thumbnails.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/transports/smooth/extract_timings_infos.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/transports/smooth/index.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/transports/smooth/is_mp4_embedded_track.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/transports/smooth/isobmff/create_audio_init_segment.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/transports/smooth/isobmff/create_boxes.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/transports/smooth/isobmff/create_init_segment.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/transports/smooth/isobmff/create_traf_box.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/transports/smooth/isobmff/create_video_init_segment.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/transports/smooth/isobmff/get_aaces_header.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/transports/smooth/isobmff/parse_tfrf.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/transports/smooth/isobmff/parse_tfxd.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/transports/smooth/isobmff/patch_segment.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/transports/smooth/pipelines.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/transports/smooth/segment_loader.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/transports/smooth/utils.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/transports/utils/add_query_string.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/transports/utils/byte_range.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/transports/utils/call_custom_manifest_loader.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/transports/utils/check_isobmff_integrity.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/transports/utils/generate_manifest_loader.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/transports/utils/get_isobmff_timing_infos.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/transports/utils/infer_segment_container.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/transports/utils/parse_text_track.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/are_arrays_of_numbers_equal.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/are_codecs_compatible.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/array_find.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/array_find_index.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/array_includes.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/assert.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/base64.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/byte_parsing.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/cancellable_sleep.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/create_cancellable_promise.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/create_uuid.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/deep_merge.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/event_emitter.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/flat_map.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/get_fuzzed_delay.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/global_scope.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/hash_buffer.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/id_generator.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/is_node.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/is_non_empty_string.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/is_null_or_undefined.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/is_worker.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/languages/ISO_639-1_to_ISO_639-3.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/languages/ISO_639-2_to_ISO_639-3.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/languages/index.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/languages/normalize.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/logger.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/monotonic_timestamp.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/noop.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/object_assign.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/object_values.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/queue_microtask.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/ranges.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/reference.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/request/fetch.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/request/index.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/request/request_error.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/request/xhr.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/retry_promise_with_backoff.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/sleep.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/slice_uint8array.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/sorted_list.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/starts_with.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/string_parsing.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/sync_or_async.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/task_canceller.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/url-utils.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/warn_once.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/weak_map_memory.js","webpack://ott_media_player/./node_modules/rx-player/dist/es2017/utils/wrapInPromise.js","webpack://ott_media_player/./src/const/appConfig.js","webpack://ott_media_player/./src/const/appEvents.js","webpack://ott_media_player/./src/const/appState.js","webpack://ott_media_player/./src/solutions/index.js","webpack://ott_media_player/./src/solutions/rxplayer/const/playerError.js","webpack://ott_media_player/./src/solutions/rxplayer/const/playerEvents.js","webpack://ott_media_player/./src/solutions/rxplayer/const/playerStates.js","webpack://ott_media_player/./src/solutions/rxplayer/player.js","webpack://ott_media_player/./src/utils/logger.js","webpack://ott_media_player/./src/utils/utils.js","webpack://ott_media_player/webpack/bootstrap","webpack://ott_media_player/webpack/runtime/define property getters","webpack://ott_media_player/webpack/runtime/global","webpack://ott_media_player/webpack/runtime/hasOwnProperty shorthand","webpack://ott_media_player/webpack/runtime/make namespace object","webpack://ott_media_player/./src/app.js"],"sourcesContent":["const mediaInfo = {\r\n    \"dash\": [\r\n        {\r\n            title: \"[DASH-IF] SegmentBase, ondemand profile\",\r\n            manifestURL: \"https://dash.akamaized.net/akamai/bbb_30fps/bbb_30fps.mpd\"\r\n        },\r\n        {\r\n            title: \"Low Latency Chunked Single-Bitrate, AVC, and AAC\",\r\n            manifestURL: \"https://livesim.dashif.org/livesim/chunkdur_1/ato_7/testpic4_8s/Manifest.mpd\"\r\n        },\r\n        {\r\n            title: \"10-bit UHD SDR Live profile\",\r\n            manifestURL: \"https://dash.akamaized.net/dash264/TestCasesUHD/2b/11/MultiRate.mpd\"\r\n        },\r\n        {\r\n            title: \"Switching across adaptation set  With switching element\",\r\n            manifestURL: \"https://dash.akamaized.net/dash264/TestCasesIOP33/adapatationSetSwitching/5/manifest.mpd\"\r\n        },\r\n        {\r\n            title: \"AVC, Multi-Resolution Multi-Rate, Live profile, SegmentTimeline\",\r\n            manifestURL: \"https://dash.akamaized.net/dash264/TestCases/2c/qualcomm/1/MultiResMPEG2.mpd\"\r\n        },\r\n        {\r\n            title: \"AVC, Multi-Resolution Multi-Rate, Live profile, up to 1080p\",\r\n            manifestURL: \"https://dash.akamaized.net/dash264/TestCasesHD/2b/qualcomm/1/MultiResMPEG2.mpd\"\r\n        },\r\n        {\r\n            title: \"AVC, Single-Resolution Multi-Rate, Live profile\",\r\n            manifestURL: \"https://dash.akamaized.net/dash264/TestCases/1b/qualcomm/1/MultiRatePatched.mpd\"\r\n        },\r\n        {\r\n            title: \"dash sample 02\",\r\n            manifestURL: \"https://media.axprod.net/TestVectors/Cmaf/protected_1080p_h264_cbcs/manifest.mpd\",\r\n            drmOptions: {\r\n                PlayReady: {\r\n                    laURL: \"https://drm-playready-licensing.axprod.net/AcquireLicense\",\r\n                    priority: 0,\r\n                    requestHeaderKey: {\r\n                        \"X-AxDRM-Message\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.ewogICJ2ZXJzaW9uIjogMSwKICAiY29tX2tleV9pZCI6ICI2OWU1NDA4OC1lOWUwLTQ1MzAtOGMxYS0xZWI2ZGNkMGQxNGUiLAogICJtZXNzYWdlIjogewogICAgInR5cGUiOiAiZW50aXRsZW1lbnRfbWVzc2FnZSIsCiAgICAidmVyc2lvbiI6IDIsCiAgICAibGljZW5zZSI6IHsKICAgICAgImFsbG93X3BlcnNpc3RlbmNlIjogdHJ1ZQogICAgfSwKICAgICJjb250ZW50X2tleXNfc291cmNlIjogewogICAgICAiaW5saW5lIjogWwogICAgICAgIHsKICAgICAgICAgICJpZCI6ICIzMDJmODBkZC00MTFlLTQ4ODYtYmNhNS1iYjFmODAxOGEwMjQiLAogICAgICAgICAgImVuY3J5cHRlZF9rZXkiOiAicm9LQWcwdDdKaTFpNDNmd3YremZ0UT09IiwKICAgICAgICAgICJ1c2FnZV9wb2xpY3kiOiAiUG9saWN5IEEiCiAgICAgICAgfQogICAgICBdCiAgICB9LAogICAgImNvbnRlbnRfa2V5X3VzYWdlX3BvbGljaWVzIjogWwogICAgICB7CiAgICAgICAgIm5hbWUiOiAiUG9saWN5IEEiLAogICAgICAgICJwbGF5cmVhZHkiOiB7CiAgICAgICAgICAibWluX2RldmljZV9zZWN1cml0eV9sZXZlbCI6IDE1MCwKICAgICAgICAgICJwbGF5X2VuYWJsZXJzIjogWwogICAgICAgICAgICAiNzg2NjI3RDgtQzJBNi00NEJFLThGODgtMDhBRTI1NUIwMUE3IgogICAgICAgICAgXQogICAgICAgIH0KICAgICAgfQogICAgXQogIH0KfQ._NfhLVY7S6k8TJDWPeMPhUawhympnrk6WAZHOVjER6M\"\r\n                    }\r\n                },\r\n                WideVine: {\r\n                    laURL: \"https://drm-widevine-licensing.axprod.net/AcquireLicense\",\r\n                    priority: 1,\r\n                    requestHeaderKey: {\r\n                        \"X-AxDRM-Message\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.ewogICJ2ZXJzaW9uIjogMSwKICAiY29tX2tleV9pZCI6ICI2OWU1NDA4OC1lOWUwLTQ1MzAtOGMxYS0xZWI2ZGNkMGQxNGUiLAogICJtZXNzYWdlIjogewogICAgInR5cGUiOiAiZW50aXRsZW1lbnRfbWVzc2FnZSIsCiAgICAidmVyc2lvbiI6IDIsCiAgICAibGljZW5zZSI6IHsKICAgICAgImFsbG93X3BlcnNpc3RlbmNlIjogdHJ1ZQogICAgfSwKICAgICJjb250ZW50X2tleXNfc291cmNlIjogewogICAgICAiaW5saW5lIjogWwogICAgICAgIHsKICAgICAgICAgICJpZCI6ICIzMDJmODBkZC00MTFlLTQ4ODYtYmNhNS1iYjFmODAxOGEwMjQiLAogICAgICAgICAgImVuY3J5cHRlZF9rZXkiOiAicm9LQWcwdDdKaTFpNDNmd3YremZ0UT09IiwKICAgICAgICAgICJ1c2FnZV9wb2xpY3kiOiAiUG9saWN5IEEiCiAgICAgICAgfQogICAgICBdCiAgICB9LAogICAgImNvbnRlbnRfa2V5X3VzYWdlX3BvbGljaWVzIjogWwogICAgICB7CiAgICAgICAgIm5hbWUiOiAiUG9saWN5IEEiLAogICAgICAgICJwbGF5cmVhZHkiOiB7CiAgICAgICAgICAibWluX2RldmljZV9zZWN1cml0eV9sZXZlbCI6IDE1MCwKICAgICAgICAgICJwbGF5X2VuYWJsZXJzIjogWwogICAgICAgICAgICAiNzg2NjI3RDgtQzJBNi00NEJFLThGODgtMDhBRTI1NUIwMUE3IgogICAgICAgICAgXQogICAgICAgIH0KICAgICAgfQogICAgXQogIH0KfQ._NfhLVY7S6k8TJDWPeMPhUawhympnrk6WAZHOVjER6M\"\r\n                    }\r\n                },\r\n                clearkey: \"KID123=Key456\"\r\n            }\r\n        }\r\n    ],\r\n    hls: [\r\n        {\r\n            title: \"[Bitmovin Default] Manifest URL\",\r\n            manifestURL: \"https://cdn.bitmovin.com/content/assets/art-of-motion-dash-hls-progressive/m3u8s/f08e80da-bf1d-4e3d-8899-f0f6155f6efa.m3u8\"\r\n        },\r\n        { title: \"Tears of Steel m3u8\", url: \"https://demo.unified-streaming.com/k8s/features/stable/video/tears-of-steel/tears-of-steel.ism/.m3u8\" },\r\n        { title: \"fMP4 m3u8\", url: \"https://devstreaming-cdn.apple.com/videos/streaming/examples/img_bipbop_adv_example_fmp4/master.m3u8\" },\r\n        { title: \"MP4 m3u8\", url: \"https://demo.unified-streaming.com/k8s/features/stable/video/tears-of-steel/tears-of-steel.mp4/.m3u8\" },\r\n        { title: \"Live Akamai m3u8\", url: \"https://cph-p2p-msl.akamaized.net/hls/live/2000341/test/master.m3u8\" },\r\n        { title: \"Live Akamai m3u8\", url: \"https://moctobpltc-i.akamaihd.net/hls/live/571329/eight/playlist.m3u8\" },\r\n        { title: \"Dolby VOD m3u8\", url: \"http://d3rlna7iyyu8wu.cloudfront.net/skip_armstrong/skip_armstrong_stereo_subs.m3u8\" },\r\n        { title: \"Dolby Multichannel m3u8\", url: \"http://d3rlna7iyyu8wu.cloudfront.net/skip_armstrong/skip_armstrong_multichannel_subs.m3u8\" },\r\n        { title: \"Dolby Multilanguage m3u8\", url: \"http://d3rlna7iyyu8wu.cloudfront.net/skip_armstrong/skip_armstrong_multi_language_subs.m3u8\" },\r\n        { title: \"Azure HLSv4 m3u8\", url: \"http://amssamples.streaming.mediaservices.windows.net/91492735-c523-432b-ba01-faba6c2206a2/AzureMediaServicesPromo.ism/manifest(format=m3u8-aapl)\" },\r\n        { title: \"Azure HLSv4 m3u8\", url: \"http://amssamples.streaming.mediaservices.windows.net/69fbaeba-8e92-4740-aedc-ce09ae945073/AzurePromo.ism/manifest(format=m3u8-aapl)\" },\r\n        { title: \"Azure 4K HLSv4 m3u8\", url: \"http://amssamples.streaming.mediaservices.windows.net/634cd01c-6822-4630-8444-8dd6279f94c6/CaminandesLlamaDrama4K.ism/manifest(format=m3u8-aapl)\" }\r\n    ]\r\n};\r\n\r\nexport default mediaInfo;","// extracted by mini-css-extract-plugin\nexport {};","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nlet hasClassList;\n/**\n * Add className to an HTMLElement. Do nothing if the className was already\n * added.\n * @param {HTMLElement} elt\n * @param {string} className\n */\nexport default function addClassName(elt, className) {\n    if (hasClassList === undefined) {\n        hasClassList = elt.classList !== undefined && typeof elt.classList.add === \"function\";\n    }\n    if (hasClassList) {\n        elt.classList.add(className);\n    }\n    else {\n        const classNamesWithSpaces = \" \" + elt.className + \" \";\n        if (classNamesWithSpaces.indexOf(\" \" + className + \" \") < 0) {\n            elt.className += \" \" + className;\n        }\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { isIEOrEdge } from \"./browser_detection\";\n/**\n * Add text track to the given media element.\n *\n * Returns an object with the following properties:\n *   - track {TextTrack}: the added text track\n *   - trackElement {HTMLElement|undefined}: the added <track> element.\n *     undefined if no trackElement was added.\n *\n * @param {HTMLMediaElement} mediaElement\n * @returns {Object}\n */\nexport default function addTextTrack(mediaElement) {\n    var _a;\n    let track;\n    let trackElement;\n    const kind = \"subtitles\";\n    if (isIEOrEdge) {\n        const tracksLength = mediaElement.textTracks.length;\n        track = (tracksLength > 0\n            ? mediaElement.textTracks[tracksLength - 1]\n            : mediaElement.addTextTrack(kind));\n        track.mode = (_a = track.SHOWING) !== null && _a !== void 0 ? _a : \"showing\";\n    }\n    else {\n        trackElement = document.createElement(\"track\");\n        mediaElement.appendChild(trackElement);\n        track = trackElement.track;\n        trackElement.kind = kind;\n        track.mode = \"showing\";\n    }\n    return { track, trackElement };\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a, _b, _c, _d, _e;\nimport globalScope from \"../utils/global_scope\";\n// Trick to ensure our own types are compatible to TypeScript's\nfunction assertTypeCompatibility() {\n    // noop\n}\n/* eslint-disable @typescript-eslint/no-restricted-types */\nassertTypeCompatibility();\nassertTypeCompatibility();\nassertTypeCompatibility();\nassertTypeCompatibility();\nassertTypeCompatibility();\nassertTypeCompatibility();\nassertTypeCompatibility();\n/** MediaSource implementation, including vendored implementations. */\nconst gs = globalScope;\nconst MediaSource_ = (_e = (_d = (_c = (_b = (_a = gs === null || gs === void 0 ? void 0 : gs.MediaSource) !== null && _a !== void 0 ? _a : gs === null || gs === void 0 ? void 0 : gs.MozMediaSource) !== null && _b !== void 0 ? _b : gs === null || gs === void 0 ? void 0 : gs.WebKitMediaSource) !== null && _c !== void 0 ? _c : gs === null || gs === void 0 ? void 0 : gs.MSMediaSource) !== null && _d !== void 0 ? _d : gs === null || gs === void 0 ? void 0 : gs.ManagedMediaSource) !== null && _e !== void 0 ? _e : undefined;\nconst isManagedMediaSource = MediaSource_ !== undefined && MediaSource_ === (gs === null || gs === void 0 ? void 0 : gs.ManagedMediaSource);\n/** List an HTMLMediaElement's possible values for its readyState property. */\nconst READY_STATES = {\n    HAVE_NOTHING: 0,\n    HAVE_METADATA: 1,\n    HAVE_CURRENT_DATA: 2,\n    HAVE_FUTURE_DATA: 3,\n    HAVE_ENOUGH_DATA: 4,\n};\nexport { MediaSource_, isManagedMediaSource, READY_STATES };\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport globalScope from \"../utils/global_scope\";\nimport isNode from \"../utils/is_node\";\n/** Edge Chromium, regardless of the device */\nlet isEdgeChromium = false;\n/** IE11, regardless of the device */\nlet isIE11 = false;\n/** IE11 or Edge __Legacy__ (not Edge Chromium), regardless of the device */\nlet isIEOrEdge = false;\n/** Firefox, regardless of the device */\nlet isFirefox = false;\n/** `true` on Safari on a PC platform (i.e. not iPhone / iPad etc.) */\nlet isSafariDesktop = false;\n/** `true` on Safari on an iPhone, iPad & iPod platform */\nlet isSafariMobile = false;\n/** Samsung's own browser application */\nlet isSamsungBrowser = false;\n/** `true` on devices where Tizen is the OS (e.g. Samsung TVs). */\nlet isTizen = false;\n/** `true` on devices where WebOS is the OS (e.g. LG TVs). */\nlet isWebOs = false;\n/** `true` specifically for WebOS 2021 version. */\nlet isWebOs2021 = false;\n/** `true` specifically for WebOS 2022 version. */\nlet isWebOs2022 = false;\n/** `true` for Panasonic devices. */\nlet isPanasonic = false;\n/** `true` we're relying on Philips's NetTv browser. */\nlet isPhilipsNetTv = false;\n/** `true` for the PlayStation 4 game console. */\nlet isPlayStation4 = false;\n/** `true` for the PlayStation 5 game console. */\nlet isPlayStation5 = false;\n/** `true` for the Xbox game consoles. */\nlet isXbox = false;\n/** `true` for specific A1 STB: KSTB 40xx from Kaon Media. */\nlet isA1KStb40xx = false;\n(function findCurrentBrowser() {\n    var _a, _b, _c;\n    if (isNode) {\n        return;\n    }\n    // 1 - Find out browser between IE/Edge Legacy/Edge Chromium/Firefox/Safari\n    if (typeof globalScope.MSInputMethodContext !== \"undefined\" &&\n        typeof document.documentMode !== \"undefined\") {\n        isIE11 = true;\n        isIEOrEdge = true;\n    }\n    else if (navigator.appName === \"Microsoft Internet Explorer\" ||\n        (navigator.appName === \"Netscape\" && /(Trident|Edge)\\//.test(navigator.userAgent))) {\n        isIEOrEdge = true;\n    }\n    else if (navigator.userAgent.toLowerCase().indexOf(\"edg/\") !== -1) {\n        isEdgeChromium = true;\n    }\n    else if (navigator.userAgent.toLowerCase().indexOf(\"firefox\") !== -1) {\n        isFirefox = true;\n    }\n    else if (typeof navigator.platform === \"string\" &&\n        /iPad|iPhone|iPod/.test(navigator.platform)) {\n        isSafariMobile = true;\n    }\n    else if (\n    // the following statement check if the window.safari contains the method\n    // \"pushNotification\", this condition is not met when using web app from the dock\n    // on macOS, this is why we also check userAgent.\n    Object.prototype.toString.call(globalScope.HTMLElement).indexOf(\"Constructor\") >= 0 ||\n        ((_b = (_a = globalScope.safari) === null || _a === void 0 ? void 0 : _a.pushNotification) === null || _b === void 0 ? void 0 : _b.toString()) ===\n            \"[object SafariRemoteNotification]\" ||\n        // browsers are lying: Chrome reports both as Chrome and Safari in user\n        // agent string, So to detect Safari we have to check for the Safari string\n        // and the absence of the Chrome string\n        // @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent#which_part_of_the_user_agent_contains_the_information_you_are_looking_for\n        (/Safari\\/(\\d+)/.test(navigator.userAgent) &&\n            // Safari should contain Version/ in userAgent\n            /Version\\/(\\d+)/.test(navigator.userAgent) &&\n            ((_c = navigator.vendor) === null || _c === void 0 ? void 0 : _c.indexOf(\"Apple\")) !== -1 &&\n            !/Chrome\\/(\\d+)/.test(navigator.userAgent) &&\n            !/Chromium\\/(\\d+)/.test(navigator.userAgent))) {\n        isSafariDesktop = true;\n    }\n    // 2 - Find out specific device/platform information\n    // Samsung browser e.g. on Android\n    if (/SamsungBrowser/.test(navigator.userAgent)) {\n        isSamsungBrowser = true;\n    }\n    if (navigator.userAgent.indexOf(\"PlayStation 4\") !== -1) {\n        isPlayStation4 = true;\n    }\n    else if (navigator.userAgent.indexOf(\"PlayStation 5\") !== -1) {\n        isPlayStation5 = true;\n    }\n    else if (/Tizen/.test(navigator.userAgent)) {\n        isTizen = true;\n        // Inspired form: http://webostv.developer.lge.com/discover/specifications/web-engine/\n        // Note: even that page doesn't correspond to what we've actually seen in the\n        // wild\n    }\n    else if (/[Ww]eb[O0]S/.test(navigator.userAgent)) {\n        isWebOs = true;\n        if (/[Ww]eb[O0]S.TV-2022/.test(navigator.userAgent) ||\n            /[Cc]hr[o0]me\\/87/.test(navigator.userAgent)) {\n            isWebOs2022 = true;\n        }\n        else if (/[Ww]eb[O0]S.TV-2021/.test(navigator.userAgent) ||\n            /[Cc]hr[o0]me\\/79/.test(navigator.userAgent)) {\n            isWebOs2021 = true;\n        }\n    }\n    else if (navigator.userAgent.indexOf(\"NETTV\") !== -1 &&\n        navigator.userAgent.indexOf(\"Philips\") !== -1) {\n        isPhilipsNetTv = true;\n    }\n    else if (/[Pp]anasonic/.test(navigator.userAgent)) {\n        isPanasonic = true;\n    }\n    else if (navigator.userAgent.indexOf(\"Xbox\") !== -1) {\n        isXbox = true;\n    }\n    else if (navigator.userAgent.indexOf(\"Model/a1-kstb40xx\") !== -1) {\n        isA1KStb40xx = true;\n    }\n})();\nexport { \n// browsers\nisEdgeChromium, isFirefox, isIE11, isIEOrEdge, isSafariDesktop, isSafariMobile, \n// specific devices\nisA1KStb40xx, isPanasonic, isPhilipsNetTv, isPlayStation4, isPlayStation5, isSamsungBrowser, isTizen, isWebOs, isWebOs2021, isWebOs2022, isXbox, };\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../log\";\nimport { isFirefox } from \"./browser_detection\";\n/**\n * Returns either :\n * - 'null' when the current browser is not Firefox.\n * - '-1' when it is impossible to get the Firefox version\n * - A number above 0 that is the Firefox version number\n * @returns {number|null}\n */\nfunction getFirefoxVersion() {\n    if (!isFirefox) {\n        log.warn(\"Compat: Can't access Firefox version on no firefox browser.\");\n        return null;\n    }\n    const userAgent = navigator.userAgent;\n    const match = /Firefox\\/([0-9]+)\\./.exec(userAgent);\n    if (match === null) {\n        return -1;\n    }\n    const result = parseInt(match[1], 10);\n    if (isNaN(result)) {\n        return -1;\n    }\n    return result;\n}\nexport { getFirefoxVersion };\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { isIEOrEdge } from \"./browser_detection\";\n/**\n * TODO(pierre): fix patchSegmentInPlace to work with IE11. Maybe\n * try to put free atom inside traf children\n *\n * Returns true if the current target is tolerant enough for us to\n * simply be able to \"patch\" an ISOBMFF segment or if we have to create a\n * new one from scratch instead.\n * @returns {Boolean}\n */\nexport default function canPatchISOBMFFSegment() {\n    return !isIEOrEdge;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { isEdgeChromium } from \"./browser_detection\";\n/**\n * This functions tells if the RxPlayer can trust the browser when it has\n * successfully granted the MediaKeySystemAccess with\n * `navigator.requestMediaKeySystemAccess(keySystem)` function, or if it should do\n * some additional testing to confirm that the `keySystem` is supported on the device.\n *\n * This behavior has been experienced on the following device:\n *\n * On a Microsoft Surface with Edge v.124:\n * - Althought `requestMediaKeySystemAccess` resolve correctly with the keySystem\n *   \"com.microsoft.playready.recommendation.3000\", generating a request with\n *   `generateRequest` throws an error: \"NotSupportedError: Failed to execute\n *   'generateRequest' on 'MediaKeySession': Failed to create MF PR CdmSession\".\n *   In this particular case, the work-around was to consider recommendation.3000 as not supported\n *   and try another keySystem.\n * @param keySystem - The key system in use.\n * @returns {boolean}\n */\nexport function canRelyOnRequestMediaKeySystemAccess(keySystem) {\n    if (isEdgeChromium && keySystem.indexOf(\"playready\") !== -1) {\n        return false;\n    }\n    return true;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { isFirefox } from \"./browser_detection\";\nimport { getFirefoxVersion } from \"./browser_version\";\n/**\n * This functions tells if the RxPlayer can trust on any browser data\n * about video element visibility and size.\n *\n * On Firefox (version >= 67) :\n * - The PIP feature exists but can be disabled by default according\n * to the OS and the channel used for updating / getting Firefox binaries.\n * - There is no API to know if the Picture-in-picture (PIP) is enabled\n * - There is no API to get the width of the PIP window\n *\n * The element clientWidth tells the width of the original video element, and\n * no PIP window API exists to determine its presence or width. Thus, there are\n * no way to determine the real width of the video window, as we can't know when\n * the PIP feature or window is enabled, and we can't have access to the windo\n * size information.\n *\n * Moreover, when the document is considered as hidden (e.g. in case of hidden\n * tab), as there is no way to know if the PIP feature or window is enabled,\n * we can't know if the video window is visible or not.\n * @returns {boolean}\n */\nexport default function canRelyOnVideoVisibilityAndSize() {\n    if (!isFirefox) {\n        return true;\n    }\n    const firefoxVersion = getFirefoxVersion();\n    if (firefoxVersion === null || firefoxVersion < 67) {\n        return true;\n    }\n    const proto = HTMLVideoElement === null || HTMLVideoElement === void 0 ? void 0 : HTMLVideoElement.prototype;\n    return (proto === null || proto === void 0 ? void 0 : proto.requirePictureInPicture) !== undefined;\n}\n","import { isA1KStb40xx, isPanasonic, isPhilipsNetTv, isWebOs } from \"./browser_detection\";\n/**\n * Returns `true` if a `MediaKeys` instance (the  `Encrypted Media Extension`\n * concept) can be reused between contents.\n *\n * This should usually be the case but we found rare devices where this would\n * cause problem:\n *   - (2022-11-21): WebOS (LG TVs), for some encrypted contents, just\n *     rebuffered indefinitely when loading a content already-loaded on the\n *     HTMLMediaElement.\n *   - (2024-08-23): Seen on Philips 2024 and 2023 in:\n *     https://github.com/canalplus/rx-player/issues/1464\n *   - (2024-09-04): Another case seen on an \"A1\" set-top box model made by\n *     Kaonmedia we will call the KSTB40xx.\n *     It may share the problematic with other devices, but we have only seen\n *     the problem on this one for now.\n *\n * @returns {boolean}\n */\nexport default function canReuseMediaKeys() {\n    return !isWebOs && !isPhilipsNetTv && !isPanasonic && !isA1KStb40xx;\n}\n","import { isSafariMobile } from \"./browser_detection\";\n/**\n * On safari mobile (version 17.1.2) seeking too early cause the video to never buffer\n * media data. Using delaying mechanisms such as `setTimeout(fn, 0)` defers the seek\n * to a moment at which safari should be more able to handle a seek.\n */\nconst canSeekDirectlyAfterLoadedMetadata = !isSafariMobile;\nexport default canSeekDirectlyAfterLoadedMetadata;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../log\";\n/**\n * If the changeType MSE API is implemented, update the current codec of the\n * SourceBuffer and return true if it succeeded.\n * In any other cases, return false.\n * @param {Object} sourceBuffer\n * @param {string} codec\n * @returns {boolean}\n */\nexport default function tryToChangeSourceBufferType(sourceBuffer, codec) {\n    if (typeof sourceBuffer.changeType === \"function\") {\n        try {\n            sourceBuffer.changeType(codec);\n        }\n        catch (e) {\n            log.warn(\"Could not call 'changeType' on the given SourceBuffer:\", e instanceof Error ? e : \"\");\n            return false;\n        }\n        return true;\n    }\n    return false;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../log\";\nimport isNullOrUndefined from \"../utils/is_null_or_undefined\";\n/**\n * Clear element's src attribute.\n * @param {HTMLMediaElement} element\n */\nexport default function clearElementSrc(element) {\n    // On some browsers, we first have to make sure the textTracks elements are\n    // both disabled and removed from the DOM.\n    // If we do not do that, we may be left with displayed text tracks on the\n    // screen, even if the track elements are properly removed, due to browser\n    // issues.\n    // Bug seen on Firefox (I forgot which version) and Chrome 96.\n    const { textTracks } = element;\n    if (!isNullOrUndefined(textTracks)) {\n        for (let i = 0; i < textTracks.length; i++) {\n            textTracks[i].mode = \"disabled\";\n        }\n        if (element.hasChildNodes()) {\n            const { childNodes } = element;\n            for (let j = childNodes.length - 1; j >= 0; j--) {\n                if (childNodes[j].nodeName === \"track\") {\n                    try {\n                        element.removeChild(childNodes[j]);\n                    }\n                    catch (_err) {\n                        log.warn(\"Compat: Could not remove text track child from element.\");\n                    }\n                }\n            }\n        }\n    }\n    element.src = \"\";\n    // On IE11, element.src = \"\" is not sufficient as it\n    // does not clear properly the current MediaKey Session.\n    // Microsoft recommended to use element.removeAttr(\"src\").\n    element.removeAttribute(\"src\");\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../log\";\nimport cancellableSleep from \"../../utils/cancellable_sleep\";\nimport TaskCanceller, { CancellationError } from \"../../utils/task_canceller\";\n/**\n * Close the given `MediaKeySession` and returns a Promise resolving when the\n * session is closed.\n * This promise does not reject, even if we're unable to close the\n * `MediaKeySession`.\n *\n * Note that there is a lot of browser issues linked to the impossibility to\n * either close a MediaKeySession or to know if a MediaKeySession was closed.\n * Due to this, the returned Promise might take some time before resolving on\n * some devices.\n * @param {MediaKeySession|Object} session\n * @returns {Promise.<undefined>}\n */\nexport default function closeSession(session) {\n    const timeoutCanceller = new TaskCanceller();\n    return Promise.race([\n        session.close().then(() => {\n            timeoutCanceller.cancel();\n        }),\n        // The `closed` promise may resolve, even if `close()` result has not\n        // (seen at some point on Firefox).\n        session.closed.then(() => {\n            timeoutCanceller.cancel();\n        }),\n        waitTimeoutAndCheck(),\n    ]);\n    /**\n     * If the session is not closed after 1000ms, try to communicate with the\n     * MediaKeySession and check if an error is returned.\n     * This is needed because on some browsers with poor EME implementation,\n     * knowing when a MediaKeySession is closed is actually a hard task.\n     *\n     * The returned Promise will never reject.\n     * @returns {Promise.<undefined>}\n     */\n    async function waitTimeoutAndCheck() {\n        try {\n            await cancellableSleep(1000, timeoutCanceller.signal);\n            await tryUpdatingSession();\n        }\n        catch (err) {\n            if (err instanceof CancellationError) {\n                // cancelled == session closed\n                return;\n            }\n            const message = err instanceof Error\n                ? err.message\n                : \"Unknown error made it impossible to close the session\";\n            log.error(`DRM: ${message}`);\n        }\n    }\n    /**\n     * Try to update `MediaKeySession` and check its error if it failed.\n     * If we still don't know whether it closed yet, wait a second\n     * timeout then quit.\n     *\n     * The returned Promise resolves if the `MediaKeySession` seems closed and\n     * rejects if we couldn't know or it doesn't.\n     * @returns {Promise.<undefined>}\n     */\n    async function tryUpdatingSession() {\n        try {\n            await session.update(new Uint8Array(1));\n        }\n        catch (err) {\n            if (timeoutCanceller.isUsed()) {\n                // Reminder: cancelled == session closed\n                return;\n            }\n            // The caught error can tell if session is closed\n            // (Chrome may throw this error)\n            // I know... Checking the error message is not the best practice ever.\n            if (err instanceof Error && err.message === \"The session is already closed.\") {\n                return;\n            }\n            await cancellableSleep(1000, timeoutCanceller.signal);\n        }\n        if (timeoutCanceller.isUsed()) {\n            // Reminder: cancelled == session closed\n            return;\n        }\n        throw new Error(\"Compat: Couldn't know if session is closed\");\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { be4toi } from \"../../utils/byte_parsing\";\nimport { strToUtf8 } from \"../../utils/string_parsing\";\n// The way \"pssh\" will be written in ISOBMFF files\nexport const PSSH_TO_INTEGER = be4toi(strToUtf8(\"pssh\"), 0);\n","/**\n * Simple implementation of the MediaKeySystemAccess EME API.\n *\n * All needed arguments are given to the constructor\n * @class CustomMediaKeySystemAccess\n */\nexport default class CustomMediaKeySystemAccess {\n    /**\n     * @param {string} _keyType - type of key system (e.g. \"widevine\" or\n     * \"com.widevine.alpha\").\n     * @param {Object} _mediaKeys - MediaKeys implementation\n     * @param {Object} _configuration - Configuration accepted for this\n     * MediaKeySystemAccess.\n     */\n    constructor(_keyType, _mediaKeys, _configuration) {\n        this._keyType = _keyType;\n        this._mediaKeys = _mediaKeys;\n        this._configuration = _configuration;\n    }\n    /**\n     * @returns {string} - current key system type (e.g. \"widevine\" or\n     * \"com.widevine.alpha\").\n     */\n    get keySystem() {\n        return this._keyType;\n    }\n    /**\n     * @returns {Promise.<Object>} - Promise wrapping the MediaKeys for this\n     * MediaKeySystemAccess. Never rejects.\n     */\n    createMediaKeys() {\n        return new Promise((res) => res(this._mediaKeys));\n    }\n    /**\n     * @returns {Object} - Configuration accepted for this MediaKeySystemAccess.\n     */\n    getConfiguration() {\n        return this._configuration;\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport EventEmitter from \"../../../utils/event_emitter\";\nimport isNullOrUndefined from \"../../../utils/is_null_or_undefined\";\nimport TaskCanceller from \"../../../utils/task_canceller\";\nimport wrapInPromise from \"../../../utils/wrapInPromise\";\nimport * as events from \"../../event_listeners\";\nimport { MSMediaKeysConstructor } from \"./ms_media_keys_constructor\";\nclass IE11MediaKeySession extends EventEmitter {\n    constructor(mk) {\n        super();\n        this.expiration = NaN;\n        this.keyStatuses = new Map();\n        this._mk = mk;\n        this._sessionClosingCanceller = new TaskCanceller();\n        this.closed = new Promise((resolve) => {\n            this._sessionClosingCanceller.signal.register(() => resolve(\"closed-by-application\"));\n        });\n        this.update = (license) => {\n            return new Promise((resolve, reject) => {\n                if (this._ss === undefined) {\n                    return reject(\"MediaKeySession not set.\");\n                }\n                try {\n                    resolve(this._ss.update(license, \"\"));\n                }\n                catch (err) {\n                    reject(err);\n                }\n            });\n        };\n    }\n    generateRequest(_initDataType, initData) {\n        return new Promise((resolve) => {\n            let initDataU8;\n            if (initData instanceof Uint8Array) {\n                initDataU8 = initData;\n            }\n            else if (initData instanceof ArrayBuffer) {\n                initDataU8 = new Uint8Array(initData);\n            }\n            else {\n                initDataU8 = new Uint8Array(initData.buffer);\n            }\n            this._ss = this._mk.createSession(\"video/mp4\", initDataU8);\n            events.onKeyMessage(this._ss, (evt) => {\n                var _a;\n                this.trigger(((_a = evt.type) !== null && _a !== void 0 ? _a : \"message\"), evt);\n            }, this._sessionClosingCanceller.signal);\n            events.onKeyAdded(this._ss, (evt) => {\n                var _a;\n                this.trigger(((_a = evt.type) !== null && _a !== void 0 ? _a : \"keyadded\"), evt);\n            }, this._sessionClosingCanceller.signal);\n            events.onKeyError(this._ss, (evt) => {\n                var _a;\n                this.trigger(((_a = evt.type) !== null && _a !== void 0 ? _a : \"keyerror\"), evt);\n            }, this._sessionClosingCanceller.signal);\n            resolve();\n        });\n    }\n    close() {\n        return new Promise((resolve) => {\n            if (!isNullOrUndefined(this._ss)) {\n                this._ss.close();\n                this._ss = undefined;\n            }\n            this._sessionClosingCanceller.cancel();\n            resolve();\n        });\n    }\n    load() {\n        return Promise.resolve(false);\n    }\n    remove() {\n        return Promise.resolve();\n    }\n    get sessionId() {\n        var _a, _b;\n        return (_b = (_a = this._ss) === null || _a === void 0 ? void 0 : _a.sessionId) !== null && _b !== void 0 ? _b : \"\";\n    }\n}\nclass IE11CustomMediaKeys {\n    constructor(keyType) {\n        if (MSMediaKeysConstructor === undefined) {\n            throw new Error(\"No MSMediaKeys API.\");\n        }\n        this._mediaKeys = new MSMediaKeysConstructor(keyType);\n    }\n    _setVideo(videoElement) {\n        return wrapInPromise(() => {\n            this._videoElement = videoElement;\n            if (this._videoElement.msSetMediaKeys !== undefined) {\n                this._videoElement.msSetMediaKeys(this._mediaKeys);\n            }\n        });\n    }\n    createSession( /* sessionType */) {\n        if (this._videoElement === undefined || this._mediaKeys === undefined) {\n            throw new Error(\"Video not attached to the MediaKeys\");\n        }\n        return new IE11MediaKeySession(this._mediaKeys);\n    }\n    setServerCertificate() {\n        throw new Error(\"Server certificate is not implemented in your browser\");\n    }\n}\nexport default function getIE11MediaKeysCallbacks() {\n    const isTypeSupported = (keySystem, type) => {\n        if (MSMediaKeysConstructor === undefined) {\n            throw new Error(\"No MSMediaKeys API.\");\n        }\n        if (type !== undefined) {\n            return MSMediaKeysConstructor.isTypeSupported(keySystem, type);\n        }\n        return MSMediaKeysConstructor.isTypeSupported(keySystem);\n    };\n    const createCustomMediaKeys = (keyType) => new IE11CustomMediaKeys(keyType);\n    const setMediaKeys = (elt, mediaKeys) => {\n        if (mediaKeys === null) {\n            // msSetMediaKeys only accepts native MSMediaKeys as argument.\n            // Calling it with null or undefined will raise an exception.\n            // There is no way to unset the mediakeys in that case, so return here.\n            return Promise.resolve(undefined);\n        }\n        if (!(mediaKeys instanceof IE11CustomMediaKeys)) {\n            throw new Error(\"Custom setMediaKeys is supposed to be called \" + \"with IE11 custom MediaKeys.\");\n        }\n        return mediaKeys._setVideo(elt);\n    };\n    return {\n        isTypeSupported,\n        createCustomMediaKeys,\n        setMediaKeys,\n    };\n}\nexport { MSMediaKeysConstructor };\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport globalScope from \"../../../utils/global_scope\";\nimport wrapInPromise from \"../../../utils/wrapInPromise\";\nlet MozMediaKeysConstructor;\nconst { MozMediaKeys } = globalScope;\nif (MozMediaKeys !== undefined &&\n    MozMediaKeys.prototype !== undefined &&\n    typeof MozMediaKeys.isTypeSupported === \"function\" &&\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    typeof MozMediaKeys.prototype.createSession === \"function\") {\n    MozMediaKeysConstructor = MozMediaKeys;\n}\nexport { MozMediaKeysConstructor };\nexport default function getMozMediaKeysCallbacks() {\n    const isTypeSupported = (keySystem, type) => {\n        if (MozMediaKeysConstructor === undefined) {\n            throw new Error(\"No MozMediaKeys API.\");\n        }\n        if (type !== undefined) {\n            return MozMediaKeysConstructor.isTypeSupported(keySystem, type);\n        }\n        return MozMediaKeysConstructor.isTypeSupported(keySystem);\n    };\n    const createCustomMediaKeys = (keyType) => {\n        if (MozMediaKeysConstructor === undefined) {\n            throw new Error(\"No MozMediaKeys API.\");\n        }\n        return new MozMediaKeysConstructor(keyType);\n    };\n    const setMediaKeys = (elt, mediaKeys) => {\n        return wrapInPromise(() => {\n            if (elt.mozSetMediaKeys === undefined ||\n                typeof elt.mozSetMediaKeys !== \"function\") {\n                throw new Error(\"Can't set video on MozMediaKeys.\");\n            }\n            return elt.mozSetMediaKeys(mediaKeys);\n        });\n    };\n    return {\n        isTypeSupported,\n        createCustomMediaKeys,\n        setMediaKeys,\n    };\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport globalScope from \"../../../utils/global_scope\";\nlet MSMediaKeysConstructor;\nconst { MSMediaKeys } = globalScope;\nif (MSMediaKeys !== undefined &&\n    MSMediaKeys.prototype !== undefined &&\n    typeof MSMediaKeys.isTypeSupported === \"function\" &&\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    typeof MSMediaKeys.prototype.createSession === \"function\") {\n    MSMediaKeysConstructor = MSMediaKeys;\n}\nexport { MSMediaKeysConstructor };\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { base64ToBytes } from \"../../../utils/base64\";\nimport EventEmitter from \"../../../utils/event_emitter\";\nimport isNullOrUndefined from \"../../../utils/is_null_or_undefined\";\nimport noop from \"../../../utils/noop\";\nimport { utf8ToStr } from \"../../../utils/string_parsing\";\nimport wrapInPromise from \"../../../utils/wrapInPromise\";\n/**\n * Returns true if the given media element has old webkit methods\n * corresponding to the IOldWebkitHTMLMediaElement interface.\n * @param {HTMLMediaElement} element\n * @returns {Boolean}\n */\nexport function isOldWebkitMediaElement(element) {\n    return (typeof (element === null || element === void 0 ? void 0 : element.webkitGenerateKeyRequest) ===\n        \"function\");\n}\n/**\n * MediaKeySession implementation for older versions of WebKit relying on APIs\n * such as `webkitGenerateKeyRequest` `webkitAddKey` to be called on the\n * HTMLMediaElement.\n * @class OldWebkitMediaKeySession\n */\nclass OldWebkitMediaKeySession extends EventEmitter {\n    constructor(mediaElement, keySystem) {\n        super();\n        this._vid = mediaElement;\n        this._key = keySystem;\n        this.sessionId = \"\";\n        this._closeSession = noop; // Just here to make TypeScript happy\n        this.keyStatuses = new Map();\n        this.expiration = NaN;\n        const onSessionRelatedEvent = (evt) => {\n            this.trigger(evt.type, evt);\n        };\n        this.closed = new Promise((resolve) => {\n            this._closeSession = () => {\n                [\"keymessage\", \"message\", \"keyadded\", \"ready\", \"keyerror\", \"error\"].forEach((evt) => {\n                    mediaElement.removeEventListener(evt, onSessionRelatedEvent);\n                    mediaElement.removeEventListener(`webkit${evt}`, onSessionRelatedEvent);\n                });\n                resolve(\"closed-by-application\");\n            };\n        });\n        [\"keymessage\", \"message\", \"keyadded\", \"ready\", \"keyerror\", \"error\"].forEach((evt) => {\n            mediaElement.addEventListener(evt, onSessionRelatedEvent);\n            mediaElement.addEventListener(`webkit${evt}`, onSessionRelatedEvent);\n        });\n    }\n    update(license) {\n        return new Promise((resolve, reject) => {\n            try {\n                if (this._key.indexOf(\"clearkey\") >= 0) {\n                    const licenseTypedArray = license instanceof ArrayBuffer ? new Uint8Array(license) : license;\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                    const json = JSON.parse(utf8ToStr(licenseTypedArray));\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-argument\n                    const key = base64ToBytes(json.keys[0].k);\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-argument\n                    const kid = base64ToBytes(json.keys[0].kid);\n                    resolve(this._vid.webkitAddKey(this._key, key, kid, /* sessionId */ \"\"));\n                }\n                else {\n                    resolve(this._vid.webkitAddKey(this._key, license, null, /* sessionId */ \"\"));\n                }\n            }\n            catch (err) {\n                reject(err);\n            }\n        });\n    }\n    generateRequest(_initDataType, initData) {\n        return new Promise((resolve) => {\n            this._vid.webkitGenerateKeyRequest(this._key, initData);\n            resolve();\n        });\n    }\n    close() {\n        return new Promise((resolve) => {\n            this._closeSession();\n            resolve();\n        });\n    }\n    /**\n     * Load a Persistent MediaKeySession.\n     * Do nothing here because this implementation doesn't handle them.\n     * @returns {Promise.<boolean>}\n     */\n    load() {\n        // Not implemented. Always return false as in \"no session with that id\".\n        return Promise.resolve(false);\n    }\n    remove() {\n        return Promise.resolve();\n    }\n}\nclass OldWebKitCustomMediaKeys {\n    constructor(keySystem) {\n        this._keySystem = keySystem;\n    }\n    _setVideo(videoElement) {\n        return wrapInPromise(() => {\n            if (!isOldWebkitMediaElement(videoElement)) {\n                throw new Error(\"Video not attached to the MediaKeys\");\n            }\n            this._videoElement = videoElement;\n        });\n    }\n    createSession( /* sessionType */) {\n        if (isNullOrUndefined(this._videoElement)) {\n            throw new Error(\"Video not attached to the MediaKeys\");\n        }\n        return new OldWebkitMediaKeySession(this._videoElement, this._keySystem);\n    }\n    setServerCertificate() {\n        throw new Error(\"Server certificate is not implemented in your browser\");\n    }\n}\nexport default function getOldWebKitMediaKeysCallbacks() {\n    const isTypeSupported = function (keyType) {\n        // get any <video> element from the DOM or create one\n        // and try the `canPlayType` method\n        let videoElement = document.querySelector(\"video\");\n        if (isNullOrUndefined(videoElement)) {\n            videoElement = document.createElement(\"video\");\n        }\n        if (!isNullOrUndefined(videoElement) &&\n            typeof videoElement.canPlayType === \"function\") {\n            return !!videoElement.canPlayType(\"video/mp4\", keyType);\n        }\n        else {\n            return false;\n        }\n    };\n    const createCustomMediaKeys = (keyType) => new OldWebKitCustomMediaKeys(keyType);\n    const setMediaKeys = (elt, mediaKeys) => {\n        if (mediaKeys === null) {\n            return Promise.resolve(undefined);\n        }\n        if (!(mediaKeys instanceof OldWebKitCustomMediaKeys)) {\n            throw new Error(\"Custom setMediaKeys is supposed to be called \" +\n                \"with old webkit custom MediaKeys.\");\n        }\n        return mediaKeys._setVideo(elt);\n    };\n    return {\n        isTypeSupported,\n        createCustomMediaKeys,\n        setMediaKeys,\n    };\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport EventEmitter from \"../../../utils/event_emitter\";\nimport noop from \"../../../utils/noop\";\nimport startsWith from \"../../../utils/starts_with\";\nimport wrapInPromise from \"../../../utils/wrapInPromise\";\nimport getWebKitFairplayInitData from \"../get_webkit_fairplay_initdata\";\nimport { WebKitMediaKeysConstructor } from \"./webkit_media_keys_constructor\";\n/**\n * Check if keyType is for fairplay DRM\n * @param {string} keyType\n * @returns {boolean}\n */\nfunction isFairplayKeyType(keyType) {\n    return startsWith(keyType, \"com.apple.fps\");\n}\n/**\n * Set media keys on video element using native HTMLMediaElement\n * setMediaKeys from WebKit.\n * @param {HTMLMediaElement} elt\n * @param {Object|null} mediaKeys\n * @returns {Promise}\n */\nfunction setWebKitMediaKeys(elt, mediaKeys) {\n    return wrapInPromise(() => {\n        if (elt.webkitSetMediaKeys === undefined) {\n            throw new Error(\"No webKitMediaKeys API.\");\n        }\n        elt.webkitSetMediaKeys(mediaKeys);\n    });\n}\n/**\n * On Safari browsers (>= 9), there are specific webkit prefixed APIs for cyphered\n * content playback. Standard EME APIs are therefore available since Safari 12.1, but they\n * don't allow to play fairplay cyphered content.\n *\n * This class implements a standard EME API polyfill that wraps webkit prefixed Safari\n * EME custom APIs.\n */\nclass WebkitMediaKeySession extends EventEmitter {\n    /**\n     * @param {HTMLMediaElement} mediaElement\n     * @param {string} keyType\n     * @param {Uint8Array | undefined} serverCertificate\n     */\n    constructor(mediaElement, keyType, serverCertificate) {\n        super();\n        this._serverCertificate = serverCertificate;\n        this._videoElement = mediaElement;\n        this._keyType = keyType;\n        this._unbindSession = noop;\n        this._closeSession = noop; // Just here to make TypeScript happy\n        this.closed = new Promise((resolve) => {\n            this._closeSession = resolve;\n        });\n        this.keyStatuses = new Map();\n        this.expiration = NaN;\n    }\n    update(license) {\n        return new Promise((resolve, reject) => {\n            if (this._nativeSession === undefined ||\n                this._nativeSession.update === undefined ||\n                typeof this._nativeSession.update !== \"function\") {\n                return reject(\"Unavailable WebKit key session.\");\n            }\n            try {\n                let uInt8Arraylicense;\n                if (license instanceof ArrayBuffer) {\n                    uInt8Arraylicense = new Uint8Array(license);\n                }\n                else if (license instanceof Uint8Array) {\n                    uInt8Arraylicense = license;\n                }\n                else {\n                    uInt8Arraylicense = new Uint8Array(license.buffer);\n                }\n                resolve(this._nativeSession.update(uInt8Arraylicense));\n            }\n            catch (err) {\n                reject(err);\n            }\n        });\n    }\n    generateRequest(_initDataType, initData) {\n        return new Promise((resolve) => {\n            var _a;\n            const elt = this._videoElement;\n            if (((_a = elt.webkitKeys) === null || _a === void 0 ? void 0 : _a.createSession) === undefined) {\n                throw new Error(\"No WebKitMediaKeys API.\");\n            }\n            let formattedInitData;\n            if (isFairplayKeyType(this._keyType)) {\n                if (this._serverCertificate === undefined) {\n                    throw new Error(\"A server certificate is needed for creating fairplay session.\");\n                }\n                formattedInitData = getWebKitFairplayInitData(initData, this._serverCertificate);\n            }\n            else {\n                formattedInitData = initData;\n            }\n            const keySession = elt.webkitKeys.createSession(\"video/mp4\", formattedInitData);\n            if (keySession === undefined || keySession === null) {\n                throw new Error(\"Impossible to get the key sessions\");\n            }\n            this._listenEvent(keySession);\n            this._nativeSession = keySession;\n            resolve();\n        });\n    }\n    close() {\n        return new Promise((resolve, reject) => {\n            this._unbindSession();\n            this._closeSession(\"closed-by-application\");\n            if (this._nativeSession === undefined) {\n                reject(\"No session to close.\");\n                return;\n            }\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            this._nativeSession.close();\n            resolve();\n        });\n    }\n    load() {\n        return Promise.resolve(false);\n    }\n    remove() {\n        return Promise.resolve();\n    }\n    get sessionId() {\n        var _a, _b;\n        return (_b = (_a = this._nativeSession) === null || _a === void 0 ? void 0 : _a.sessionId) !== null && _b !== void 0 ? _b : \"\";\n    }\n    _listenEvent(session) {\n        this._unbindSession(); // If previous session was linked\n        const onEvent = (evt) => {\n            this.trigger(evt.type, evt);\n        };\n        [\"keymessage\", \"message\", \"keyadded\", \"ready\", \"keyerror\", \"error\"].forEach((evt) => {\n            session.addEventListener(evt, onEvent);\n            session.addEventListener(`webkit${evt}`, onEvent);\n        });\n        this._unbindSession = () => {\n            [\"keymessage\", \"message\", \"keyadded\", \"ready\", \"keyerror\", \"error\"].forEach((evt) => {\n                session.removeEventListener(evt, onEvent);\n                session.removeEventListener(`webkit${evt}`, onEvent);\n            });\n        };\n    }\n}\nclass WebKitCustomMediaKeys {\n    constructor(keyType) {\n        if (WebKitMediaKeysConstructor === undefined) {\n            throw new Error(\"No WebKitMediaKeys API.\");\n        }\n        this._keyType = keyType;\n        this._mediaKeys = new WebKitMediaKeysConstructor(keyType);\n    }\n    _setVideo(videoElement) {\n        this._videoElement = videoElement;\n        if (this._videoElement === undefined) {\n            throw new Error(\"Video not attached to the MediaKeys\");\n        }\n        return setWebKitMediaKeys(this._videoElement, this._mediaKeys);\n    }\n    createSession( /* sessionType */) {\n        if (this._videoElement === undefined || this._mediaKeys === undefined) {\n            throw new Error(\"Video not attached to the MediaKeys\");\n        }\n        return new WebkitMediaKeySession(this._videoElement, this._keyType, this._serverCertificate);\n    }\n    setServerCertificate(serverCertificate) {\n        this._serverCertificate = serverCertificate;\n        return Promise.resolve(true);\n    }\n}\nexport default function getWebKitMediaKeysCallbacks() {\n    if (WebKitMediaKeysConstructor === undefined) {\n        throw new Error(\"No WebKitMediaKeys API.\");\n    }\n    const isTypeSupported = WebKitMediaKeysConstructor.isTypeSupported;\n    const createCustomMediaKeys = (keyType) => new WebKitCustomMediaKeys(keyType);\n    const setMediaKeys = (elt, mediaKeys) => {\n        if (mediaKeys === null) {\n            return setWebKitMediaKeys(elt, mediaKeys);\n        }\n        if (!(mediaKeys instanceof WebKitCustomMediaKeys)) {\n            throw new Error(\"Custom setMediaKeys is supposed to be called \" + \"with webkit custom MediaKeys.\");\n        }\n        return mediaKeys._setVideo(elt);\n    };\n    return {\n        isTypeSupported,\n        createCustomMediaKeys,\n        setMediaKeys,\n    };\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport globalScope from \"../../../utils/global_scope\";\nlet WebKitMediaKeysConstructor;\nconst { WebKitMediaKeys } = globalScope;\nif (WebKitMediaKeys !== undefined &&\n    typeof WebKitMediaKeys.isTypeSupported === \"function\" &&\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    typeof WebKitMediaKeys.prototype.createSession === \"function\" &&\n    typeof HTMLMediaElement.prototype.webkitSetMediaKeys === \"function\") {\n    WebKitMediaKeysConstructor = WebKitMediaKeys;\n}\nexport { WebKitMediaKeysConstructor };\n","import { MediaError } from \"../../errors\";\nimport assert from \"../../utils/assert\";\nimport globalScope from \"../../utils/global_scope\";\nimport isNode from \"../../utils/is_node\";\nimport isNullOrUndefined from \"../../utils/is_null_or_undefined\";\nimport objectAssign from \"../../utils/object_assign\";\nimport { isIE11 } from \"../browser_detection\";\nimport { createCompatibleEventListener } from \"../event_listeners\";\nimport shouldFavourCustomSafariEME from \"../should_favour_custom_safari_EME\";\nimport CustomMediaKeySystemAccess from \"./custom_key_system_access\";\nimport getIE11MediaKeysCallbacks, { MSMediaKeysConstructor, } from \"./custom_media_keys/ie11_media_keys\";\nimport getMozMediaKeysCallbacks, { MozMediaKeysConstructor, } from \"./custom_media_keys/moz_media_keys_constructor\";\nimport getOldKitWebKitMediaKeyCallbacks, { isOldWebkitMediaElement, } from \"./custom_media_keys/old_webkit_media_keys\";\nimport getWebKitMediaKeysCallbacks from \"./custom_media_keys/webkit_media_keys\";\nimport { WebKitMediaKeysConstructor } from \"./custom_media_keys/webkit_media_keys_constructor\";\n/**\n * Automatically detect and set which EME implementation should be used in the\n * current platform.\n *\n * You can call `getEmeApiImplementation` for a different implementation.\n */\nconst defaultEmeImplementation = getEmeApiImplementation(\"auto\");\nexport default defaultEmeImplementation;\n/**\n * Returns the current EME implementation based on what's present on the device\n * and the given preference.\n * @param {string} preferredApiType - EME API preference\n * (@see IPreferredEmeApiType).\n * @returns {Object}\n */\nfunction getEmeApiImplementation(preferredApiType) {\n    var _a;\n    let requestMediaKeySystemAccess;\n    let onEncrypted;\n    let setMediaKeys = defaultSetMediaKeys;\n    let implementation;\n    if ((preferredApiType === \"standard\" ||\n        (preferredApiType === \"auto\" && !shouldFavourCustomSafariEME())) &&\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        (isNode || !isNullOrUndefined(navigator.requestMediaKeySystemAccess))) {\n        requestMediaKeySystemAccess = (...args) => navigator.requestMediaKeySystemAccess(...args);\n        onEncrypted = createCompatibleEventListener([\"encrypted\"]);\n        implementation = \"standard\";\n    }\n    else {\n        let isTypeSupported;\n        let createCustomMediaKeys;\n        if (preferredApiType === \"webkit\" && WebKitMediaKeysConstructor !== undefined) {\n            const callbacks = getWebKitMediaKeysCallbacks();\n            onEncrypted = createOnEncryptedForWebkit();\n            isTypeSupported = callbacks.isTypeSupported;\n            createCustomMediaKeys = callbacks.createCustomMediaKeys;\n            setMediaKeys = callbacks.setMediaKeys;\n            implementation = \"webkit\";\n        }\n        else {\n            // This is for Chrome with unprefixed EME api\n            if (isOldWebkitMediaElement((_a = globalScope.HTMLVideoElement) === null || _a === void 0 ? void 0 : _a.prototype)) {\n                onEncrypted = createCompatibleEventListener([\"needkey\"]);\n                const callbacks = getOldKitWebKitMediaKeyCallbacks();\n                isTypeSupported = callbacks.isTypeSupported;\n                createCustomMediaKeys = callbacks.createCustomMediaKeys;\n                setMediaKeys = callbacks.setMediaKeys;\n                implementation = \"older-webkit\";\n                // This is for WebKit with prefixed EME api\n            }\n            else if (WebKitMediaKeysConstructor !== undefined) {\n                onEncrypted = createOnEncryptedForWebkit();\n                const callbacks = getWebKitMediaKeysCallbacks();\n                isTypeSupported = callbacks.isTypeSupported;\n                createCustomMediaKeys = callbacks.createCustomMediaKeys;\n                setMediaKeys = callbacks.setMediaKeys;\n                implementation = \"webkit\";\n            }\n            else if (isIE11 && MSMediaKeysConstructor !== undefined) {\n                onEncrypted = createCompatibleEventListener([\"encrypted\", \"needkey\"]);\n                const callbacks = getIE11MediaKeysCallbacks();\n                isTypeSupported = callbacks.isTypeSupported;\n                createCustomMediaKeys = callbacks.createCustomMediaKeys;\n                setMediaKeys = callbacks.setMediaKeys;\n                implementation = \"ms\";\n            }\n            else if (MozMediaKeysConstructor !== undefined) {\n                onEncrypted = createCompatibleEventListener([\"encrypted\", \"needkey\"]);\n                const callbacks = getMozMediaKeysCallbacks();\n                isTypeSupported = callbacks.isTypeSupported;\n                createCustomMediaKeys = callbacks.createCustomMediaKeys;\n                setMediaKeys = callbacks.setMediaKeys;\n                implementation = \"moz\";\n            }\n            else {\n                onEncrypted = createCompatibleEventListener([\"encrypted\", \"needkey\"]);\n                const MK = globalScope.MediaKeys;\n                const checkForStandardMediaKeys = () => {\n                    if (MK === undefined) {\n                        throw new MediaError(\"MEDIA_KEYS_NOT_SUPPORTED\", \"No `MediaKeys` implementation found \" + \"in the current browser.\");\n                    }\n                    if (typeof MK.isTypeSupported === \"undefined\") {\n                        const message = \"This browser seems to be unable to play encrypted \" +\n                            \"contents currently.\" +\n                            \"Note: Some browsers do not allow decryption \" +\n                            \"in some situations, like when not using HTTPS.\";\n                        throw new Error(message);\n                    }\n                };\n                isTypeSupported = (keyType) => {\n                    checkForStandardMediaKeys();\n                    assert(typeof MK.isTypeSupported === \"function\");\n                    return MK.isTypeSupported(keyType);\n                };\n                createCustomMediaKeys = (keyType) => {\n                    checkForStandardMediaKeys();\n                    return new MK(keyType);\n                };\n                implementation = \"unknown\";\n            }\n        }\n        requestMediaKeySystemAccess = function (keyType, keySystemConfigurations) {\n            if (!isTypeSupported(keyType)) {\n                return Promise.reject(new Error(\"Unsupported key type\"));\n            }\n            for (let i = 0; i < keySystemConfigurations.length; i++) {\n                const keySystemConfiguration = keySystemConfigurations[i];\n                const { videoCapabilities, audioCapabilities, initDataTypes, distinctiveIdentifier, } = keySystemConfiguration;\n                let supported = true;\n                supported =\n                    supported &&\n                        (isNullOrUndefined(initDataTypes) ||\n                            initDataTypes.some((idt) => idt === \"cenc\"));\n                supported = supported && distinctiveIdentifier !== \"required\";\n                if (supported) {\n                    const keySystemConfigurationResponse = {\n                        initDataTypes: [\"cenc\"],\n                        distinctiveIdentifier: \"not-allowed\",\n                        persistentState: \"required\",\n                        sessionTypes: [\"temporary\", \"persistent-license\"],\n                    };\n                    if (videoCapabilities !== undefined) {\n                        keySystemConfigurationResponse.videoCapabilities = videoCapabilities;\n                    }\n                    if (audioCapabilities !== undefined) {\n                        keySystemConfigurationResponse.audioCapabilities = audioCapabilities;\n                    }\n                    const customMediaKeys = createCustomMediaKeys(keyType);\n                    return Promise.resolve(new CustomMediaKeySystemAccess(keyType, customMediaKeys, keySystemConfigurationResponse));\n                }\n            }\n            return Promise.reject(new Error(\"Unsupported configuration\"));\n        };\n    }\n    return {\n        requestMediaKeySystemAccess,\n        onEncrypted,\n        setMediaKeys,\n        implementation,\n    };\n}\n/**\n * Create an event listener for the \"webkitneedkey\" event\n * @returns\n */\nfunction createOnEncryptedForWebkit() {\n    const compatibleEventListener = createCompatibleEventListener([\"needkey\"], undefined /* prefixes */);\n    const onEncrypted = (target, listener, cancelSignal) => {\n        compatibleEventListener(target, (event) => {\n            const patchedEvent = objectAssign(event, {\n                forceSessionRecreation: true,\n            });\n            listener(patchedEvent);\n        }, cancelSignal);\n    };\n    return onEncrypted;\n}\n/**\n * Set the given MediaKeys on the given HTMLMediaElement.\n * Emits null when done then complete.\n * @param {HTMLMediaElement} elt\n * @param {Object} mediaKeys\n * @returns {Promise}\n */\nfunction defaultSetMediaKeys(elt, mediaKeys) {\n    try {\n        let ret;\n        if (typeof elt.setMediaKeys === \"function\") {\n            // eslint-disable-next-line @typescript-eslint/no-restricted-types\n            ret = elt.setMediaKeys(mediaKeys);\n        }\n        // If we get in the following code, it means that no compat case has been\n        // found and no standard setMediaKeys API exists. This case is particulary\n        // rare. We will try to call each API with native media keys.\n        else if (typeof elt.webkitSetMediaKeys === \"function\") {\n            ret = elt.webkitSetMediaKeys(mediaKeys);\n        }\n        else if (typeof elt.mozSetMediaKeys === \"function\") {\n            ret = elt.mozSetMediaKeys(mediaKeys);\n        }\n        else if (typeof elt.msSetMediaKeys === \"function\" && mediaKeys !== null) {\n            ret = elt.msSetMediaKeys(mediaKeys);\n        }\n        if (typeof ret === \"object\" &&\n            ret !== null &&\n            typeof ret.then === \"function\") {\n            return ret;\n        }\n        else {\n            return Promise.resolve(ret);\n        }\n    }\n    catch (err) {\n        return Promise.reject(err);\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../log\";\nimport { getNextBoxOffsets } from \"../../parsers/containers/isobmff\";\nimport { be4toi, concat } from \"../../utils/byte_parsing\";\nimport { PSSH_TO_INTEGER } from \"./constants\";\n/**\n * Modify \"initialization data\" sent to a `generateKeyRequest` EME call to\n * improve the player's browser compatibility:\n *\n *   1. some browsers/CDM have problems when the CENC PSSH box is the first\n *      encountered PSSH box in the initialization data (for the moment just\n *      Edge was noted with this behavior).\n *      We found however that it works on every browser when the CENC pssh\n *      box(es) is/are the last box(es) encountered.\n *\n *      To that end, we move CENC pssh boxes at the end of the initialization\n *      data in this function.\n *\n *   2. Some poorly encoded/packaged contents communicate both a CENC with a\n *      pssh version of 0 and one with a version of 1. We found out that this is\n *      not always well handled on some devices/browsers (on Edge and some other\n *      embedded devices that shall remain nameless for now!).\n *\n *      Here this function will filter out CENC pssh with a version different to\n *      1 when one(s) with a version of 1 is/are already present.\n *\n * If the initData is unrecognized or if a CENC PSSH is not found, this function\n * throws.\n * @param {Uint8Array} initData - Initialization data you want to patch\n * @returns {Uint8Array} - Initialization data, patched\n */\nexport function patchInitData(initData) {\n    log.info(\"Compat: Trying to move CENC PSSH from init data at the end of it.\");\n    let foundCencV1 = false;\n    let concatenatedCencs = new Uint8Array();\n    let resInitData = new Uint8Array();\n    let offset = 0;\n    while (offset < initData.length) {\n        if (initData.length < offset + 8 ||\n            be4toi(initData, offset + 4) !== PSSH_TO_INTEGER) {\n            log.warn(\"Compat: unrecognized initialization data. Cannot patch it.\");\n            throw new Error(\"Compat: unrecognized initialization data. Cannot patch it.\");\n        }\n        const len = be4toi(new Uint8Array(initData), offset);\n        if (offset + len > initData.length) {\n            log.warn(\"Compat: unrecognized initialization data. Cannot patch it.\");\n            throw new Error(\"Compat: unrecognized initialization data. Cannot patch it.\");\n        }\n        const currentPSSH = initData.subarray(offset, offset + len);\n        // yep\n        if (initData[offset + 12] === 0x10 &&\n            initData[offset + 13] === 0x77 &&\n            initData[offset + 14] === 0xef &&\n            initData[offset + 15] === 0xec &&\n            initData[offset + 16] === 0xc0 &&\n            initData[offset + 17] === 0xb2 &&\n            initData[offset + 18] === 0x4d &&\n            initData[offset + 19] === 0x02 &&\n            initData[offset + 20] === 0xac &&\n            initData[offset + 21] === 0xe3 &&\n            initData[offset + 22] === 0x3c &&\n            initData[offset + 23] === 0x1e &&\n            initData[offset + 24] === 0x52 &&\n            initData[offset + 25] === 0xe2 &&\n            initData[offset + 26] === 0xfb &&\n            initData[offset + 27] === 0x4b) {\n            const cencOffsets = getNextBoxOffsets(currentPSSH);\n            const version = cencOffsets === null ? undefined : currentPSSH[cencOffsets[1]];\n            log.info(\"Compat: CENC PSSH found with version\", version);\n            if (version === undefined) {\n                log.warn(\"Compat: could not read version of CENC PSSH\");\n            }\n            else if (foundCencV1 === (version === 1)) {\n                // Either `concatenatedCencs` only contains v1 or does not contain any\n                concatenatedCencs = concat(concatenatedCencs, currentPSSH);\n            }\n            else if (version === 1) {\n                log.warn(\"Compat: cenc version 1 encountered, \" + \"removing every other cenc pssh box.\");\n                concatenatedCencs = currentPSSH;\n                foundCencV1 = true;\n            }\n            else {\n                log.warn(\"Compat: filtering out cenc pssh box with wrong version\", version);\n            }\n        }\n        else {\n            resInitData = concat(resInitData, currentPSSH);\n        }\n        offset += len;\n    }\n    if (offset !== initData.length) {\n        log.warn(\"Compat: unrecognized initialization data. Cannot patch it.\");\n        throw new Error(\"Compat: unrecognized initialization data. Cannot patch it.\");\n    }\n    return concat(resInitData, concatenatedCencs);\n}\n/**\n * Generate a request from session.\n * @param {MediaKeySession} session - MediaKeySession on which the request will\n * be done.\n * @param {string} initializationDataType - Initialization data type given e.g.\n * by the \"encrypted\" event for the corresponding request.\n * @param {Uint8Array} initializationData - Initialization data given e.g. by\n * the \"encrypted\" event for the corresponding request.\n * @returns {Promise} - Emit when done. Errors if fails.\n */\nexport default function generateKeyRequest(session, initializationDataType, initializationData) {\n    log.debug(\"Compat: Calling generateRequest on the MediaKeySession\");\n    let patchedInit;\n    try {\n        patchedInit = patchInitData(initializationData);\n    }\n    catch (_e) {\n        patchedInit = initializationData;\n    }\n    const initDataType = initializationDataType !== null && initializationDataType !== void 0 ? initializationDataType : \"\";\n    return session.generateRequest(initDataType, patchedInit).catch((error) => {\n        if (initDataType !== \"\" || !(error instanceof TypeError)) {\n            throw error;\n        }\n        // On newer EME versions of the specification, the initialization data\n        // type given to generateRequest cannot be an empty string (it returns\n        // a rejected promise with a TypeError in that case).\n        // Retry with a default \"cenc\" value for initialization data type if\n        // we're in that condition.\n        log.warn(\"Compat: error while calling `generateRequest` with an empty \" +\n            'initialization data type. Retrying with a default \"cenc\" value.', error);\n        return session.generateRequest(\"cenc\", patchedInit);\n    });\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../log\";\nimport { getPsshSystemID } from \"../../parsers/containers/isobmff\";\nimport areArraysOfNumbersEqual from \"../../utils/are_arrays_of_numbers_equal\";\nimport { be4toi } from \"../../utils/byte_parsing\";\nimport isNullOrUndefined from \"../../utils/is_null_or_undefined\";\nimport { PSSH_TO_INTEGER } from \"./constants\";\n/**\n * Take in input initialization data from an encrypted event and generate the\n * corresponding array of initialization data values from it.\n *\n * At the moment, this function only handles initialization data which have the\n * \"cenc\" initialization data type.\n * It will just return a single value with an `undefined` `systemId` for all\n * other types of data.\n * @param {Uint8Array} initData - Raw initialization data\n * @returns {Array.<Object>}\n */\nfunction getInitializationDataValues(initData) {\n    const result = [];\n    let offset = 0;\n    while (offset < initData.length) {\n        if (initData.length < offset + 8 ||\n            be4toi(initData, offset + 4) !== PSSH_TO_INTEGER) {\n            log.warn(\"Compat: Unrecognized initialization data. Use as is.\");\n            return [{ systemId: undefined, data: initData }];\n        }\n        const len = be4toi(new Uint8Array(initData), offset);\n        if (offset + len > initData.length) {\n            log.warn(\"Compat: Unrecognized initialization data. Use as is.\");\n            return [{ systemId: undefined, data: initData }];\n        }\n        const currentPSSH = initData.subarray(offset, offset + len);\n        const systemId = getPsshSystemID(currentPSSH, 8);\n        const currentItem = { systemId, data: currentPSSH };\n        if (isPSSHAlreadyEncountered(result, currentItem)) {\n            // As we observed on some browsers (IE and Edge), the initialization data on\n            // some segments have sometimes duplicated PSSH when sent through an encrypted\n            // event (but not when the corresponding segment has been pushed to the\n            // SourceBuffer).\n            // We prefer filtering them out, to avoid further issues.\n            log.warn(\"Compat: Duplicated PSSH found in initialization data, removing it.\");\n        }\n        else {\n            result.push(currentItem);\n        }\n        offset += len;\n    }\n    if (offset !== initData.length) {\n        log.warn(\"Compat: Unrecognized initialization data. Use as is.\");\n        return [{ systemId: undefined, data: initData }];\n    }\n    return result;\n}\n/**\n * Returns `true` if the given PSSH has already been stored in the\n * `encounteredPSSHs` cache given.\n * Returns `false` otherwise.\n * @param {Array.<Object>} encounteredPSSHs\n * @param {Uint8Array} pssh\n * @returns {boolean}\n */\nfunction isPSSHAlreadyEncountered(encounteredPSSHs, pssh) {\n    for (let i = 0; i < encounteredPSSHs.length; i++) {\n        const item = encounteredPSSHs[i];\n        if (pssh.systemId === undefined ||\n            item.systemId === undefined ||\n            pssh.systemId === item.systemId) {\n            if (areArraysOfNumbersEqual(pssh.data, item.data)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n/**\n * Take out the two things we need on an encryptedEvent:\n *   - the initialization Data\n *   - the initialization Data type\n *\n * @param {MediaEncryptedEvent} encryptedEvent - Payload received with an\n * \"encrypted\" event.\n * @returns {Object} - Initialization data and Initialization data type.\n * @throws {EncryptedMediaError} - Throws if no initialization data is\n * encountered in the given event.\n */\nexport default function getInitData(encryptedEvent) {\n    const { initData, initDataType, forceSessionRecreation } = encryptedEvent;\n    if (isNullOrUndefined(initData)) {\n        log.warn(\"Compat: No init data found on media encrypted event.\");\n        return null;\n    }\n    const initDataBytes = new Uint8Array(initData);\n    const values = getInitializationDataValues(initDataBytes);\n    return { type: initDataType, values, forceSessionRecreation };\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { guidToUuid } from \"../../utils/string_parsing\";\nimport { isEdgeChromium, isIEOrEdge } from \"../browser_detection\";\n/**\n * Get KID from MediaKeySession keyStatus, and convert it in usual big-endian kid\n * if necessary. On EDGE, Microsoft Playready KID are presented into little-endian GUID.\n * @param {String} keySystem\n * @param {Uint8Array} baseKeyId\n * @returns {Uint8Array}\n */\nexport default function getUUIDKIDFromKeyStatusKID(keySystem, baseKeyId) {\n    if (keySystem.indexOf(\"playready\") !== -1 && (isIEOrEdge || isEdgeChromium)) {\n        return guidToUuid(baseKeyId);\n    }\n    return baseKeyId;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { itole4, le4toi } from \"../../utils/byte_parsing\";\nimport { strToUtf16LE, utf16LEToStr } from \"../../utils/string_parsing\";\n/**\n * Create formatted fairplay initdata for WebKit createSession.\n * Layout is :\n * [initData][4 byte: idLength][idLength byte: id]\n * [4 byte:certLength][certLength byte: cert]\n * @param {Uint8Array} initData\n * @param {Uint8Array} serverCertificate\n * @returns {Uint8Array}\n */\nexport default function getWebKitFairPlayInitData(initDataBytes, serverCertificateBytes) {\n    const initData = initDataBytes instanceof Uint8Array ? initDataBytes : new Uint8Array(initDataBytes);\n    const serverCertificate = serverCertificateBytes instanceof Uint8Array\n        ? serverCertificateBytes\n        : new Uint8Array(serverCertificateBytes);\n    const length = le4toi(initData, 0);\n    if (length + 4 !== initData.length) {\n        throw new Error(\"Unsupported WebKit initData.\");\n    }\n    const initDataUri = utf16LEToStr(initData);\n    const skdIndexInInitData = initDataUri.indexOf(\"skd://\");\n    const contentIdStr = skdIndexInInitData > -1 ? initDataUri.substring(skdIndexInInitData + 6) : initDataUri;\n    const id = strToUtf16LE(contentIdStr);\n    let offset = 0;\n    const res = new Uint8Array(initData.byteLength +\n        /* id length */ 4 +\n        id.byteLength +\n        /* certificate length */ 4 +\n        serverCertificate.byteLength);\n    res.set(initData);\n    offset += initData.length;\n    res.set(itole4(id.byteLength), offset);\n    offset += 4;\n    res.set(id, offset);\n    offset += id.byteLength;\n    res.set(itole4(serverCertificate.byteLength), offset);\n    offset += 4;\n    res.set(serverCertificate, offset);\n    return res;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport closeSession from \"./close_session\";\nimport defaultEmeImplementation from \"./eme-api-implementation\";\nimport generateKeyRequest from \"./generate_key_request\";\nimport getInitData from \"./get_init_data\";\nimport loadSession from \"./load_session\";\nexport default defaultEmeImplementation;\nexport { closeSession, generateKeyRequest, getInitData, loadSession };\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../log\";\nconst EME_WAITING_DELAY_LOADED_SESSION_EMPTY_KEYSTATUSES = 100;\n/**\n * Load a persistent session, based on its `sessionId`, on the given\n * MediaKeySession.\n *\n * Returns a Promise which resolves with:\n *   - `true` if the persistent MediaKeySession was found and loaded\n *   - `false` if no persistent MediaKeySession was found with that `sessionId`.\n *\n * The Promise rejects if anything goes wrong in the process.\n * @param {MediaKeySession} session\n * @param {string} sessionId\n * @returns {Promise.<boolean>}\n */\nexport default async function loadSession(session, sessionId) {\n    log.info(\"DRM: Load persisted session\", sessionId);\n    const isLoaded = await session.load(sessionId);\n    if (!isLoaded || session.keyStatuses.size > 0) {\n        return isLoaded;\n    }\n    // A browser race condition can exist, seen for example in some\n    // Chromium/Chrome versions where the `keyStatuses` property from a loaded\n    // MediaKeySession would not be populated directly as the load answer but\n    // asynchronously after.\n    return new Promise((resolve) => {\n        session.addEventListener(\"keystatuseschange\", resolveWithLoadedStatus);\n        const timeout = setTimeout(resolveWithLoadedStatus, EME_WAITING_DELAY_LOADED_SESSION_EMPTY_KEYSTATUSES);\n        function resolveWithLoadedStatus() {\n            cleanUp();\n            resolve(isLoaded);\n        }\n        function cleanUp() {\n            clearTimeout(timeout);\n            session.removeEventListener(\"keystatuseschange\", resolveWithLoadedStatus);\n        }\n    });\n}\n","import log from \"../../log\";\nimport sleep from \"../../utils/sleep\";\nimport shouldAwaitSetMediaKeys from \"../should_await_set_media_keys\";\n/**\n * @param {Object} emeImplementation\n * @param {Object} mediaElement\n * @param {Object|null} mediaKeys\n * @returns {Promise}\n */\nexport function setMediaKeys(emeImplementation, mediaElement, mediaKeys) {\n    const prom = emeImplementation\n        .setMediaKeys(mediaElement, mediaKeys)\n        .then(() => {\n        log.info(\"Compat: MediaKeys updated with success\");\n    })\n        .catch((err) => {\n        if (mediaKeys === null) {\n            log.error(\"Compat: Could not reset MediaKeys\", err instanceof Error ? err : \"Unknown Error\");\n            return;\n        }\n        log.error(\"Compat: Could not update MediaKeys\", err instanceof Error ? err : \"Unknown Error\");\n        throw err;\n    });\n    if (shouldAwaitSetMediaKeys()) {\n        return prom;\n    }\n    return Promise.race([\n        prom,\n        // Because we know how much EME has implementation issues, let's not block\n        // everything because that API hangs\n        sleep(1000),\n    ]);\n}\n","import { isTizen } from \"./browser_detection\";\n/**\n * Enable the audio track at the given index while disabling all others in the\n * `audioTracks` array.\n *\n * Returns false if the given index is not found in the `audioTracks` array.\n * @param {array.<audioTrack>} audioTracks\n * @param {number} indexToEnable\n * @returns {boolean}\n */\nexport default function enableAudioTrack(audioTracks, indexToEnable) {\n    // Seen on Safari MacOS only (2022-02-14), not disabling ALL audio tracks\n    // first (even the wanted one), can lead to the media not playing.\n    for (let i = 0; i < audioTracks.length; i++) {\n        // However, Tizen just plays no audio if it is disabled then enabled\n        // synchronously (2022-10-12)\n        if (!isTizen || i !== indexToEnable) {\n            audioTracks[i].enabled = false;\n        }\n    }\n    if (indexToEnable < 0 || indexToEnable >= audioTracks.length) {\n        return false;\n    }\n    audioTracks[indexToEnable].enabled = true;\n    return true;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport config from \"../config\";\nimport log from \"../log\";\nimport globalScope from \"../utils/global_scope\";\nimport isNonEmptyString from \"../utils/is_non_empty_string\";\nimport isNullOrUndefined from \"../utils/is_null_or_undefined\";\nimport noop from \"../utils/noop\";\nimport SharedReference from \"../utils/reference\";\nconst BROWSER_PREFIXES = [\"\", \"webkit\", \"moz\", \"ms\"];\n/**\n * Find the first supported event from the list given.\n * @param {HTMLElement} element\n * @param {string} eventNameSuffix\n * @returns {Boolean}\n */\nfunction isEventSupported(element, eventNameSuffix) {\n    const clone = document.createElement(element.tagName);\n    const eventName = \"on\" + eventNameSuffix;\n    if (eventName in clone) {\n        return true;\n    }\n    else {\n        clone.setAttribute(eventName, \"return;\");\n        return (typeof clone[eventName] ===\n            \"function\");\n    }\n}\n/**\n * Find the first supported event from the list given.\n * @param {HTMLElement} element\n * @param {Array.<string>} eventNames\n * @returns {string|undefined}\n */\nfunction findSupportedEvent(element, eventNames) {\n    return eventNames.filter((name) => isEventSupported(element, name))[0];\n}\n/**\n * @param {Array.<string>} eventNames\n * @param {Array.<string>|undefined} prefixes\n * @returns {Array.<string>}\n */\nfunction eventPrefixed(eventNames, prefixes) {\n    return eventNames.reduce((parent, name) => parent.concat((prefixes === undefined ? BROWSER_PREFIXES : prefixes).map((p) => p + name)), []);\n}\nfunction createCompatibleEventListener(eventNames, prefixes) {\n    let mem;\n    const prefixedEvents = eventPrefixed(eventNames, prefixes);\n    return (element, listener, cancelSignal) => {\n        if (cancelSignal.isCancelled()) {\n            return;\n        }\n        // if the element is a HTMLElement we can detect\n        // the supported event, and memoize it in `mem`\n        if (typeof HTMLElement !== \"undefined\" && element instanceof HTMLElement) {\n            if (typeof mem === \"undefined\") {\n                mem = findSupportedEvent(element, prefixedEvents);\n            }\n            if (isNonEmptyString(mem)) {\n                element.addEventListener(mem, listener);\n                cancelSignal.register(() => {\n                    if (mem !== undefined) {\n                        element.removeEventListener(mem, listener);\n                    }\n                });\n            }\n            else {\n                if (0 /* __ENVIRONMENT__.CURRENT_ENV */ === 1 /* __ENVIRONMENT__.DEV */) {\n                    log.warn(`compat: element ${element.tagName}` +\n                        \" does not support any of these events: \" +\n                        prefixedEvents.join(\", \"));\n                }\n                return;\n            }\n        }\n        prefixedEvents.forEach((eventName) => {\n            let hasSetOnFn = false;\n            if (typeof element.addEventListener === \"function\") {\n                element.addEventListener(eventName, listener);\n            }\n            else {\n                hasSetOnFn = true;\n                element[(\"on\" + eventName)] = listener;\n            }\n            cancelSignal.register(() => {\n                if (typeof element.removeEventListener === \"function\") {\n                    element.removeEventListener(eventName, listener);\n                }\n                if (hasSetOnFn) {\n                    delete element[(\"on\" + eventName)];\n                }\n            });\n        });\n    };\n}\n/**\n * Returns a reference:\n *   - set to `true` when the document is visible\n *   - set to `false` when the document is hidden\n * @param {Object} stopListening - `CancellationSignal` allowing to free the\n * ressources allocated to update this value.\n * @returns {Object}\n */\nfunction getDocumentVisibilityRef(stopListening) {\n    let prefix;\n    const doc = document;\n    if (!isNullOrUndefined(doc.hidden)) {\n        prefix = \"\";\n    }\n    else if (!isNullOrUndefined(doc.mozHidden)) {\n        prefix = \"moz\";\n    }\n    else if (!isNullOrUndefined(doc.msHidden)) {\n        prefix = \"ms\";\n    }\n    else if (!isNullOrUndefined(doc.webkitHidden)) {\n        prefix = \"webkit\";\n    }\n    const hidden = isNonEmptyString(prefix) ? (prefix + \"Hidden\") : \"hidden\";\n    const visibilityChangeEvent = isNonEmptyString(prefix)\n        ? prefix + \"visibilitychange\"\n        : \"visibilitychange\";\n    const isHidden = document[hidden];\n    const ref = new SharedReference(!isHidden, stopListening);\n    addEventListener(document, visibilityChangeEvent, () => {\n        const isVisible = !document[hidden];\n        ref.setValueIfChanged(isVisible);\n    }, stopListening);\n    return ref;\n}\n/**\n * Emit when video enters and leaves Picture-In-Picture mode.\n * @param {HTMLMediaElement} mediaElement\n * @param {Object} stopListening\n * @returns {Object}\n */\nfunction getPictureOnPictureStateRef(mediaElement, stopListening) {\n    if (mediaElement.webkitSupportsPresentationMode === true &&\n        typeof mediaElement.webkitSetPresentationMode === \"function\") {\n        const isWebKitPIPEnabled = mediaElement.webkitPresentationMode === \"picture-in-picture\";\n        const ref = new SharedReference({\n            isEnabled: isWebKitPIPEnabled,\n            pipWindow: null,\n        }, stopListening);\n        addEventListener(mediaElement, \"webkitpresentationmodechanged\", () => {\n            const isEnabled = mediaElement.webkitPresentationMode === \"picture-in-picture\";\n            ref.setValue({ isEnabled, pipWindow: null });\n        }, stopListening);\n        return ref;\n    }\n    const isPIPEnabled = document.pictureInPictureElement === mediaElement;\n    const ref = new SharedReference({ isEnabled: isPIPEnabled, pipWindow: null }, stopListening);\n    addEventListener(mediaElement, \"enterpictureinpicture\", (evt) => {\n        var _a;\n        ref.setValue({\n            isEnabled: true,\n            pipWindow: (_a = evt.pictureInPictureWindow) !== null && _a !== void 0 ? _a : null,\n        });\n    }, stopListening);\n    addEventListener(mediaElement, \"leavepictureinpicture\", () => {\n        ref.setValue({ isEnabled: false, pipWindow: null });\n    }, stopListening);\n    return ref;\n}\n/**\n * Returns a reference:\n *   - Set to `true` when video is considered as visible (the page is visible\n *     and/or the Picture-In-Picture is activated).\n *   - Set to `false` otherwise.\n * @param {Object} pipStatus\n * @param {Object} stopListening - `CancellationSignal` allowing to free the\n * resources reserved to listen to video visibility change.\n * @returns {Object}\n */\nfunction getVideoVisibilityRef(pipStatus, stopListening) {\n    const isDocVisibleRef = getDocumentVisibilityRef(stopListening);\n    let currentTimeout;\n    const ref = new SharedReference(true, stopListening);\n    stopListening.register(() => {\n        clearTimeout(currentTimeout);\n        currentTimeout = undefined;\n    });\n    isDocVisibleRef.onUpdate(checkCurrentVisibility, {\n        clearSignal: stopListening,\n    });\n    pipStatus.onUpdate(checkCurrentVisibility, { clearSignal: stopListening });\n    checkCurrentVisibility();\n    return ref;\n    function checkCurrentVisibility() {\n        clearTimeout(currentTimeout);\n        currentTimeout = undefined;\n        if (pipStatus.getValue().isEnabled || isDocVisibleRef.getValue()) {\n            ref.setValueIfChanged(true);\n        }\n        else {\n            const { INACTIVITY_DELAY } = config.getCurrent();\n            currentTimeout = setTimeout(() => {\n                ref.setValueIfChanged(false);\n            }, INACTIVITY_DELAY);\n        }\n    }\n}\n/**\n * Get video width and height from the screen dimensions.\n * @param {Object} stopListening\n * @returns {Object}\n */\nfunction getScreenResolutionRef(stopListening) {\n    var _a, _b;\n    const pixelRatio = isNullOrUndefined(globalScope.devicePixelRatio) || globalScope.devicePixelRatio === 0\n        ? 1\n        : globalScope.devicePixelRatio;\n    const ref = new SharedReference({\n        width: (_a = globalScope.screen) === null || _a === void 0 ? void 0 : _a.width,\n        height: (_b = globalScope.screen) === null || _b === void 0 ? void 0 : _b.height,\n        pixelRatio,\n    }, stopListening);\n    const interval = setInterval(checkScreenResolution, 20000);\n    stopListening.register(function stopUpdating() {\n        clearInterval(interval);\n    });\n    return ref;\n    function checkScreenResolution() {\n        const oldVal = ref.getValue();\n        if (oldVal.width !== screen.width ||\n            oldVal.height !== screen.height ||\n            oldVal.pixelRatio !== pixelRatio) {\n            ref.setValue({ width: screen.width, height: screen.height, pixelRatio });\n        }\n    }\n}\n/**\n * Get video width and height from HTML media element, or video estimated\n * dimensions when Picture-in-Picture is activated.\n * @param {HTMLMediaElement} mediaElement\n * @param {Object} pipStatusRef\n * @param {Object} stopListening\n * @returns {Object}\n */\nfunction getElementResolutionRef(mediaElement, pipStatusRef, stopListening) {\n    const pixelRatio = isNullOrUndefined(globalScope.devicePixelRatio) || globalScope.devicePixelRatio === 0\n        ? 1\n        : globalScope.devicePixelRatio;\n    const ref = new SharedReference({\n        width: mediaElement.clientWidth,\n        height: mediaElement.clientHeight,\n        pixelRatio,\n    }, stopListening);\n    let clearPreviousEventListener = noop;\n    pipStatusRef.onUpdate(checkElementResolution, { clearSignal: stopListening });\n    addEventListener(globalScope, \"resize\", checkElementResolution, stopListening);\n    addEventListener(mediaElement, \"enterpictureinpicture\", checkElementResolution, stopListening);\n    addEventListener(mediaElement, \"leavepictureinpicture\", checkElementResolution, stopListening);\n    const interval = setInterval(checkElementResolution, 20000);\n    checkElementResolution();\n    stopListening.register(function stopUpdating() {\n        clearPreviousEventListener();\n        clearInterval(interval);\n    });\n    return ref;\n    function checkElementResolution() {\n        clearPreviousEventListener();\n        const pipStatus = pipStatusRef.getValue();\n        const { pipWindow } = pipStatus;\n        if (!pipStatus.isEnabled) {\n            const oldVal = ref.getValue();\n            if (oldVal.width !== mediaElement.clientWidth ||\n                oldVal.height !== mediaElement.clientHeight ||\n                oldVal.pixelRatio !== pixelRatio) {\n                ref.setValue({\n                    width: mediaElement.clientWidth,\n                    height: mediaElement.clientHeight,\n                    pixelRatio,\n                });\n            }\n        }\n        else if (!isNullOrUndefined(pipWindow)) {\n            const onPipResize = () => {\n                updateToPipWindowResolution();\n            };\n            pipWindow.addEventListener(\"resize\", onPipResize);\n            clearPreviousEventListener = () => {\n                pipWindow.removeEventListener(\"resize\", onPipResize);\n                clearPreviousEventListener = noop;\n            };\n            updateToPipWindowResolution();\n        }\n        else {\n            const oldVal = ref.getValue();\n            if (oldVal.width !== undefined ||\n                oldVal.height !== undefined ||\n                oldVal.pixelRatio !== pixelRatio) {\n                ref.setValue({ width: undefined, height: undefined, pixelRatio });\n            }\n        }\n        function updateToPipWindowResolution() {\n            const oldVal = ref.getValue();\n            if (oldVal.width !== (pipWindow === null || pipWindow === void 0 ? void 0 : pipWindow.width) ||\n                oldVal.height !== (pipWindow === null || pipWindow === void 0 ? void 0 : pipWindow.height) ||\n                oldVal.pixelRatio !== pixelRatio) {\n                ref.setValue({\n                    width: pipWindow === null || pipWindow === void 0 ? void 0 : pipWindow.width,\n                    height: pipWindow === null || pipWindow === void 0 ? void 0 : pipWindow.height,\n                    pixelRatio,\n                });\n            }\n        }\n    }\n}\n/**\n * @param {HTMLMediaElement} mediaElement\n */\nconst onLoadedMetadata = createCompatibleEventListener([\"loadedmetadata\"]);\n/**\n * @param {HTMLMediaElement} mediaElement\n */\nconst onTimeUpdate = createCompatibleEventListener([\"timeupdate\"]);\n/**\n * @param {TextTrackList} mediaElement\n */\nconst onTextTrackAdded = createCompatibleEventListener([\"addtrack\"]);\n/**\n * @param {TextTrackList} textTrackList\n */\nconst onTextTrackRemoved = createCompatibleEventListener([\"removetrack\"]);\n/**\n * @param {MediaSource} mediaSource\n * @param {Function} listener\n * @param {Object} cancelSignal\n */\nconst onSourceOpen = createCompatibleEventListener([\"sourceopen\", \"webkitsourceopen\"]);\n/**\n * @param {MediaSource} mediaSource\n * @param {Function} listener\n * @param {Object} cancelSignal\n */\nconst onSourceClose = createCompatibleEventListener([\"sourceclose\", \"webkitsourceclose\"]);\n/**\n * @param {MediaSource} mediaSource\n * @param {Function} listener\n * @param {Object} cancelSignal\n */\nconst onSourceEnded = createCompatibleEventListener([\"sourceended\", \"webkitsourceended\"]);\n/**\n * @param {MediaSource} mediaSource\n * @param {Function} listener\n * @param {Object} cancelSignal\n */\nconst onSourceBufferUpdate = createCompatibleEventListener([\"update\"]);\n/**\n * @param {SourceBufferList} sourceBuffers\n * @param {Function} listener\n * @param {Object} cancelSignal\n */\nconst onRemoveSourceBuffers = createCompatibleEventListener([\"removesourcebuffer\"]);\n/**\n * @param {MediaKeySession} mediaKeySession\n */\nconst onKeyMessage = createCompatibleEventListener([\"keymessage\", \"message\"]);\n/**\n * @param {MediaKeySession} mediaKeySession\n */\nconst onKeyAdded = createCompatibleEventListener([\"keyadded\", \"ready\"]);\n/**\n * @param {MediaKeySession} mediaKeySession\n */\nconst onKeyError = createCompatibleEventListener([\"keyerror\", \"error\"]);\n/**\n * @param {MediaKeySession} mediaKeySession\n */\nconst onKeyStatusesChange = createCompatibleEventListener([\"keystatuseschange\"]);\n/**\n * @param {HTMLMediaElement} mediaElement\n */\nconst onSeeking = createCompatibleEventListener([\"seeking\"]);\n/**\n * @param {HTMLMediaElement} mediaElement\n */\nconst onSeeked = createCompatibleEventListener([\"seeked\"]);\n/**\n * @param {HTMLMediaElement} mediaElement\n */\nconst onEnded = createCompatibleEventListener([\"ended\"]);\n/**\n * Utilitary function allowing to add an event listener and remove it\n * automatically once the given `CancellationSignal` emits.\n * @param {EventTarget} elt - The element on which should be attached the event\n * listener.\n * @param {string} evt - The event you wish to listen to\n * @param {Function} listener - The listener function\n * @param {Object} stopListening - Removes the event listener once this signal\n * emits\n */\nfunction addEventListener(elt, evt, listener, stopListening) {\n    elt.addEventListener(evt, listener);\n    stopListening.register(() => {\n        elt.removeEventListener(evt, listener);\n    });\n}\nexport { addEventListener, createCompatibleEventListener, getPictureOnPictureStateRef, getVideoVisibilityRef, getElementResolutionRef, getScreenResolutionRef, onEnded, onKeyAdded, onKeyError, onKeyMessage, onKeyStatusesChange, onLoadedMetadata, onRemoveSourceBuffers, onSeeked, onSeeking, onSourceClose, onSourceEnded, onSourceOpen, onTimeUpdate, onSourceBufferUpdate, onTextTrackAdded, onTextTrackRemoved, };\n","import { itole4, itobe4, itole2, concat } from \"../utils/byte_parsing\";\nimport { strToUtf8, strToUtf16LE, hexToBytes } from \"../utils/string_parsing\";\n/**\n * The PlayReadyHeader sample that will be used to test if the CDM is supported.\n * The KID does not matter because no content will be played, it's only to check if\n * the CDM is capable of creating a session and generating a request.\n */\nexport const DUMMY_PLAY_READY_HEADER = '<WRMHEADER xmlns=\"http://schemas.microsoft.com/DRM/2007/03/PlayReadyHeader\" version=\"4.0.0.0\"><DATA><PROTECTINFO><KEYLEN>16</KEYLEN><ALGID>AESCTR</ALGID></PROTECTINFO><KID>ckB07BNLskeUq0qd83fTbA==</KID><DS_ID>yYIPDBca1kmMfL60IsfgAQ==</DS_ID><CUSTOMATTRIBUTES xmlns=\"\"><encryptionref>312_4024_2018127108</encryptionref></CUSTOMATTRIBUTES><CHECKSUM>U/tsUYRgMzw=</CHECKSUM></DATA></WRMHEADER>';\n/**\n * Generate the \"cenc\" init data for playready from the PlayreadyHeader string.\n * @param {string} playreadyHeader - String representing the PlayreadyHeader XML.\n * @returns {Uint8Array} The init data generated for that PlayreadyHeader.\n * @see https://learn.microsoft.com/en-us/playready/specifications/playready-header-specification\n */\nexport function generatePlayReadyInitData(playreadyHeader) {\n    const recordValueEncoded = strToUtf16LE(playreadyHeader);\n    const recordLength = itole2(recordValueEncoded.length);\n    // RecordType: 0x0001\tIndicates that the record contains a PlayReady Header (PRH).\n    const recordType = new Uint8Array([1, 0]);\n    const numberOfObjects = new Uint8Array([1, 0]); // 1 PlayReady object\n    /* playReadyObjectLength equals = X bytes for record + 2 bytes for record length,\n    + 2 bytes for record types + 2 bytes for number of object  */\n    const playReadyObjectLength = itole4(recordValueEncoded.length + 6);\n    const playReadyObject = concat(playReadyObjectLength, // 4 bytes for the Playready object length\n    numberOfObjects, // 2 bytes for the number of PlayReady objects\n    recordType, // 2 bytes for record type\n    recordLength, // 2 bytes for record length\n    recordValueEncoded);\n    /**  the systemId is define at https://dashif.org/identifiers/content_protection/ */\n    const playreadySystemId = hexToBytes(\"9a04f07998404286ab92e65be0885f95\");\n    return generateInitData(playReadyObject, playreadySystemId);\n}\n/**\n * Generate the \"cenc\" initData given the data and the systemId to use.\n * Note this will generate an initData for version 0 of pssh.\n * @param data - The data that is contained inside the pssh.\n * @param systemId - The systemId to use.\n * @returns\n */\nfunction generateInitData(data, systemId) {\n    const psshBoxName = strToUtf8(\"pssh\");\n    const versionAndFlags = new Uint8Array([0, 0, 0, 0]); // pssh version 0\n    const sizeOfData = itobe4(data.length);\n    const psshSize = itobe4(4 /* pssh size */ +\n        4 /* pssh box */ +\n        4 /* version and flags */ +\n        16 /* systemId */ +\n        4 /* size of data */ +\n        data.length /* data */);\n    return concat(psshSize, // 4 bytes for the pssh size\n    psshBoxName, // 4 bytes for the pssh box\n    versionAndFlags, // 4 bytes for version and flags\n    systemId, // 16 bytes for the systemId\n    sizeOfData, // 4 bytes for the data size\n    data);\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Calculating a live-offseted media position necessitate to obtain first an\n * offset, and then adding that offset to the wanted position.\n *\n * That offset is in most case present inside the Manifest file, yet in cases\n * without it or without a Manifest, such as the \"directfile\" mode, the RxPlayer\n * won't know that offset.\n *\n * Thankfully Safari declares a `getStartDate` method allowing to obtain that\n * offset when available. This logic is mainly useful when playing HLS contents\n * in directfile mode on Safari.\n * @param {HTMLMediaElement} mediaElement\n * @returns {number|undefined}\n */\nexport default function getStartDate(mediaElement) {\n    const _mediaElement = mediaElement;\n    if (typeof _mediaElement.getStartDate === \"function\") {\n        const startDate = _mediaElement.getStartDate();\n        if (typeof startDate === \"object\" && startDate !== null) {\n            const startDateNum = +startDate;\n            if (!isNaN(startDateNum)) {\n                return startDateNum / 1000;\n            }\n        }\n        else if (typeof startDate === \"number\" && !isNaN(startDate)) {\n            return startDate;\n        }\n    }\n}\n","import { isPlayStation5 } from \"./browser_detection\";\n/**\n * Some platforms have issues when the `MediaSource`'s `duration` property\n * is set to a very high value (playback freezes) but not when setting it\n * to `Infinity`, which is what the HTML spec as of now (2023-05-15) recommends\n * for live contents.\n *\n * However setting the `MediaSource`'s `duration` property to `Infinity` seems\n * more risky, considering all platforms we now support, than setting it at a\n * relatively high ~2**32 value which is what we do generally.\n *\n * Moreover, setting it to `Infinity` require us to use another MSE API,\n * `setLiveSeekableRange` to properly allow seeking. We're used to MSE issues so\n * I'm not too confident of using another MSE API for all platforms directly.\n *\n * So this methods just return `true` based on a whitelist of platform for which\n * it has been detected that high `duration` values cause issues but setting it\n * to Infinity AND playing with `setLiveSeekableRange` does not.\n *\n * @returns {boolean}\n */\nexport default function hasIssuesWithHighMediaSourceDuration() {\n    // For now only seen on the Webkit present in the PlayStation 5, for which the\n    // alternative is known to work.\n    return isPlayStation5;\n}\n","const hasMseInWorker = typeof MediaSource === \"function\" &&\n    // eslint-disable-next-line\n    MediaSource.canConstructInDedicatedWorker === true;\nexport default hasMseInWorker;\n","import { isPlayStation4 } from \"./browser_detection\";\n/**\n * Return `true` if the current device is compatible with the Worker API.\n *\n * Some old webkit devices, such as the PlayStation 4, returns weird results\n * when doing the most straightforward check. We have to check if other Webkit\n * devices have the same issue.\n * @returns {boolean}\n */\nexport default function hasWorkerApi() {\n    return isPlayStation4\n        ? typeof Worker === \"object\" || typeof Worker === \"function\"\n        : typeof Worker === \"function\";\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../log\";\nimport isNullOrUndefined from \"../utils/is_null_or_undefined\";\nimport isWorker from \"../utils/is_worker\";\nimport { MediaSource_ } from \"./browser_compatibility_types\";\n/**\n * Setting this value limit the number of entries in the support map\n * preventing important memory usage, value is arbitrary\n */\nconst MAX_SUPPORT_MAP_ENTRIES = 200;\n/**\n * caching the codec support reduce the amount of call to `isTypeSupported`\n * and help for performance especially on low-end devices.\n */\nconst supportMap = new Map();\n/**\n * Returns true if the given codec is supported by the browser's MediaSource\n * implementation.\n * @param {string} mimeType - The MIME media type that you want to test support\n * for in the current browser.\n * This may include the codecs parameter to provide added details about the\n * codecs used within the file.\n * @returns {Boolean}\n */\nexport default function isCodecSupported(mimeType) {\n    if (isNullOrUndefined(MediaSource_)) {\n        if (isWorker) {\n            log.error(\"Compat: Cannot request codec support in a worker without MSE.\");\n        }\n        return false;\n    }\n    if (typeof MediaSource_.isTypeSupported === \"function\") {\n        const cachedSupport = supportMap.get(mimeType);\n        if (cachedSupport !== undefined) {\n            return cachedSupport;\n        }\n        else {\n            const isSupported = MediaSource_.isTypeSupported(mimeType);\n            if (supportMap.size >= MAX_SUPPORT_MAP_ENTRIES) {\n                supportMap.clear();\n            }\n            supportMap.set(mimeType, isSupported);\n            return isSupported;\n        }\n    }\n    return true;\n}\n","/**\n * Some external tools set that boolean, in which case, we should enable DEBUG\n * logs and various tricks to make as much logs as available to those tools.\n *\n * @returns {boolean}\n */\nexport default function isDebugModeEnabled() {\n    return typeof __RX_PLAYER_DEBUG_MODE__ === \"boolean\" && __RX_PLAYER_DEBUG_MODE__;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { isTizen } from \"./browser_detection\";\n/**\n * On some devices (right now only seen on Tizen), seeking through the\n * `currentTime` property can lead to the browser re-seeking once the\n * segments have been loaded to improve seeking performances (for\n * example, by seeking right to an intra video frame).\n *\n * This can lead to conflicts with the RxPlayer code.\n *\n * This boolean is only `true` on the devices where this behavior has been\n * observed.\n */\nconst isSeekingApproximate = isTizen;\nexport default isSeekingApproximate;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport globalScope from \"../utils/global_scope\";\n/**\n * Returns true if the given cue is an instance of a VTTCue.\n * @param {*} cue\n * @returns {boolean}\n */\nexport default function isVTTCue(cue) {\n    return typeof globalScope.VTTCue === \"function\" && cue instanceof globalScope.VTTCue;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../log\";\nimport globalScope from \"../utils/global_scope\";\nimport isNullOrUndefined from \"../utils/is_null_or_undefined\";\n/**\n * Creates a cue using the best platform-specific interface available.\n *\n * @param {Number} startTime\n * @param {Number} endTime\n * @param {string} payload\n * @returns {VTTCue|TextTrackCue|null} Text track cue or null if the parameters\n * were invalid.\n */\nexport default function makeCue(startTime, endTime, payload) {\n    if (startTime >= endTime) {\n        // IE/Edge will throw in this case.\n        // See issue #501\n        log.warn(`Compat: Invalid cue times: ${startTime} - ${endTime}`);\n        return null;\n    }\n    if (isNullOrUndefined(globalScope.VTTCue)) {\n        if (isNullOrUndefined(globalScope.TextTrackCue)) {\n            throw new Error(\"VTT cues not supported in your target\");\n        }\n        return new TextTrackCue(startTime, endTime, payload);\n    }\n    else {\n        return new VTTCue(startTime, endTime, payload);\n    }\n}\n","import { isPlayStation5 } from \"./browser_detection\";\n/**\n * We noticed that the PlayStation 5 may have the HTMLMediaElement on which the\n * content is played stop on a `MEDIA_ERR_DECODE` error if it encounters\n * encrypted media data whose key is not usable due to policy restrictions (the\n * most usual issue being non-respect of HDCP restrictions).\n *\n * This is not an usual behavior, other platforms just do not attempt to decode\n * the encrypted media data and stall the playback instead (which is a much\n * preferable behavior for us as we have some advanced mechanism to restart\n * playback when this happens).\n *\n * Consequently, we have to specifically consider platforms with that\n * fail-on-undecipherable-data issue, to perform a work-around in that case.\n */\nconst mayMediaElementFailOnUndecipherableData = isPlayStation5;\nexport default mayMediaElementFailOnUndecipherableData;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../log\";\nimport globalScope from \"../utils/global_scope\";\nimport SharedReference from \"../utils/reference\";\nconst _ResizeObserver = globalScope.ResizeObserver;\n/**\n * Emit the current height and width of the given `element` each time it\n * changes.\n *\n * On some browsers, we might not be able to rely on a native API to know when\n * it changes, the `interval` argument allow us to provide us an inverval in\n * milliseconds at which we should query that element's size.\n * @param {HTMLElement} element\n * @param {number} interval\n * @returns {Object}\n */\nexport default function onHeightWidthChange(element, interval, cancellationSignal) {\n    const { height: initHeight, width: initWidth } = element.getBoundingClientRect();\n    const ref = new SharedReference({\n        height: initHeight,\n        width: initWidth,\n    }, cancellationSignal);\n    let lastHeight = initHeight;\n    let lastWidth = initWidth;\n    if (_ResizeObserver !== undefined) {\n        const resizeObserver = new _ResizeObserver((entries) => {\n            if (entries.length === 0) {\n                log.error(\"Compat: Resized but no observed element.\");\n                return;\n            }\n            const entry = entries[0];\n            const { height, width } = entry.contentRect;\n            if (height !== lastHeight || width !== lastWidth) {\n                lastHeight = height;\n                lastWidth = width;\n                ref.setValue({ height, width });\n            }\n        });\n        resizeObserver.observe(element);\n        cancellationSignal.register(() => {\n            resizeObserver.disconnect();\n        });\n    }\n    else {\n        const intervalId = setInterval(() => {\n            const { height, width } = element.getBoundingClientRect();\n            if (height !== lastHeight || width !== lastWidth) {\n                lastHeight = height;\n                lastWidth = width;\n                ref.setValue({ height, width });\n            }\n        }, interval);\n        cancellationSignal.register(() => {\n            clearInterval(intervalId);\n        });\n    }\n    return ref;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport EventEmitter from \"../utils/event_emitter\";\nimport globalScope from \"../utils/global_scope\";\nimport isNode from \"../utils/is_node\";\nimport isNullOrUndefined from \"../utils/is_null_or_undefined\";\nimport queueMicrotask from \"../utils/queue_microtask\";\n// TODO This is the last ugly side-effect here.\n// Either remove it or find the best way to implement that\nexport default function patchWebkitSourceBuffer() {\n    // old WebKit SourceBuffer implementation,\n    // where a synchronous append is used instead of appendBuffer\n    if (!isNode &&\n        !isNullOrUndefined(globalScope.WebKitSourceBuffer) &&\n        globalScope.WebKitSourceBuffer.prototype.addEventListener === undefined) {\n        const sourceBufferWebkitRef = globalScope.WebKitSourceBuffer;\n        const sourceBufferWebkitProto = sourceBufferWebkitRef.prototype;\n        for (const fnName in EventEmitter.prototype) {\n            if (Object.prototype.hasOwnProperty.call(EventEmitter.prototype, fnName)) {\n                sourceBufferWebkitProto[fnName] = EventEmitter.prototype[fnName];\n            }\n        }\n        sourceBufferWebkitProto._listeners = [];\n        sourceBufferWebkitProto._emitUpdate = function (eventName, val) {\n            queueMicrotask(() => {\n                this.trigger(eventName, val);\n                this.updating = false;\n                this.trigger(\"updateend\", new Event(\"updateend\"));\n            });\n        };\n        sourceBufferWebkitProto.appendBuffer = function (data) {\n            var _a, _b;\n            if (this.updating) {\n                throw new Error(\"updating\");\n            }\n            this.trigger(\"updatestart\", new Event(\"updatestart\"));\n            this.updating = true;\n            try {\n                this.append(data);\n            }\n            catch (error) {\n                (_a = this._emitUpdate) === null || _a === void 0 ? void 0 : _a.call(this, \"error\", error);\n                return;\n            }\n            (_b = this._emitUpdate) === null || _b === void 0 ? void 0 : _b.call(this, \"update\", new Event(\"update\"));\n        };\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../log\";\nimport { isFirefox } from \"./browser_detection\";\n/**\n * Return true if given cue is active.\n * @param {TextTrack} track\n * @param {TextTrackCue} cue\n * @returns {boolean}\n */\nfunction isActiveCue(track, cue) {\n    const { activeCues } = track;\n    if (activeCues === null) {\n        return false;\n    }\n    for (let i = 0; i < activeCues.length; i++) {\n        if (activeCues[i] === cue) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Remove cue from text track.\n * @param {TextTrack} track\n * @param {TextTrackCue} cue\n */\nexport default function removeCue(track, cue) {\n    // On Firefox, cue doesn't dissapear when it is removed from track. Track\n    // should be hidden, and shown again after removing cue, in order to\n    // definitely clean the cue.\n    if (isFirefox && isActiveCue(track, cue)) {\n        const trackMode = track.mode;\n        track.mode = \"hidden\";\n        try {\n            track.removeCue(cue);\n        }\n        catch (_err) {\n            log.warn(\"Compat: Could not remove cue from text track.\");\n        }\n        track.mode = trackMode;\n        return;\n    }\n    try {\n        track.removeCue(cue);\n    }\n    catch (_err) {\n        log.warn(\"Compat: Could not remove cue from text track.\");\n    }\n}\n","import { isWebOs } from \"./browser_detection\";\n/**\n * Some devices will give an error if you did not ensure that a `setMediaKeys`\n * call was performed until the end before making another one.\n *\n * This is actually spec-compliant, but we were bitten previously by the other\n * side of that story, when a `setMediaKeys` took a very long time to resolve\n * (thus leading us to not await it).\n *\n * So this function returns `true` when, in actually reproduced scenarios, we\n * encountered situations where both:\n *   1. Time to perform a `setMediaKeys` is not excessive\n *   2. An issue was encountered due to too-close `setMediaKeys` calls.\n *\n * @returns {boolean}\n */\nexport default function shouldAwaitSetMediaKeys() {\n    return isWebOs;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { isSafariDesktop, isSafariMobile } from \"./browser_detection\";\nimport { WebKitMediaKeysConstructor } from \"./eme/custom_media_keys/webkit_media_keys_constructor\";\n/**\n * On Safari 12.1, it seems that since fairplay CDM implementation\n * within the browser is not standard with EME w3c current spec, the\n * requestMediaKeySystemAccess API doesn't resolve positively, even\n * if the drm (fairplay in most cases) is supported.\n * @returns {boolean}\n */\nexport default function shouldFavourCustomSafariEME() {\n    return (isSafariDesktop || isSafariMobile) && WebKitMediaKeysConstructor !== undefined;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Returns true if we have to reload the MediaSource due to an update in the\n * decipherability status of some segments based on the current key sytem.\n *\n * We found that on all Widevine targets tested, a simple seek is sufficient.\n * As widevine clients make a good chunk of users, we can make a difference\n * between them and others as it is for the better.\n * @param {string|undefined} currentKeySystem\n * @returns {Boolean}\n */\nexport default function shouldReloadMediaSourceOnDecipherabilityUpdate(currentKeySystem) {\n    return currentKeySystem === undefined || currentKeySystem.indexOf(\"widevine\") < 0;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { isIE11 } from \"./browser_detection\";\n/**\n * Returns true if the current target require the MediaKeySystemAccess to be\n * renewed on each content.\n * @returns {Boolean}\n */\nexport default function shouldRenewMediaKeySystemAccess() {\n    return isIE11;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { isIE11 } from \"./browser_detection\";\n/**\n * Returns true if the mediakeys associated to a media element should be\n * unset once the content is stopped.\n * Depends on the target.\n * @returns {Boolean}\n */\nexport default function shouldUnsetMediaKeys() {\n    return isIE11;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { isSamsungBrowser } from \"./browser_detection\";\n/**\n * Returns true if the metadata received after a \"loadedmetadata\" event has\n * to be validated in the current browser (which means that we do not trust\n * this event on these browsers).\n * @returns {boolean}\n */\nexport default function shouldValidateMetadata() {\n    return isSamsungBrowser;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { isSafariMobile } from \"./browser_detection\";\n/**\n * On some browsers, the ready state might never go above `1` when autoplay is\n * blocked. On these cases, for now, we just advertise the content as \"loaded\".\n * We might go into BUFFERING just after that state, but that's a small price to\n * pay.\n * @param {Boolean} isDirectfile\n * @returns {Boolean}\n */\nexport default function shouldWaitForDataBeforeLoaded(isDirectfile) {\n    if (isDirectfile && isSafariMobile) {\n        return false;\n    }\n    else {\n        return true;\n    }\n}\n","import { isPlayStation5 } from \"./browser_detection\";\n/**\n * An `HTMLMediaElement`'s readyState allows the browser to communicate whether\n * it can play a content reliably.\n * Usually, we may consider that a `HAVE_FUTURE_DATA` (readyState `3`) or even\n * a `HAVE_CURRENT_DATA` (readyState `2`) is enough to begin playing the content\n * and consider it as loaded.\n *\n * However some devices wrongly anounce those readyStates before being actually\n * able to decode the content. For those devices we wait for the\n * `HAVE_ENOUGH_DATA` readyState before considering the content as loaded.\n * @returns {boolean}\n */\nexport default function shouldWaitForHaveEnoughData() {\n    return isPlayStation5;\n}\n","/**\n * This file exportsa tool allowing to easily update the global RxPlayer config\n * at runtime.\n *\n * Note that this should only be used for debugging purposes as the config is\n * __NOT__ part of the RxPlayer API.\n */\nimport DEFAULT_CONFIG from \"./default_config\";\nimport deepMerge from \"./utils/deep_merge\";\nimport EventEmitter from \"./utils/event_emitter\";\nclass ConfigHandler extends EventEmitter {\n    constructor() {\n        super(...arguments);\n        this.updated = false;\n        this._config = DEFAULT_CONFIG;\n    }\n    update(config) {\n        const newConfig = deepMerge(this._config, config);\n        this._config = newConfig;\n        this.updated = true;\n        this.trigger(\"update\", config);\n    }\n    getCurrent() {\n        return this._config;\n    }\n}\nconst configHandler = new ConfigHandler();\nexport default configHandler;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport config from \"../../config\";\nimport log from \"../../log\";\nimport isNullOrUndefined from \"../../utils/is_null_or_undefined\";\nimport noop from \"../../utils/noop\";\nimport { getLeftSizeOfRange } from \"../../utils/ranges\";\nimport SharedReference from \"../../utils/reference\";\nimport TaskCanceller from \"../../utils/task_canceller\";\nimport BufferBasedChooser from \"./buffer_based_chooser\";\nimport GuessBasedChooser from \"./guess_based_chooser\";\nimport NetworkAnalyzer from \"./network_analyzer\";\nimport BandwidthEstimator from \"./utils/bandwidth_estimator\";\nimport filterByBitrate from \"./utils/filter_by_bitrate\";\nimport filterByResolution from \"./utils/filter_by_resolution\";\nimport LastEstimateStorage from \"./utils/last_estimate_storage\";\nimport PendingRequestsStore from \"./utils/pending_requests_store\";\nimport RepresentationScoreCalculator from \"./utils/representation_score_calculator\";\nimport selectOptimalRepresentation from \"./utils/select_optimal_representation\";\n// Create default shared references\nconst limitResolutionDefaultRef = new SharedReference(undefined);\nlimitResolutionDefaultRef.finish();\nconst throttleBitrateDefaultRef = new SharedReference(Infinity);\nthrottleBitrateDefaultRef.finish();\n/**\n * Select the most adapted Representation according to the network and buffer\n * metrics it receives.\n *\n * @param {Object} options - Initial configuration (see type definition)\n * @returns {Object} - Interface allowing to select a Representation.\n * @see IRepresentationEstimator\n */\nexport default function createAdaptiveRepresentationSelector(options) {\n    /**\n     * Allows to estimate the current network bandwidth.\n     * One per active media type.\n     */\n    const bandwidthEstimators = {};\n    const { initialBitrates, throttlers, lowLatencyMode } = options;\n    /**\n     * Returns Object emitting Representation estimates as well as callbacks\n     * allowing to helping it produce them.\n     *\n     * @see IRepresentationEstimator\n     * @param {Object} context\n     * @param {Object} currentRepresentation\n     * @param {Object} representations\n     * @param {Object} playbackObserver\n     * @param {Object} stopAllEstimates\n     * @returns {Array.<Object>}\n     */\n    return function getEstimates(context, currentRepresentation, representations, playbackObserver, stopAllEstimates) {\n        var _a, _b, _c;\n        const { type } = context.adaptation;\n        const bandwidthEstimator = _getBandwidthEstimator(type);\n        const initialBitrate = (_a = initialBitrates[type]) !== null && _a !== void 0 ? _a : 0;\n        const filters = {\n            limitResolution: (_b = throttlers.limitResolution[type]) !== null && _b !== void 0 ? _b : limitResolutionDefaultRef,\n            throttleBitrate: (_c = throttlers.throttleBitrate[type]) !== null && _c !== void 0 ? _c : throttleBitrateDefaultRef,\n        };\n        return getEstimateReference({\n            bandwidthEstimator,\n            context,\n            currentRepresentation,\n            filters,\n            initialBitrate,\n            playbackObserver,\n            representations,\n            lowLatencyMode,\n        }, stopAllEstimates);\n    };\n    /**\n     * Returns interface allowing to estimate network throughtput for a given type.\n     * @param {string} bufferType\n     * @returns {Object}\n     */\n    function _getBandwidthEstimator(bufferType) {\n        const originalBandwidthEstimator = bandwidthEstimators[bufferType];\n        if (isNullOrUndefined(originalBandwidthEstimator)) {\n            log.debug(\"ABR: Creating new BandwidthEstimator for \", bufferType);\n            const bandwidthEstimator = new BandwidthEstimator();\n            bandwidthEstimators[bufferType] = bandwidthEstimator;\n            return bandwidthEstimator;\n        }\n        return originalBandwidthEstimator;\n    }\n}\n/**\n * Estimate regularly the current network bandwidth and the best Representation\n * that can be played according to the current network and playback conditions.\n *\n * `getEstimateReference` only does estimations for a given type (e.g.\n * \"audio\", \"video\" etc.) and Period.\n *\n * If estimates for multiple types and/or Periods are needed, you should\n * call `getEstimateReference` as many times.\n *\n * This function returns a tuple:\n *   - the first element being the object through which estimates will be produced\n *   - the second element being callbacks that have to be triggered at various\n *     events to help it doing those estimates.\n *\n * @param {Object} args\n * @param {Object} stopAllEstimates\n * @returns {Array.<Object>}\n */\nfunction getEstimateReference({ bandwidthEstimator, context, currentRepresentation, filters, initialBitrate, lowLatencyMode, playbackObserver, representations: representationsRef, }, stopAllEstimates) {\n    const scoreCalculator = new RepresentationScoreCalculator();\n    const networkAnalyzer = new NetworkAnalyzer(initialBitrate !== null && initialBitrate !== void 0 ? initialBitrate : 0, lowLatencyMode);\n    const requestsStore = new PendingRequestsStore();\n    /**\n     * Callback called each time a new segment is pushed, with the information on the\n     * new pushed segment.\n     */\n    let onAddedSegment = noop;\n    const callbacks = {\n        metrics: onMetric,\n        requestBegin: onRequestBegin,\n        requestProgress: onRequestProgress,\n        requestEnd: onRequestEnd,\n        addedSegment(val) {\n            onAddedSegment(val);\n        },\n    };\n    /**\n     * `TaskCanceller` allowing to stop producing estimate.\n     * This TaskCanceller is used both for restarting estimates with a new\n     * configuration and to cancel them altogether.\n     */\n    let currentEstimatesCanceller = new TaskCanceller();\n    currentEstimatesCanceller.linkToSignal(stopAllEstimates);\n    // Create `SharedReference` on which estimates will be emitted.\n    const estimateRef = createEstimateReference(representationsRef.getValue(), currentEstimatesCanceller.signal);\n    representationsRef.onUpdate(restartEstimatesProductionFromCurrentConditions, {\n        clearSignal: stopAllEstimates,\n    });\n    return { estimates: estimateRef, callbacks };\n    /**\n     * Emit the ABR estimates on various events through the returned\n     * `SharedReference`.\n     * @param {Array.<Object>} unsortedRepresentations - All `Representation` that\n     * the ABR logic can choose from.\n     * @param {Object} innerCancellationSignal - When this `CancellationSignal`\n     * emits, all events registered to to emit new estimates will be unregistered.\n     * Note that the returned reference may still be used to produce new estimates\n     * in the future if you want to even after this signal emits.\n     * @returns {Object} - `SharedReference` through which ABR estimates will be\n     * produced.\n     */\n    function createEstimateReference(unsortedRepresentations, innerCancellationSignal) {\n        if (unsortedRepresentations.length <= 1) {\n            // There's only a single Representation. Just choose it.\n            return new SharedReference({\n                bitrate: undefined,\n                representation: unsortedRepresentations[0],\n                urgent: true,\n                knownStableBitrate: undefined,\n            });\n        }\n        /** If true, Representation estimates based on the buffer health might be used. */\n        let allowBufferBasedEstimates = false;\n        /** Ensure `Representation` objects are sorted by bitrates and only rely on this. */\n        const sortedRepresentations = unsortedRepresentations.sort((ra, rb) => ra.bitrate - rb.bitrate);\n        /**\n         * Module calculating the optimal Representation based on the current\n         * buffer's health (i.e. whether enough data is buffered, history of\n         * buffer size etc.).\n         */\n        const bufferBasedChooser = new BufferBasedChooser(sortedRepresentations.map((r) => r.bitrate));\n        /** Store the previous estimate made here. */\n        const prevEstimate = new LastEstimateStorage();\n        /**\n         * Module calculating the optimal Representation by \"guessing it\" with a\n         * step-by-step algorithm.\n         * Only used in very specific scenarios.\n         */\n        const guessBasedChooser = new GuessBasedChooser(scoreCalculator, prevEstimate);\n        // get initial observation for initial estimate\n        let lastPlaybackObservation = playbackObserver.getReference().getValue();\n        /** Reference through which estimates are emitted. */\n        const innerEstimateRef = new SharedReference(getCurrentEstimate());\n        // Listen to playback observations\n        playbackObserver.listen((obs) => {\n            lastPlaybackObservation = obs;\n            updateEstimate();\n        }, { includeLastObservation: false, clearSignal: innerCancellationSignal });\n        onAddedSegment = function (val) {\n            if (lastPlaybackObservation === null) {\n                return;\n            }\n            const { position, speed } = lastPlaybackObservation;\n            const timeRanges = val.buffered;\n            const bufferGap = getLeftSizeOfRange(timeRanges, position.getWanted());\n            const { representation } = val.content;\n            const currentScore = scoreCalculator.getEstimate(representation);\n            const currentBitrate = representation.bitrate;\n            const observation = { bufferGap, currentBitrate, currentScore, speed };\n            bufferBasedChooser.onAddedSegment(observation);\n            updateEstimate();\n        };\n        innerCancellationSignal.register(() => {\n            onAddedSegment = noop;\n        });\n        filters.throttleBitrate.onUpdate(updateEstimate, {\n            clearSignal: innerCancellationSignal,\n        });\n        filters.limitResolution.onUpdate(updateEstimate, {\n            clearSignal: innerCancellationSignal,\n        });\n        return innerEstimateRef;\n        function updateEstimate() {\n            innerEstimateRef.setValue(getCurrentEstimate());\n        }\n        /** Returns the actual estimate based on all methods and algorithm available. */\n        function getCurrentEstimate() {\n            const { bufferGap, position, maximumPosition } = lastPlaybackObservation;\n            const resolutionLimit = filters.limitResolution.getValue();\n            const bitrateThrottle = filters.throttleBitrate.getValue();\n            const currentRepresentationVal = currentRepresentation.getValue();\n            const filteredReps = getFilteredRepresentations(sortedRepresentations, resolutionLimit, bitrateThrottle);\n            const requests = requestsStore.getRequests();\n            const { bandwidthEstimate, bitrateChosen } = networkAnalyzer.getBandwidthEstimate(lastPlaybackObservation, bandwidthEstimator, currentRepresentationVal, requests, prevEstimate.bandwidth);\n            const stableRepresentation = scoreCalculator.getLastStableRepresentation();\n            const knownStableBitrate = stableRepresentation === null\n                ? undefined\n                : stableRepresentation.bitrate /\n                    (lastPlaybackObservation.speed > 0 ? lastPlaybackObservation.speed : 1);\n            const { ABR_ENTER_BUFFER_BASED_ALGO, ABR_EXIT_BUFFER_BASED_ALGO } = config.getCurrent();\n            if (allowBufferBasedEstimates && bufferGap <= ABR_EXIT_BUFFER_BASED_ALGO) {\n                allowBufferBasedEstimates = false;\n            }\n            else if (!allowBufferBasedEstimates &&\n                isFinite(bufferGap) &&\n                bufferGap >= ABR_ENTER_BUFFER_BASED_ALGO) {\n                allowBufferBasedEstimates = true;\n            }\n            /**\n             * Representation chosen when considering only [pessimist] bandwidth\n             * calculation.\n             * This is a safe enough choice but might be lower than what the user\n             * could actually profit from.\n             */\n            const chosenRepFromBandwidth = selectOptimalRepresentation(filteredReps, bitrateChosen);\n            /**\n             * Current optimal Representation's bandwidth choosen by a buffer-based\n             * adaptive algorithm.\n             */\n            const currentBufferBasedEstimate = bufferBasedChooser.getLastEstimate();\n            let currentBestBitrate = chosenRepFromBandwidth.bitrate;\n            /**\n             * Representation chosen when considering the current buffer size.\n             * If defined, takes precedence over `chosenRepFromBandwidth`.\n             *\n             * This is a very safe choice, yet it is very slow and might not be\n             * adapted to cases where a buffer cannot be build, such as live contents.\n             *\n             * `null` if this buffer size mode is not enabled or if we don't have a\n             * choice from it yet.\n             */\n            let chosenRepFromBufferSize = null;\n            if (allowBufferBasedEstimates &&\n                currentBufferBasedEstimate !== undefined &&\n                currentBufferBasedEstimate > currentBestBitrate) {\n                chosenRepFromBufferSize = selectOptimalRepresentation(filteredReps, currentBufferBasedEstimate);\n                currentBestBitrate = chosenRepFromBufferSize.bitrate;\n            }\n            /**\n             * Representation chosen by the more adventurous `GuessBasedChooser`,\n             * which iterates through Representations one by one until finding one\n             * that cannot be \"maintained\".\n             *\n             * If defined, takes precedence over both `chosenRepFromBandwidth` and\n             * `chosenRepFromBufferSize`.\n             *\n             * This is the riskiest choice (in terms of rebuffering chances) but is\n             * only enabled when no other solution is adapted (for now, this just\n             * applies for low-latency contents when playing close to the live\n             * edge).\n             *\n             * `null` if not enabled or if there's currently no guess.\n             */\n            let chosenRepFromGuessMode = null;\n            if (lowLatencyMode &&\n                currentRepresentationVal !== null &&\n                context.manifest.isDynamic &&\n                maximumPosition - position.getWanted() < 40) {\n                chosenRepFromGuessMode = guessBasedChooser.getGuess(sortedRepresentations, lastPlaybackObservation, currentRepresentationVal, currentBestBitrate, requests);\n            }\n            if (chosenRepFromGuessMode !== null &&\n                chosenRepFromGuessMode.bitrate > currentBestBitrate) {\n                log.debug(\"ABR: Choosing representation with guess-based estimation.\", chosenRepFromGuessMode.bitrate, chosenRepFromGuessMode.id);\n                prevEstimate.update(chosenRepFromGuessMode, bandwidthEstimate, 2 /* ABRAlgorithmType.GuessBased */);\n                return {\n                    bitrate: bandwidthEstimate,\n                    representation: chosenRepFromGuessMode,\n                    urgent: currentRepresentationVal === null ||\n                        chosenRepFromGuessMode.bitrate < currentRepresentationVal.bitrate,\n                    knownStableBitrate,\n                };\n            }\n            else if (chosenRepFromBufferSize !== null) {\n                log.debug(\"ABR: Choosing representation with buffer-based estimation.\", chosenRepFromBufferSize.bitrate, chosenRepFromBufferSize.id);\n                prevEstimate.update(chosenRepFromBufferSize, bandwidthEstimate, 0 /* ABRAlgorithmType.BufferBased */);\n                return {\n                    bitrate: bandwidthEstimate,\n                    representation: chosenRepFromBufferSize,\n                    urgent: networkAnalyzer.isUrgent(chosenRepFromBufferSize.bitrate, currentRepresentationVal, requests, lastPlaybackObservation),\n                    knownStableBitrate,\n                };\n            }\n            else {\n                log.debug(\"ABR: Choosing representation with bandwidth estimation.\", chosenRepFromBandwidth.bitrate, chosenRepFromBandwidth.id);\n                prevEstimate.update(chosenRepFromBandwidth, bandwidthEstimate, 1 /* ABRAlgorithmType.BandwidthBased */);\n                return {\n                    bitrate: bandwidthEstimate,\n                    representation: chosenRepFromBandwidth,\n                    urgent: networkAnalyzer.isUrgent(chosenRepFromBandwidth.bitrate, currentRepresentationVal, requests, lastPlaybackObservation),\n                    knownStableBitrate,\n                };\n            }\n        }\n    }\n    /**\n     * Stop previous estimate production (if one) and restart it considering new\n     * conditions (such as a new list of Representations).\n     */\n    function restartEstimatesProductionFromCurrentConditions() {\n        const representations = representationsRef.getValue();\n        currentEstimatesCanceller.cancel();\n        currentEstimatesCanceller = new TaskCanceller();\n        currentEstimatesCanceller.linkToSignal(stopAllEstimates);\n        const newRef = createEstimateReference(representations, currentEstimatesCanceller.signal);\n        newRef.onUpdate(function onNewEstimate(newEstimate) {\n            estimateRef.setValue(newEstimate);\n        }, { clearSignal: currentEstimatesCanceller.signal, emitCurrentValue: true });\n    }\n    /**\n     * Callback to call when new metrics are available\n     * @param {Object} value\n     */\n    function onMetric(value) {\n        const { requestDuration, segmentDuration, size, content } = value;\n        // calculate bandwidth\n        bandwidthEstimator.addSample(requestDuration, size);\n        if (!content.segment.isInit) {\n            // calculate \"maintainability score\"\n            const { segment, representation } = content;\n            if (segmentDuration === undefined && !segment.complete) {\n                // We cannot know the real duration of the segment\n                return;\n            }\n            const segDur = segmentDuration !== null && segmentDuration !== void 0 ? segmentDuration : segment.duration;\n            scoreCalculator.addSample(representation, requestDuration / 1000, segDur);\n        }\n    }\n    /** Callback called when a new request begins. */\n    function onRequestBegin(val) {\n        requestsStore.add(val);\n    }\n    /** Callback called when progress information is known on a pending request. */\n    function onRequestProgress(val) {\n        requestsStore.addProgress(val);\n    }\n    /** Callback called when a pending request ends. */\n    function onRequestEnd(val) {\n        requestsStore.remove(val.id);\n    }\n}\n/**\n * Filter representations given through filters options.\n * @param {Array.<Representation>} representations\n * @param {Object | undefined} resolutionLimit\n * @param {number | undefined} bitrateThrottle\n * @returns {Array.<Representation>}\n */\nfunction getFilteredRepresentations(representations, resolutionLimit, bitrateThrottle) {\n    let filteredReps = representations;\n    if (bitrateThrottle !== undefined && bitrateThrottle < Infinity) {\n        filteredReps = filterByBitrate(filteredReps, bitrateThrottle);\n    }\n    if (resolutionLimit !== undefined) {\n        filteredReps = filterByResolution(filteredReps, resolutionLimit);\n    }\n    return filteredReps;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../log\";\nimport arrayFindIndex from \"../../utils/array_find_index\";\nimport isNullOrUndefined from \"../../utils/is_null_or_undefined\";\nimport getMonotonicTimeStamp from \"../../utils/monotonic_timestamp\";\nimport getBufferLevels from \"./utils/get_buffer_levels\";\n/**\n * Minimum amount of time, in milliseconds, during which we are blocked from\n * raising in quality after it had been considered as too high.\n */\nconst MINIMUM_BLOCK_RAISE_DELAY = 6000;\n/**\n * Maximum amount of time, in milliseconds, during which we are blocked from\n * raising in quality after it had been considered as too high.\n */\nconst MAXIMUM_BLOCK_RAISE_DELAY = 15000;\n/**\n * Amount of time, in milliseconds, with which the blocking time in raising\n * the quality will be incremented if the current quality estimate is seen\n * as too unstable.\n */\nconst RAISE_BLOCKING_DELAY_INCREMENT = 3000;\n/**\n * Amount of time, in milliseconds, with which the blocking time in raising\n * the quality will be dcremented if the current quality estimate is seen\n * as relatively stable, until `MINIMUM_BLOCK_RAISE_DELAY` is reached.\n */\nconst RAISE_BLOCKING_DELAY_DECREMENT = 1000;\n/**\n * Amount of time, in milliseconds, after the \"raise blocking delay\" currently\n * in place (during which it is forbidden to raise up in quality), during which\n * we might want to raise the \"raise blocking delay\" if the last chosen quality\n * seems unsuitable.\n *\n * For example, let's consider that the current raise blocking delay is at\n * `4000`, or 4 seconds, and that this `STABILITY_CHECK_DELAY` is at `5000`, or\n * 5 seconds.\n * Here it means that if the estimated quality is found to be unsuitable less\n * than 4+5 = 9 seconds after it last was, we will increment the raise blocking\n * delay by `RAISE_BLOCKING_DELAY_INCREMENT` (unless `MAXIMUM_BLOCK_RAISE_DELAY`\n * is reached).\n * Else, if takes more than 9 seconds, the raise blocking delay might be\n * decremented.\n */\nconst STABILITY_CHECK_DELAY = 9000;\n/**\n * Choose a bitrate based on the currently available buffer.\n *\n * This algorithm is based on a deviation of the BOLA algorithm.\n * It is a hybrid solution that also relies on a given bitrate's\n * \"maintainability\".\n * Each time a chunk is downloaded, from the ratio between the chunk duration\n * and chunk's request time, we can assume that the representation is\n * \"maintanable\" or not.\n * If so, we may switch to a better quality, or conversely to a worse quality.\n *\n * It also rely on mechanisms to avoid fluctuating too much between qualities.\n *\n * @class BufferBasedChooser\n */\nexport default class BufferBasedChooser {\n    /**\n     * @param {Array.<number>} bitrates\n     */\n    constructor(bitrates) {\n        this._levelsMap = getBufferLevels(bitrates).map((bl) => {\n            return bl + 4; // Add some buffer security as it will be used conjointly with\n            // other algorithms anyway\n        });\n        this._bitrates = bitrates;\n        this._lastUnsuitableQualityTimestamp = undefined;\n        this._blockRaiseDelay = MINIMUM_BLOCK_RAISE_DELAY;\n        log.debug(\"ABR: Steps for buffer based chooser.\", this._levelsMap\n            .map((l, i) => `bufferLevel: ${l}, bitrate: ${bitrates[i]}`)\n            .join(\" ,\"));\n    }\n    /**\n     * @param {Object} playbackObservation\n     * @returns {number|undefined}\n     */\n    onAddedSegment(playbackObservation) {\n        const bufferLevels = this._levelsMap;\n        const bitrates = this._bitrates;\n        const { bufferGap, currentBitrate, currentScore, speed } = playbackObservation;\n        if (isNullOrUndefined(currentBitrate)) {\n            this._currentEstimate = bitrates[0];\n            return;\n        }\n        let currentBitrateIndex = -1;\n        for (let i = 0; i < bitrates.length; i++) {\n            // There could be bitrate duplicates. Only take the last one to simplify\n            const bitrate = bitrates[i];\n            if (bitrate === currentBitrate) {\n                currentBitrateIndex = i;\n            }\n            else if (bitrate > currentBitrate) {\n                break;\n            }\n        }\n        if (currentBitrateIndex < 0 || bitrates.length !== bufferLevels.length) {\n            log.info(\"ABR: Current Bitrate not found in the calculated levels\");\n            this._currentEstimate = bitrates[0];\n            return;\n        }\n        let scaledScore;\n        if (currentScore !== undefined) {\n            scaledScore = speed === 0 ? currentScore.score : currentScore.score / speed;\n        }\n        const actualBufferGap = isFinite(bufferGap) ? bufferGap : 0;\n        const now = getMonotonicTimeStamp();\n        if (actualBufferGap < bufferLevels[currentBitrateIndex] ||\n            (scaledScore !== undefined &&\n                scaledScore < 1 &&\n                (currentScore === null || currentScore === void 0 ? void 0 : currentScore.confidenceLevel) === 1 /* ScoreConfidenceLevel.HIGH */)) {\n            const timeSincePrev = this._lastUnsuitableQualityTimestamp === undefined\n                ? -1\n                : now - this._lastUnsuitableQualityTimestamp;\n            if (timeSincePrev < this._blockRaiseDelay + STABILITY_CHECK_DELAY) {\n                const newDelay = this._blockRaiseDelay + RAISE_BLOCKING_DELAY_INCREMENT;\n                this._blockRaiseDelay = Math.min(newDelay, MAXIMUM_BLOCK_RAISE_DELAY);\n                log.debug(\"ABR: Incrementing blocking raise in BufferBasedChooser due \" +\n                    \"to unstable quality\", this._blockRaiseDelay);\n            }\n            else {\n                const newDelay = this._blockRaiseDelay - RAISE_BLOCKING_DELAY_DECREMENT;\n                this._blockRaiseDelay = Math.max(MINIMUM_BLOCK_RAISE_DELAY, newDelay);\n                log.debug(\"ABR: Lowering quality in BufferBasedChooser\", this._blockRaiseDelay);\n            }\n            this._lastUnsuitableQualityTimestamp = now;\n            // Security if multiple bitrates are equal, we now take the first one\n            const baseIndex = arrayFindIndex(bitrates, (b) => b === currentBitrate);\n            for (let i = baseIndex - 1; i >= 0; i--) {\n                if (actualBufferGap >= bufferLevels[i]) {\n                    this._currentEstimate = bitrates[i];\n                    return;\n                }\n            }\n            this._currentEstimate = bitrates[0];\n            return;\n        }\n        if ((this._lastUnsuitableQualityTimestamp !== undefined &&\n            now - this._lastUnsuitableQualityTimestamp < this._blockRaiseDelay) ||\n            scaledScore === undefined ||\n            scaledScore < 1.15 ||\n            (currentScore === null || currentScore === void 0 ? void 0 : currentScore.confidenceLevel) !== 1 /* ScoreConfidenceLevel.HIGH */) {\n            this._currentEstimate = currentBitrate;\n            return;\n        }\n        const currentBufferLevel = bufferLevels[currentBitrateIndex];\n        const nextIndex = (() => {\n            for (let i = currentBitrateIndex + 1; i < bufferLevels.length; i++) {\n                if (bufferLevels[i] > currentBufferLevel) {\n                    return i;\n                }\n            }\n        })();\n        if (nextIndex !== undefined) {\n            const nextBufferLevel = bufferLevels[nextIndex];\n            if (bufferGap >= nextBufferLevel) {\n                log.debug(\"ABR: Raising quality in BufferBasedChooser\", bitrates[nextIndex]);\n                this._currentEstimate = bitrates[nextIndex];\n                return;\n            }\n        }\n        this._currentEstimate = currentBitrate;\n        return;\n    }\n    /**\n     * Returns the last best Representation's bitrate estimate made by the\n     * `BufferBasedChooser` or `undefined` if it has no such guess for now.\n     *\n     * Might be updated after `onAddedSegment` is called.\n     *\n     * @returns {number|undefined}\n     */\n    getLastEstimate() {\n        return this._currentEstimate;\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../log\";\nimport arrayFindIndex from \"../../utils/array_find_index\";\nimport getMonotonicTimeStamp from \"../../utils/monotonic_timestamp\";\nimport { estimateRequestBandwidth } from \"./network_analyzer\";\n/**\n * Estimate which Representation should be played based on risky \"guesses\".\n *\n * Basically, this `GuessBasedChooser` will attempt switching to the superior\n * quality when conditions allows this and then check if we're able to maintain\n * this quality. If we're not, it will rollbacks to the previous, maintaninable,\n * guess.\n *\n * The algorithm behind the `GuessBasedChooser` is very risky in terms of\n * rebuffering chances. As such, it should only be used when other approach\n * don't work (e.g.  low-latency contents).\n * @class GuessBasedChooser\n */\nexport default class GuessBasedChooser {\n    /**\n     * Create a new `GuessBasedChooser`.\n     * @param {Object} scoreCalculator\n     * @param {Object} prevEstimate\n     */\n    constructor(scoreCalculator, prevEstimate) {\n        this._scoreCalculator = scoreCalculator;\n        this._lastAbrEstimate = prevEstimate;\n        this._consecutiveWrongGuesses = 0;\n        this._blockGuessesUntil = 0;\n        this._lastMaintanableBitrate = null;\n    }\n    /**\n     * Perform a \"guess\", which basically indicates which Representation should be\n     * chosen according to the `GuessBasedChooser`.\n     *\n     * @param {Array.<Object>} representations - Array of all Representation the\n     * GuessBasedChooser can choose from, sorted by bitrate ascending.\n     * /!\\ It is very important that Representation in that Array are sorted by\n     * bitrate ascending for this method to work as intented.\n     * @param {Object} observation - Last playback observation performed.\n     * @param {Object} currentRepresentation - The Representation currently\n     * loading.\n     * @param {number} incomingBestBitrate - The bitrate of the Representation\n     * chosen by the more optimistic of the other ABR algorithms currently.\n     * @param {Array.<Object>} requests - Information on all pending requests.\n     * @returns {Object|null} - If a guess is made, return that guess, else\n     * returns `null` (in which case you should fallback to another ABR\n     * algorithm).\n     */\n    getGuess(representations, observation, currentRepresentation, incomingBestBitrate, requests) {\n        const { bufferGap, speed } = observation;\n        const lastChosenRep = this._lastAbrEstimate.representation;\n        if (lastChosenRep === null) {\n            return null; // There's nothing to base our guess on\n        }\n        if (incomingBestBitrate > lastChosenRep.bitrate) {\n            // ABR estimates are already superior or equal to the guess\n            // we'll be doing here, so no need to guess\n            if (this._lastAbrEstimate.algorithmType === 2 /* ABRAlgorithmType.GuessBased */) {\n                if (this._lastAbrEstimate.representation !== null) {\n                    this._lastMaintanableBitrate = this._lastAbrEstimate.representation.bitrate;\n                }\n                this._consecutiveWrongGuesses = 0;\n            }\n            return null;\n        }\n        const scoreData = this._scoreCalculator.getEstimate(currentRepresentation);\n        if (this._lastAbrEstimate.algorithmType !== 2 /* ABRAlgorithmType.GuessBased */) {\n            if (scoreData === undefined) {\n                return null; // not enough information to start guessing\n            }\n            if (this._canGuessHigher(bufferGap, speed, scoreData)) {\n                const nextRepresentation = getNextRepresentation(representations, currentRepresentation);\n                if (nextRepresentation !== null) {\n                    return nextRepresentation;\n                }\n            }\n            return null;\n        }\n        // If we reached here, we're currently already in guessing mode\n        if (this._isLastGuessValidated(lastChosenRep, incomingBestBitrate, scoreData)) {\n            log.debug(\"ABR: Guessed Representation validated\", lastChosenRep.bitrate);\n            this._lastMaintanableBitrate = lastChosenRep.bitrate;\n            this._consecutiveWrongGuesses = 0;\n        }\n        if (currentRepresentation.id !== lastChosenRep.id) {\n            return lastChosenRep;\n        }\n        const shouldStopGuess = this._shouldStopGuess(currentRepresentation, scoreData, bufferGap, requests);\n        if (shouldStopGuess) {\n            // Block guesses for a time\n            this._consecutiveWrongGuesses++;\n            this._blockGuessesUntil =\n                getMonotonicTimeStamp() + Math.min(this._consecutiveWrongGuesses * 15000, 120000);\n            return getPreviousRepresentation(representations, currentRepresentation);\n        }\n        else if (scoreData === undefined) {\n            return currentRepresentation;\n        }\n        if (this._canGuessHigher(bufferGap, speed, scoreData)) {\n            const nextRepresentation = getNextRepresentation(representations, currentRepresentation);\n            if (nextRepresentation !== null) {\n                return nextRepresentation;\n            }\n        }\n        return currentRepresentation;\n    }\n    /**\n     * Returns `true` if we've enough confidence on the current situation to make\n     * a higher guess.\n     * @param {number} bufferGap\n     * @param {number} speed\n     * @param {Array} scoreData\n     * @returns {boolean}\n     */\n    _canGuessHigher(bufferGap, speed, { score, confidenceLevel }) {\n        return (isFinite(bufferGap) &&\n            bufferGap >= 2.5 &&\n            getMonotonicTimeStamp() > this._blockGuessesUntil &&\n            confidenceLevel === 1 /* ScoreConfidenceLevel.HIGH */ &&\n            score / speed > 1.01);\n    }\n    /**\n     * Returns `true` if the pending guess of `lastGuess` seems to not\n     * be maintainable and as such should be stopped.\n     * @param {Object} lastGuess\n     * @param {Array} scoreData\n     * @param {number} bufferGap\n     * @param {Array.<Object>} requests\n     * @returns {boolean}\n     */\n    _shouldStopGuess(lastGuess, scoreData, bufferGap, requests) {\n        if (scoreData !== undefined && scoreData.score < 1.01) {\n            return true;\n        }\n        else if ((scoreData === undefined || scoreData.score < 1.2) && bufferGap < 0.6) {\n            return true;\n        }\n        const guessedRepresentationRequests = requests.filter((req) => {\n            return req.content.representation.id === lastGuess.id;\n        });\n        const now = getMonotonicTimeStamp();\n        for (const req of guessedRepresentationRequests) {\n            const requestElapsedTime = now - req.requestTimestamp;\n            if (req.content.segment.isInit) {\n                if (requestElapsedTime > 1000) {\n                    return true;\n                }\n            }\n            else if (requestElapsedTime > req.content.segment.duration * 1000 + 200) {\n                return true;\n            }\n            else {\n                const fastBw = estimateRequestBandwidth(req);\n                if (fastBw !== undefined && fastBw < lastGuess.bitrate * 0.8) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    _isLastGuessValidated(lastGuess, incomingBestBitrate, scoreData) {\n        if (scoreData !== undefined &&\n            scoreData.confidenceLevel === 1 /* ScoreConfidenceLevel.HIGH */ &&\n            scoreData.score > 1.5) {\n            return true;\n        }\n        return (incomingBestBitrate >= lastGuess.bitrate &&\n            (this._lastMaintanableBitrate === null ||\n                this._lastMaintanableBitrate < lastGuess.bitrate));\n    }\n}\n/**\n * From the array of Representations given, returns the Representation with a\n * bitrate immediately superior to the current one.\n * Returns `null` if that \"next\" Representation is not found.\n *\n * /!\\ The representations have to be already sorted by bitrate, in ascending\n * order.\n * @param {Array.<Object>} representations - Available representations to choose\n * from, sorted by bitrate in ascending order.\n * @param {Object} currentRepresentation - The Representation currently\n * considered.\n * @returns {Object|null}\n */\nfunction getNextRepresentation(representations, currentRepresentation) {\n    const len = representations.length;\n    let index = arrayFindIndex(representations, ({ id }) => id === currentRepresentation.id);\n    if (index < 0) {\n        log.error(\"ABR: Current Representation not found.\");\n        return null;\n    }\n    while (++index < len) {\n        if (representations[index].bitrate > currentRepresentation.bitrate) {\n            return representations[index];\n        }\n    }\n    return null;\n}\n/**\n * From the array of Representations given, returns the Representation with a\n * bitrate immediately inferior.\n * Returns `null` if that \"previous\" Representation is not found.\n * @param {Array.<Object>} representations\n * @param {Object} currentRepresentation\n * @returns {Object|null}\n */\nfunction getPreviousRepresentation(representations, currentRepresentation) {\n    let index = arrayFindIndex(representations, ({ id }) => id === currentRepresentation.id);\n    if (index < 0) {\n        log.error(\"ABR: Current Representation not found.\");\n        return null;\n    }\n    while (--index >= 0) {\n        if (representations[index].bitrate < currentRepresentation.bitrate) {\n            return representations[index];\n        }\n    }\n    return null;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport AdaptiveRepresentationSelector from \"./adaptive_representation_selector\";\nexport default AdaptiveRepresentationSelector;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport config from \"../../config\";\nimport log from \"../../log\";\nimport arrayFind from \"../../utils/array_find\";\nimport isNullOrUndefined from \"../../utils/is_null_or_undefined\";\nimport getMonotonicTimeStamp from \"../../utils/monotonic_timestamp\";\nimport EWMA from \"./utils/ewma\";\n/**\n * Get pending segment request(s) starting with the asked segment position.\n * @param {Object} requests - Every requests pending, in a chronological\n * order in terms of segment time.\n * @param {number} neededPosition\n * @returns {Array.<Object>}\n */\nfunction getConcernedRequests(requests, neededPosition) {\n    /** Index of the request for the next needed segment, in `requests`. */\n    let nextSegmentIndex = -1;\n    for (let i = 0; i < requests.length; i++) {\n        const { segment } = requests[i].content;\n        if (segment.duration <= 0) {\n            continue;\n        }\n        const segmentEnd = segment.time + segment.duration;\n        if (!segment.complete) {\n            if (i === requests.length - 1 && neededPosition - segment.time > -1.2) {\n                nextSegmentIndex = i;\n                break;\n            }\n        }\n        if (segmentEnd > neededPosition && neededPosition - segment.time > -1.2) {\n            nextSegmentIndex = i;\n            break;\n        }\n    }\n    if (nextSegmentIndex < 0) {\n        // Not found\n        return [];\n    }\n    const nextRequest = requests[nextSegmentIndex];\n    const segmentTime = nextRequest.content.segment.time;\n    const filteredRequests = [nextRequest];\n    // Get the possibly multiple requests for that segment's position\n    for (let i = nextSegmentIndex + 1; i < requests.length; i++) {\n        if (requests[i].content.segment.time === segmentTime) {\n            filteredRequests.push(requests[i]);\n        }\n        else {\n            break;\n        }\n    }\n    return filteredRequests;\n}\n/**\n * Estimate the __VERY__ recent bandwidth based on a single unfinished request.\n * Useful when the current bandwidth seemed to have fallen quickly.\n *\n * @param {Object} request\n * @returns {number|undefined}\n */\nexport function estimateRequestBandwidth(request) {\n    if (request.progress.length < 5) {\n        // threshold from which we can consider\n        // progress events reliably\n        return undefined;\n    }\n    // try to infer quickly the current bitrate based on the\n    // progress events\n    const ewma1 = new EWMA(2);\n    const { progress } = request;\n    for (let i = 1; i < progress.length; i++) {\n        const bytesDownloaded = progress[i].size - progress[i - 1].size;\n        const timeElapsed = progress[i].timestamp - progress[i - 1].timestamp;\n        const reqBitrate = (bytesDownloaded * 8) / (timeElapsed / 1000);\n        ewma1.addSample(timeElapsed / 1000, reqBitrate);\n    }\n    return ewma1.getEstimate();\n}\n/**\n * Estimate remaining time for a pending request from a progress event.\n * @param {Object} lastProgressEvent\n * @param {number} bandwidthEstimate\n * @returns {number}\n */\nfunction estimateRemainingTime(lastProgressEvent, bandwidthEstimate) {\n    const remainingData = (lastProgressEvent.totalSize - lastProgressEvent.size) * 8;\n    return Math.max(remainingData / bandwidthEstimate, 0);\n}\n/**\n * Check if the request for the most needed segment is too slow.\n * If that's the case, re-calculate the bandwidth urgently based on\n * this single request.\n * @param {Object} pendingRequests - Every requests pending, in a chronological\n * order in terms of segment time.\n * @param {Object} playbackInfo - Information on the current playback.\n * @param {Object|null} currentRepresentation - The Representation being\n * presently being loaded.\n * @param {boolean} lowLatencyMode - If `true`, we're playing the content as a\n * low latency content - where requests might be pending when the segment is\n * still encoded.\n * @param {Number} lastEstimatedBitrate - Last bitrate estimate emitted.\n * @returns {Number|undefined}\n */\nfunction estimateStarvationModeBitrate(pendingRequests, playbackInfo, currentRepresentation, lowLatencyMode, lastEstimatedBitrate) {\n    if (lowLatencyMode) {\n        // TODO Skip only for newer segments?\n        return undefined;\n    }\n    const { bufferGap, speed, position } = playbackInfo;\n    const realBufferGap = isFinite(bufferGap) ? bufferGap : 0;\n    const nextNeededPosition = position.getWanted() + realBufferGap;\n    const concernedRequests = getConcernedRequests(pendingRequests, nextNeededPosition);\n    if (concernedRequests.length !== 1) {\n        // 0  == no request\n        // 2+ == too complicated to calculate\n        return undefined;\n    }\n    const concernedRequest = concernedRequests[0];\n    const now = getMonotonicTimeStamp();\n    let minimumRequestTime = concernedRequest.content.segment.duration * 1.5;\n    minimumRequestTime = Math.min(minimumRequestTime, 3000);\n    minimumRequestTime = Math.max(minimumRequestTime, 12000);\n    if (now - concernedRequest.requestTimestamp < minimumRequestTime) {\n        return undefined;\n    }\n    const lastProgressEvent = concernedRequest.progress.length > 0\n        ? concernedRequest.progress[concernedRequest.progress.length - 1]\n        : undefined;\n    // first, try to do a quick estimate from progress events\n    const bandwidthEstimate = estimateRequestBandwidth(concernedRequest);\n    if (lastProgressEvent !== undefined && bandwidthEstimate !== undefined) {\n        const remainingTime = estimateRemainingTime(lastProgressEvent, bandwidthEstimate);\n        // if the remaining time does seem reliable\n        if ((now - lastProgressEvent.timestamp) / 1000 <= remainingTime) {\n            // Calculate estimated time spent rebuffering if we continue doing that request.\n            const expectedRebufferingTime = remainingTime - realBufferGap / speed;\n            if (expectedRebufferingTime > 2500) {\n                return bandwidthEstimate;\n            }\n        }\n    }\n    if (!concernedRequest.content.segment.complete) {\n        return undefined;\n    }\n    const chunkDuration = concernedRequest.content.segment.duration;\n    const requestElapsedTime = (now - concernedRequest.requestTimestamp) / 1000;\n    const reasonableElapsedTime = requestElapsedTime <= (chunkDuration * 1.5 + 2) / speed;\n    if (isNullOrUndefined(currentRepresentation) || reasonableElapsedTime) {\n        return undefined;\n    }\n    // calculate a reduced bitrate from the current one\n    const factor = chunkDuration / requestElapsedTime;\n    const reducedBitrate = currentRepresentation.bitrate * Math.min(0.7, factor);\n    if (lastEstimatedBitrate === undefined || reducedBitrate < lastEstimatedBitrate) {\n        return reducedBitrate;\n    }\n}\n/**\n * Returns true if, based on the current requests, it seems that the ABR should\n * switch immediately if a lower bitrate is more adapted.\n * Returns false if it estimates that you have time before switching to a lower\n * bitrate.\n * @param {Object} playbackInfo - Information on the current playback.\n * @param {Object} requests - Every requests pending, in a chronological\n * order in terms of segment time.\n * @param {boolean} lowLatencyMode - If `true`, we're playing the content as a\n * low latency content, as close to the live edge as possible.\n * @returns {boolean}\n */\nfunction shouldDirectlySwitchToLowBitrate(playbackInfo, requests, lowLatencyMode) {\n    if (lowLatencyMode) {\n        // TODO only when playing close to the live edge?\n        return true;\n    }\n    const realBufferGap = isFinite(playbackInfo.bufferGap) ? playbackInfo.bufferGap : 0;\n    const nextNeededPosition = playbackInfo.position.getWanted() + realBufferGap;\n    const nextRequest = arrayFind(requests, ({ content }) => content.segment.duration > 0 &&\n        content.segment.time + content.segment.duration > nextNeededPosition);\n    if (nextRequest === undefined) {\n        return true;\n    }\n    const now = getMonotonicTimeStamp();\n    const lastProgressEvent = nextRequest.progress.length > 0\n        ? nextRequest.progress[nextRequest.progress.length - 1]\n        : undefined;\n    // first, try to do a quick estimate from progress events\n    const bandwidthEstimate = estimateRequestBandwidth(nextRequest);\n    if (lastProgressEvent === undefined || bandwidthEstimate === undefined) {\n        return true;\n    }\n    const remainingTime = estimateRemainingTime(lastProgressEvent, bandwidthEstimate);\n    if ((now - lastProgressEvent.timestamp) / 1000 > remainingTime * 1.2) {\n        return true;\n    }\n    const expectedRebufferingTime = remainingTime - realBufferGap / playbackInfo.speed;\n    return expectedRebufferingTime > -1.5;\n}\n/**\n * Analyze the current network conditions and give a bandwidth estimate as well\n * as a maximum bitrate a Representation should be.\n * @class NetworkAnalyzer\n */\nexport default class NetworkAnalyzer {\n    constructor(initialBitrate, lowLatencyMode) {\n        const { ABR_STARVATION_GAP, OUT_OF_STARVATION_GAP, ABR_STARVATION_FACTOR, ABR_REGULAR_FACTOR, } = config.getCurrent();\n        this._initialBitrate = initialBitrate;\n        this._inStarvationMode = false;\n        this._lowLatencyMode = lowLatencyMode;\n        if (lowLatencyMode) {\n            this._config = {\n                starvationGap: ABR_STARVATION_GAP.LOW_LATENCY,\n                outOfStarvationGap: OUT_OF_STARVATION_GAP.LOW_LATENCY,\n                starvationBitrateFactor: ABR_STARVATION_FACTOR.LOW_LATENCY,\n                regularBitrateFactor: ABR_REGULAR_FACTOR.LOW_LATENCY,\n            };\n        }\n        else {\n            this._config = {\n                starvationGap: ABR_STARVATION_GAP.DEFAULT,\n                outOfStarvationGap: OUT_OF_STARVATION_GAP.DEFAULT,\n                starvationBitrateFactor: ABR_STARVATION_FACTOR.DEFAULT,\n                regularBitrateFactor: ABR_REGULAR_FACTOR.DEFAULT,\n            };\n        }\n    }\n    /**\n     * Gives an estimate of the current bandwidth and of the bitrate that should\n     * be considered for chosing a `representation`.\n     * This estimate is only based on network metrics.\n     * @param {Object} playbackInfo - Gives current information about playback.\n     * @param {Object} bandwidthEstimator - `BandwidthEstimator` allowing to\n     * produce network bandwidth estimates.\n     * @param {Object|null} currentRepresentation - The Representation currently\n     * chosen.\n     * `null` if no Representation has been chosen yet.\n     * @param {Array.<Object>} currentRequests - All segment requests by segment's\n     * start chronological order\n     * @param {number|undefined} lastEstimatedBitrate - Bitrate emitted during the\n     * last estimate.\n     * @returns {Object}\n     */\n    getBandwidthEstimate(playbackInfo, bandwidthEstimator, currentRepresentation, currentRequests, lastEstimatedBitrate) {\n        let newBitrateCeil; // bitrate ceil for the chosen Representation\n        let bandwidthEstimate;\n        const localConf = this._config;\n        const { bufferGap, position, duration } = playbackInfo;\n        const realBufferGap = isFinite(bufferGap) ? bufferGap : 0;\n        const { ABR_STARVATION_DURATION_DELTA } = config.getCurrent();\n        // check if should get in/out of starvation mode\n        if (isNaN(duration) ||\n            realBufferGap + position.getWanted() < duration - ABR_STARVATION_DURATION_DELTA) {\n            if (!this._inStarvationMode && realBufferGap <= localConf.starvationGap) {\n                log.info(\"ABR: enter starvation mode.\");\n                this._inStarvationMode = true;\n            }\n            else if (this._inStarvationMode &&\n                realBufferGap >= localConf.outOfStarvationGap) {\n                log.info(\"ABR: exit starvation mode.\");\n                this._inStarvationMode = false;\n            }\n        }\n        else if (this._inStarvationMode) {\n            log.info(\"ABR: exit starvation mode.\");\n            this._inStarvationMode = false;\n        }\n        // If in starvation mode, check if a quick new estimate can be done\n        // from the last requests.\n        // If so, cancel previous estimates and replace it by the new one\n        if (this._inStarvationMode) {\n            bandwidthEstimate = estimateStarvationModeBitrate(currentRequests, playbackInfo, currentRepresentation, this._lowLatencyMode, lastEstimatedBitrate);\n            if (bandwidthEstimate !== undefined) {\n                log.info(\"ABR: starvation mode emergency estimate:\", bandwidthEstimate);\n                bandwidthEstimator.reset();\n                newBitrateCeil = isNullOrUndefined(currentRepresentation)\n                    ? bandwidthEstimate\n                    : Math.min(bandwidthEstimate, currentRepresentation.bitrate);\n            }\n        }\n        // if newBitrateCeil is not yet defined, do the normal estimation\n        if (isNullOrUndefined(newBitrateCeil)) {\n            bandwidthEstimate = bandwidthEstimator.getEstimate();\n            if (bandwidthEstimate !== undefined) {\n                newBitrateCeil =\n                    bandwidthEstimate *\n                        (this._inStarvationMode\n                            ? localConf.starvationBitrateFactor\n                            : localConf.regularBitrateFactor);\n            }\n            else if (lastEstimatedBitrate !== undefined) {\n                newBitrateCeil =\n                    lastEstimatedBitrate *\n                        (this._inStarvationMode\n                            ? localConf.starvationBitrateFactor\n                            : localConf.regularBitrateFactor);\n            }\n            else {\n                newBitrateCeil = this._initialBitrate;\n            }\n        }\n        if (playbackInfo.speed > 1) {\n            newBitrateCeil /= playbackInfo.speed;\n        }\n        return { bandwidthEstimate, bitrateChosen: newBitrateCeil };\n    }\n    /**\n     * For a given wanted bitrate, tells if should switch urgently.\n     * @param {number} bitrate - The new estimated bitrate.\n     * @param {Object|null} currentRepresentation - The Representation being\n     * presently being loaded.\n     * @param {Array.<Object>} currentRequests - All segment requests by segment's\n     * start chronological order\n     * @param {Object} playbackInfo - Information on the current playback.\n     * @returns {boolean}\n     */\n    isUrgent(bitrate, currentRepresentation, currentRequests, playbackInfo) {\n        if (currentRepresentation === null) {\n            return true;\n        }\n        else if (bitrate >= currentRepresentation.bitrate) {\n            return false;\n        }\n        return shouldDirectlySwitchToLowBitrate(playbackInfo, currentRequests, this._lowLatencyMode);\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport config from \"../../../config\";\nimport EWMA from \"./ewma\";\n/**\n * Calculate a mean bandwidth based on the bytes downloaded and the amount\n * of time needed to do so.\n * @class BandwidthEstimator\n */\nexport default class BandwidthEstimator {\n    constructor() {\n        const { ABR_FAST_EMA, ABR_SLOW_EMA } = config.getCurrent();\n        this._fastEWMA = new EWMA(ABR_FAST_EMA);\n        this._slowEWMA = new EWMA(ABR_SLOW_EMA);\n        this._bytesSampled = 0;\n    }\n    /**\n     * Takes a bandwidth sample.\n     * @param {number} durationInMs - The amount of time, in milliseconds, for a\n     * particular request.\n     * @param {number} numberOfBytes - The total number of bytes transferred in\n     * that request.\n     */\n    addSample(durationInMs, numberOfBytes) {\n        const { ABR_MINIMUM_CHUNK_SIZE } = config.getCurrent();\n        if (numberOfBytes < ABR_MINIMUM_CHUNK_SIZE) {\n            return;\n        }\n        const bandwidth = (numberOfBytes * 8000) / durationInMs;\n        const weight = durationInMs / 1000;\n        this._bytesSampled += numberOfBytes;\n        this._fastEWMA.addSample(weight, bandwidth);\n        this._slowEWMA.addSample(weight, bandwidth);\n    }\n    /**\n     * Get estimate of the bandwidth, in bits per seconds.\n     * @returns {Number|undefined}\n     */\n    getEstimate() {\n        const { ABR_MINIMUM_TOTAL_BYTES } = config.getCurrent();\n        if (this._bytesSampled < ABR_MINIMUM_TOTAL_BYTES) {\n            return undefined;\n        }\n        // Take the minimum of these two estimates.\n        // This should have the effect of adapting down quickly, but up more slowly.\n        return Math.min(this._fastEWMA.getEstimate(), this._slowEWMA.getEstimate());\n    }\n    /** Reset the bandwidth estimation. */\n    reset() {\n        const { ABR_FAST_EMA, ABR_SLOW_EMA } = config.getCurrent();\n        this._fastEWMA = new EWMA(ABR_FAST_EMA);\n        this._slowEWMA = new EWMA(ABR_SLOW_EMA);\n        this._bytesSampled = 0;\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Tweaked implementation of an exponential weighted Moving Average.\n * @class EWMA\n */\nexport default class EWMA {\n    /**\n     * @param {number} halfLife\n     */\n    constructor(halfLife) {\n        // (half-life = log(1/2) / log(Decay Factor)\n        this._alpha = Math.exp(Math.log(0.5) / halfLife);\n        this._lastEstimate = 0;\n        this._totalWeight = 0;\n    }\n    /**\n     * @param {number} weight\n     * @param {number} value\n     */\n    addSample(weight, value) {\n        const adjAlpha = Math.pow(this._alpha, weight);\n        const newEstimate = value * (1 - adjAlpha) + adjAlpha * this._lastEstimate;\n        if (!isNaN(newEstimate)) {\n            this._lastEstimate = newEstimate;\n            this._totalWeight += weight;\n        }\n    }\n    /**\n     * @returns {number} value\n     */\n    getEstimate() {\n        const zeroFactor = 1 - Math.pow(this._alpha, this._totalWeight);\n        return this._lastEstimate / zeroFactor;\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport arrayFindIndex from \"../../../utils/array_find_index\";\n/**\n * Get only representations lower or equal to a given bitrate.\n * If no representation is lower than the given bitrate, returns an array containing\n * all Representation(s) with the lowest available bitrate.\n * @param {Array.<Object>} representations - All Representations available\n * @param {Number} bitrate\n * @returns {Array.<Object>}\n */\nexport default function filterByBitrate(representations, bitrate) {\n    if (representations.length === 0) {\n        return [];\n    }\n    representations.sort((ra, rb) => ra.bitrate - rb.bitrate);\n    const minimumBitrate = representations[0].bitrate;\n    const bitrateCeil = Math.max(bitrate, minimumBitrate);\n    const firstSuperiorBitrateIndex = arrayFindIndex(representations, (representation) => representation.bitrate > bitrateCeil);\n    if (firstSuperiorBitrateIndex === -1) {\n        return representations; // All representations have lower bitrates.\n    }\n    return representations.slice(0, firstSuperiorBitrateIndex);\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport arrayFind from \"../../../utils/array_find\";\n/**\n * Filter representations based on their resolution.\n *   - the highest resolution considered will be the one linked to the first\n *     representation which has a superior resolution or equal to the one\n *     given.\n * @param {Array.<Object>} representations - The representations array\n * @param {Object} resolution\n * @returns {Array.<Object>}\n */\nexport default function filterByResolution(representations, resolution) {\n    if (resolution.width === undefined || resolution.height === undefined) {\n        return representations;\n    }\n    const width = resolution.width * resolution.pixelRatio;\n    const height = resolution.height * resolution.pixelRatio;\n    const sortedRepsByWidth = representations\n        .slice() // clone\n        .sort((a, b) => { var _a, _b; return ((_a = a.width) !== null && _a !== void 0 ? _a : 0) - ((_b = b.width) !== null && _b !== void 0 ? _b : 0); });\n    const repWithMaxWidth = arrayFind(sortedRepsByWidth, (representation) => typeof representation.width === \"number\" &&\n        representation.width >= width &&\n        typeof representation.height === \"number\" &&\n        representation.height >= height);\n    if (repWithMaxWidth === undefined) {\n        return representations;\n    }\n    const maxWidth = typeof repWithMaxWidth.width === \"number\" ? repWithMaxWidth.width : 0;\n    return representations.filter((representation) => typeof representation.width === \"number\" ? representation.width <= maxWidth : true);\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Return \"Buffer Levels\" which are steps of available buffers from which we\n * are normally able switch safely to the next available bitrate.\n * (Following an algorithm close to BOLA)\n * @param {Array.<number>} bitrates - All available bitrates, __sorted__ in\n * ascending order.\n * @returns {Array.<number>}\n */\nexport default function getBufferLevels(bitrates) {\n    const logs = bitrates.map((b) => Math.log(b / bitrates[0]));\n    const utilities = logs.map((l) => l - logs[0] + 1); // normalize\n    const gp = (utilities[utilities.length - 1] - 1) / (bitrates.length * 2 + 10);\n    const Vp = 1 / gp;\n    return bitrates.map((_, i) => minBufferLevelForBitrate(i));\n    /**\n     * Get minimum buffer we should keep ahead to pick this bitrate.\n     * @param {number} index\n     * @returns {number}\n     */\n    function minBufferLevelForBitrate(index) {\n        if (index === 0) {\n            return 0;\n        }\n        const boundedIndex = Math.min(Math.max(1, index), bitrates.length - 1);\n        if (bitrates[boundedIndex] === bitrates[boundedIndex - 1]) {\n            return minBufferLevelForBitrate(index - 1);\n        }\n        return (Vp *\n            (gp +\n                (bitrates[boundedIndex] * utilities[boundedIndex - 1] -\n                    bitrates[boundedIndex - 1] * utilities[boundedIndex]) /\n                    (bitrates[boundedIndex] - bitrates[boundedIndex - 1])) +\n            4);\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Stores the last estimate made by the `RepresentationEstimator`. */\nexport default class LastEstimateStorage {\n    constructor() {\n        this.bandwidth = undefined;\n        this.representation = null;\n        this.algorithmType = 3 /* ABRAlgorithmType.None */;\n    }\n    /**\n     * Update this `LastEstimateStorage` with new values.\n     * @param {Object} representation - Estimated Representation.\n     * @param {number|undefined} bandwidth - Estimated bandwidth.\n     * @param {number} algorithmType - The type of algorithm used to produce that\n     * estimate.\n     */\n    update(representation, bandwidth, algorithmType) {\n        this.representation = representation;\n        this.bandwidth = bandwidth;\n        this.algorithmType = algorithmType;\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../../log\";\nimport isNullOrUndefined from \"../../../utils/is_null_or_undefined\";\nimport objectValues from \"../../../utils/object_values\";\n/**\n * Store information about pending requests, like information about:\n *   - for which segments they are\n *   - how the request's progress goes\n * @class PendingRequestsStore\n */\nexport default class PendingRequestsStore {\n    constructor() {\n        this._currentRequests = {};\n    }\n    /**\n     * Add information about a new pending request.\n     * @param {Object} payload\n     */\n    add(payload) {\n        const { id, requestTimestamp, content } = payload;\n        this._currentRequests[id] = { requestTimestamp, progress: [], content };\n    }\n    /**\n     * Notify of the progress of a currently pending request.\n     * @param {Object} progress\n     */\n    addProgress(progress) {\n        const request = this._currentRequests[progress.id];\n        if (isNullOrUndefined(request)) {\n            if (0 /* __ENVIRONMENT__.CURRENT_ENV */ === 1 /* __ENVIRONMENT__.DEV */) {\n                throw new Error(\"ABR: progress for a request not added\");\n            }\n            log.warn(\"ABR: progress for a request not added\");\n            return;\n        }\n        request.progress.push(progress);\n    }\n    /**\n     * Remove a request previously set as pending.\n     * @param {string} id\n     */\n    remove(id) {\n        if (isNullOrUndefined(this._currentRequests[id])) {\n            if (0 /* __ENVIRONMENT__.CURRENT_ENV */ === 1 /* __ENVIRONMENT__.DEV */) {\n                throw new Error(\"ABR: can't remove unknown request\");\n            }\n            log.warn(\"ABR: can't remove unknown request\");\n        }\n        delete this._currentRequests[id];\n    }\n    /**\n     * Returns information about all pending requests, in segment's chronological\n     * order.\n     * @returns {Array.<Object>}\n     */\n    getRequests() {\n        return objectValues(this._currentRequests)\n            .filter((x) => !isNullOrUndefined(x))\n            .sort((reqA, reqB) => reqA.content.segment.time - reqB.content.segment.time);\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../../log\";\nimport EWMA from \"./ewma\";\n/**\n * Calculate the \"maintainability score\" of a given Representation:\n *   - A score higher than 1 means that the Representation can theorically\n *     be downloaded faster than the duration of the media it represents.\n *     (e.g. a segment representing 4 seconds can be downloaded in less than 4\n *     seconds).\n *   - A score lower or equal to 1 means that the Representation cannot be\n *     downloaded\n *\n * The score follows a simple linear relation to both variables it is based\n * on:\n *   - if n seconds of content can be downloaded in 2*n seconds, the score will\n *     be `0.5`.\n *   - if n seconds of content can be downloaded in n seconds, the score will be\n *     `1`.\n *   - if n seconds of content can be downloaded in n/2 seconds, the score will\n *     be `2`.\n *   - ...\n *\n * The score is mainly here to tell you when your buffer-based guesses are\n * actually higher than the quality you should normally reach.\n *\n * /!\\ Please bear in mind that we don't consider the playback rate in those\n * operations.\n * Still, integrating the playback rate a posteriori should not be difficult\n * (e.g. you can just divide the score by that rate).\n *\n * @class RepresentationScoreCalculator\n */\nexport default class RepresentationScoreCalculator {\n    constructor() {\n        this._currentRepresentationData = null;\n        this._lastRepresentationWithGoodScore = null;\n    }\n    /**\n     * Add new sample data.\n     * @param {Object} representation\n     * @param {number} requestDuration - duration taken for doing the request for\n     * the whole segment.\n     * @param {number} segmentDuration - media duration of the whole segment, in\n     * seconds.\n     */\n    addSample(representation, requestDuration, segmentDuration) {\n        const ratio = segmentDuration / requestDuration;\n        const currentRep = this._currentRepresentationData;\n        let currentEWMA;\n        if (currentRep !== null && currentRep.representation.id === representation.id) {\n            currentEWMA = currentRep.ewma;\n            currentRep.ewma.addSample(requestDuration, ratio);\n            currentRep.loadedDuration += segmentDuration;\n            currentRep.loadedSegments++;\n        }\n        else {\n            currentEWMA = new EWMA(5);\n            currentEWMA.addSample(requestDuration, ratio);\n            this._currentRepresentationData = {\n                representation,\n                ewma: currentEWMA,\n                loadedDuration: segmentDuration,\n                loadedSegments: 0,\n            };\n        }\n        if (currentEWMA.getEstimate() > 1 &&\n            this._lastRepresentationWithGoodScore !== representation) {\n            log.debug(\"ABR: New last stable representation\", representation.bitrate);\n            this._lastRepresentationWithGoodScore = representation;\n        }\n    }\n    /**\n     * Get score estimate for the given Representation.\n     * undefined if no estimate is available.\n     * @param {Object} representation\n     * @returns {number|undefined}\n     */\n    getEstimate(representation) {\n        if (this._currentRepresentationData === null ||\n            this._currentRepresentationData.representation.id !== representation.id) {\n            return undefined;\n        }\n        const { ewma, loadedSegments, loadedDuration } = this._currentRepresentationData;\n        const estimate = ewma.getEstimate();\n        const confidenceLevel = loadedSegments >= 5 && loadedDuration >= 10\n            ? 1 /* ScoreConfidenceLevel.HIGH */\n            : 0 /* ScoreConfidenceLevel.LOW */;\n        return { score: estimate, confidenceLevel };\n    }\n    /**\n     * Returns last Representation which had reached a score superior to 1.\n     * This Representation is the last known one which could be maintained.\n     * Useful to know if a current guess is higher than what you should\n     * normally be able to play.\n     * `null` if no Representation ever reach that score.\n     * @returns {Object|null}\n     */\n    getLastStableRepresentation() {\n        return this._lastRepresentationWithGoodScore;\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport arrayFindIndex from \"../../../utils/array_find_index\";\n/**\n * From the given array of Representations (sorted by bitrate order ascending),\n * returns the one corresponding to the given optimal, minimum and maximum\n * bitrates.\n * @param {Array.<Object>} representations - The representations array,\n * sorted in bitrate ascending order.\n * @param {Number} wantedBitrate - The optimal bitrate the Representation\n * should have under the current condition.\n * @returns {Object|undefined}\n */\nexport default function selectOptimalRepresentation(representations, wantedBitrate) {\n    const firstIndexTooHigh = arrayFindIndex(representations, (representation) => representation.bitrate > wantedBitrate);\n    if (firstIndexTooHigh === -1) {\n        return representations[representations.length - 1];\n    }\n    else if (firstIndexTooHigh === 0) {\n        return representations[0];\n    }\n    return representations[firstIndexTooHigh - 1];\n}\n","import log from \"../../log\";\nimport createUuid from \"../../utils/create_uuid\";\nimport isNullOrUndefined from \"../../utils/is_null_or_undefined\";\nimport TaskCanceller from \"../../utils/task_canceller\";\nimport { getRelativeUrl } from \"../../utils/url-utils\";\n/**\n * `rtp`, for \"REQUESTED_MAXIMUM_THROUGHPUT\", indicates the maximum throughput\n * needed to load a given segment without experience degration.\n * It acts as a hint to a CDN so it can scale its resources between multiple\n * clients.\n *\n * We could indicate through `rtp` the exact minimum bandwidth needed, but this\n * may lead to much higher risk of rebuffering, so we prefer to multiply that\n * value by a safe-enough factor, this `RTP_FACTOR`.\n */\nconst RTP_FACTOR = 4;\n/**\n * Class allowing to easily obtain \"Common Media Client Data\" (CMCD) properties\n * that may be relied on while performing HTTP(S) requests on a CDN.\n *\n * @class CmcdDataBuilder\n */\nexport default class CmcdDataBuilder {\n    /**\n     * Create a new `CmcdDataBuilder`, linked to the given options (see type\n     * definition).\n     * @param {Object} options\n     */\n    constructor(options) {\n        var _a, _b;\n        this._sessionId = (_a = options.sessionId) !== null && _a !== void 0 ? _a : createUuid();\n        this._contentId = (_b = options.contentId) !== null && _b !== void 0 ? _b : createUuid();\n        this._typePreference =\n            options.communicationType === \"headers\"\n                ? 0 /* TypePreference.Headers */\n                : 1 /* TypePreference.QueryString */;\n        this._bufferStarvationToggle = false;\n        this._playbackObserver = null;\n        this._lastThroughput = {};\n        this._canceller = null;\n    }\n    /**\n     * Start listening to the given `playbackObserver` so the `CmcdDataBuilder`\n     * can extract some playback-linked metadata that it needs.\n     *\n     * It will keep listening for media data until `stopMonitoringPlayback` is called.\n     *\n     * If `startMonitoringPlayback` is called again, the previous monitoring is\n     * also cancelled.\n     * @param {Object} playbackObserver\n     */\n    startMonitoringPlayback(playbackObserver) {\n        var _a;\n        (_a = this._canceller) === null || _a === void 0 ? void 0 : _a.cancel();\n        this._canceller = new TaskCanceller();\n        this._playbackObserver = playbackObserver;\n        playbackObserver.listen((obs) => {\n            if (obs.rebuffering !== null) {\n                this._bufferStarvationToggle = true;\n            }\n        }, { includeLastObservation: true, clearSignal: this._canceller.signal });\n    }\n    /**\n     * Stop the monitoring of playback conditions started from the last\n     * `stopMonitoringPlayback` call.\n     */\n    stopMonitoringPlayback() {\n        var _a;\n        (_a = this._canceller) === null || _a === void 0 ? void 0 : _a.cancel();\n        this._canceller = null;\n        this._playbackObserver = null;\n    }\n    /**\n     * Update the last measured throughput for a specific media type.\n     * Needed for some of CMCD's properties.\n     * @param {string} trackType\n     * @param {number|undefined} throughput - Last throughput measured for that\n     * media type. `undefined` if unknown.\n     */\n    updateThroughput(trackType, throughput) {\n        this._lastThroughput[trackType] = throughput;\n    }\n    /**\n     * Returns the base of data that is common to all resources' requests.\n     * @param {number|undefined} lastThroughput - The last measured throughput to\n     * provide. `undefined` to provide no throughput.\n     * @returns {Object}\n     */\n    _getCommonCmcdData(lastThroughput) {\n        var _a;\n        const props = {};\n        props.bs = this._bufferStarvationToggle;\n        this._bufferStarvationToggle = false;\n        props.cid = this._contentId;\n        props.mtp =\n            lastThroughput !== undefined\n                ? Math.floor(Math.round(lastThroughput / 1000 / 100) * 100)\n                : undefined;\n        props.sid = this._sessionId;\n        const lastObservation = (_a = this._playbackObserver) === null || _a === void 0 ? void 0 : _a.getReference().getValue();\n        props.pr =\n            lastObservation === undefined || lastObservation.speed === 1\n                ? undefined\n                : lastObservation.speed;\n        if (lastObservation !== undefined) {\n            props.su = lastObservation.rebuffering !== null;\n        }\n        return props;\n    }\n    /**\n     * For the given type of Manifest, returns the corresponding CMCD payload\n     * that should be provided alongside its request.\n     * @param {string} transportType\n     * @returns {Object}\n     */\n    getCmcdDataForManifest(transportType) {\n        var _a;\n        const props = this._getCommonCmcdData((_a = this._lastThroughput.video) !== null && _a !== void 0 ? _a : this._lastThroughput.audio);\n        props.ot = \"m\";\n        switch (transportType) {\n            case \"dash\":\n                props.sf = \"d\";\n                break;\n            case \"smooth\":\n                props.sf = \"s\";\n                break;\n            default:\n                props.sf = \"o\";\n                break;\n        }\n        return this._producePayload(props);\n    }\n    /**\n     * For the given segment information, returns the corresponding CMCD payload\n     * that should be provided alongside its request.\n     * @param {Object} content\n     * @returns {Object}\n     */\n    getCmcdDataForSegmentRequest(content) {\n        var _a, _b, _c, _d;\n        const lastObservation = (_a = this._playbackObserver) === null || _a === void 0 ? void 0 : _a.getReference().getValue();\n        const props = this._getCommonCmcdData(this._lastThroughput[content.adaptation.type]);\n        props.br = Math.round(content.representation.bitrate / 1000);\n        props.d = Math.round(content.segment.duration * 1000);\n        switch (content.adaptation.type) {\n            case \"video\":\n                props.ot = \"v\";\n                break;\n            case \"audio\":\n                props.ot = \"a\";\n                break;\n            case \"text\":\n                props.ot = \"c\";\n                break;\n        }\n        if (content.segment.isInit) {\n            props.ot = \"i\";\n        }\n        if (!isNullOrUndefined(content.nextSegment) &&\n            content.segment.url !== null &&\n            content.nextSegment.url !== null) {\n            // We add a special case for some initialization segment which need\n            // multiple byte-ranges to fully request, as the `CmcdDataBuilder`\n            // is not supposed to keep track of how the requesting part of the\n            // RxPlayer actually perform its multi-byte-range requests\n            if (!content.nextSegment.isInit || content.nextSegment.indexRange === undefined) {\n                const currSegmentUrl = content.segment.url;\n                const nextSegmentUrl = content.nextSegment.url;\n                const relativeUrl = getRelativeUrl(currSegmentUrl, nextSegmentUrl);\n                if (relativeUrl !== null) {\n                    if (relativeUrl !== \".\") {\n                        props.nor = encodeURIComponent(relativeUrl);\n                    }\n                    if (content.nextSegment.range !== undefined) {\n                        props.nrr = String(content.nextSegment.range[0]) + \"-\";\n                        if (isFinite(content.nextSegment.range[1])) {\n                            props.nrr += String(content.nextSegment.range[1]);\n                        }\n                    }\n                }\n            }\n        }\n        let precizeBufferLengthMs;\n        if (lastObservation !== undefined &&\n            (props.ot === \"v\" || props.ot === \"a\" || props.ot === \"av\")) {\n            const bufferedForType = lastObservation.buffered[content.adaptation.type];\n            if (!isNullOrUndefined(bufferedForType)) {\n                // TODO more precize position estimate?\n                const position = (_d = (_c = (_b = this._playbackObserver) === null || _b === void 0 ? void 0 : _b.getCurrentTime()) !== null && _c !== void 0 ? _c : lastObservation.position.getWanted()) !== null && _d !== void 0 ? _d : lastObservation.position.getPolled();\n                for (const range of bufferedForType) {\n                    if (position >= range.start && position < range.end) {\n                        precizeBufferLengthMs = (range.end - position) * 1000;\n                        props.bl = Math.floor(Math.round(precizeBufferLengthMs / 100) * 100);\n                        break;\n                    }\n                }\n            }\n        }\n        const precizeDeadlineMs = precizeBufferLengthMs === undefined || lastObservation === undefined\n            ? undefined\n            : precizeBufferLengthMs / lastObservation.speed;\n        props.dl =\n            precizeDeadlineMs === undefined\n                ? undefined\n                : Math.floor(Math.round(precizeDeadlineMs / 100) * 100);\n        if (precizeDeadlineMs !== undefined) {\n            // estimate the file size, in kilobits\n            const estimatedFileSizeKb = (content.representation.bitrate * content.segment.duration) / 1000;\n            const wantedCeilBandwidthKbps = estimatedFileSizeKb / (precizeDeadlineMs / 1000);\n            props.rtp = Math.floor(Math.round((wantedCeilBandwidthKbps * RTP_FACTOR) / 100) * 100);\n        }\n        switch (content.manifest.transport) {\n            case \"dash\":\n                props.sf = \"d\";\n                break;\n            case \"smooth\":\n                props.sf = \"s\";\n                break;\n            default:\n                props.sf = \"o\";\n                break;\n        }\n        props.st = content.manifest.isDynamic ? \"l\" : \"v\";\n        props.tb = content.adaptation.representations.reduce((acc, representation) => {\n            if (representation.isPlayable() !== true) {\n                return acc;\n            }\n            if (acc === undefined) {\n                return Math.round(representation.bitrate / 1000);\n            }\n            return Math.max(acc, Math.round(representation.bitrate / 1000));\n        }, undefined);\n        return this._producePayload(props);\n    }\n    /**\n     * From the given CMCD properties, produce the corresponding payload according\n     * to current settings.\n     * @param {Object} props\n     * @returns {Object}\n     */\n    _producePayload(props) {\n        const headers = {\n            object: \"\",\n            request: \"\",\n            session: \"\",\n            status: \"\",\n        };\n        let queryStringPayload = \"\";\n        const addPayload = (payload, headerName) => {\n            if (this._typePreference === 0 /* TypePreference.Headers */) {\n                headers[headerName] += payload;\n            }\n            else {\n                queryStringPayload += payload;\n            }\n        };\n        const addNumberProperty = (prop, headerName) => {\n            const val = props[prop];\n            if (val !== undefined) {\n                const toAdd = `${prop}=${String(val)},`;\n                addPayload(toAdd, headerName);\n            }\n        };\n        const addBooleanProperty = (prop, headerName) => {\n            if (props[prop] === true) {\n                const toAdd = `${prop},`;\n                addPayload(toAdd, headerName);\n            }\n        };\n        const addStringProperty = (prop, headerName) => {\n            const val = props[prop];\n            if (val !== undefined) {\n                const formatted = `\"${val.replace(\"\\\\\", \"\\\\\\\\\").replace('\"', '\\\\\"')}\"`;\n                const toAdd = `prop=${formatted},`;\n                addPayload(toAdd, headerName);\n            }\n        };\n        const addTokenProperty = (prop, headerName) => {\n            const val = props[prop];\n            if (val !== undefined) {\n                const toAdd = `prop=${val},`;\n                addPayload(toAdd, headerName);\n            }\n        };\n        addNumberProperty(\"bl\", \"request\");\n        addNumberProperty(\"br\", \"object\");\n        addBooleanProperty(\"bs\", \"status\");\n        addStringProperty(\"cid\", \"session\");\n        addNumberProperty(\"d\", \"object\");\n        addNumberProperty(\"dl\", \"request\");\n        addNumberProperty(\"mtp\", \"request\");\n        addStringProperty(\"nor\", \"request\");\n        addStringProperty(\"nrr\", \"request\");\n        addTokenProperty(\"ot\", \"object\");\n        addNumberProperty(\"pr\", \"session\");\n        addNumberProperty(\"rtp\", \"status\");\n        addTokenProperty(\"sf\", \"session\");\n        addStringProperty(\"sid\", \"session\");\n        addTokenProperty(\"st\", \"session\");\n        addBooleanProperty(\"su\", \"request\");\n        addNumberProperty(\"tb\", \"object\");\n        if (this._typePreference === 0 /* TypePreference.Headers */) {\n            if (headers.object[headers.object.length - 1] === \",\") {\n                headers.object = headers.object.substring(0, headers.object.length - 1);\n            }\n            if (headers.request[headers.request.length - 1] === \",\") {\n                headers.request = headers.request.substring(0, headers.request.length - 1);\n            }\n            if (headers.session[headers.session.length - 1] === \",\") {\n                headers.session = headers.session.substring(0, headers.session.length - 1);\n            }\n            if (headers.status[headers.status.length - 1] === \",\") {\n                headers.status = headers.status.substring(0, headers.status.length - 1);\n            }\n            log.debug(\"CMCD: proposing headers payload\");\n            return {\n                type: \"headers\",\n                value: {\n                    /* eslint-disable @typescript-eslint/naming-convention */\n                    \"CMCD-Object\": headers.object,\n                    \"CMCD-Request\": headers.request,\n                    \"CMCD-Session\": headers.session,\n                    \"CMCD-Status\": headers.status,\n                    /* eslint-enable @typescript-eslint/naming-convention */\n                },\n            };\n        }\n        if (queryStringPayload[queryStringPayload.length - 1] === \",\") {\n            queryStringPayload = queryStringPayload.substring(0, queryStringPayload.length - 1);\n        }\n        queryStringPayload = encodeURIComponent(queryStringPayload);\n        log.debug(\"CMCD: proposing query string payload\", queryStringPayload);\n        return {\n            type: \"query\",\n            value: [[\"CMCD\", queryStringPayload]],\n        };\n    }\n}\n","import CmcdDataBuilder from \"./cmcd_data_builder\";\nexport default CmcdDataBuilder;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport config from \"../../config\";\nimport arrayFindIndex from \"../../utils/array_find_index\";\nimport EventEmitter from \"../../utils/event_emitter\";\n/**\n * Class storing and signaling the priority between multiple CDN available for\n * any given resource.\n *\n * This class was first created to implement the complexities behind\n * Content Steering features, though its handling hasn't been added yet as we\n * wait for its specification to be both standardized and relied on in the wild.\n * In the meantime, it acts as an abstraction for the simple concept of\n * avoiding to request a CDN for any segment when an issue is encountered with\n * one (e.g. HTTP 500 statuses) and several CDN exist for a given resource. It\n * should be noted that this is also one of the planified features of the\n * Content Steering specification.\n *\n * @class CdnPrioritizer\n */\nexport default class CdnPrioritizer extends EventEmitter {\n    /**\n     * @param {Object} destroySignal\n     */\n    constructor(destroySignal) {\n        super();\n        this._downgradedCdnList = { metadata: [], timeouts: [] };\n        destroySignal.register(() => {\n            for (const timeout of this._downgradedCdnList.timeouts) {\n                clearTimeout(timeout);\n            }\n            this._downgradedCdnList = { metadata: [], timeouts: [] };\n        });\n    }\n    /**\n     * From the list of __ALL__ CDNs available to a resource, return them in the\n     * order in which requests should be performed.\n     *\n     * Note: It is VERY important to include all CDN that are able to reach the\n     * wanted resource, even those which will in the end not be used anyway.\n     * If some CDN are not communicated, the `CdnPrioritizer` might wrongly\n     * consider that the current resource don't have any of the CDN prioritized\n     * internally and return other CDN which should have been forbidden if it knew\n     * about the other, non-used, ones.\n     *\n     * @param {Array.<string>} everyCdnForResource - Array of ALL available CDN\n     * able to reach the wanted resource - even those which might not be used in\n     * the end.\n     * @returns {Array.<Object>} - Array of CDN that can be tried to reach the\n     * resource, sorted by order of CDN preference, according to the\n     * `CdnPrioritizer`'s own list of priorities.\n     */\n    getCdnPreferenceForResource(everyCdnForResource) {\n        if (everyCdnForResource.length <= 1) {\n            // The huge majority of contents have only one CDN available.\n            // Here, prioritizing make no sense.\n            return everyCdnForResource;\n        }\n        return this._innerGetCdnPreferenceForResource(everyCdnForResource);\n    }\n    /**\n     * Limit usage of the CDN for a configured amount of time.\n     * Call this method if you encountered an issue with that CDN which leads you\n     * to want to prevent its usage currently.\n     *\n     * Note that the CDN can still be the preferred one if no other CDN exist for\n     * a wanted resource.\n     * @param {string} metadata\n     */\n    downgradeCdn(metadata) {\n        const indexOf = indexOfMetadata(this._downgradedCdnList.metadata, metadata);\n        if (indexOf >= 0) {\n            this._removeIndexFromDowngradeList(indexOf);\n        }\n        const { DEFAULT_CDN_DOWNGRADE_TIME } = config.getCurrent();\n        const downgradeTime = DEFAULT_CDN_DOWNGRADE_TIME;\n        this._downgradedCdnList.metadata.push(metadata);\n        const timeout = setTimeout(() => {\n            const newIndex = indexOfMetadata(this._downgradedCdnList.metadata, metadata);\n            if (newIndex >= 0) {\n                this._removeIndexFromDowngradeList(newIndex);\n            }\n            this.trigger(\"priorityChange\", null);\n        }, downgradeTime);\n        this._downgradedCdnList.timeouts.push(timeout);\n        this.trigger(\"priorityChange\", null);\n    }\n    /**\n     * From the list of __ALL__ CDNs available to a resource, return them in the\n     * order in which requests should be performed.\n     *\n     * Note: It is VERY important to include all CDN that are able to reach the\n     * wanted resource, even those which will in the end not be used anyway.\n     * If some CDN are not communicated, the `CdnPrioritizer` might wrongly\n     * consider that the current resource don't have any of the CDN prioritized\n     * internally and return other CDN which should have been forbidden if it knew\n     * about the other, non-used, ones.\n     *\n     * @param {Array.<string>} everyCdnForResource - Array of ALL available CDN\n     * able to reach the wanted resource - even those which might not be used in\n     * the end.\n     * @returns {Array.<string>} - Array of CDN that can be tried to reach the\n     * resource, sorted by order of CDN preference, according to the\n     * `CdnPrioritizer`'s own list of priorities.\n     */\n    _innerGetCdnPreferenceForResource(everyCdnForResource) {\n        const [allowedInOrder, downgradedInOrder] = everyCdnForResource.reduce((acc, elt) => {\n            if (this._downgradedCdnList.metadata.some((c) => c.id === elt.id && c.baseUrl === elt.baseUrl)) {\n                acc[1].push(elt);\n            }\n            else {\n                acc[0].push(elt);\n            }\n            return acc;\n        }, [[], []]);\n        return allowedInOrder.concat(downgradedInOrder);\n    }\n    /**\n     * @param {number} index\n     */\n    _removeIndexFromDowngradeList(index) {\n        this._downgradedCdnList.metadata.splice(index, 1);\n        const oldTimeout = this._downgradedCdnList.timeouts.splice(index, 1);\n        clearTimeout(oldTimeout[0]);\n    }\n}\n/**\n * Find the index of the given CDN metadata in a CDN metadata array.\n * Returns `-1` if not found.\n * @param {Array.<Object>} arr\n * @param {Object} elt\n * @returns {number}\n */\nfunction indexOfMetadata(arr, elt) {\n    if (arr.length === 0) {\n        return -1;\n    }\n    return elt.id !== undefined\n        ? arrayFindIndex(arr, (m) => m.id === elt.id)\n        : arrayFindIndex(arr, (m) => m.baseUrl === elt.baseUrl);\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport ManifestFetcher from \"./manifest_fetcher\";\nexport default ManifestFetcher;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport config from \"../../../config\";\nimport { formatError } from \"../../../errors\";\nimport log from \"../../../log\";\nimport Manifest from \"../../../manifest/classes\";\nimport EventEmitter from \"../../../utils/event_emitter\";\nimport getMonotonicTimeStamp from \"../../../utils/monotonic_timestamp\";\nimport noop from \"../../../utils/noop\";\nimport TaskCanceller from \"../../../utils/task_canceller\";\nimport errorSelector from \"../utils/error_selector\";\nimport { scheduleRequestPromise } from \"../utils/schedule_request\";\n/**\n * Class allowing to facilitate the task of loading and parsing a Manifest, as\n * well as automatically refreshing it.\n * @class ManifestFetcher\n */\nexport default class ManifestFetcher extends EventEmitter {\n    /**\n     * Construct a new ManifestFetcher.\n     * @param {Array.<string> | undefined} urls - Manifest URLs, will be used when\n     * no URL is provided to the `fetch` function.\n     * `undefined` if unknown or if a Manifest should be retrieved through other\n     * means than an HTTP request.\n     * @param {Object} pipelines - Transport pipelines used to perform the\n     * Manifest loading and parsing operations.\n     * @param {Object} settings - Configure the `ManifestFetcher`.\n     */\n    constructor(urls, pipelines, settings) {\n        super();\n        this.scheduleManualRefresh = noop;\n        this._manifestUrls = urls;\n        this._pipelines = pipelines.manifest;\n        this._transportName = pipelines.transportName;\n        this._settings = settings;\n        this._canceller = new TaskCanceller();\n        this._isStarted = false;\n        this._isRefreshPending = false;\n        this._consecutiveUnsafeMode = 0;\n        this._prioritizedContentUrl = null;\n    }\n    /**\n     * Free resources and stop refresh mechanism from happening.\n     *\n     * Once `dispose` has been called. This `ManifestFetcher` cannot be relied on\n     * anymore.\n     */\n    dispose() {\n        this._canceller.cancel();\n        this.removeEventListener();\n    }\n    /**\n     * Start requesting the Manifest as well as the Manifest refreshing logic, if\n     * needed.\n     *\n     * Once `start` has been called, this mechanism can only be stopped by calling\n     * `dispose`.\n     */\n    start() {\n        if (this._isStarted) {\n            return;\n        }\n        this._isStarted = true;\n        let manifestProm;\n        const initialManifest = this._settings.initialManifest;\n        if (initialManifest instanceof Manifest) {\n            manifestProm = Promise.resolve({ manifest: initialManifest });\n        }\n        else if (initialManifest !== undefined) {\n            manifestProm = this.parse(initialManifest, { previousManifest: null, unsafeMode: false }, undefined);\n        }\n        else {\n            manifestProm = this._fetchManifest(undefined).then((val) => {\n                return val.parse({ previousManifest: null, unsafeMode: false });\n            });\n        }\n        manifestProm\n            .then((val) => {\n            this.trigger(\"manifestReady\", val.manifest);\n            if (!this._canceller.isUsed()) {\n                this._recursivelyRefreshManifest(val.manifest, val);\n            }\n        })\n            .catch((err) => this._onFatalError(err));\n    }\n    /**\n     * Update URL of the fetched Manifest.\n     * @param {Array.<string> | undefined} urls - New Manifest URLs by order of\n     * priority or `undefined` if there's now no URL.\n     * @param {boolean} refreshNow - If set to `true`, the next Manifest refresh\n     * will be triggered immediately.\n     */\n    updateContentUrls(urls, refreshNow) {\n        var _a;\n        this._prioritizedContentUrl = (_a = urls === null || urls === void 0 ? void 0 : urls[0]) !== null && _a !== void 0 ? _a : undefined;\n        if (refreshNow) {\n            this.scheduleManualRefresh({\n                enablePartialRefresh: false,\n                delay: 0,\n                canUseUnsafeMode: false,\n            });\n        }\n    }\n    /**\n     * (re-)Load the Manifest.\n     * This method does not yet parse it, parsing will then be available through\n     * a callback available on the response.\n     *\n     * You can set an `url` on which that Manifest will be requested.\n     * If not set, the regular Manifest url - defined on the `ManifestFetcher`\n     * instanciation - will be used instead.\n     *\n     * @param {string | undefined} url\n     * @returns {Promise}\n     */\n    async _fetchManifest(url) {\n        var _a;\n        const cancelSignal = this._canceller.signal;\n        const settings = this._settings;\n        const transportName = this._transportName;\n        const pipelines = this._pipelines;\n        // TODO Better handle multiple Manifest URLs\n        const requestUrl = url !== null && url !== void 0 ? url : (_a = this._manifestUrls) === null || _a === void 0 ? void 0 : _a[0];\n        const backoffSettings = this._getBackoffSetting((err) => {\n            this.trigger(\"warning\", errorSelector(err));\n        });\n        try {\n            const response = await callLoaderWithRetries(requestUrl);\n            return {\n                parse: (parserOptions) => {\n                    return this._parseLoadedManifest(response, parserOptions, requestUrl);\n                },\n            };\n        }\n        catch (err) {\n            throw errorSelector(err);\n        }\n        /**\n         * Call the loader part of the pipeline, retrying if it fails according\n         * to the current settings.\n         * Returns the Promise of the last attempt.\n         * @param {string | undefined} manifestUrl\n         * @returns {Promise}\n         */\n        function callLoaderWithRetries(manifestUrl) {\n            var _a;\n            const { loadManifest } = pipelines;\n            let requestTimeout = settings.requestTimeout === undefined\n                ? config.getCurrent().DEFAULT_REQUEST_TIMEOUT\n                : settings.requestTimeout;\n            let connectionTimeout = settings.connectionTimeout === undefined\n                ? config.getCurrent().DEFAULT_CONNECTION_TIMEOUT\n                : settings.connectionTimeout;\n            if (requestTimeout < 0) {\n                requestTimeout = undefined;\n            }\n            if (connectionTimeout < 0) {\n                connectionTimeout = undefined;\n            }\n            const requestOptions = {\n                timeout: requestTimeout,\n                connectionTimeout,\n                cmcdPayload: (_a = settings.cmcdDataBuilder) === null || _a === void 0 ? void 0 : _a.getCmcdDataForManifest(transportName),\n            };\n            const callLoader = () => loadManifest(manifestUrl, requestOptions, cancelSignal);\n            return scheduleRequestPromise(callLoader, backoffSettings, cancelSignal);\n        }\n    }\n    /**\n     * Parse an already loaded Manifest.\n     *\n     * This method should be reserved for Manifests for which no request has been\n     * done.\n     * In other cases, it's preferable to go through the `fetch` method, so\n     * information on the request can be used by the parsing process.\n     * @param {*} manifest\n     * @param {Object} parserOptions\n     * @param {string | undefined} originalUrl\n     * @returns {Promise}\n     */\n    parse(manifest, parserOptions, originalUrl) {\n        return this._parseLoadedManifest({ responseData: manifest, size: undefined, requestDuration: undefined }, parserOptions, originalUrl);\n    }\n    /**\n     * Parse a Manifest.\n     *\n     * @param {Object} loaded - Information about the loaded Manifest as well as\n     * about the corresponding request.\n     * @param {Object} parserOptions - Options used when parsing the Manifest.\n     * @param {string | undefined} requestUrl\n     * @returns {Promise}\n     */\n    async _parseLoadedManifest(loaded, parserOptions, requestUrl) {\n        var _a;\n        const parsingTimeStart = getMonotonicTimeStamp();\n        const cancelSignal = this._canceller.signal;\n        const trigger = this.trigger.bind(this);\n        const { sendingTime, receivedTime } = loaded;\n        const backoffSettings = this._getBackoffSetting((err) => {\n            this.trigger(\"warning\", errorSelector(err));\n        });\n        const originalUrl = requestUrl !== null && requestUrl !== void 0 ? requestUrl : (_a = this._manifestUrls) === null || _a === void 0 ? void 0 : _a[0];\n        const opts = {\n            externalClockOffset: parserOptions.externalClockOffset,\n            unsafeMode: parserOptions.unsafeMode,\n            previousManifest: parserOptions.previousManifest,\n            originalUrl,\n        };\n        try {\n            const res = this._pipelines.parseManifest(loaded, opts, onWarnings, cancelSignal, scheduleRequest);\n            if (!isPromise(res)) {\n                return finish(res.manifest, res.warnings);\n            }\n            else {\n                const { manifest, warnings } = await res;\n                return finish(manifest, warnings);\n            }\n        }\n        catch (err) {\n            const formattedError = formatError(err, {\n                defaultCode: \"PIPELINE_PARSE_ERROR\",\n                defaultReason: \"Unknown error when parsing the Manifest\",\n            });\n            throw formattedError;\n        }\n        /**\n         * Perform a request with the same retry mechanisms and error handling\n         * than for a Manifest loader.\n         * @param {Function} performRequest\n         * @returns {Function}\n         */\n        async function scheduleRequest(performRequest) {\n            try {\n                const data = await scheduleRequestPromise(performRequest, backoffSettings, cancelSignal);\n                return data;\n            }\n            catch (err) {\n                throw errorSelector(err);\n            }\n        }\n        /**\n         * Handle minor errors encountered by a Manifest parser.\n         * @param {Array.<Error>} warnings\n         */\n        function onWarnings(warnings) {\n            for (const warning of warnings) {\n                if (cancelSignal.isCancelled()) {\n                    return;\n                }\n                const formattedError = formatError(warning, {\n                    defaultCode: \"PIPELINE_PARSE_ERROR\",\n                    defaultReason: \"Unknown error when parsing the Manifest\",\n                });\n                trigger(\"warning\", formattedError);\n            }\n        }\n        /**\n         * Emit a formatted \"parsed\" event through `obs`.\n         * To call once the Manifest has been parsed.\n         * @param {Object} manifest\n         */\n        function finish(manifest, warnings) {\n            onWarnings(warnings);\n            const parsingTime = getMonotonicTimeStamp() - parsingTimeStart;\n            log.info(`MF: Manifest parsed in ${parsingTime}ms`);\n            return { manifest, sendingTime, receivedTime, parsingTime };\n        }\n    }\n    /**\n     * Construct \"backoff settings\" that can be used with a range of functions\n     * allowing to perform multiple request attempts\n     * @param {Function} onRetry\n     * @returns {Object}\n     */\n    _getBackoffSetting(onRetry) {\n        const { DEFAULT_MAX_MANIFEST_REQUEST_RETRY, INITIAL_BACKOFF_DELAY_BASE, MAX_BACKOFF_DELAY_BASE, } = config.getCurrent();\n        const { lowLatencyMode, maxRetry: ogRegular } = this._settings;\n        const baseDelay = lowLatencyMode\n            ? INITIAL_BACKOFF_DELAY_BASE.LOW_LATENCY\n            : INITIAL_BACKOFF_DELAY_BASE.REGULAR;\n        const maxDelay = lowLatencyMode\n            ? MAX_BACKOFF_DELAY_BASE.LOW_LATENCY\n            : MAX_BACKOFF_DELAY_BASE.REGULAR;\n        const maxRetry = ogRegular !== null && ogRegular !== void 0 ? ogRegular : DEFAULT_MAX_MANIFEST_REQUEST_RETRY;\n        return { onRetry, baseDelay, maxDelay, maxRetry };\n    }\n    /**\n     * Performs Manifest refresh (recursively) when it judges it is time to do so.\n     * @param {Object} manifest\n     * @param {Object} manifestRequestInfos - Various information linked to the\n     * last Manifest loading and parsing operations.\n     */\n    _recursivelyRefreshManifest(manifest, { sendingTime, parsingTime, updatingTime, }) {\n        const { MAX_CONSECUTIVE_MANIFEST_PARSING_IN_UNSAFE_MODE, MIN_MANIFEST_PARSING_TIME_TO_ENTER_UNSAFE_MODE, } = config.getCurrent();\n        /**\n         * Total time taken to fully update the last Manifest, in milliseconds.\n         * Note: this time also includes possible requests done by the parsers.\n         */\n        const totalUpdateTime = parsingTime !== undefined ? parsingTime + (updatingTime !== null && updatingTime !== void 0 ? updatingTime : 0) : undefined;\n        /**\n         * \"unsafeMode\" is a mode where we unlock advanced Manifest parsing\n         * optimizations with the added risk to lose some information.\n         * `unsafeModeEnabled` is set to `true` when the `unsafeMode` is enabled.\n         *\n         * Only perform parsing in `unsafeMode` when the last full parsing took a\n         * lot of time and do not go higher than the maximum consecutive time.\n         */\n        let unsafeModeEnabled = false;\n        if (this._consecutiveUnsafeMode > 0) {\n            unsafeModeEnabled =\n                this._consecutiveUnsafeMode < MAX_CONSECUTIVE_MANIFEST_PARSING_IN_UNSAFE_MODE;\n        }\n        else if (totalUpdateTime !== undefined) {\n            unsafeModeEnabled =\n                totalUpdateTime >= MIN_MANIFEST_PARSING_TIME_TO_ENTER_UNSAFE_MODE;\n        }\n        /** Time elapsed since the beginning of the Manifest request, in milliseconds. */\n        const timeSinceRequest = sendingTime === undefined ? 0 : getMonotonicTimeStamp() - sendingTime;\n        /** Minimum update delay we should not go below, in milliseconds. */\n        const minInterval = Math.max(this._settings.minimumManifestUpdateInterval - timeSinceRequest, 0);\n        /**\n         * Multiple refresh trigger are scheduled here, but only the first one should\n         * be effectively considered.\n         * `nextRefreshCanceller` will allow to cancel every other when one is triggered.\n         */\n        const nextRefreshCanceller = new TaskCanceller();\n        nextRefreshCanceller.linkToSignal(this._canceller.signal);\n        /* Function to manually schedule a Manifest refresh */\n        this.scheduleManualRefresh = (settings) => {\n            const { enablePartialRefresh, delay, canUseUnsafeMode } = settings;\n            const unsafeMode = canUseUnsafeMode && unsafeModeEnabled;\n            // The value allows to set a delay relatively to the last Manifest refresh\n            // (to avoid asking for it too often).\n            const timeSinceLastRefresh = sendingTime === undefined ? 0 : getMonotonicTimeStamp() - sendingTime;\n            const _minInterval = Math.max(this._settings.minimumManifestUpdateInterval - timeSinceLastRefresh, 0);\n            const timeoutId = setTimeout(() => {\n                nextRefreshCanceller.cancel();\n                this._triggerNextManifestRefresh(manifest, {\n                    enablePartialRefresh,\n                    unsafeMode,\n                });\n            }, Math.max((delay !== null && delay !== void 0 ? delay : 0) - timeSinceLastRefresh, _minInterval));\n            nextRefreshCanceller.signal.register(() => {\n                clearTimeout(timeoutId);\n            });\n        };\n        /* Handle Manifest expiration. */\n        if (manifest.expired !== null) {\n            const timeoutId = setTimeout(() => {\n                var _a;\n                (_a = manifest.expired) === null || _a === void 0 ? void 0 : _a.then(() => {\n                    nextRefreshCanceller.cancel();\n                    this._triggerNextManifestRefresh(manifest, {\n                        enablePartialRefresh: false,\n                        unsafeMode: unsafeModeEnabled,\n                    });\n                }, noop /* `expired` should not reject */);\n            }, minInterval);\n            nextRefreshCanceller.signal.register(() => {\n                clearTimeout(timeoutId);\n            });\n        }\n        /*\n         * Trigger Manifest refresh when the Manifest needs to be refreshed\n         * according to the Manifest's internal properties (parsing time is also\n         * taken into account in this operation to avoid refreshing too often).\n         */\n        if (manifest.lifetime !== undefined && manifest.lifetime >= 0) {\n            /** Regular refresh delay as asked by the Manifest. */\n            const regularRefreshDelay = manifest.lifetime * 1000 - timeSinceRequest;\n            /** Actually choosen delay to refresh the Manifest. */\n            let actualRefreshInterval;\n            if (totalUpdateTime === undefined) {\n                actualRefreshInterval = regularRefreshDelay;\n            }\n            else if (manifest.lifetime < 3 && totalUpdateTime >= 100) {\n                // If Manifest update is very frequent and we take time to update it,\n                // postpone it.\n                actualRefreshInterval = Math.min(Math.max(\n                // Take 3 seconds as a default safe value for a base interval.\n                3000 - timeSinceRequest, \n                // Add update time to the original interval.\n                Math.max(regularRefreshDelay, 0) + totalUpdateTime), \n                // Limit the postponment's higher bound to a very high value relative\n                // to `regularRefreshDelay`.\n                // This avoid perpetually postponing a Manifest update when\n                // performance seems to have been abysmal one time.\n                regularRefreshDelay * 6);\n                log.info(\"MUS: Manifest update rythm is too frequent. Postponing next request.\", regularRefreshDelay, actualRefreshInterval);\n            }\n            else if (totalUpdateTime >= (manifest.lifetime * 1000) / 10) {\n                // If Manifest updating time is very long relative to its lifetime,\n                // postpone it:\n                actualRefreshInterval = Math.min(\n                // Just add the update time to the original waiting time\n                Math.max(regularRefreshDelay, 0) + totalUpdateTime, \n                // Limit the postponment's higher bound to a very high value relative\n                // to `regularRefreshDelay`.\n                // This avoid perpetually postponing a Manifest update when\n                // performance seems to have been abysmal one time.\n                regularRefreshDelay * 6);\n                log.info(\"MUS: Manifest took too long to parse. Postponing next request\", actualRefreshInterval, actualRefreshInterval);\n            }\n            else {\n                actualRefreshInterval = regularRefreshDelay;\n            }\n            const timeoutId = setTimeout(() => {\n                nextRefreshCanceller.cancel();\n                this._triggerNextManifestRefresh(manifest, {\n                    enablePartialRefresh: false,\n                    unsafeMode: unsafeModeEnabled,\n                });\n            }, Math.max(actualRefreshInterval, minInterval));\n            nextRefreshCanceller.signal.register(() => {\n                clearTimeout(timeoutId);\n            });\n        }\n    }\n    /**\n     * Refresh the Manifest, performing a full update if a partial update failed.\n     * Also re-call `recursivelyRefreshManifest` to schedule the next refresh\n     * trigger.\n     * @param {Object} manifest\n     * @param {Object} refreshInformation\n     */\n    _triggerNextManifestRefresh(manifest, { enablePartialRefresh, unsafeMode, }) {\n        const manifestUpdateUrl = manifest.updateUrl;\n        let fullRefresh;\n        let refreshURL;\n        if (this._prioritizedContentUrl !== null) {\n            fullRefresh = true;\n            refreshURL = this._prioritizedContentUrl;\n            this._prioritizedContentUrl = null;\n        }\n        else {\n            fullRefresh = !enablePartialRefresh || manifestUpdateUrl === undefined;\n            refreshURL = fullRefresh ? manifest.getUrls()[0] : manifestUpdateUrl;\n        }\n        const externalClockOffset = manifest.clockOffset;\n        if (unsafeMode) {\n            this._consecutiveUnsafeMode += 1;\n            log.info('Init: Refreshing the Manifest in \"unsafeMode\" for the ' +\n                String(this._consecutiveUnsafeMode) +\n                \" consecutive time.\");\n        }\n        else if (this._consecutiveUnsafeMode > 0) {\n            log.info('Init: Not parsing the Manifest in \"unsafeMode\" anymore after ' +\n                String(this._consecutiveUnsafeMode) +\n                \" consecutive times.\");\n            this._consecutiveUnsafeMode = 0;\n        }\n        if (this._isRefreshPending) {\n            return;\n        }\n        this._isRefreshPending = true;\n        this._fetchManifest(refreshURL)\n            .then((res) => res.parse({\n            externalClockOffset,\n            previousManifest: manifest,\n            unsafeMode,\n        }))\n            .then((res) => {\n            this._isRefreshPending = false;\n            const { manifest: newManifest, sendingTime: newSendingTime, parsingTime } = res;\n            const updateTimeStart = getMonotonicTimeStamp();\n            if (fullRefresh) {\n                manifest.replace(newManifest);\n            }\n            else {\n                try {\n                    manifest.update(newManifest);\n                }\n                catch (e) {\n                    const message = e instanceof Error ? e.message : \"unknown error\";\n                    log.warn(`MUS: Attempt to update Manifest failed: ${message}`, \"Re-downloading the Manifest fully\");\n                    const { FAILED_PARTIAL_UPDATE_MANIFEST_REFRESH_DELAY } = config.getCurrent();\n                    // The value allows to set a delay relatively to the last Manifest refresh\n                    // (to avoid asking for it too often).\n                    const timeSinceLastRefresh = newSendingTime === undefined ? 0 : getMonotonicTimeStamp() - newSendingTime;\n                    const _minInterval = Math.max(this._settings.minimumManifestUpdateInterval - timeSinceLastRefresh, 0);\n                    let unregisterCanceller = noop;\n                    const timeoutId = setTimeout(() => {\n                        unregisterCanceller();\n                        this._triggerNextManifestRefresh(manifest, {\n                            enablePartialRefresh: false,\n                            unsafeMode: false,\n                        });\n                    }, Math.max(FAILED_PARTIAL_UPDATE_MANIFEST_REFRESH_DELAY - timeSinceLastRefresh, _minInterval));\n                    unregisterCanceller = this._canceller.signal.register(() => {\n                        clearTimeout(timeoutId);\n                    });\n                    return;\n                }\n            }\n            const updatingTime = getMonotonicTimeStamp() - updateTimeStart;\n            this._recursivelyRefreshManifest(manifest, {\n                sendingTime: newSendingTime,\n                parsingTime,\n                updatingTime,\n            });\n        })\n            .catch((err) => {\n            this._isRefreshPending = false;\n            this._onFatalError(err);\n        });\n    }\n    _onFatalError(err) {\n        if (this._canceller.isUsed()) {\n            return;\n        }\n        this.trigger(\"error\", err);\n        this.dispose();\n    }\n}\n/**\n * Returns `true` when the returned value seems to be a Promise instance, as\n * created by the RxPlayer.\n * @param {*} val\n * @returns {boolean}\n */\nfunction isPromise(val) {\n    return val instanceof Promise;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport SegmentQueueCreator from \"./segment_queue_creator\";\nexport default SegmentQueueCreator;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Caching object used to cache initialization segments.\n * This allow to have a faster representation switch and faster seeking.\n * @class InitializationSegmentCache\n */\nclass InitializationSegmentCache {\n    constructor() {\n        this._cache = new WeakMap();\n    }\n    /**\n     * @param {Object} obj\n     * @param {*} response\n     */\n    add({ representation, segment }, response) {\n        if (segment.isInit) {\n            this._cache.set(representation, response);\n        }\n    }\n    /**\n     * @param {Object} obj\n     * @returns {*} response\n     */\n    get({ representation, segment, }) {\n        if (segment.isInit) {\n            const value = this._cache.get(representation);\n            if (value !== undefined) {\n                return value;\n            }\n        }\n        return null;\n    }\n}\nexport default InitializationSegmentCache;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../../log\";\n/**\n * This function basically put in relation:\n *   - an `ISegmentFetcher`, which will be used to perform the segment requests\n *   - a `TaskPrioritizer`, which will handle the priority of a segment request\n *\n * and returns functions to fetch segments with a given priority.\n * @param {Object} prioritizer\n * @param {Object} fetcher\n * @returns {Object}\n */\nexport default function applyPrioritizerToSegmentFetcher(prioritizer, fetcher) {\n    /**\n     * Map Promises returned by the `createRequest` method into the actual tasks\n     * used by the `TaskPrioritizer`, allowing to update task priorities just by\n     * using the Promise.\n     */\n    const taskHandlers = new WeakMap();\n    return {\n        /**\n         * Create a Segment request with a given priority.\n         * @param {Object} content - content to request\n         * @param {Number} priority - priority at which the content should be requested.\n         * Lower number == higher priority.\n         * @param {Object} callbacks\n         * @param {Object} cancelSignal\n         * @returns {Promise}\n         */\n        createRequest(content, priority, callbacks, cancelSignal) {\n            const givenTask = (innerCancelSignal) => {\n                return fetcher(content, callbacks, innerCancelSignal);\n            };\n            const ret = prioritizer.create(givenTask, priority, callbacks, cancelSignal);\n            taskHandlers.set(ret, givenTask);\n            return ret;\n        },\n        /**\n         * Update the priority of a pending request, created through\n         * `createRequest`.\n         * @param {Promise} task - The Promise returned by `createRequest`.\n         * @param {Number} priority - The new priority value.\n         */\n        updatePriority(task, priority) {\n            const correspondingTask = taskHandlers.get(task);\n            if (correspondingTask === undefined) {\n                log.warn(\"Fetchers: Cannot update the priority of a request: task not found.\");\n                return;\n            }\n            prioritizer.updatePriority(correspondingTask, priority);\n        },\n    };\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport config from \"../../../config\";\nimport { formatError } from \"../../../errors\";\nimport log from \"../../../log\";\nimport { getLoggableSegmentId } from \"../../../manifest\";\nimport arrayIncludes from \"../../../utils/array_includes\";\nimport idGenerator from \"../../../utils/id_generator\";\nimport isNullOrUndefined from \"../../../utils/is_null_or_undefined\";\nimport getTimestamp from \"../../../utils/monotonic_timestamp\";\nimport objectAssign from \"../../../utils/object_assign\";\nimport { CancellationError } from \"../../../utils/task_canceller\";\nimport errorSelector from \"../utils/error_selector\";\nimport { scheduleRequestWithCdns } from \"../utils/schedule_request\";\nimport InitializationSegmentCache from \"./initialization_segment_cache\";\n/** Allows to generate a unique identifies for each request. */\nconst generateRequestID = idGenerator();\n/**\n * Create an `ISegmentFetcher` object which will allow to easily fetch and parse\n * segments.\n * An `ISegmentFetcher` also implements a retry mechanism, based on the given\n * `requestOptions` argument, which may retry a segment request when it fails.\n *\n * @param {Object} args\n * @returns {Function}\n */\nexport default function createSegmentFetcher({ bufferType, pipeline, cdnPrioritizer, cmcdDataBuilder, eventListeners, requestOptions, }) {\n    let connectionTimeout;\n    if (requestOptions.connectionTimeout === undefined ||\n        requestOptions.connectionTimeout < 0) {\n        connectionTimeout = undefined;\n    }\n    else {\n        connectionTimeout = requestOptions.connectionTimeout;\n    }\n    const pipelineRequestOptions = {\n        timeout: requestOptions.requestTimeout < 0 ? undefined : requestOptions.requestTimeout,\n        connectionTimeout,\n        cmcdPayload: undefined,\n    };\n    /**\n     * Cache audio and video initialization segments.\n     * This allows to avoid doing too many requests for what are usually very\n     * small files.\n     */\n    const cache = arrayIncludes([\"audio\", \"video\"], bufferType)\n        ? new InitializationSegmentCache()\n        : undefined;\n    const { loadSegment, parseSegment } = pipeline;\n    /**\n     * Fetch a specific segment.\n     * @param {Object} content\n     * @param {Object} fetcherCallbacks\n     * @param {Object} cancellationSignal\n     * @returns {Promise}\n     */\n    return async function fetchSegment(content, fetcherCallbacks, cancellationSignal) {\n        var _a, _b, _c;\n        const { segment, adaptation, representation, manifest, period } = content;\n        // used by logs\n        const segmentIdString = getLoggableSegmentId(content);\n        const requestId = generateRequestID();\n        /**\n         * If the request succeeded, set to the corresponding\n         * `IChunkCompleteInformation` object.\n         * For any other completion cases: if the request either failed, was\n         * cancelled or just if no request was needed, set to `null`.\n         *\n         * Stays to `undefined` when the request is still pending.\n         */\n        let requestInfo;\n        /**\n         * Array containing one entry per loaded chunk, in chronological order.\n         * The boolean indicates if the chunk has been parsed at least once.\n         *\n         * This is used to know when all loaded chunks have been parsed, which\n         * can be useful to e.g. construct metrics about the loaded segment.\n         */\n        const parsedChunks = [];\n        /**\n         * Addition of the duration of each encountered and parsed chunks.\n         * Allows to have an idea of the real duration of the full segment once\n         * all chunks have been parsed.\n         *\n         * `undefined` if at least one of the parsed chunks has unknown duration.\n         */\n        let segmentDurationAcc = 0;\n        /** Set to `true` once network metrics have been sent. */\n        let metricsSent = false;\n        /** Segment context given to the transport pipelines. */\n        const context = {\n            segment,\n            type: adaptation.type,\n            language: adaptation.language,\n            isLive: manifest.isLive,\n            periodStart: period.start,\n            periodEnd: period.end,\n            mimeType: representation.mimeType,\n            codecs: representation.codecs[0],\n            manifestPublishTime: manifest.publishTime,\n        };\n        const loaderCallbacks = {\n            /**\n             * Callback called when the segment loader has progress information on\n             * the request.\n             * @param {Object} info\n             */\n            onProgress(info) {\n                var _a;\n                if (requestInfo !== undefined) {\n                    return; // request already termminated\n                }\n                if (info.totalSize !== undefined && info.size < info.totalSize) {\n                    (_a = eventListeners.onProgress) === null || _a === void 0 ? void 0 : _a.call(eventListeners, {\n                        duration: info.duration,\n                        size: info.size,\n                        totalSize: info.totalSize,\n                        timestamp: getTimestamp(),\n                        id: requestId,\n                    });\n                }\n            },\n            /**\n             * Callback called when the segment is communicated by the loader\n             * through decodable sub-segment(s) called chunk(s), with a chunk in\n             * argument.\n             * @param {*} chunkData\n             */\n            onNewChunk(chunkData) {\n                fetcherCallbacks.onChunk(generateParserFunction(chunkData, true));\n            },\n        };\n        // Retrieve from cache if it exists\n        const cached = cache !== undefined ? cache.get(content) : null;\n        if (cached !== null) {\n            log.debug(\"SF: Found wanted segment in cache\", segmentIdString);\n            fetcherCallbacks.onChunk(generateParserFunction(cached, false));\n            return Promise.resolve();\n        }\n        log.debug(\"SF: Beginning request\", segmentIdString);\n        (_a = eventListeners.onRequestBegin) === null || _a === void 0 ? void 0 : _a.call(eventListeners, {\n            requestTimestamp: getTimestamp(),\n            id: requestId,\n            content,\n        });\n        cancellationSignal.register(onCancellation);\n        try {\n            const res = await scheduleRequestWithCdns(content.representation.cdnMetadata, cdnPrioritizer, callLoaderWithUrl, objectAssign({ onRetry }, requestOptions), cancellationSignal);\n            if (res.resultType === \"segment-loaded\") {\n                const loadedData = res.resultData.responseData;\n                if (cache !== undefined) {\n                    cache.add(content, res.resultData.responseData);\n                }\n                fetcherCallbacks.onChunk(generateParserFunction(loadedData, false));\n            }\n            else if (res.resultType === \"segment-created\") {\n                fetcherCallbacks.onChunk(generateParserFunction(res.resultData, false));\n            }\n            log.debug(\"SF: Segment request ended with success\", segmentIdString);\n            fetcherCallbacks.onAllChunksReceived();\n            if (res.resultType !== \"segment-created\") {\n                requestInfo = res.resultData;\n                sendNetworkMetricsIfAvailable();\n            }\n            else {\n                requestInfo = null;\n            }\n            if (!cancellationSignal.isCancelled()) {\n                // The current task could have been canceled as a result of one\n                // of the previous callbacks call. In that case, we don't want to send\n                // a \"requestEnd\" again as it has already been sent on cancellation.\n                (_b = eventListeners.onRequestEnd) === null || _b === void 0 ? void 0 : _b.call(eventListeners, { id: requestId });\n            }\n            cancellationSignal.deregister(onCancellation);\n        }\n        catch (err) {\n            cancellationSignal.deregister(onCancellation);\n            requestInfo = null;\n            if (err instanceof CancellationError) {\n                log.debug(\"SF: Segment request aborted\", segmentIdString);\n                throw err;\n            }\n            log.debug(\"SF: Segment request failed\", segmentIdString);\n            (_c = eventListeners.onRequestEnd) === null || _c === void 0 ? void 0 : _c.call(eventListeners, { id: requestId });\n            throw errorSelector(err);\n        }\n        function onCancellation() {\n            var _a;\n            if (requestInfo !== undefined) {\n                return; // Request already terminated\n            }\n            log.debug(\"SF: Segment request cancelled\", segmentIdString);\n            requestInfo = null;\n            (_a = eventListeners.onRequestEnd) === null || _a === void 0 ? void 0 : _a.call(eventListeners, { id: requestId });\n        }\n        /**\n         * Call a segment loader for the given URL with the right arguments.\n         * @param {Object|null} cdnMetadata\n         * @returns {Promise}\n         */\n        function callLoaderWithUrl(cdnMetadata) {\n            pipelineRequestOptions.cmcdPayload =\n                cmcdDataBuilder === null || cmcdDataBuilder === void 0 ? void 0 : cmcdDataBuilder.getCmcdDataForSegmentRequest(content);\n            return loadSegment(cdnMetadata, context, pipelineRequestOptions, cancellationSignal, loaderCallbacks);\n        }\n        /**\n         * Generate function allowing to parse a loaded segment.\n         * @param {*} data\n         * @param {Boolean} isChunked\n         * @returns {Function}\n         */\n        function generateParserFunction(data, isChunked) {\n            parsedChunks.push(false);\n            const parsedChunkId = parsedChunks.length - 1;\n            return function parse(initTimescale) {\n                const loaded = { data, isChunked };\n                try {\n                    const parsed = parseSegment(loaded, context, initTimescale);\n                    if (!parsedChunks[parsedChunkId]) {\n                        segmentDurationAcc =\n                            segmentDurationAcc !== undefined &&\n                                parsed.segmentType === \"media\" &&\n                                parsed.chunkInfos !== null &&\n                                parsed.chunkInfos.duration !== undefined\n                                ? segmentDurationAcc + parsed.chunkInfos.duration\n                                : undefined;\n                        parsedChunks[parsedChunkId] = true;\n                        sendNetworkMetricsIfAvailable();\n                    }\n                    return parsed;\n                }\n                catch (error) {\n                    throw formatError(error, {\n                        defaultCode: \"PIPELINE_PARSE_ERROR\",\n                        defaultReason: \"Unknown parsing error\",\n                    });\n                }\n            };\n        }\n        /**\n         * Function called when the function request is retried.\n         * @param {*} err\n         */\n        function onRetry(err) {\n            fetcherCallbacks.onRetry(errorSelector(err));\n        }\n        /**\n         * Send netork metrics if they haven't yet been sent and if all data to\n         * define them is available.\n         */\n        function sendNetworkMetricsIfAvailable() {\n            var _a;\n            if (metricsSent) {\n                return;\n            }\n            if (!isNullOrUndefined(requestInfo) &&\n                requestInfo.size !== undefined &&\n                requestInfo.requestDuration !== undefined &&\n                parsedChunks.length > 0 &&\n                parsedChunks.every((isParsed) => isParsed)) {\n                metricsSent = true;\n                (_a = eventListeners.onMetrics) === null || _a === void 0 ? void 0 : _a.call(eventListeners, {\n                    size: requestInfo.size,\n                    requestDuration: requestInfo.requestDuration,\n                    content,\n                    segmentDuration: segmentDurationAcc,\n                });\n            }\n        }\n    };\n}\n/**\n * @param {Object} baseOptions\n * @returns {Object}\n */\nexport function getSegmentFetcherRequestOptions({ maxRetry, lowLatencyMode, requestTimeout, connectionTimeout, }) {\n    const { DEFAULT_MAX_REQUESTS_RETRY_ON_ERROR, DEFAULT_REQUEST_TIMEOUT, DEFAULT_CONNECTION_TIMEOUT, INITIAL_BACKOFF_DELAY_BASE, MAX_BACKOFF_DELAY_BASE, } = config.getCurrent();\n    return {\n        maxRetry: maxRetry !== null && maxRetry !== void 0 ? maxRetry : DEFAULT_MAX_REQUESTS_RETRY_ON_ERROR,\n        baseDelay: lowLatencyMode\n            ? INITIAL_BACKOFF_DELAY_BASE.LOW_LATENCY\n            : INITIAL_BACKOFF_DELAY_BASE.REGULAR,\n        maxDelay: lowLatencyMode\n            ? MAX_BACKOFF_DELAY_BASE.LOW_LATENCY\n            : MAX_BACKOFF_DELAY_BASE.REGULAR,\n        requestTimeout: requestTimeout === undefined ? DEFAULT_REQUEST_TIMEOUT : requestTimeout,\n        connectionTimeout: connectionTimeout === undefined ? DEFAULT_CONNECTION_TIMEOUT : connectionTimeout,\n    };\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../../log\";\nimport assert from \"../../../utils/assert\";\nimport EventEmitter from \"../../../utils/event_emitter\";\nimport noop from \"../../../utils/noop\";\nimport objectAssign from \"../../../utils/object_assign\";\nimport SharedReference from \"../../../utils/reference\";\nimport TaskCanceller from \"../../../utils/task_canceller\";\n/**\n * Class scheduling segment downloads as a FIFO queue.\n */\nexport default class SegmentQueue extends EventEmitter {\n    /**\n     * Create a new `SegmentQueue`.\n     *\n     * @param {Object} segmentFetcher - Interface to facilitate the download of\n     * segments.\n     * @param {Object} isMediaSegmentQueueInterrupted - Reference to a boolean indicating\n     * if the media segment queue is interrupted.\n     */\n    constructor(segmentFetcher, isMediaSegmentQueueInterrupted) {\n        super();\n        this._segmentFetcher = segmentFetcher;\n        this._currentContentInfo = null;\n        this.isMediaSegmentQueueInterrupted = isMediaSegmentQueueInterrupted;\n    }\n    /**\n     * Returns the initialization segment currently being requested.\n     * Returns `null` if no initialization segment request is pending.\n     * @returns {Object | null}\n     */\n    getRequestedInitSegment() {\n        var _a, _b, _c;\n        return (_c = (_b = (_a = this._currentContentInfo) === null || _a === void 0 ? void 0 : _a.initSegmentRequest) === null || _b === void 0 ? void 0 : _b.segment) !== null && _c !== void 0 ? _c : null;\n    }\n    /**\n     * Returns the media segment currently being requested.\n     * Returns `null` if no media segment request is pending.\n     * @returns {Object | null}\n     */\n    getRequestedMediaSegment() {\n        var _a, _b, _c;\n        return (_c = (_b = (_a = this._currentContentInfo) === null || _a === void 0 ? void 0 : _a.mediaSegmentRequest) === null || _b === void 0 ? void 0 : _b.segment) !== null && _c !== void 0 ? _c : null;\n    }\n    /**\n     * Return an object allowing to schedule segment requests linked to the given\n     * content.\n     * The `SegmentQueue` will emit events as it loads and parses initialization\n     * and media segments.\n     *\n     * Calling this method resets all previous queues that were previously started\n     * on the same instance.\n     *\n     * @param {Object} content - The context of the Representation you want to\n     * load segments for.\n     * @param {boolean} hasInitSegment - Declare that an initialization segment\n     * will need to be downloaded.\n     *\n     * A `SegmentQueue` ALWAYS wait for the initialization segment to be\n     * loaded and parsed before parsing a media segment.\n     *\n     * In cases where no initialization segment exist, this would lead to the\n     * `SegmentQueue` waiting indefinitely for it.\n     *\n     * By setting that value to `false`, you anounce to the `SegmentQueue`\n     * that it should not wait for an initialization segment before parsing a\n     * media segment.\n     * @returns {Object} - `SharedReference` on which the queue of segment for\n     * that content can be communicated and updated. See type for more\n     * information.\n     */\n    resetForContent(content, hasInitSegment) {\n        var _a;\n        (_a = this._currentContentInfo) === null || _a === void 0 ? void 0 : _a.currentCanceller.cancel();\n        const downloadQueue = new SharedReference({\n            initSegment: null,\n            segmentQueue: [],\n        });\n        const currentCanceller = new TaskCanceller();\n        currentCanceller.signal.register(() => {\n            downloadQueue.finish();\n        });\n        const currentContentInfo = {\n            content,\n            downloadQueue,\n            initSegmentInfoRef: hasInitSegment\n                ? new SharedReference(undefined)\n                : new SharedReference(null),\n            currentCanceller,\n            initSegmentRequest: null,\n            mediaSegmentRequest: null,\n            mediaSegmentAwaitingInitMetadata: null,\n        };\n        this._currentContentInfo = currentContentInfo;\n        this.isMediaSegmentQueueInterrupted.onUpdate((val) => {\n            if (!val) {\n                log.debug(\"SQ: Media segment can be loaded again, restarting queue.\", content.adaptation.type);\n                this._restartMediaSegmentDownloadingQueue(currentContentInfo);\n            }\n        }, { clearSignal: currentCanceller.signal });\n        // Listen for asked media segments\n        downloadQueue.onUpdate((queue) => {\n            const { segmentQueue } = queue;\n            if (segmentQueue.length > 0 &&\n                segmentQueue[0].segment.id ===\n                    currentContentInfo.mediaSegmentAwaitingInitMetadata) {\n                // The most needed segment is still the same one, and there's no need to\n                // update its priority as the request already ended, just quit.\n                return;\n            }\n            const currentSegmentRequest = currentContentInfo.mediaSegmentRequest;\n            if (segmentQueue.length === 0) {\n                if (currentSegmentRequest === null) {\n                    // There's nothing to load but there's already no request pending.\n                    return;\n                }\n                log.debug(\"SQ: no more media segment to request. Cancelling queue.\", content.adaptation.type);\n                this._restartMediaSegmentDownloadingQueue(currentContentInfo);\n                return;\n            }\n            else if (currentSegmentRequest === null) {\n                // There's no request although there are needed segments: start requests\n                log.debug(\"SQ: Media segments now need to be requested. Starting queue.\", content.adaptation.type, segmentQueue.length);\n                this._restartMediaSegmentDownloadingQueue(currentContentInfo);\n                return;\n            }\n            else {\n                const nextItem = segmentQueue[0];\n                if (currentSegmentRequest.segment.id !== nextItem.segment.id) {\n                    // The most important request if for another segment, request it\n                    log.debug(\"SQ: Next media segment changed, cancelling previous\", content.adaptation.type);\n                    this._restartMediaSegmentDownloadingQueue(currentContentInfo);\n                    return;\n                }\n                if (currentSegmentRequest.priority !== nextItem.priority) {\n                    // The priority of the most important request has changed, update it\n                    log.debug(\"SQ: Priority of next media segment changed, updating\", content.adaptation.type, currentSegmentRequest.priority, nextItem.priority);\n                    this._segmentFetcher.updatePriority(currentSegmentRequest.request, nextItem.priority);\n                }\n                return;\n            }\n        }, { emitCurrentValue: true, clearSignal: currentCanceller.signal });\n        // Listen for asked init segment\n        downloadQueue.onUpdate((next) => {\n            var _a;\n            const initSegmentRequest = currentContentInfo.initSegmentRequest;\n            if (next.initSegment !== null && initSegmentRequest !== null) {\n                if (next.initSegment.priority !== initSegmentRequest.priority) {\n                    this._segmentFetcher.updatePriority(initSegmentRequest.request, next.initSegment.priority);\n                }\n                return;\n            }\n            else if (((_a = next.initSegment) === null || _a === void 0 ? void 0 : _a.segment.id) === (initSegmentRequest === null || initSegmentRequest === void 0 ? void 0 : initSegmentRequest.segment.id)) {\n                return;\n            }\n            if (next.initSegment === null) {\n                log.debug(\"SQ: no more init segment to request. Cancelling queue.\", content.adaptation.type);\n            }\n            this._restartInitSegmentDownloadingQueue(currentContentInfo, next.initSegment);\n        }, { emitCurrentValue: true, clearSignal: currentCanceller.signal });\n        return downloadQueue;\n    }\n    /**\n     * Stop the currently-active `SegmentQueue`.\n     *\n     * Do nothing if no queue is active.\n     */\n    stop() {\n        var _a;\n        (_a = this._currentContentInfo) === null || _a === void 0 ? void 0 : _a.currentCanceller.cancel();\n        this._currentContentInfo = null;\n    }\n    /**\n     * Internal logic performing media segment requests.\n     */\n    _restartMediaSegmentDownloadingQueue(contentInfo) {\n        if (contentInfo.mediaSegmentRequest !== null) {\n            contentInfo.mediaSegmentRequest.canceller.cancel();\n        }\n        const { downloadQueue, content, initSegmentInfoRef, currentCanceller } = contentInfo;\n        const recursivelyRequestSegments = () => {\n            var _a;\n            if (this.isMediaSegmentQueueInterrupted.getValue()) {\n                log.debug(\"SQ: Segment fetching postponed because it cannot stream now.\");\n                return;\n            }\n            const { segmentQueue } = downloadQueue.getValue();\n            const startingSegment = segmentQueue[0];\n            if (currentCanceller !== null && currentCanceller.isUsed()) {\n                contentInfo.mediaSegmentRequest = null;\n                return;\n            }\n            if (startingSegment === undefined) {\n                contentInfo.mediaSegmentRequest = null;\n                this.trigger(\"emptyQueue\", null);\n                return;\n            }\n            const canceller = new TaskCanceller();\n            const unlinkCanceller = currentCanceller === null\n                ? noop\n                : canceller.linkToSignal(currentCanceller.signal);\n            const { segment, priority } = startingSegment;\n            const context = objectAssign({ segment, nextSegment: (_a = segmentQueue[1]) === null || _a === void 0 ? void 0 : _a.segment }, content);\n            /**\n             * If `true` , the current task has either errored, finished, or was\n             * cancelled.\n             */\n            let isComplete = false;\n            /**\n             * If true, we're currently waiting for the initialization segment to be\n             * parsed before parsing a received chunk.\n             */\n            let isWaitingOnInitSegment = false;\n            canceller.signal.register(() => {\n                contentInfo.mediaSegmentRequest = null;\n                if (isComplete) {\n                    return;\n                }\n                if (contentInfo.mediaSegmentAwaitingInitMetadata === segment.id) {\n                    contentInfo.mediaSegmentAwaitingInitMetadata = null;\n                }\n                isComplete = true;\n                isWaitingOnInitSegment = false;\n            });\n            const emitChunk = (parsed) => {\n                assert(parsed.segmentType === \"media\", \"Should have loaded a media segment.\");\n                this.trigger(\"parsedMediaSegment\", objectAssign({}, parsed, { segment }));\n            };\n            const continueToNextSegment = () => {\n                const lastQueue = downloadQueue.getValue().segmentQueue;\n                if (lastQueue.length === 0) {\n                    isComplete = true;\n                    this.trigger(\"emptyQueue\", null);\n                    return;\n                }\n                else if (lastQueue[0].segment.id === segment.id) {\n                    lastQueue.shift();\n                }\n                isComplete = true;\n                recursivelyRequestSegments();\n            };\n            /** Scheduled actual segment request. */\n            const request = this._segmentFetcher.createRequest(context, priority, {\n                /**\n                 * Callback called when the request has to be retried.\n                 * @param {Error} error\n                 */\n                onRetry: (error) => {\n                    this.trigger(\"requestRetry\", { segment, error });\n                },\n                /**\n                 * Callback called when the request has to be interrupted and\n                 * restarted later.\n                 */\n                beforeInterrupted() {\n                    log.info(\"SQ: segment request interrupted temporarly.\", segment.id, segment.time);\n                },\n                /**\n                 * Callback called when a decodable chunk of the segment is available.\n                 * @param {Function} parse - Function allowing to parse the segment.\n                 */\n                onChunk: (parse) => {\n                    const initTimescale = initSegmentInfoRef.getValue();\n                    if (initTimescale !== undefined) {\n                        emitChunk(parse(initTimescale !== null && initTimescale !== void 0 ? initTimescale : undefined));\n                    }\n                    else {\n                        isWaitingOnInitSegment = true;\n                        // We could also technically call `waitUntilDefined` in both cases,\n                        // but I found it globally clearer to segregate the two cases,\n                        // especially to always have a meaningful `isWaitingOnInitSegment`\n                        // boolean which is a very important variable.\n                        initSegmentInfoRef.waitUntilDefined((actualTimescale) => {\n                            emitChunk(parse(actualTimescale !== null && actualTimescale !== void 0 ? actualTimescale : undefined));\n                        }, { clearSignal: canceller.signal });\n                    }\n                },\n                /** Callback called after all chunks have been sent. */\n                onAllChunksReceived: () => {\n                    if (!isWaitingOnInitSegment) {\n                        this.trigger(\"fullyLoadedSegment\", segment);\n                    }\n                    else {\n                        contentInfo.mediaSegmentAwaitingInitMetadata = segment.id;\n                        initSegmentInfoRef.waitUntilDefined(() => {\n                            contentInfo.mediaSegmentAwaitingInitMetadata = null;\n                            isWaitingOnInitSegment = false;\n                            this.trigger(\"fullyLoadedSegment\", segment);\n                        }, { clearSignal: canceller.signal });\n                    }\n                },\n                /**\n                 * Callback called right after the request ended but before the next\n                 * requests are scheduled. It is used to schedule the next segment.\n                 */\n                beforeEnded: () => {\n                    unlinkCanceller();\n                    contentInfo.mediaSegmentRequest = null;\n                    if (isWaitingOnInitSegment) {\n                        initSegmentInfoRef.waitUntilDefined(continueToNextSegment, {\n                            clearSignal: canceller.signal,\n                        });\n                    }\n                    else {\n                        continueToNextSegment();\n                    }\n                },\n            }, canceller.signal);\n            request.catch((error) => {\n                unlinkCanceller();\n                if (!isComplete) {\n                    isComplete = true;\n                    this.stop();\n                    this.trigger(\"error\", error);\n                }\n            });\n            contentInfo.mediaSegmentRequest = { segment, priority, request, canceller };\n        };\n        recursivelyRequestSegments();\n    }\n    /**\n     * Internal logic performing initialization segment requests.\n     * @param {Object} contentInfo\n     * @param {Object} queuedInitSegment\n     */\n    _restartInitSegmentDownloadingQueue(contentInfo, queuedInitSegment) {\n        const { content, initSegmentInfoRef } = contentInfo;\n        if (contentInfo.initSegmentRequest !== null) {\n            contentInfo.initSegmentRequest.canceller.cancel();\n        }\n        if (queuedInitSegment === null) {\n            return;\n        }\n        const canceller = new TaskCanceller();\n        const unlinkCanceller = contentInfo.currentCanceller === null\n            ? noop\n            : canceller.linkToSignal(contentInfo.currentCanceller.signal);\n        const { segment, priority } = queuedInitSegment;\n        const context = objectAssign({ segment, nextSegment: undefined }, content);\n        /**\n         * If `true` , the current task has either errored, finished, or was\n         * cancelled.\n         */\n        let isComplete = false;\n        const request = this._segmentFetcher.createRequest(context, priority, {\n            onRetry: (err) => {\n                this.trigger(\"requestRetry\", { segment, error: err });\n            },\n            beforeInterrupted: () => {\n                log.info(\"SQ: init segment request interrupted temporarly.\", segment.id);\n            },\n            beforeEnded: () => {\n                unlinkCanceller();\n                contentInfo.initSegmentRequest = null;\n                isComplete = true;\n            },\n            onChunk: (parse) => {\n                var _a;\n                const parsed = parse(undefined);\n                assert(parsed.segmentType === \"init\", \"Should have loaded an init segment.\");\n                this.trigger(\"parsedInitSegment\", objectAssign({}, parsed, { segment }));\n                if (parsed.segmentType === \"init\") {\n                    initSegmentInfoRef.setValue((_a = parsed.initTimescale) !== null && _a !== void 0 ? _a : null);\n                }\n            },\n            onAllChunksReceived: () => {\n                this.trigger(\"fullyLoadedSegment\", segment);\n            },\n        }, canceller.signal);\n        request.catch((error) => {\n            unlinkCanceller();\n            if (!isComplete) {\n                isComplete = true;\n                this.stop();\n                this.trigger(\"error\", error);\n            }\n        });\n        canceller.signal.register(() => {\n            contentInfo.initSegmentRequest = null;\n            if (isComplete) {\n                return;\n            }\n            isComplete = true;\n        });\n        contentInfo.initSegmentRequest = { segment, priority, request, canceller };\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport config from \"../../../config\";\nimport applyPrioritizerToSegmentFetcher from \"./prioritized_segment_fetcher\";\nimport createSegmentFetcher, { getSegmentFetcherRequestOptions } from \"./segment_fetcher\";\nimport SegmentQueue from \"./segment_queue\";\nimport TaskPrioritizer from \"./task_prioritizer\";\n/**\n * Interact with the transport pipelines to download segments with the right\n * priority.\n *\n * @class SegmentQueueCreator\n */\nexport default class SegmentQueueCreator {\n    /**\n     * @param {Object} transport\n     * @param {Object} cdnPrioritizer\n     * @param {Object|null} cmcdDataBuilder\n     * @param {Object} options\n     */\n    constructor(transport, cdnPrioritizer, cmcdDataBuilder, options) {\n        const { MIN_CANCELABLE_PRIORITY, MAX_HIGH_PRIORITY_LEVEL } = config.getCurrent();\n        this._transport = transport;\n        this._prioritizer = new TaskPrioritizer({\n            prioritySteps: {\n                high: MAX_HIGH_PRIORITY_LEVEL,\n                low: MIN_CANCELABLE_PRIORITY,\n            },\n        });\n        this._cdnPrioritizer = cdnPrioritizer;\n        this._backoffOptions = options;\n        this._cmcdDataBuilder = cmcdDataBuilder;\n    }\n    /**\n     * Create a `SegmentQueue`, allowing to easily perform segment requests.\n     * @param {string} bufferType - The type of buffer concerned (e.g. \"audio\",\n     * \"video\", etc.)\n     * @param {Object} eventListeners\n     * @param {Object} isMediaSegmentQueueInterrupted - Wheter the downloading of media\n     * segment should be interrupted or not.\n     * @returns {Object} - `SegmentQueue`, which is an abstraction allowing to\n     * perform a queue of segment requests for a given media type (here defined by\n     * `bufferType`) with associated priorities.\n     */\n    createSegmentQueue(bufferType, eventListeners, isMediaSegmentQueueInterrupted) {\n        const requestOptions = getSegmentFetcherRequestOptions(this._backoffOptions);\n        const pipelines = this._transport[bufferType];\n        // Types are very complicated here as they are per-type of buffer.\n        const segmentFetcher = createSegmentFetcher({\n            bufferType,\n            pipeline: pipelines,\n            cdnPrioritizer: this._cdnPrioritizer,\n            cmcdDataBuilder: this._cmcdDataBuilder,\n            eventListeners,\n            requestOptions,\n        });\n        const prioritizedSegmentFetcher = applyPrioritizerToSegmentFetcher(this._prioritizer, segmentFetcher);\n        return new SegmentQueue(prioritizedSegmentFetcher, isMediaSegmentQueueInterrupted);\n    }\n}\n","import log from \"../../../log\";\nimport arrayFindIndex from \"../../../utils/array_find_index\";\nimport createCancellablePromise from \"../../../utils/create_cancellable_promise\";\nimport TaskCanceller, { CancellationError } from \"../../../utils/task_canceller\";\n/**\n * Utilitary class which allows to perform multiple tasks at once each with an\n * associated priority.\n *\n * This class will then schedule the given tasks in the right order based on the\n * priorities.\n *\n * @class TaskPrioritizer\n */\nexport default class TaskPrioritizer {\n    /**\n     * @param {Options} prioritizerOptions\n     */\n    constructor({ prioritySteps }) {\n        this._minPendingPriority = null;\n        this._waitingQueue = [];\n        this._pendingTasks = [];\n        this._prioritySteps = prioritySteps;\n        if (this._prioritySteps.high >= this._prioritySteps.low) {\n            throw new Error(\"TP: the max high level priority should be given a lower\" +\n                \"priority number than the min low priority.\");\n        }\n    }\n    /**\n     * Create a priorized Promise from a base task.\n     *\n     * This task will immediately have its priority compared to all the\n     * already-running ones created from this class.\n     *\n     * Only if this number is inferior or equal to the priority of the\n     * minimum priority number of all currently-running tasks  will it be\n     * immediately started.\n     * In the opposite case, we will wait for higher-priority tasks to\n     * finish before starting it.\n     *\n     * Note that while this task is waiting for its turn, it is possible\n     * to update its property through the updatePriority method, by providing\n     * the task again and its new priority number.\n     *\n     * @param {Function} taskFn\n     * @param {number} priority\n     * @param {Object} callbacks\n     * @param {Object} cancelSignal\n     * @returns {Promise}\n     */\n    create(taskFn, priority, callbacks, cancelSignal) {\n        let newTask;\n        return createCancellablePromise(cancelSignal, (resolve, reject) => {\n            /** Function allowing to start the underlying Promise. */\n            const trigger = () => {\n                if (newTask.hasEnded) {\n                    return;\n                }\n                const finishTask = () => {\n                    unlinkInterrupter();\n                    this._endTask(newTask);\n                };\n                const onResolve = (value) => {\n                    callbacks.beforeEnded();\n                    finishTask();\n                    resolve(value);\n                };\n                const onReject = (err) => {\n                    finishTask();\n                    reject(err);\n                };\n                const interrupter = new TaskCanceller();\n                const unlinkInterrupter = interrupter.linkToSignal(cancelSignal);\n                newTask.interrupter = interrupter;\n                interrupter.signal.register(() => {\n                    newTask.interrupter = null;\n                    if (!cancelSignal.isCancelled()) {\n                        callbacks.beforeInterrupted();\n                    }\n                });\n                this._minPendingPriority =\n                    this._minPendingPriority === null\n                        ? newTask.priority\n                        : Math.min(this._minPendingPriority, newTask.priority);\n                this._pendingTasks.push(newTask);\n                newTask\n                    .taskFn(interrupter.signal)\n                    .then(onResolve)\n                    .catch((err) => {\n                    if (!cancelSignal.isCancelled() &&\n                        interrupter.isUsed() &&\n                        err instanceof CancellationError) {\n                        return;\n                    }\n                    onReject(err);\n                });\n            };\n            newTask = {\n                hasEnded: false,\n                priority,\n                trigger,\n                taskFn,\n                interrupter: null,\n            };\n            if (!this._canBeStartedNow(newTask)) {\n                this._waitingQueue.push(newTask);\n            }\n            else {\n                // We can start the task right away\n                newTask.trigger();\n                if (this._isRunningHighPriorityTasks()) {\n                    // Note: we want to begin interrupting low-priority tasks just\n                    // after starting the current one because the interrupting\n                    // logic can call external code.\n                    // This would mean re-entrancy, itself meaning that some weird\n                    // half-state could be reached unless we're very careful.\n                    // To be sure no harm is done, we put that code at the last\n                    // possible position.\n                    this._interruptCancellableTasks();\n                }\n            }\n            return () => this._endTask(newTask);\n        });\n    }\n    _endTask(task) {\n        task.hasEnded = true;\n        const waitingQueueIndex = _findTaskIndex(task.taskFn, this._waitingQueue);\n        if (waitingQueueIndex >= 0) {\n            // If it was still waiting for its turn\n            this._waitingQueue.splice(waitingQueueIndex, 1);\n        }\n        else {\n            // remove it from pending queue if in it\n            const pendingTasksIndex = _findTaskIndex(task.taskFn, this._pendingTasks);\n            if (pendingTasksIndex < 0) {\n                return;\n            }\n            this._pendingTasks.splice(pendingTasksIndex, 1);\n            if (this._pendingTasks.length > 0) {\n                if (this._minPendingPriority === task.priority) {\n                    this._minPendingPriority = Math.min(...this._pendingTasks.map((t) => t.priority));\n                }\n            }\n            else {\n                this._minPendingPriority = null;\n            }\n            this._loopThroughWaitingQueue();\n        }\n    }\n    /**\n     * Update the priority of a promise given to the TaskPrioritizer.\n     * @param {Object} promise\n     * @param {number} priority\n     */\n    updatePriority(promise, priority) {\n        const waitingQueueIndex = _findTaskIndex(promise, this._waitingQueue);\n        if (waitingQueueIndex >= 0) {\n            // If it was still waiting for its turn\n            const waitingQueueElt = this._waitingQueue[waitingQueueIndex];\n            if (waitingQueueElt.priority === priority) {\n                return;\n            }\n            waitingQueueElt.priority = priority;\n            if (!this._canBeStartedNow(waitingQueueElt)) {\n                return;\n            }\n            this._findAndRunWaitingQueueTask(waitingQueueIndex);\n            if (this._isRunningHighPriorityTasks()) {\n                // Re-check to cancel every \"cancellable\" pending task\n                //\n                // Note: We start the task before interrupting cancellable tasks on\n                // purpose.\n                // Because both `_findAndRunWaitingQueueTask` and\n                // `_interruptCancellableTasks` can emit events and thus call external\n                // code, we could retrieve ourselves in a very weird state at this point\n                //\n                // By starting the task first, we ensure that this is manageable:\n                // `_getMinPendingPriority()` has already been updated to the right value at\n                // the time we reached external code, the priority of the current\n                // Task has just been updated, and `_interruptCancellableTasks`\n                // will ensure that we're basing ourselves on the last `priority` value\n                // each time.\n                // Doing it in the reverse order is an order of magnitude more difficult\n                // to write and to reason about.\n                this._interruptCancellableTasks();\n            }\n            return;\n        }\n        const pendingTasksIndex = _findTaskIndex(promise, this._pendingTasks);\n        if (pendingTasksIndex < 0) {\n            log.warn(\"TP: request to update the priority of a non-existent task\");\n            return;\n        }\n        const task = this._pendingTasks[pendingTasksIndex];\n        if (task.priority === priority) {\n            return;\n        }\n        const prevPriority = task.priority;\n        task.priority = priority;\n        if (this._minPendingPriority === null || priority < this._minPendingPriority) {\n            this._minPendingPriority = priority;\n        }\n        else if (this._minPendingPriority === prevPriority) {\n            // was highest priority\n            if (this._pendingTasks.length === 1) {\n                this._minPendingPriority = priority;\n            }\n            else {\n                this._minPendingPriority = Math.min(...this._pendingTasks.map((t) => t.priority));\n            }\n            this._loopThroughWaitingQueue();\n        }\n        if (this._isRunningHighPriorityTasks()) {\n            // Always interrupt cancellable tasks after all other side-effects, to\n            // avoid re-entrancy issues\n            this._interruptCancellableTasks();\n        }\n    }\n    /**\n     * Browse the current waiting queue and start all task in it that needs to be\n     * started: start the ones with the lowest priority value below\n     * `_minPendingPriority`.\n     *\n     * Private properties, such as `_minPendingPriority` are updated accordingly\n     * while this method is called.\n     */\n    _loopThroughWaitingQueue() {\n        const minWaitingPriority = this._waitingQueue.reduce((acc, elt) => {\n            return acc === null || acc > elt.priority ? elt.priority : acc;\n        }, null);\n        if (minWaitingPriority === null ||\n            (this._minPendingPriority !== null && this._minPendingPriority < minWaitingPriority)) {\n            return;\n        }\n        for (let i = 0; i < this._waitingQueue.length; i++) {\n            const priorityToCheck = this._minPendingPriority === null\n                ? minWaitingPriority\n                : Math.min(this._minPendingPriority, minWaitingPriority);\n            const elt = this._waitingQueue[i];\n            if (elt.priority <= priorityToCheck) {\n                this._findAndRunWaitingQueueTask(i);\n                i--; // previous operation should have removed that element from the\n                // the waiting queue\n            }\n        }\n    }\n    /**\n     * Interrupt and move back to the waiting queue all pending tasks that are\n     * low priority (having a higher priority number than\n     * `this._prioritySteps.low`).\n     */\n    _interruptCancellableTasks() {\n        for (const pendingObj of this._pendingTasks) {\n            if (pendingObj.priority >= this._prioritySteps.low) {\n                this._interruptPendingTask(pendingObj);\n                // The previous call could have a lot of potential side-effects.\n                // It is safer to re-start the function to not miss any pending\n                // task that needs to be cancelled.\n                return this._interruptCancellableTasks();\n            }\n        }\n    }\n    /**\n     * Start task which is at the given index in the waiting queue.\n     * The task will be removed from the waiting queue in the process.\n     * @param {number} index\n     */\n    _findAndRunWaitingQueueTask(index) {\n        if (index >= this._waitingQueue.length || index < 0) {\n            log.warn(\"TP : Tried to start a non existing task\");\n            return false;\n        }\n        const task = this._waitingQueue.splice(index, 1)[0];\n        task.trigger();\n        return true;\n    }\n    /**\n     * Move back pending task to the waiting queue and interrupt it.\n     * @param {object} task\n     */\n    _interruptPendingTask(task) {\n        var _a;\n        const pendingTasksIndex = _findTaskIndex(task.taskFn, this._pendingTasks);\n        if (pendingTasksIndex < 0) {\n            log.warn(\"TP: Interrupting a non-existent pending task. Aborting...\");\n            return;\n        }\n        // Stop task and put it back in the waiting queue\n        this._pendingTasks.splice(pendingTasksIndex, 1);\n        this._waitingQueue.push(task);\n        if (this._pendingTasks.length === 0) {\n            this._minPendingPriority = null;\n        }\n        else if (this._minPendingPriority === task.priority) {\n            this._minPendingPriority = Math.min(...this._pendingTasks.map((t) => t.priority));\n        }\n        (_a = task.interrupter) === null || _a === void 0 ? void 0 : _a.cancel(); // Interrupt at last step because it calls external code\n    }\n    /**\n     * Return `true` if the given task can be started immediately based on its\n     * priority.\n     * @param {Object} task\n     * @returns {boolean}\n     */\n    _canBeStartedNow(task) {\n        return this._minPendingPriority === null || task.priority <= this._minPendingPriority;\n    }\n    /**\n     * Returns `true` if any running task is considered \"high priority\".\n     * returns `false` otherwise.\n     * @returns {boolean}\n     */\n    _isRunningHighPriorityTasks() {\n        return (this._minPendingPriority !== null &&\n            this._minPendingPriority <= this._prioritySteps.high);\n    }\n}\n/**\n * Simple utils function allowing to find a given task function in the given\n * `queue`.\n *\n * Returns `-1` if `taskFn` is not found.\n * @param {Function} taskFn\n * @param {Array.<Object>} queue\n * @returns {number}\n */\nfunction _findTaskIndex(taskFn, queue) {\n    return arrayFindIndex(queue, (elt) => elt.taskFn === taskFn);\n}\n","import createThumbnailFetcher, { getThumbnailFetcherRequestOptions, } from \"./thumbnail_fetcher\";\nexport default createThumbnailFetcher;\nexport { getThumbnailFetcherRequestOptions };\n","import config from \"../../../config\";\nimport { formatError } from \"../../../errors\";\nimport log from \"../../../log\";\nimport objectAssign from \"../../../utils/object_assign\";\nimport { CancellationError } from \"../../../utils/task_canceller\";\nimport errorSelector from \"../utils/error_selector\";\nimport { scheduleRequestWithCdns } from \"../utils/schedule_request\";\n/**\n * Create an `IThumbnailFetcher` object which will allow to easily fetch and parse\n * segments.\n * An `IThumbnailFetcher` also implements a retry mechanism, based on the given\n * `requestOptions` argument, which may retry a segment request when it fails.\n *\n * @param {Object} pipeline\n * @param {Object|null} cdnPrioritizer\n * @returns {Function}\n */\nexport default function createThumbnailFetcher(\n/** The transport-specific logic allowing to load thumbnails. */\npipeline, \n/**\n * Abstraction allowing to synchronize, update and keep track of the\n * priorization of the CDN to use to load any given segment, in cases where\n * multiple ones are available.\n *\n * Can be set to `null` in which case a minimal priorization logic will be used\n * instead.\n */\ncdnPrioritizer) {\n    const { loadThumbnail } = pipeline;\n    // TODO short-lived cache?\n    /**\n     * Fetch a specific segment.\n     * @param {Object} thumbnail\n     * @param {Object} thumbnailTrack\n     * @param {Object} requestOptions\n     * @param {Object} cancellationSignal\n     * @returns {Promise}\n     */\n    return async function fetchThumbnail(thumbnail, thumbnailTrack, requestOptions, cancellationSignal) {\n        let connectionTimeout;\n        if (requestOptions.connectionTimeout === undefined ||\n            requestOptions.connectionTimeout < 0) {\n            connectionTimeout = undefined;\n        }\n        else {\n            connectionTimeout = requestOptions.connectionTimeout;\n        }\n        const pipelineRequestOptions = {\n            timeout: requestOptions.requestTimeout < 0 ? undefined : requestOptions.requestTimeout,\n            connectionTimeout,\n            cmcdPayload: undefined,\n        };\n        log.debug(\"TF: Beginning thumbnail request\", thumbnail.time);\n        cancellationSignal.register(onCancellation);\n        let res;\n        try {\n            res = await scheduleRequestWithCdns(thumbnailTrack.cdnMetadata, cdnPrioritizer, callLoaderWithUrl, objectAssign({ onRetry }, requestOptions), cancellationSignal);\n            if (cancellationSignal.isCancelled()) {\n                return Promise.reject(cancellationSignal.cancellationError);\n            }\n            log.debug(\"TF: Thumbnail request ended with success\", thumbnail.time);\n            cancellationSignal.deregister(onCancellation);\n        }\n        catch (err) {\n            cancellationSignal.deregister(onCancellation);\n            if (err instanceof CancellationError) {\n                log.debug(\"TF: Thumbnail request aborted\", thumbnail.time);\n                throw err;\n            }\n            log.debug(\"TF: Thumbnail request failed\", thumbnail.time);\n            throw errorSelector(err);\n        }\n        try {\n            const parsed = pipeline.parseThumbnail(res.responseData, {\n                thumbnail,\n                thumbnailTrack,\n            });\n            return parsed;\n        }\n        catch (error) {\n            throw formatError(error, {\n                defaultCode: \"PIPELINE_PARSE_ERROR\",\n                defaultReason: \"Unknown parsing error\",\n            });\n        }\n        function onCancellation() {\n            log.debug(\"TF: Thumbnail request cancelled\", thumbnail.time);\n        }\n        /**\n         * Call a segment loader for the given URL with the right arguments.\n         * @param {Object|null} cdnMetadata\n         * @returns {Promise}\n         */\n        function callLoaderWithUrl(cdnMetadata) {\n            return loadThumbnail(cdnMetadata, thumbnail, pipelineRequestOptions, cancellationSignal);\n        }\n        /**\n         * Function called when the function request is retried.\n         * @param {*} err\n         */\n        function onRetry(err) {\n            const formattedErr = errorSelector(err);\n            log.warn(\"TF: Thumbnail request retry \", thumbnail.time, formattedErr);\n        }\n    };\n}\n/**\n * @param {Object} baseOptions\n * @returns {Object}\n */\nexport function getThumbnailFetcherRequestOptions({ maxRetry, requestTimeout, connectionTimeout, }) {\n    const { DEFAULT_MAX_THUMBNAIL_REQUESTS_RETRY_ON_ERROR, DEFAULT_THUMBNAIL_REQUEST_TIMEOUT, DEFAULT_THUMBNAIL_CONNECTION_TIMEOUT, INITIAL_BACKOFF_DELAY_BASE, MAX_BACKOFF_DELAY_BASE, } = config.getCurrent();\n    return {\n        maxRetry: maxRetry !== null && maxRetry !== void 0 ? maxRetry : DEFAULT_MAX_THUMBNAIL_REQUESTS_RETRY_ON_ERROR,\n        baseDelay: INITIAL_BACKOFF_DELAY_BASE.REGULAR,\n        maxDelay: MAX_BACKOFF_DELAY_BASE.REGULAR,\n        requestTimeout: requestTimeout === undefined ? DEFAULT_THUMBNAIL_REQUEST_TIMEOUT : requestTimeout,\n        connectionTimeout: connectionTimeout === undefined\n            ? DEFAULT_THUMBNAIL_CONNECTION_TIMEOUT\n            : connectionTimeout,\n    };\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { formatError, NetworkError } from \"../../../errors\";\nimport { RequestError } from \"../../../utils/request\";\n/**\n * Generate a new error from the infos given.\n * @param {Error} error\n * @returns {Error}\n */\nexport default function errorSelector(error) {\n    if (error instanceof RequestError) {\n        return new NetworkError(\"PIPELINE_LOAD_ERROR\", error);\n    }\n    return formatError(error, {\n        defaultCode: \"PIPELINE_LOAD_ERROR\",\n        defaultReason: \"Unknown error when fetching the Manifest\",\n    });\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { CustomLoaderError, isKnownError, NetworkErrorTypes } from \"../../../errors\";\nimport log from \"../../../log\";\nimport cancellableSleep from \"../../../utils/cancellable_sleep\";\nimport getFuzzedDelay from \"../../../utils/get_fuzzed_delay\";\nimport getTimestamp from \"../../../utils/monotonic_timestamp\";\nimport noop from \"../../../utils/noop\";\nimport { RequestError } from \"../../../utils/request\";\nimport TaskCanceller from \"../../../utils/task_canceller\";\n/**\n * Called on a loader error.\n * Returns whether the loader request should be retried.\n *\n * TODO the notion of retrying or not could be transport-specific (e.g. 412 are\n * mainly used for Smooth contents) and thus as part of the transport code (e.g.\n * by rejecting with an error always having a `canRetry` property?).\n * Or not, to ponder.\n *\n * @param {Error} error\n * @returns {Boolean} - If true, the request can be retried.\n */\nfunction shouldRetry(error) {\n    if (error instanceof RequestError) {\n        if (error.type === NetworkErrorTypes.ERROR_HTTP_CODE) {\n            return (error.status >= 500 ||\n                error.status === 404 ||\n                error.status === 415 || // some CDN seems to use that code when\n                // requesting low-latency segments too much\n                // in advance\n                error.status === 412);\n        }\n        return (error.type === NetworkErrorTypes.TIMEOUT ||\n            error.type === NetworkErrorTypes.ERROR_EVENT);\n    }\n    else if (error instanceof CustomLoaderError) {\n        if (typeof error.canRetry === \"boolean\") {\n            return error.canRetry;\n        }\n        if (error.xhr !== undefined) {\n            return (error.xhr.status >= 500 ||\n                error.xhr.status === 404 ||\n                error.xhr.status === 415 || // some CDN seems to use that code when\n                // requesting low-latency segments too much\n                // in advance\n                error.xhr.status === 412);\n        }\n        return false;\n    }\n    return isKnownError(error) && error.code === \"INTEGRITY_ERROR\";\n}\n/**\n * Specific algorithm used to perform segment and manifest requests.\n *\n * Here how it works:\n *\n *   1. You give it one or multiple of the CDN available for the resource you\n *      want to request (from the most important one to the least important),\n *      a callback doing the request with the chosen CDN in argument, and some\n *      options.\n *\n *   2. it tries to call the request callback with the most prioritized CDN\n *      first:\n *        - if it works as expected, it resolves the returned Promise with that\n *          request's response.\n *        - if it fails, it calls ther `onRetry` callback given with the\n *          corresponding error, un-prioritize that CDN and try with the new\n *          most prioritized CDN.\n *\n *      Each CDN might be retried multiple times, depending on the nature of the\n *      error and the Configuration given.\n *\n *      Multiple retries of the same CDN are done after a delay to avoid\n *      overwhelming it, this is what we call a \"backoff\". That delay raises\n *      exponentially as multiple consecutive errors are encountered on this\n *      CDN.\n *\n * @param {Array.<string>|null} cdns - The different CDN on which the\n * wanted resource is available. `scheduleRequestWithCdns` will call the\n * `performRequest` callback with the right element from that array if different\n * from `null`.\n *\n * Can be set to `null` when that resource is not reachable through a CDN, in\n * which case the `performRequest` callback may be called with `null`.\n * @param {Object|null} cdnPrioritizer - Interface allowing to give the priority\n * between multiple CDNs.\n * @param {Function} performRequest - Callback implementing the request in\n * itself. Resolving when the resource request succeed and rejecting with the\n * corresponding error when the request failed.\n * @param {Object} options - Configuration allowing to tweak the number on which\n * the algorithm behind `scheduleRequestWithCdns` bases itself.\n * @param {Object} cancellationSignal - CancellationSignal allowing to cancel\n * the logic of `scheduleRequestWithCdns`.\n * To trigger if the resource is not needed anymore.\n * @returns {Promise} - Promise resolving, with the corresponding\n * `performRequest`'s data, when the resource request succeed and rejecting in\n * the following scenarios:\n *   - `scheduleRequestWithCdns` has been cancelled due to `cancellationSignal`\n *     being triggered. In that case a `CancellationError` is thrown.\n *\n *   - The resource request(s) failed and will not be retried anymore.\n */\nexport async function scheduleRequestWithCdns(cdns, cdnPrioritizer, performRequest, options, cancellationSignal) {\n    if (cancellationSignal.cancellationError !== null) {\n        return Promise.reject(cancellationSignal.cancellationError);\n    }\n    const { baseDelay, maxDelay, maxRetry, onRetry } = options;\n    if (cdns !== null && cdns.length === 0) {\n        log.warn(\"Fetchers: no CDN given to `scheduleRequestWithCdns`.\");\n    }\n    const missedAttempts = new Map();\n    const initialCdnToRequest = getCdnToRequest();\n    if (initialCdnToRequest === undefined) {\n        throw new Error(\"No CDN to request\");\n    }\n    return requestCdn(initialCdnToRequest);\n    /**\n     * Returns what is now the most prioritary CDN to request the wanted resource.\n     *\n     * A return value of `null` indicates that the resource can be requested\n     * through another mean than by doing an HTTP request.\n     *\n     * A return value of `undefined` indicates that there's no CDN left to request\n     * the resource.\n     * @returns {Object|null|undefined}\n     */\n    function getCdnToRequest() {\n        if (cdns === null) {\n            const nullAttemptObject = missedAttempts.get(null);\n            if (nullAttemptObject !== undefined && nullAttemptObject.isBlacklisted) {\n                return undefined;\n            }\n            return null;\n        }\n        else if (cdnPrioritizer === null) {\n            return getPrioritaryRequestableCdnFromSortedList(cdns);\n        }\n        else {\n            const prioritized = cdnPrioritizer.getCdnPreferenceForResource(cdns);\n            return getPrioritaryRequestableCdnFromSortedList(prioritized);\n        }\n    }\n    /**\n     * Perform immediately the request for the given CDN.\n     *\n     * If it fails, forbid the CDN from being used - optionally and in some\n     * conditions, only temporarily, then try the next CDN according to\n     * previously-set delays (with a potential sleep before to respect them).\n     *\n     * Reject if both the request fails and there's no CDN left to use.\n     * @param {string|null} cdn\n     * @returns {Promise}\n     */\n    async function requestCdn(cdn) {\n        try {\n            const res = await performRequest(cdn, cancellationSignal);\n            return res;\n        }\n        catch (error) {\n            if (TaskCanceller.isCancellationError(error)) {\n                throw error;\n            }\n            if (cdn !== null && cdnPrioritizer !== null) {\n                // We failed requesting the resource on this CDN.\n                // Globally give priority to the next CDN through the CdnPrioritizer.\n                cdnPrioritizer.downgradeCdn(cdn);\n            }\n            let missedAttemptsObj = missedAttempts.get(cdn);\n            if (missedAttemptsObj === undefined) {\n                missedAttemptsObj = {\n                    errorCounter: 1,\n                    blockedUntil: undefined,\n                    isBlacklisted: false,\n                };\n                missedAttempts.set(cdn, missedAttemptsObj);\n            }\n            else {\n                missedAttemptsObj.errorCounter++;\n            }\n            if (!shouldRetry(error)) {\n                missedAttemptsObj.blockedUntil = undefined;\n                missedAttemptsObj.isBlacklisted = true;\n                return retryWithNextCdn(error);\n            }\n            if (missedAttemptsObj.errorCounter > maxRetry) {\n                missedAttemptsObj.blockedUntil = undefined;\n                missedAttemptsObj.isBlacklisted = true;\n            }\n            else {\n                const errorCounter = missedAttemptsObj.errorCounter;\n                const delay = Math.min(baseDelay * Math.pow(2, errorCounter - 1), maxDelay);\n                const fuzzedDelay = getFuzzedDelay(delay);\n                missedAttemptsObj.blockedUntil = getTimestamp() + fuzzedDelay;\n            }\n            return retryWithNextCdn(error);\n        }\n    }\n    /**\n     * After a request error, find the new most prioritary CDN and perform the\n     * request with it, optionally after a delay.\n     *\n     * If there's no CDN left to test, reject the original request error.\n     * @param {*} prevRequestError\n     * @returns {Promise}\n     */\n    async function retryWithNextCdn(prevRequestError) {\n        const nextCdn = getCdnToRequest();\n        if (cancellationSignal.isCancelled()) {\n            throw cancellationSignal.cancellationError;\n        }\n        if (nextCdn === undefined) {\n            throw prevRequestError;\n        }\n        onRetry(prevRequestError);\n        if (cancellationSignal.isCancelled()) {\n            throw cancellationSignal.cancellationError;\n        }\n        return waitPotentialBackoffAndRequest(nextCdn, prevRequestError);\n    }\n    /**\n     * Request the corresponding CDN after the optional backoff needed before\n     * requesting it.\n     *\n     * If a new CDN become prioritary in the meantime, request it instead, again\n     * awaiting its optional backoff delay if it exists.\n     * @param {string|null} nextWantedCdn\n     * @param {*} prevRequestError\n     * @returns {Promise}\n     */\n    function waitPotentialBackoffAndRequest(nextWantedCdn, prevRequestError) {\n        const nextCdnAttemptObj = missedAttempts.get(nextWantedCdn);\n        if (nextCdnAttemptObj === undefined || nextCdnAttemptObj.blockedUntil === undefined) {\n            return requestCdn(nextWantedCdn);\n        }\n        const now = getTimestamp();\n        const blockedFor = nextCdnAttemptObj.blockedUntil - now;\n        if (blockedFor <= 0) {\n            return requestCdn(nextWantedCdn);\n        }\n        const canceller = new TaskCanceller();\n        const unlinkCanceller = canceller.linkToSignal(cancellationSignal);\n        return new Promise((res, rej) => {\n            cdnPrioritizer === null || cdnPrioritizer === void 0 ? void 0 : cdnPrioritizer.addEventListener(\"priorityChange\", () => {\n                const updatedPrioritaryCdn = getCdnToRequest();\n                if (cancellationSignal.isCancelled()) {\n                    throw cancellationSignal.cancellationError;\n                }\n                if (updatedPrioritaryCdn === undefined) {\n                    return cleanAndReject(prevRequestError);\n                }\n                if (updatedPrioritaryCdn !== nextWantedCdn) {\n                    canceller.cancel();\n                    waitPotentialBackoffAndRequest(updatedPrioritaryCdn, prevRequestError).then(cleanAndResolve, cleanAndReject);\n                }\n            }, canceller.signal);\n            cancellableSleep(blockedFor, canceller.signal).then(() => requestCdn(nextWantedCdn).then(cleanAndResolve, cleanAndReject), noop);\n            function cleanAndResolve(response) {\n                unlinkCanceller();\n                res(response);\n            }\n            function cleanAndReject(err) {\n                unlinkCanceller();\n                rej(err);\n            }\n        });\n    }\n    /**\n     * Takes in input the list of CDN that can be used to request the resource, in\n     * a general preference order.\n     *\n     * Returns the actual most prioritary Cdn to request, based on the current\n     * attempts already done for that resource.\n     *\n     * Returns `undefined` if there's no Cdn left to request the resource.\n     * @param {Array.<Object>} sortedCdns\n     * @returns {Object|undefined}\n     */\n    function getPrioritaryRequestableCdnFromSortedList(sortedCdns) {\n        var _a;\n        if (missedAttempts.size === 0) {\n            return sortedCdns[0];\n        }\n        const now = getTimestamp();\n        return (_a = sortedCdns\n            .filter((c) => { var _a; return ((_a = missedAttempts.get(c)) === null || _a === void 0 ? void 0 : _a.isBlacklisted) !== true; })\n            .reduce((acc, x) => {\n            var _a;\n            let blockedUntil = (_a = missedAttempts.get(x)) === null || _a === void 0 ? void 0 : _a.blockedUntil;\n            if (blockedUntil !== undefined && blockedUntil <= now) {\n                blockedUntil = undefined;\n            }\n            if (acc === undefined) {\n                return [x, blockedUntil];\n            }\n            if (acc[1] === undefined) {\n                return acc;\n            }\n            if (blockedUntil === undefined) {\n                return [x, undefined];\n            }\n            if (blockedUntil < acc[1]) {\n                return [x, blockedUntil];\n            }\n            return acc;\n        }, undefined)) === null || _a === void 0 ? void 0 : _a[0];\n    }\n}\n/**\n * Lightweight version of the request algorithm, this time with only a simple\n * Promise given.\n * @param {Function} performRequest\n * @param {Object} options\n * @returns {Promise}\n */\nexport function scheduleRequestPromise(performRequest, options, cancellationSignal) {\n    // same than for a single unknown CDN\n    return scheduleRequestWithCdns(null, null, performRequest, options, cancellationSignal);\n}\n","import { config } from \"../../../experimental\";\nimport log from \"../../../log\";\nimport getMonotonicTimeStamp from \"../../../utils/monotonic_timestamp\";\n/**\n * \"Freezing\" is a complex situation indicating that playback is not advancing\n * despite no valid reason for it not to.\n *\n * Technically, there's multiple scenarios in which the RxPlayer will consider\n * the stream as \"freezing\" and try to fix it.\n * One of those scenarios is when there's a\n * `HTMLMediaElement.prototype.readyState` set to `1` (which is how the browser\n * tells us that it doesn't have any data to play), despite the fact that\n * there's actually data in the buffer.\n *\n * The `MINIMUM_BUFFER_GAP_AT_READY_STATE_1_BEFORE_FREEZING` is the minimum\n * buffer size in seconds after which we will suspect a \"freezing\" scenario if\n * the `readyState` is still at `1`.\n */\nconst MINIMUM_BUFFER_GAP_AT_READY_STATE_1_BEFORE_FREEZING = 6;\n/**\n * The amount of milliseconds since a freeze was detected from which we consider\n * that the freeze should be worked around: either by flushing buffers,\n * reloading, or any other kind of strategies.\n *\n * Before that delay, will continue to wait to see if the browser succeeds to\n * un-freeze by itself.\n */\nconst FREEZING_FOR_TOO_LONG_DELAY = 4000;\n/**\n * To avoid handling freezes (e.g. \"reloading\" or \"seeking\") in a loop when\n * things go wrong, we have a security delay in milliseconds, this\n * `MINIMUM_TIME_BETWEEN_FREEZE_HANDLING` constant, which we'll await between\n * un-freezing attempts.\n */\nconst MINIMUM_TIME_BETWEEN_FREEZE_HANDLING = 6000;\n/**\n * We maintain here a short-term history of what segments have been played\n * recently, to then implement heuristics detecting if a freeze was due to a\n * particular quality or track.\n *\n * To avoid growing that history indefinitely in size, we only save data\n * corresponding to the last `MAXIMUM_SEGMENT_HISTORY_RETENTION_TIME`\n * milliseconds from now.\n */\nconst MAXIMUM_SEGMENT_HISTORY_RETENTION_TIME = 60000;\n/**\n * Sometimes playback is stuck for no known reason, despite having data in\n * buffers.\n *\n * This can be due to relatively valid cause: performance being slow on the\n * device making the content slow to start up, decryption keys not being\n * obtained / usable yet etc.\n *\n * Yet in many cases, this is abnormal and may lead to being stuck at the same\n * position and video frame indefinitely.\n *\n * For those situations, we have a series of tricks and heuristic, which are\n * implemented by the `FreezeResolver`.\n *\n * @class FreezeResolver\n */\nexport default class FreezeResolver {\n    constructor(segmentSinksStore) {\n        this._segmentSinksStore = segmentSinksStore;\n        this._decipherabilityFreezeStartingTimestamp = null;\n        this._ignoreFreezeUntil = null;\n        this._lastFlushAttempt = null;\n        this._lastSegmentInfo = {\n            audio: [],\n            video: [],\n        };\n    }\n    /**\n     * Check that playback is not freezing, and if it is, return a solution that\n     * should be attempted to unfreeze it.\n     *\n     * Returns `null` either when there's no freeze happening or if there's one\n     * but there's nothing we should do about it yet.\n     *\n     * Refer to the returned type's definition for more information.\n     *\n     * @param {Object} observation - The last playback observation produced, it\n     * has to be recent (just triggered for example).\n     * @returns {Object|null}\n     */\n    onNewObservation(observation) {\n        var _a, _b;\n        const now = getMonotonicTimeStamp();\n        this._addPositionToHistory(observation, now);\n        if (this._ignoreFreezeUntil !== null && now < this._ignoreFreezeUntil) {\n            return null;\n        }\n        this._ignoreFreezeUntil = null;\n        const { UNFREEZING_SEEK_DELAY, UNFREEZING_DELTA_POSITION, FREEZING_FLUSH_FAILURE_DELAY, } = config.getCurrent();\n        const { readyState, rebuffering, freezing, fullyLoaded } = observation;\n        const freezingPosition = observation.position.getPolled();\n        const bufferGap = normalizeBufferGap(observation.bufferGap);\n        /** If set to `true`, we consider playback \"frozen\" */\n        const isFrozen = freezing !== null ||\n            // When rebuffering, `freezing` might be not set as we're actively pausing\n            // playback. Yet, rebuffering occurences can also be abnormal, such as\n            // when enough buffer is constructed but with a low readyState (those are\n            // generally decryption issues).\n            (rebuffering !== null &&\n                readyState === 1 &&\n                (bufferGap >= MINIMUM_BUFFER_GAP_AT_READY_STATE_1_BEFORE_FREEZING ||\n                    fullyLoaded));\n        if (!isFrozen) {\n            this._decipherabilityFreezeStartingTimestamp = null;\n            return null;\n        }\n        const freezingTs = (_b = (_a = freezing === null || freezing === void 0 ? void 0 : freezing.timestamp) !== null && _a !== void 0 ? _a : rebuffering === null || rebuffering === void 0 ? void 0 : rebuffering.timestamp) !== null && _b !== void 0 ? _b : null;\n        log.info(\"FR: Freeze detected\", freezingTs, now - (freezingTs !== null && freezingTs !== void 0 ? freezingTs : now));\n        /**\n         * If `true`, we recently tried to \"flush\" to unstuck playback but playback\n         * is still stuck\n         */\n        const recentFlushAttemptFailed = this._lastFlushAttempt !== null &&\n            now - this._lastFlushAttempt.timestamp < FREEZING_FLUSH_FAILURE_DELAY.MAXIMUM &&\n            now - this._lastFlushAttempt.timestamp >= FREEZING_FLUSH_FAILURE_DELAY.MINIMUM &&\n            Math.abs(freezingPosition - this._lastFlushAttempt.position) <\n                FREEZING_FLUSH_FAILURE_DELAY.POSITION_DELTA;\n        if (recentFlushAttemptFailed) {\n            const secondUnfreezeStrat = this._getStrategyIfFlushingFails(freezingPosition);\n            this._decipherabilityFreezeStartingTimestamp = null;\n            this._ignoreFreezeUntil = now + MINIMUM_TIME_BETWEEN_FREEZE_HANDLING;\n            return secondUnfreezeStrat;\n        }\n        const decipherabilityFreezeStrat = this._checkForDecipherabilityRelatedFreeze(observation, now);\n        if (decipherabilityFreezeStrat !== null) {\n            return decipherabilityFreezeStrat;\n        }\n        if (freezingTs !== null && now - freezingTs > UNFREEZING_SEEK_DELAY) {\n            this._lastFlushAttempt = {\n                timestamp: now,\n                position: freezingPosition + UNFREEZING_DELTA_POSITION,\n            };\n            log.debug(\"FR: trying to flush to un-freeze\");\n            this._decipherabilityFreezeStartingTimestamp = null;\n            this._ignoreFreezeUntil = now + MINIMUM_TIME_BETWEEN_FREEZE_HANDLING;\n            return {\n                type: \"flush\",\n                value: { relativeSeek: UNFREEZING_DELTA_POSITION },\n            };\n        }\n        return null;\n    }\n    /**\n     * Performs decipherability-related checks if it makes sense.\n     *\n     * If decipherability-related checks have been performed **AND** an\n     * un-freezing strategy has been selected by this method, then return\n     * an object describing this wanted unfreezing strategy.\n     *\n     * If this method decides to take no action for now, it returns `null`.\n     * @param {Object} observation - playback observation that has just been\n     * performed.\n     * @param {number} now - Monotonically-raising timestamp for the current\n     * time.\n     * @returns {Object|null}\n     */\n    _checkForDecipherabilityRelatedFreeze(observation, now) {\n        const { readyState, rebuffering, freezing, fullyLoaded } = observation;\n        const bufferGap = normalizeBufferGap(observation.bufferGap);\n        const rebufferingForTooLong = rebuffering !== null && now - rebuffering.timestamp > FREEZING_FOR_TOO_LONG_DELAY;\n        const frozenForTooLong = freezing !== null && now - freezing.timestamp > FREEZING_FOR_TOO_LONG_DELAY;\n        const hasDecipherabilityFreezePotential = (rebufferingForTooLong || frozenForTooLong) &&\n            (bufferGap >= MINIMUM_BUFFER_GAP_AT_READY_STATE_1_BEFORE_FREEZING || fullyLoaded) &&\n            readyState <= 1;\n        if (!hasDecipherabilityFreezePotential) {\n            this._decipherabilityFreezeStartingTimestamp = null;\n        }\n        else if (this._decipherabilityFreezeStartingTimestamp === null) {\n            log.debug(\"FR: Start of a potential decipherability freeze detected\");\n            this._decipherabilityFreezeStartingTimestamp = now;\n        }\n        const shouldHandleDecipherabilityFreeze = this._decipherabilityFreezeStartingTimestamp !== null &&\n            getMonotonicTimeStamp() - this._decipherabilityFreezeStartingTimestamp >\n                FREEZING_FOR_TOO_LONG_DELAY;\n        let hasOnlyDecipherableSegments = true;\n        let isClear = true;\n        for (const ttype of [\"audio\", \"video\"]) {\n            const status = this._segmentSinksStore.getStatus(ttype);\n            if (status.type === \"initialized\") {\n                for (const segment of status.value.getLastKnownInventory()) {\n                    const { representation } = segment.infos;\n                    if (representation.decipherable === false) {\n                        log.warn(\"FR: we have undecipherable segments left in the buffer, reloading\");\n                        this._decipherabilityFreezeStartingTimestamp = null;\n                        this._ignoreFreezeUntil = now + MINIMUM_TIME_BETWEEN_FREEZE_HANDLING;\n                        return { type: \"reload\", value: null };\n                    }\n                    else if (representation.contentProtections !== undefined) {\n                        isClear = false;\n                        if (representation.decipherable !== true) {\n                            hasOnlyDecipherableSegments = false;\n                        }\n                    }\n                }\n            }\n        }\n        if (shouldHandleDecipherabilityFreeze && !isClear && hasOnlyDecipherableSegments) {\n            log.warn(\"FR: we are frozen despite only having decipherable \" +\n                \"segments left in the buffer, reloading\");\n            this._decipherabilityFreezeStartingTimestamp = null;\n            this._ignoreFreezeUntil = now + MINIMUM_TIME_BETWEEN_FREEZE_HANDLING;\n            return { type: \"reload\", value: null };\n        }\n        return null;\n    }\n    /**\n     * This method should only be called if a \"flush\" strategy has recently be\n     * taken to try to unfreeze playback yet playback is still frozen.\n     *\n     * It considers the current played content and returns a more-involved\n     * unfreezing strategy (most often reload-related) to try to unfree playback.\n     * @param {number} freezingPosition - The playback position at which we're\n     * currently frozen.\n     * @returns {Object}\n     */\n    _getStrategyIfFlushingFails(freezingPosition) {\n        log.warn(\"FR: A recent flush seemed to have no effect on freeze, checking for transitions\");\n        /** Contains Representation we might want to avoid after the following algorithm */\n        const toAvoid = [];\n        for (const ttype of [\"audio\", \"video\"]) {\n            const segmentList = this._lastSegmentInfo[ttype];\n            if (segmentList.length === 0) {\n                // There's no buffered segment for that type, go to next type\n                continue;\n            }\n            /** Played history information on the current segment we're stuck on. */\n            let currentSegmentEntry = segmentList[segmentList.length - 1];\n            if (currentSegmentEntry.segment === null) {\n                // No segment currently played for that given type, go to next type\n                continue;\n            }\n            /** Metadata on the segment currently being played. */\n            const currentSegment = currentSegmentEntry.segment;\n            /**\n             * Set to the first previous segment which is linked to a different\n             * Representation.\n             */\n            let previousRepresentationEntry;\n            // Now find `previousRepresentationEntry` and `currentSegmentEntry`.\n            for (let i = segmentList.length - 2; i >= 0; i--) {\n                const segment = segmentList[i];\n                if (segment.segment === null) {\n                    // Before the current segment, there was no segment being played\n                    previousRepresentationEntry = segment;\n                    break;\n                }\n                else if (segment.segment.infos.representation.uniqueId !==\n                    currentSegment.infos.representation.uniqueId &&\n                    currentSegmentEntry.timestamp - segment.timestamp < 5000) {\n                    // Before the current segment, there was a segment of a different\n                    // Representation being played\n                    previousRepresentationEntry = segment;\n                    break;\n                }\n                else if (segment.segment.start === currentSegment.start &&\n                    // Ignore history entry concerning the same segment more than 3\n                    // seconds of playback behind - we don't want to compare things\n                    // that happended too long ago.\n                    freezingPosition - segment.position < 3000) {\n                    // We're still playing the last segment at that point, update it.\n                    //\n                    // (We may be playing, or be freezing, on the current segment for some\n                    // time, this allows to consider a more precize timestamp at which we\n                    // switched segments).\n                    currentSegmentEntry = segment;\n                }\n            }\n            if (previousRepresentationEntry === undefined ||\n                previousRepresentationEntry.segment === null) {\n                log.debug(\"FR: Freeze when beginning to play a content, try avoiding this quality\");\n                toAvoid.push({\n                    adaptation: currentSegment.infos.adaptation,\n                    period: currentSegment.infos.period,\n                    representation: currentSegment.infos.representation,\n                });\n            }\n            else if (currentSegment.infos.period.id !==\n                previousRepresentationEntry.segment.infos.period.id) {\n                log.debug(\"FR: Freeze when switching Period, reloading\");\n                return { type: \"reload\", value: null };\n            }\n            else if (currentSegment.infos.representation.uniqueId !==\n                previousRepresentationEntry.segment.infos.representation.uniqueId) {\n                log.warn(\"FR: Freeze when switching Representation, avoiding\", currentSegment.infos.representation.bitrate);\n                toAvoid.push({\n                    adaptation: currentSegment.infos.adaptation,\n                    period: currentSegment.infos.period,\n                    representation: currentSegment.infos.representation,\n                });\n            }\n        }\n        if (toAvoid.length > 0) {\n            return { type: \"avoid-representations\", value: toAvoid };\n        }\n        else {\n            log.debug(\"FR: Reloading because flush doesn't work\");\n            return { type: \"reload\", value: null };\n        }\n    }\n    /**\n     * Add entry to `this._lastSegmentInfo` for the position that is currently\n     * played according to the given `observation`.\n     *\n     * @param {Object} observation\n     * @param {number} currentTimestamp\n     */\n    _addPositionToHistory(observation, currentTimestamp) {\n        var _a, _b;\n        const position = observation.position.getPolled();\n        for (const ttype of [\"audio\", \"video\"]) {\n            const status = this._segmentSinksStore.getStatus(ttype);\n            if (status.type === \"initialized\") {\n                for (const segment of status.value.getLastKnownInventory()) {\n                    if (((_a = segment.bufferedStart) !== null && _a !== void 0 ? _a : segment.start) <= position &&\n                        ((_b = segment.bufferedEnd) !== null && _b !== void 0 ? _b : segment.end) > position) {\n                        this._lastSegmentInfo[ttype].push({\n                            segment,\n                            position,\n                            timestamp: currentTimestamp,\n                        });\n                    }\n                }\n            }\n            else {\n                this._lastSegmentInfo[ttype].push({\n                    segment: null,\n                    position,\n                    timestamp: currentTimestamp,\n                });\n            }\n            if (this._lastSegmentInfo[ttype].length > 100) {\n                const toRemove = this._lastSegmentInfo[ttype].length - 100;\n                this._lastSegmentInfo[ttype].splice(0, toRemove);\n            }\n            const removalTs = currentTimestamp - MAXIMUM_SEGMENT_HISTORY_RETENTION_TIME;\n            let i;\n            for (i = 0; i < this._lastSegmentInfo[ttype].length; i++) {\n                if (this._lastSegmentInfo[ttype][i].timestamp > removalTs) {\n                    break;\n                }\n            }\n            if (i > 0) {\n                this._lastSegmentInfo[ttype].splice(0, i);\n            }\n        }\n    }\n}\n/**\n * Constructs a `bufferGap` value that is more usable than what the\n * `PlaybackObserver` returns:\n *   - it cannot be `undefined`\n *   - its weird `Infinity` value is translated to the more explicit `0`.\n * @param {number|undefined} bufferGap\n * @returns {number}\n */\nfunction normalizeBufferGap(bufferGap) {\n    return bufferGap !== undefined && isFinite(bufferGap) ? bufferGap : 0;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { MediaError } from \"../../../errors\";\nimport EventEmitter from \"../../../utils/event_emitter\";\nimport isNullOrUndefined from \"../../../utils/is_null_or_undefined\";\nimport SortedList from \"../../../utils/sorted_list\";\nimport TaskCanceller from \"../../../utils/task_canceller\";\n/**\n * Observes what's being played and take care of media events relating to time\n * boundaries:\n *   - Emits a `endingPositionChange` when the known maximum playable position\n *     of the current content is known and every time it changes.\n *   - Emits `endOfStream` API once segments have been pushed until the end and\n *     `resumeStream` if downloads starts back.\n *   - Emits a `periodChange` event when the currently-playing Period seemed to\n *     have changed.\n *   - emit \"warning\" events when what is being played is outside of the\n *     Manifest range.\n * @class ContentTimeBoundariesObserver\n */\nexport default class ContentTimeBoundariesObserver extends EventEmitter {\n    /**\n     * @param {Object} manifest\n     * @param {Object} playbackObserver\n     */\n    constructor(manifest, playbackObserver, bufferTypes) {\n        super();\n        this._canceller = new TaskCanceller();\n        this._manifest = manifest;\n        this._activeStreams = new Map();\n        this._allBufferTypes = bufferTypes;\n        this._lastCurrentPeriodId = null;\n        /**\n         * Allows to calculate the minimum and maximum playable position on the\n         * whole content.\n         */\n        const maximumPositionCalculator = new MaximumPositionCalculator(manifest);\n        this._maximumPositionCalculator = maximumPositionCalculator;\n        const cancelSignal = this._canceller.signal;\n        playbackObserver.listen(({ position }) => {\n            const wantedPosition = position.getWanted();\n            if (wantedPosition < manifest.getMinimumSafePosition()) {\n                const warning = new MediaError(\"MEDIA_TIME_BEFORE_MANIFEST\", \"The current position is behind the \" +\n                    \"earliest time announced in the Manifest.\");\n                this.trigger(\"warning\", warning);\n            }\n            else if (wantedPosition > maximumPositionCalculator.getMaximumAvailablePosition()) {\n                const warning = new MediaError(\"MEDIA_TIME_AFTER_MANIFEST\", \"The current position is after the latest \" +\n                    \"time announced in the Manifest.\");\n                this.trigger(\"warning\", warning);\n            }\n        }, { includeLastObservation: true, clearSignal: cancelSignal });\n        manifest.addEventListener(\"manifestUpdate\", () => {\n            this.trigger(\"endingPositionChange\", this._getManifestEndTime());\n            if (cancelSignal.isCancelled()) {\n                return;\n            }\n            this._checkEndOfStream();\n        }, cancelSignal);\n    }\n    /**\n     * Returns an estimate of the current last position which may be played in\n     * the content at the moment.\n     * @returns {Object}\n     */\n    getCurrentEndingTime() {\n        return this._getManifestEndTime();\n    }\n    /**\n     * Method to call any time an Adaptation has been selected.\n     *\n     * That Adaptation switch will be considered as active until the\n     * `onPeriodCleared` method has been called for the same `bufferType` and\n     * `Period`, or until `dispose` is called.\n     * @param {string} bufferType - The type of buffer concerned by the Adaptation\n     * switch\n     * @param {Object} period - The Period concerned by the Adaptation switch\n     * @param {Object|null} adaptation - The Adaptation selected. `null` if the\n     * absence of `Adaptation` has been explicitely selected for this Period and\n     * buffer type (e.g. no video).\n     */\n    onAdaptationChange(bufferType, period, adaptation) {\n        if (this._manifest.isLastPeriodKnown) {\n            const lastPeriod = this._manifest.periods[this._manifest.periods.length - 1];\n            if (period.id === (lastPeriod === null || lastPeriod === void 0 ? void 0 : lastPeriod.id)) {\n                if (bufferType === \"audio\" || bufferType === \"video\") {\n                    if (bufferType === \"audio\") {\n                        this._maximumPositionCalculator.updateLastAudioAdaptation(adaptation);\n                    }\n                    else {\n                        this._maximumPositionCalculator.updateLastVideoAdaptation(adaptation);\n                    }\n                    const endingPosition = this._maximumPositionCalculator.getEndingPosition();\n                    const newEndingPosition = endingPosition !== undefined\n                        ? { isEnd: true, endingPosition }\n                        : {\n                            isEnd: false,\n                            endingPosition: this._maximumPositionCalculator.getMaximumAvailablePosition(),\n                        };\n                    this.trigger(\"endingPositionChange\", newEndingPosition);\n                }\n            }\n        }\n        if (this._canceller.isUsed()) {\n            return;\n        }\n        if (adaptation === null) {\n            this._addActivelyLoadedPeriod(period, bufferType);\n        }\n    }\n    /**\n     * Method to call any time a Representation has been selected.\n     *\n     * That Representation switch will be considered as active until the\n     * `onPeriodCleared` method has been called for the same `bufferType` and\n     * `Period`, or until `dispose` is called.\n     * @param {string} bufferType - The type of buffer concerned by the\n     * Representation switch\n     * @param {Object} period - The Period concerned by the Representation switch\n     */\n    onRepresentationChange(bufferType, period) {\n        this._addActivelyLoadedPeriod(period, bufferType);\n    }\n    /**\n     * Method to call any time a Period and type combination is not considered\n     * anymore.\n     *\n     * Calling this method allows to signal that a previous Adaptation and/or\n     * Representation change respectively indicated by an `onAdaptationChange` and\n     * an `onRepresentationChange` call, are not active anymore.\n     * @param {string} bufferType - The type of buffer concerned\n     * @param {Object} period - The Period concerned\n     */\n    onPeriodCleared(bufferType, period) {\n        this._removeActivelyLoadedPeriod(period, bufferType);\n    }\n    /**\n     * Method to call when the last chronological segment for a given buffer type\n     * is known to have been loaded and is either pushed or in the process of\n     * being pushed to the corresponding MSE `SourceBuffer` or equivalent.\n     *\n     * This method can even be called multiple times in a row as long as the\n     * aforementioned condition is true, if it simplify your code's management.\n     * @param {string} bufferType\n     */\n    onLastSegmentFinishedLoading(bufferType) {\n        const streamInfo = this._lazilyCreateActiveStreamInfo(bufferType);\n        if (!streamInfo.hasFinishedLoadingLastPeriod) {\n            streamInfo.hasFinishedLoadingLastPeriod = true;\n            this._checkEndOfStream();\n        }\n    }\n    /**\n     * Method to call to \"cancel\" a previous call to\n     * `onLastSegmentFinishedLoading`.\n     *\n     * That is, calling this method indicates that the last chronological segment\n     * of a given buffer type is now either not loaded or it is not known.\n     *\n     * This method can even be called multiple times in a row as long as the\n     * aforementioned condition is true, if it simplify your code's management.\n     * @param {string} bufferType\n     */\n    onLastSegmentLoadingResume(bufferType) {\n        const streamInfo = this._lazilyCreateActiveStreamInfo(bufferType);\n        if (streamInfo.hasFinishedLoadingLastPeriod) {\n            streamInfo.hasFinishedLoadingLastPeriod = false;\n            this._checkEndOfStream();\n        }\n    }\n    /**\n     * Free all resources used by the `ContentTimeBoundariesObserver` and cancels\n     * all recurring processes it performs.\n     */\n    dispose() {\n        this.removeEventListener();\n        this._canceller.cancel();\n    }\n    _addActivelyLoadedPeriod(period, bufferType) {\n        const streamInfo = this._lazilyCreateActiveStreamInfo(bufferType);\n        if (!streamInfo.activePeriods.has(period)) {\n            streamInfo.activePeriods.add(period);\n            this._checkCurrentPeriod();\n        }\n    }\n    _removeActivelyLoadedPeriod(period, bufferType) {\n        const streamInfo = this._activeStreams.get(bufferType);\n        if (streamInfo === undefined) {\n            return;\n        }\n        if (streamInfo.activePeriods.has(period)) {\n            streamInfo.activePeriods.removeElement(period);\n            this._checkCurrentPeriod();\n        }\n    }\n    _checkCurrentPeriod() {\n        if (this._allBufferTypes.length === 0) {\n            return;\n        }\n        const streamInfo = this._activeStreams.get(this._allBufferTypes[0]);\n        if (streamInfo === undefined) {\n            return;\n        }\n        for (const period of streamInfo.activePeriods.toArray()) {\n            let wasFoundInAllTypes = true;\n            for (const bufferType of this._allBufferTypes) {\n                const streamInfo2 = this._activeStreams.get(bufferType);\n                if (streamInfo2 === undefined) {\n                    return;\n                }\n                const activePeriods = streamInfo2.activePeriods.toArray();\n                const hasPeriod = activePeriods.some((p) => p.id === period.id);\n                if (!hasPeriod) {\n                    wasFoundInAllTypes = false;\n                    break;\n                }\n            }\n            if (wasFoundInAllTypes) {\n                if (this._lastCurrentPeriodId !== period.id) {\n                    this._lastCurrentPeriodId = period.id;\n                    this.trigger(\"periodChange\", period);\n                }\n                return;\n            }\n        }\n    }\n    _getManifestEndTime() {\n        const endingPosition = this._maximumPositionCalculator.getEndingPosition();\n        return endingPosition !== undefined\n            ? { isEnd: true, endingPosition }\n            : {\n                isEnd: false,\n                endingPosition: this._maximumPositionCalculator.getMaximumAvailablePosition(),\n            };\n    }\n    _lazilyCreateActiveStreamInfo(bufferType) {\n        let streamInfo = this._activeStreams.get(bufferType);\n        if (streamInfo === undefined) {\n            streamInfo = {\n                activePeriods: new SortedList((a, b) => a.start - b.start),\n                hasFinishedLoadingLastPeriod: false,\n            };\n            this._activeStreams.set(bufferType, streamInfo);\n        }\n        return streamInfo;\n    }\n    _checkEndOfStream() {\n        if (!this._manifest.isLastPeriodKnown) {\n            return;\n        }\n        const everyBufferTypeLoaded = this._allBufferTypes.every((bt) => {\n            const streamInfo = this._activeStreams.get(bt);\n            return streamInfo !== undefined && streamInfo.hasFinishedLoadingLastPeriod;\n        });\n        if (everyBufferTypeLoaded) {\n            this.trigger(\"endOfStream\", null);\n        }\n        else {\n            this.trigger(\"resumeStream\", null);\n        }\n    }\n}\n/**\n * Calculate the last position from the last chosen audio and video Adaptations\n * for the last Period (or a default one, if no Adaptations has been chosen).\n * @class MaximumPositionCalculator\n */\nclass MaximumPositionCalculator {\n    /**\n     * @param {Object} manifest\n     */\n    constructor(manifest) {\n        this._manifest = manifest;\n        this._lastAudioAdaptation = undefined;\n        this._lastVideoAdaptation = undefined;\n    }\n    /**\n     * Update the last known audio Adaptation for the last Period.\n     * If no Adaptation has been set, it should be set to `null`.\n     *\n     * Allows to calculate the maximum position more precizely in\n     * `getMaximumAvailablePosition` and `getEndingPosition`.\n     * @param {Object|null} adaptation\n     */\n    updateLastAudioAdaptation(adaptation) {\n        this._lastAudioAdaptation = adaptation;\n    }\n    /**\n     * Update the last known video Adaptation for the last Period.\n     * If no Adaptation has been set, it should be set to `null`.\n     *\n     * Allows to calculate the maximum position more precizely in\n     * `getMaximumAvailablePosition` and `getEndingPosition`.\n     * @param {Object|null} adaptation\n     */\n    updateLastVideoAdaptation(adaptation) {\n        this._lastVideoAdaptation = adaptation;\n    }\n    /**\n     * Returns an estimate of the maximum position currently reachable (i.e.\n     * segments are available) under the current circumstances.\n     * @returns {number}\n     */\n    getMaximumAvailablePosition() {\n        if (this._manifest.isDynamic) {\n            return this._manifest.getMaximumSafePosition();\n        }\n        if (this._lastVideoAdaptation === undefined ||\n            this._lastAudioAdaptation === undefined) {\n            return this._manifest.getMaximumSafePosition();\n        }\n        else if (this._lastAudioAdaptation === null) {\n            if (this._lastVideoAdaptation === null) {\n                return this._manifest.getMaximumSafePosition();\n            }\n            else {\n                const lastVideoPosition = getLastAvailablePositionFromAdaptation(this._lastVideoAdaptation);\n                if (typeof lastVideoPosition !== \"number\") {\n                    return this._manifest.getMaximumSafePosition();\n                }\n                return lastVideoPosition;\n            }\n        }\n        else if (this._lastVideoAdaptation === null) {\n            const lastAudioPosition = getLastAvailablePositionFromAdaptation(this._lastAudioAdaptation);\n            if (typeof lastAudioPosition !== \"number\") {\n                return this._manifest.getMaximumSafePosition();\n            }\n            return lastAudioPosition;\n        }\n        else {\n            const lastAudioPosition = getLastAvailablePositionFromAdaptation(this._lastAudioAdaptation);\n            const lastVideoPosition = getLastAvailablePositionFromAdaptation(this._lastVideoAdaptation);\n            if (typeof lastAudioPosition !== \"number\" ||\n                typeof lastVideoPosition !== \"number\") {\n                return this._manifest.getMaximumSafePosition();\n            }\n            else {\n                return Math.min(lastAudioPosition, lastVideoPosition);\n            }\n        }\n    }\n    /**\n     * Returns an estimate of the actual ending position once\n     * the full content is available.\n     * Returns `undefined` if that could not be determined, for various reasons.\n     * @returns {number|undefined}\n     */\n    getEndingPosition() {\n        var _a, _b;\n        if (!this._manifest.isDynamic) {\n            return this.getMaximumAvailablePosition();\n        }\n        if (this._lastVideoAdaptation === undefined ||\n            this._lastAudioAdaptation === undefined) {\n            return undefined;\n        }\n        else if (this._lastAudioAdaptation === null) {\n            if (this._lastVideoAdaptation === null) {\n                return undefined;\n            }\n            else {\n                return (_a = getEndingPositionFromAdaptation(this._lastVideoAdaptation)) !== null && _a !== void 0 ? _a : undefined;\n            }\n        }\n        else if (this._lastVideoAdaptation === null) {\n            return (_b = getEndingPositionFromAdaptation(this._lastAudioAdaptation)) !== null && _b !== void 0 ? _b : undefined;\n        }\n        else {\n            const lastAudioPosition = getEndingPositionFromAdaptation(this._lastAudioAdaptation);\n            const lastVideoPosition = getEndingPositionFromAdaptation(this._lastVideoAdaptation);\n            if (typeof lastAudioPosition !== \"number\" ||\n                typeof lastVideoPosition !== \"number\") {\n                return undefined;\n            }\n            else {\n                return Math.min(lastAudioPosition, lastVideoPosition);\n            }\n        }\n    }\n}\n/**\n * Returns last currently available position from the Adaptation given.\n * `undefined` if a time could not be found.\n * `null` if the Adaptation has no segments (it could be that it didn't started or\n * that it already finished for example).\n *\n * We consider the earliest last available position from every Representation\n * in the given Adaptation.\n * @param {Object} adaptation\n * @returns {Number|undefined|null}\n */\nfunction getLastAvailablePositionFromAdaptation(adaptation) {\n    const { representations } = adaptation;\n    let min = null;\n    /**\n     * Some Manifest parsers use the exact same `IRepresentationIndex` reference\n     * for each Representation of a given Adaptation, because in the actual source\n     * Manifest file, indexing data is often defined at Adaptation-level.\n     * This variable allows to optimize the logic here when this is the case.\n     */\n    let lastIndex;\n    for (const representation of representations) {\n        if (representation.index !== lastIndex) {\n            lastIndex = representation.index;\n            const lastPosition = representation.index.getLastAvailablePosition();\n            if (lastPosition === undefined) {\n                // we cannot tell\n                return undefined;\n            }\n            if (lastPosition !== null) {\n                min = isNullOrUndefined(min) ? lastPosition : Math.min(min, lastPosition);\n            }\n        }\n    }\n    return min;\n}\n/**\n * Returns ending time from the Adaptation given, once all its segments are\n * available.\n * `undefined` if a time could not be found.\n * `null` if the Adaptation has no segments (it could be that it already\n * finished for example).\n *\n * We consider the earliest ending time from every Representation in the given\n * Adaptation.\n * @param {Object} adaptation\n * @returns {Number|undefined|null}\n */\nfunction getEndingPositionFromAdaptation(adaptation) {\n    const { representations } = adaptation;\n    let min = null;\n    /**\n     * Some Manifest parsers use the exact same `IRepresentationIndex` reference\n     * for each Representation of a given Adaptation, because in the actual source\n     * Manifest file, indexing data is often defined at Adaptation-level.\n     * This variable allows to optimize the logic here when this is the case.\n     */\n    let lastIndex;\n    for (const representation of representations) {\n        if (representation.index !== lastIndex) {\n            lastIndex = representation.index;\n            const lastPosition = representation.index.getEnd();\n            if (lastPosition === undefined) {\n                // we cannot tell\n                return undefined;\n            }\n            if (lastPosition !== null) {\n                min = isNullOrUndefined(min) ? lastPosition : Math.min(min, lastPosition);\n            }\n        }\n    }\n    return min;\n}\n","import log from \"../../../log\";\nimport ContentTimeBoundariesObserver from \"./content_time_boundaries_observer\";\n/**\n * Creates a `ContentTimeBoundariesObserver`, a class indicating various\n * events related to media time (such as duration updates, period changes,\n * warnings about being out of the Manifest time boundaries or \"endOfStream\"\n * management), handle those events and returns the class.\n *\n * Various methods from that class need then to be called at various events\n * (see `ContentTimeBoundariesObserver`).\n * @param {Object} manifest\n * @param {Object} mediaSource\n * @param {Object} streamObserver\n * @param {Object} segmentSinksStore\n * @param {Object} cancelSignal\n * @returns {Object}\n */\nexport default function createContentTimeBoundariesObserver(manifest, mediaSource, streamObserver, segmentSinksStore, callbacks, cancelSignal) {\n    cancelSignal.register(() => {\n        mediaSource.interruptDurationSetting();\n    });\n    const contentTimeBoundariesObserver = new ContentTimeBoundariesObserver(manifest, streamObserver, segmentSinksStore.getBufferTypes());\n    cancelSignal.register(() => {\n        contentTimeBoundariesObserver.dispose();\n    });\n    contentTimeBoundariesObserver.addEventListener(\"warning\", (err) => callbacks.onWarning(err));\n    contentTimeBoundariesObserver.addEventListener(\"periodChange\", (period) => callbacks.onPeriodChanged(period));\n    contentTimeBoundariesObserver.addEventListener(\"endingPositionChange\", (evt) => {\n        mediaSource.setDuration(evt.endingPosition, evt.isEnd);\n    });\n    contentTimeBoundariesObserver.addEventListener(\"endOfStream\", () => {\n        log.debug(\"Init: end-of-stream order received.\");\n        mediaSource.maintainEndOfStream();\n    });\n    contentTimeBoundariesObserver.addEventListener(\"resumeStream\", () => {\n        mediaSource.stopEndOfStream();\n    });\n    const obj = contentTimeBoundariesObserver.getCurrentEndingTime();\n    mediaSource.setDuration(obj.endingPosition, obj.isEnd);\n    return contentTimeBoundariesObserver;\n}\n","import arrayFind from \"../../../utils/array_find\";\n/**\n * Returns a JS object where keys are the type of buffers (e.g. \"audio\",\n * \"video\", \"text\") and values are the corresponding range of buffered\n * data according to the given `IMediaSourceInterface` (or `null` if not\n * known / nothing is buffered).\n * @param {Object|null} mediaSourceInterface\n * @param {Object|null} textDisplayer\n * @returns {Object}\n */\nexport default function getBufferedDataPerMediaBuffer(mediaSourceInterface, textDisplayer) {\n    const buffered = {\n        audio: null,\n        video: null,\n        text: null,\n    };\n    if (textDisplayer !== null) {\n        buffered.text = textDisplayer.getBufferedRanges();\n    }\n    if (mediaSourceInterface === null) {\n        return buffered;\n    }\n    const audioBuffer = arrayFind(mediaSourceInterface.sourceBuffers, (s) => s.type === \"audio\" /* SourceBufferType.Audio */);\n    const videoBuffer = arrayFind(mediaSourceInterface.sourceBuffers, (s) => s.type === \"video\" /* SourceBufferType.Video */);\n    const audioBuffered = audioBuffer === null || audioBuffer === void 0 ? void 0 : audioBuffer.getBuffered();\n    if (audioBuffered !== undefined) {\n        buffered.audio = audioBuffered;\n    }\n    const videoBuffered = videoBuffer === null || videoBuffer === void 0 ? void 0 : videoBuffer.getBuffered();\n    if (videoBuffered !== undefined) {\n        buffered.video = videoBuffered;\n    }\n    return buffered;\n}\n","import arrayFind from \"../../../utils/array_find\";\nimport TaskCanceller from \"../../../utils/task_canceller\";\nimport { getThumbnailFetcherRequestOptions } from \"../../fetchers\";\n/**\n * @param {function} fetchThumbnails\n * @param {Object} manifest\n * @param {string} periodId\n * @param {string} thumbnailTrackId\n * @param {number} time\n * @returns {Promise.<Object>}\n */\nexport default async function getThumbnailData(fetchThumbnails, manifest, periodId, thumbnailTrackId, time) {\n    const period = manifest.getPeriod(periodId);\n    if (period === undefined) {\n        throw new Error(\"Wanted Period not found.\");\n    }\n    const thumbnailTrack = arrayFind(period.thumbnailTracks, (t) => {\n        return t.id === thumbnailTrackId;\n    });\n    if (thumbnailTrack === undefined) {\n        throw new Error(\"Wanted Period has no thumbnail track.\");\n    }\n    const wantedThumbnail = thumbnailTrack.index.getSegments(time, 1)[0];\n    if (wantedThumbnail === undefined) {\n        throw new Error(\"No thumbnail for the given timestamp\");\n    }\n    return fetchThumbnails(wantedThumbnail, thumbnailTrack, getThumbnailFetcherRequestOptions({}), new TaskCanceller().signal);\n}\n","/**\n * Synchronize SegmentSinks with what has been buffered.\n * @param {Object} observation - The just-received playback observation,\n * including what has been buffered on lower-level buffers\n * @param {Object} segmentSinksStore - Interface allowing to interact\n * with `SegmentSink`s, so their inventory can be updated accordingly.\n */\nexport default function synchronizeSegmentSinksOnObservation(observation, segmentSinksStore) {\n    // Synchronize SegmentSinks with what has been buffered.\n    [\"video\", \"audio\", \"text\"].forEach((tType) => {\n        var _a;\n        const segmentSinkStatus = segmentSinksStore.getStatus(tType);\n        if (segmentSinkStatus.type === \"initialized\") {\n            segmentSinkStatus.value.synchronizeInventory((_a = observation.buffered[tType]) !== null && _a !== void 0 ? _a : []);\n        }\n    });\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../log\";\nimport isNullOrUndefined from \"../../utils/is_null_or_undefined\";\nimport { getInnerAndOuterRanges } from \"../../utils/ranges\";\nimport TaskCanceller from \"../../utils/task_canceller\";\n/**\n * Perform cleaning of the buffer according to the values set by the user\n * each time `playbackObserver` emits and each times the\n * maxBufferBehind/maxBufferAhead values change.\n *\n * Abort this operation when the `cancellationSignal` emits.\n *\n * @param {Object} opt\n * @param {Object} cancellationSignal\n *\n * TODO Move to main thread?\n */\nexport default function BufferGarbageCollector({ segmentSink, playbackObserver, maxBufferBehind, maxBufferAhead, }, cancellationSignal) {\n    let lastPosition;\n    let lastBuffered = [];\n    playbackObserver.listen((o) => {\n        lastPosition = o.position.getWanted();\n        lastBuffered = o.buffered[segmentSink.bufferType];\n        clean();\n    }, { includeLastObservation: true, clearSignal: cancellationSignal });\n    function clean() {\n        if (lastBuffered === null) {\n            return;\n        }\n        clearBuffer(segmentSink, lastPosition, lastBuffered, maxBufferBehind.getValue(), maxBufferAhead.getValue(), cancellationSignal).catch((e) => {\n            if (cancellationSignal.isCancelled() && TaskCanceller.isCancellationError(e)) {\n                return;\n            }\n            const errMsg = e instanceof Error ? e.message : \"Unknown error\";\n            log.error(\"Could not run BufferGarbageCollector:\", errMsg);\n        });\n    }\n    maxBufferBehind.onUpdate(clean, { clearSignal: cancellationSignal });\n    maxBufferAhead.onUpdate(clean, { clearSignal: cancellationSignal });\n    clean();\n}\n/**\n * Remove buffer from the browser's memory based on the user's\n * maxBufferAhead / maxBufferBehind settings.\n *\n * Normally, the browser garbage-collect automatically old-added chunks of\n * buffer data when memory is scarce. However, you might want to control\n * the size of memory allocated. This function takes the current position\n * and a \"depth\" behind and ahead wanted for the buffer, in seconds.\n *\n * Anything older than the depth will be removed from the buffer.\n * @param {Object} segmentSink\n * @param {Number} position - The current position\n * @param {Array.<Object>} buffered\n * @param {Number} maxBufferBehind\n * @param {Number} maxBufferAhead\n * @param {Object} cancellationSignal\n * @returns {Promise}\n */\nasync function clearBuffer(segmentSink, position, buffered, maxBufferBehind, maxBufferAhead, cancellationSignal) {\n    if (!isFinite(maxBufferBehind) && !isFinite(maxBufferAhead)) {\n        return Promise.resolve();\n    }\n    const cleanedupRanges = [];\n    const { innerRange, outerRanges } = getInnerAndOuterRanges(buffered, position);\n    const collectBufferBehind = () => {\n        if (!isFinite(maxBufferBehind)) {\n            return;\n        }\n        // begin from the oldest\n        for (const outerRange of outerRanges) {\n            if (position - maxBufferBehind >= outerRange.end) {\n                cleanedupRanges.push(outerRange);\n            }\n            else if (position >= outerRange.end &&\n                position - maxBufferBehind > outerRange.start &&\n                position - maxBufferBehind < outerRange.end) {\n                cleanedupRanges.push({\n                    start: outerRange.start,\n                    end: position - maxBufferBehind,\n                });\n            }\n        }\n        if (!isNullOrUndefined(innerRange)) {\n            if (position - maxBufferBehind > innerRange.start) {\n                cleanedupRanges.push({\n                    start: innerRange.start,\n                    end: position - maxBufferBehind,\n                });\n            }\n        }\n    };\n    const collectBufferAhead = () => {\n        if (!isFinite(maxBufferAhead)) {\n            return;\n        }\n        // begin from the oldest\n        for (const outerRange of outerRanges) {\n            if (position + maxBufferAhead <= outerRange.start) {\n                cleanedupRanges.push(outerRange);\n            }\n            else if (position <= outerRange.start &&\n                position + maxBufferAhead < outerRange.end &&\n                position + maxBufferAhead > outerRange.start) {\n                cleanedupRanges.push({\n                    start: position + maxBufferAhead,\n                    end: outerRange.end,\n                });\n            }\n        }\n        if (!isNullOrUndefined(innerRange)) {\n            if (position + maxBufferAhead < innerRange.end) {\n                cleanedupRanges.push({\n                    start: position + maxBufferAhead,\n                    end: innerRange.end,\n                });\n            }\n        }\n    };\n    collectBufferBehind();\n    collectBufferAhead();\n    for (const range of cleanedupRanges) {\n        if (range.start < range.end) {\n            log.debug(\"GC: cleaning range from SegmentSink\", range.start, range.end);\n            if (cancellationSignal.cancellationError !== null) {\n                throw cancellationSignal.cancellationError;\n            }\n            await segmentSink.removeBuffer(range.start, range.end);\n        }\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../../../log\";\nimport { getLoggableSegmentId } from \"../../../../manifest\";\nimport getMonotonicTimeStamp from \"../../../../utils/monotonic_timestamp\";\nimport { SegmentSink, SegmentSinkOperation } from \"../types\";\n/**\n * Allows to push and remove new segments to a SourceBuffer while keeping an\n * inventory of what has been pushed and what is being pushed.\n *\n * To work correctly, only a single AudioVideoSegmentSink per SourceBuffer\n * should be created.\n *\n * @class AudioVideoSegmentSink\n */\nexport default class AudioVideoSegmentSink extends SegmentSink {\n    /**\n     * @constructor\n     * @param {string} bufferType\n     * @param {string} codec\n     * @param {Object} mediaSource\n     */\n    constructor(bufferType, codec, mediaSource) {\n        super();\n        log.info(\"AVSB: calling `mediaSource.addSourceBuffer`\", codec);\n        const sourceBuffer = mediaSource.addSourceBuffer(bufferType, codec);\n        this.bufferType = bufferType;\n        this._sourceBuffer = sourceBuffer;\n        this._lastInitSegmentUniqueId = null;\n        this.codec = codec;\n        this._initSegmentsMap = new Map();\n        this._pendingOperations = [];\n    }\n    /** @see SegmentSink */\n    declareInitSegment(uniqueId, initSegmentData) {\n        assertDataIsBufferSource(initSegmentData);\n        this._initSegmentsMap.set(uniqueId, initSegmentData);\n    }\n    /** @see SegmentSink */\n    freeInitSegment(uniqueId) {\n        this._initSegmentsMap.delete(uniqueId);\n    }\n    /**\n     * Push a chunk of the media segment given to the attached SourceBuffer.\n     *\n     * Once all chunks of a single Segment have been given to `pushChunk`, you\n     * should call `signalSegmentComplete` to indicate that the whole Segment has\n     * been pushed.\n     *\n     * Depending on the type of data appended, the pushed chunk might rely on an\n     * initialization segment, given through the `data.initSegment` property.\n     *\n     * Such initialization segment will be first pushed to the SourceBuffer if the\n     * last pushed segment was associated to another initialization segment.\n     * This detection rely on the initialization segment's reference so you need\n     * to avoid mutating in-place a initialization segment given to that function\n     * (to avoid having two different values which have the same reference).\n     *\n     * If you don't need any initialization segment to push the wanted chunk, you\n     * can just set `data.initSegment` to `null`.\n     *\n     * You can also only push an initialization segment by setting the\n     * `data.chunk` argument to null.\n     *\n     * @param {Object} infos\n     * @returns {Promise}\n     */\n    async pushChunk(infos) {\n        assertDataIsBufferSource(infos.data.chunk);\n        log.debug(\"AVSB: receiving order to push data to the SourceBuffer\", this.bufferType, getLoggableSegmentId(infos.inventoryInfos));\n        const dataToPush = this._getActualDataToPush(infos.data);\n        if (dataToPush.length === 0) {\n            // TODO\n            // For now the following code rely on the fact that there should be at\n            // least one element to push (else, we won't make the round-trip to\n            // be able to signal updated ranges).\n            //\n            // For cases where this isn't the case (e.g. when pushing an\n            // initialization segment which was already the last one pushed), we\n            // perform a trick by just pushing an empty segment instead.\n            // That seems to work on all platforms even if it is a little ugly.\n            //\n            // To provide a better solution we could either handle initialization\n            // segment references on a `SourceBufferInterface` - which has access to\n            // the buffered ranges - or just create a new `SourceBufferInterface`\n            // method to specifically obtain the current buffered range, which we\n            // would call instead here. For now, I'm more of a fan of the former\n            // solution.\n            dataToPush.push(new Uint8Array());\n        }\n        const promise = Promise.all(dataToPush.map((data) => {\n            const { codec, timestampOffset, appendWindow } = infos.data;\n            log.debug(\"AVSB: pushing segment\", this.bufferType, getLoggableSegmentId(infos.inventoryInfos));\n            return this._sourceBuffer.appendBuffer(data, {\n                codec,\n                timestampOffset,\n                appendWindow,\n            });\n        }));\n        this._addToOperationQueue(promise, {\n            type: SegmentSinkOperation.Push,\n            value: infos,\n        });\n        let res;\n        try {\n            res = await promise;\n        }\n        catch (err) {\n            this._segmentInventory.insertChunk(infos.inventoryInfos, false, getMonotonicTimeStamp());\n            throw err;\n        }\n        if (infos.inventoryInfos !== null) {\n            this._segmentInventory.insertChunk(infos.inventoryInfos, true, getMonotonicTimeStamp());\n        }\n        const ranges = res[res.length - 1];\n        this._segmentInventory.synchronizeBuffered(ranges);\n        return ranges;\n    }\n    /** @see SegmentSink */\n    async removeBuffer(start, end) {\n        log.debug(\"AVSB: receiving order to remove data from the SourceBuffer\", this.bufferType, start, end);\n        const promise = this._sourceBuffer.remove(start, end);\n        this._addToOperationQueue(promise, {\n            type: SegmentSinkOperation.Remove,\n            value: { start, end },\n        });\n        const ranges = await promise;\n        this._segmentInventory.synchronizeBuffered(ranges);\n        return ranges;\n    }\n    /**\n     * Indicate that every chunks from a Segment has been given to pushChunk so\n     * far.\n     * This will update our internal Segment inventory accordingly.\n     * The returned Promise will resolve once the whole segment has been pushed\n     * and this indication is acknowledged.\n     * @param {Object} infos\n     * @returns {Promise}\n     */\n    async signalSegmentComplete(infos) {\n        if (this._pendingOperations.length > 0) {\n            // Only validate after preceding operation\n            const { promise } = this._pendingOperations[this._pendingOperations.length - 1];\n            this._addToOperationQueue(promise, {\n                type: SegmentSinkOperation.SignalSegmentComplete,\n                value: infos,\n            });\n            try {\n                await promise;\n            }\n            catch (_) {\n                // We don't really care of what happens of the preceding operation here\n            }\n        }\n        this._segmentInventory.completeSegment(infos);\n    }\n    /**\n     * Returns the list of every operations that the `AudioVideoSegmentSink` is\n     * still processing.\n     * @returns {Array.<Object>}\n     */\n    getPendingOperations() {\n        return this._pendingOperations.map((p) => p.operation);\n    }\n    /** @see SegmentSink */\n    dispose() {\n        try {\n            log.debug(\"AVSB: Calling `dispose` on the SourceBufferInterface\");\n            this._sourceBuffer.dispose();\n        }\n        catch (e) {\n            log.debug(`AVSB: Failed to dispose a ${this.bufferType} SourceBufferInterface:`, e instanceof Error ? e : \"\");\n        }\n    }\n    /**\n     * A single `pushChunk` might actually necessitate two `appendBuffer` call\n     * if the initialization segment needs to be pushed again.\n     *\n     * This method perform this check and actually return both the\n     * initialization segment then the media segment when the former needs to\n     * be pushed again first.\n     * @param {Object} data\n     * @returns {Object}\n     */\n    _getActualDataToPush(data) {\n        // Push operation with both an init segment and a regular segment might\n        // need to be separated into two steps\n        const dataToPush = [];\n        if (data.initSegmentUniqueId !== null &&\n            !this._isLastInitSegment(data.initSegmentUniqueId)) {\n            // Push initialization segment before the media segment\n            let segmentData = this._initSegmentsMap.get(data.initSegmentUniqueId);\n            if (segmentData === undefined) {\n                throw new Error(\"Invalid initialization segment uniqueId\");\n            }\n            // Initialization segments have to be cloned for now\n            // TODO Initialization segments could be stored on the main thread?\n            const dst = new ArrayBuffer(segmentData.byteLength);\n            const tmpU8 = new Uint8Array(dst);\n            tmpU8.set(segmentData instanceof ArrayBuffer\n                ? new Uint8Array(segmentData)\n                : new Uint8Array(segmentData.buffer));\n            segmentData = tmpU8;\n            dataToPush.push(segmentData);\n            this._lastInitSegmentUniqueId = data.initSegmentUniqueId;\n        }\n        if (data.chunk !== null) {\n            dataToPush.push(data.chunk);\n        }\n        return dataToPush;\n    }\n    /**\n     * Return `true` if the given `uniqueId` is the identifier of the last\n     * initialization segment pushed to the `AudioVideoSegmentSink`.\n     * @param {string} uniqueId\n     * @returns {boolean}\n     */\n    _isLastInitSegment(uniqueId) {\n        if (this._lastInitSegmentUniqueId === null) {\n            return false;\n        }\n        return this._lastInitSegmentUniqueId === uniqueId;\n    }\n    _addToOperationQueue(promise, operation) {\n        const queueObject = { operation, promise };\n        this._pendingOperations.push(queueObject);\n        const endOperation = () => {\n            const indexOf = this._pendingOperations.indexOf(queueObject);\n            if (indexOf >= 0) {\n                this._pendingOperations.splice(indexOf, 1);\n            }\n        };\n        promise.then(endOperation, endOperation); // `finally` not supported everywhere\n    }\n}\n/**\n * Throw if the given input is not in the expected format.\n * Allows to enforce runtime type-checking as compile-time type-checking here is\n * difficult to enforce.\n * @param {Object} data\n */\nfunction assertDataIsBufferSource(data) {\n    if (0 /* __ENVIRONMENT__.CURRENT_ENV */ === 0 /* __ENVIRONMENT__.PRODUCTION */) {\n        return;\n    }\n    if (typeof data !== \"object\" ||\n        (data !== null &&\n            !(data instanceof ArrayBuffer) &&\n            !(data.buffer instanceof ArrayBuffer))) {\n        throw new Error(\"Invalid data given to the AudioVideoSegmentSink\");\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport AudioVideoSegmentSink from \"./audio_video_segment_sink\";\nexport default AudioVideoSegmentSink;\n","import TextSegmentSink from \"./text_segment_sink\";\nexport default TextSegmentSink;\n","import log from \"../../../../log\";\nimport getMonotonicTimeStamp from \"../../../../utils/monotonic_timestamp\";\nimport { SegmentSink, SegmentSinkOperation } from \"../types\";\n/**\n * SegmentSink implementation to add text data, most likely subtitles.\n * @class TextSegmentSink\n */\nexport default class TextSegmentSink extends SegmentSink {\n    /**\n     * @param {Object} textDisplayerSender\n     */\n    constructor(textDisplayerSender) {\n        log.debug(\"HTSB: Creating TextSegmentSink\");\n        super();\n        this.bufferType = \"text\";\n        this._sender = textDisplayerSender;\n        this._pendingOperations = [];\n        this._sender.reset();\n    }\n    /**\n     * @param {string} uniqueId\n     */\n    declareInitSegment(uniqueId) {\n        log.warn(\"HTSB: Declaring initialization segment for  Text SegmentSink\", uniqueId);\n    }\n    /**\n     * @param {string} uniqueId\n     */\n    freeInitSegment(uniqueId) {\n        log.warn(\"HTSB: Freeing initialization segment for  Text SegmentSink\", uniqueId);\n    }\n    /**\n     * Push text segment to the TextSegmentSink.\n     * @param {Object} infos\n     * @returns {Promise}\n     */\n    async pushChunk(infos) {\n        const { data } = infos;\n        assertChunkIsTextTrackSegmentData(data.chunk);\n        // Needed for TypeScript :(\n        const promise = this._sender.pushTextData(Object.assign(Object.assign({}, data), { chunk: data.chunk }));\n        this._addToOperationQueue(promise, {\n            type: SegmentSinkOperation.Push,\n            value: infos,\n        });\n        const ranges = await promise;\n        if (infos.inventoryInfos !== null) {\n            this._segmentInventory.insertChunk(infos.inventoryInfos, true, getMonotonicTimeStamp());\n        }\n        this._segmentInventory.synchronizeBuffered(ranges);\n        return ranges;\n    }\n    /**\n     * Remove buffered data.\n     * @param {number} start - start position, in seconds\n     * @param {number} end - end position, in seconds\n     * @returns {Promise}\n     */\n    async removeBuffer(start, end) {\n        const promise = this._sender.remove(start, end);\n        this._addToOperationQueue(promise, {\n            type: SegmentSinkOperation.Remove,\n            value: { start, end },\n        });\n        const ranges = await promise;\n        this._segmentInventory.synchronizeBuffered(ranges);\n        return ranges;\n    }\n    /**\n     * @param {Object} infos\n     * @returns {Promise}\n     */\n    async signalSegmentComplete(infos) {\n        if (this._pendingOperations.length > 0) {\n            // Only validate after preceding operation\n            const { promise } = this._pendingOperations[this._pendingOperations.length - 1];\n            this._addToOperationQueue(promise, {\n                type: SegmentSinkOperation.SignalSegmentComplete,\n                value: infos,\n            });\n            try {\n                await promise;\n            }\n            catch (_) {\n                // We don't really care of what happens of the preceding operation here\n            }\n        }\n        this._segmentInventory.completeSegment(infos);\n    }\n    /**\n     * @returns {Array.<Object>}\n     */\n    getPendingOperations() {\n        return this._pendingOperations.map((p) => p.operation);\n    }\n    dispose() {\n        log.debug(\"HTSB: Disposing TextSegmentSink\");\n        this._sender.reset();\n    }\n    _addToOperationQueue(promise, operation) {\n        const queueObject = { operation, promise };\n        this._pendingOperations.push(queueObject);\n        const endOperation = () => {\n            const indexOf = this._pendingOperations.indexOf(queueObject);\n            if (indexOf >= 0) {\n                this._pendingOperations.splice(indexOf, 1);\n            }\n        };\n        promise.then(endOperation, endOperation); // `finally` not supported everywhere\n    }\n}\n/**\n * Throw if the given input is not in the expected format.\n * Allows to enforce runtime type-checking as compile-time type-checking here is\n * difficult to enforce.\n * @param {Object} chunk\n */\nfunction assertChunkIsTextTrackSegmentData(chunk) {\n    if (0 /* __ENVIRONMENT__.CURRENT_ENV */ === 0 /* __ENVIRONMENT__.PRODUCTION */) {\n        return;\n    }\n    if (typeof chunk !== \"object\" ||\n        chunk === null ||\n        typeof chunk.data !== \"string\" ||\n        typeof chunk.type !== \"string\" ||\n        (chunk.language !== undefined &&\n            typeof chunk.language !== \"string\") ||\n        (chunk.start !== undefined &&\n            typeof chunk.start !== \"number\") ||\n        (chunk.end !== undefined &&\n            typeof chunk.end !== \"number\")) {\n        throw new Error(\"Invalid format given to a TextSegmentSink\");\n    }\n}\n/*\n * The following ugly code is here to provide a compile-time check that an\n * `ITextTracksBufferSegmentData` (type of data pushed to a\n * `TextSegmentSink`) can be derived from a `ITextTrackSegmentData`\n * (text track data parsed from a segment).\n *\n * It doesn't correspond at all to real code that will be called. This is just\n * a hack to tell TypeScript to perform that check.\n */\nif (0 /* __ENVIRONMENT__.CURRENT_ENV */ === 1 /* __ENVIRONMENT__.DEV */) {\n    // @ts-expect-error: unused function for type checking\n    function _checkType(input) {\n        function checkEqual(_arg) {\n            /* nothing */\n        }\n        checkEqual(input);\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport SegmentInventory from \"../inventory\";\n/**\n * Class allowing to push segments and remove data to a buffer to be able\n * to decode them in the future as well as retrieving information about which\n * segments have already been pushed.\n *\n * A `SegmentSink` can rely on a browser's SourceBuffer as well as being\n * entirely defined in the code.\n *\n * A SegmentSink is associated to a given \"bufferType\" (e.g. \"audio\",\n * \"video\", \"text\") and allows to push segments as well as removing part of\n * already-pushed segments for that type.\n *\n * Because a segment can be divided into multiple chunks, one should call the\n * `signalSegmentComplete` method once all chunks of a given segment have been\n * pushed (through the `pushChunk` method) to validate that a segment has been\n * completely pushed.\n * It is expected to push chunks from only one segment at a time before calling\n * the `signalSegmentComplete` function for that segment. Pushing chunks from\n * multiple segments in parallel could have unexpected result depending on the\n * underlying implementation.\n * TODO reflect that in the API?\n *\n * A SegmentSink also maintains an \"inventory\", which is the current\n * list of segments contained in the underlying buffer.\n * This inventory has to be manually \"synchronized\" (through the\n * `synchronizeInventory` method) before being retrieved (through the\n * `getInventory` method).\n *\n * Also depending on the underlying implementation, the various operations\n * performed on a `SegmentSink` (push/remove/segmentComplete) can happen\n * synchronously or asynchronously.\n *\n * You can retrieve the current queue of operations by calling the\n * `getPendingOperations` method.\n * If operations happens synchronously, this method will just return an empty\n * array.\n */\nexport class SegmentSink {\n    constructor() {\n        // Use SegmentInventory by default for inventory purposes\n        this._segmentInventory = new SegmentInventory();\n    }\n    /**\n     * The maintained inventory can fall out of sync from garbage collection or\n     * other events.\n     *\n     * This methods allow to manually trigger a synchronization by providing the\n     * buffered time ranges of the real SourceBuffer implementation.\n     */\n    synchronizeInventory(ranges) {\n        // The default implementation just use the SegmentInventory\n        this._segmentInventory.synchronizeBuffered(ranges);\n    }\n    /**\n     * Returns an inventory of the last known segments to be currently contained in\n     * the SegmentSink.\n     *\n     * /!\\ Note that this data may not be up-to-date with the real current content\n     * of the SegmentSink.\n     * Generally speaking, pushed segments are added right away to it but segments\n     * may have been since removed, which might not be known right away.\n     * Please consider this when using this method, by considering that it does\n     * not reflect the full reality of the underlying buffer.\n     * @returns {Array.<Object>}\n     */\n    getLastKnownInventory() {\n        // The default implementation just use the SegmentInventory\n        return this._segmentInventory.getInventory();\n    }\n    /**\n     * Returns a recent history of registered operations performed and event\n     * received linked to the segment given in argument.\n     *\n     * Not all operations and events are registered in the returned history.\n     * Please check the return type for more information on what is available.\n     *\n     * Note that history is short-lived for memory usage and performance reasons.\n     * You may not receive any information on operations that happened too long\n     * ago.\n     * @param {Object} context\n     * @returns {Array.<Object>}\n     */\n    getSegmentHistory(context) {\n        return this._segmentInventory.getHistoryFor(context);\n    }\n}\n/**\n * Enum used by a SegmentSink as a discriminant in its queue of\n * \"operations\".\n */\nexport var SegmentSinkOperation;\n(function (SegmentSinkOperation) {\n    SegmentSinkOperation[SegmentSinkOperation[\"Push\"] = 0] = \"Push\";\n    SegmentSinkOperation[SegmentSinkOperation[\"Remove\"] = 1] = \"Remove\";\n    SegmentSinkOperation[SegmentSinkOperation[\"SignalSegmentComplete\"] = 2] = \"SignalSegmentComplete\";\n})(SegmentSinkOperation || (SegmentSinkOperation = {}));\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport BufferGarbageCollector from \"./garbage_collector\";\nimport { SegmentSink, SegmentSinkOperation } from \"./implementations\";\nimport { getFirstSegmentAfterPeriod, getLastSegmentBeforePeriod, } from \"./inventory\";\nimport SegmentSinksStore from \"./segment_sinks_store\";\nexport default SegmentSinksStore;\nexport { BufferGarbageCollector, SegmentSink, SegmentSinkOperation, getFirstSegmentAfterPeriod, getLastSegmentBeforePeriod, };\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { areSameContent } from \"../../../manifest\";\nimport getMonotonicTimeStamp from \"../../../utils/monotonic_timestamp\";\n/**\n * Register a short-lived history of buffer information.\n *\n * This class can be useful to develop heuristics based on short-term buffer\n * history, such as knowing the real start and end of a buffered segment once\n * it has been pushed in a buffer.\n *\n * By storing in a history important recent actions and events, the\n * `BufferedHistory` can help other RxPlayer modules detect and work-around\n * unusual behavior.\n *\n * @class BufferedHistory\n */\nexport default class BufferedHistory {\n    /**\n     * @param {number} lifetime - Maximum time a history entry should be retained.\n     * @param {number} maxHistoryLength - Maximum number of entries the history\n     * should have.\n     */\n    constructor(lifetime, maxHistoryLength) {\n        this._history = [];\n        this._lifetime = lifetime;\n        this._maxHistoryLength = maxHistoryLength;\n    }\n    /**\n     * Add an entry to the `BufferedHistory`'s history indicating the buffered\n     * range of a pushed segment.\n     *\n     * To call when the full range of a given segment becomes known.\n     *\n     * @param {Object} context\n     * @param {Array.<number>|null} buffered\n     */\n    addBufferedSegment(context, buffered) {\n        const now = getMonotonicTimeStamp();\n        this._history.push({ date: now, buffered, context });\n        this._cleanHistory(now);\n    }\n    /**\n     * Returns all entries linked to the given segment.\n     * @param {Object} context\n     * @returns {Array.<Object>}\n     */\n    getHistoryFor(context) {\n        return this._history.filter((el) => areSameContent(el.context, context));\n    }\n    /**\n     * If the current history does not satisfy `_lifetime` or `_maxHistoryLength`,\n     * clear older entries until it does.\n     * @param {number} now - Current monotonically-raising timestamp.\n     */\n    _cleanHistory(now) {\n        const historyEarliestLimit = now - this._lifetime;\n        let firstKeptIndex = 0;\n        for (const event of this._history) {\n            if (event.date < historyEarliestLimit) {\n                firstKeptIndex++;\n            }\n            else {\n                break;\n            }\n        }\n        if (firstKeptIndex > 0) {\n            this._history = this._history.splice(firstKeptIndex);\n        }\n        if (this._history.length > this._maxHistoryLength) {\n            const toRemove = this._history.length - this._maxHistoryLength;\n            this._history = this._history.splice(toRemove);\n        }\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport SegmentInventory from \"./segment_inventory\";\nexport default SegmentInventory;\nexport { getFirstSegmentAfterPeriod, getLastSegmentBeforePeriod } from \"./utils\";\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport config from \"../../../config\";\nimport log from \"../../../log\";\nimport { areSameContent } from \"../../../manifest\";\nimport isNullOrUndefined from \"../../../utils/is_null_or_undefined\";\nimport getMonotonicTimeStamp from \"../../../utils/monotonic_timestamp\";\nimport BufferedHistory from \"./buffered_history\";\n/**\n * Keep track of every chunk downloaded and currently in the linked media\n * buffer.\n *\n * The main point of this class is to know which chunks are already pushed to\n * the corresponding media buffer, at which bitrate, and which have been garbage-collected\n * since by the browser (and thus may need to be re-loaded).\n * @class SegmentInventory\n */\nexport default class SegmentInventory {\n    constructor() {\n        const { BUFFERED_HISTORY_RETENTION_TIME, BUFFERED_HISTORY_MAXIMUM_ENTRIES } = config.getCurrent();\n        this._inventory = [];\n        this._bufferedHistory = new BufferedHistory(BUFFERED_HISTORY_RETENTION_TIME, BUFFERED_HISTORY_MAXIMUM_ENTRIES);\n    }\n    /**\n     * Reset the whole inventory.\n     */\n    reset() {\n        this._inventory.length = 0;\n    }\n    /**\n     * Infer each segment's `bufferedStart` and `bufferedEnd` properties from the\n     * ranges given.\n     *\n     * The ranges object given should come from the media buffer linked to that\n     * SegmentInventory.\n     *\n     * /!\\ A SegmentInventory should not be associated to multiple media buffers\n     * at a time, so each `synchronizeBuffered` call should be given ranges coming\n     * from the same buffer.\n     * @param {Array.<Object>} ranges\n     */\n    synchronizeBuffered(ranges) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        const inventory = this._inventory;\n        let inventoryIndex = 0; // Current index considered.\n        let thisSegment = inventory[0]; // Current segmentInfos considered\n        const { MINIMUM_SEGMENT_SIZE } = config.getCurrent();\n        /** Type of buffer considered, used for logs */\n        const bufferType = thisSegment === null || thisSegment === void 0 ? void 0 : thisSegment.infos.adaptation.type;\n        if (log.hasLevel(\"DEBUG\")) {\n            const prettyPrintedRanges = ranges.map((r) => `${r.start}-${r.end}`).join(\",\");\n            log.debug(`SI: synchronizing ${bufferType !== null && bufferType !== void 0 ? bufferType : \"unknown\"} buffered ranges:`, prettyPrintedRanges);\n        }\n        const rangesLength = ranges.length;\n        for (let i = 0; i < rangesLength; i++) {\n            if (thisSegment === undefined) {\n                // we arrived at the end of our inventory\n                return;\n            }\n            // take the i'nth contiguous buffered range\n            const rangeStart = ranges[i].start;\n            const rangeEnd = ranges[i].end;\n            if (rangeEnd - rangeStart < MINIMUM_SEGMENT_SIZE) {\n                log.warn(\"SI: skipped range when synchronizing because it was too small\", bufferType, rangeStart, rangeEnd);\n                continue;\n            }\n            const indexBefore = inventoryIndex; // keep track of that number\n            // Find the first segment either within this range or completely past\n            // it:\n            // skip until first segment with at least `MINIMUM_SEGMENT_SIZE` past the\n            // start of that range.\n            while (thisSegment !== undefined &&\n                ((_a = thisSegment.bufferedEnd) !== null && _a !== void 0 ? _a : thisSegment.end) - rangeStart < MINIMUM_SEGMENT_SIZE) {\n                thisSegment = inventory[++inventoryIndex];\n            }\n            // Contains infos about the last garbage-collected segment before\n            // `thisSegment`.\n            let lastDeletedSegmentInfos = null;\n            // remove garbage-collected segments\n            // (Those not in that range nor in the previous one)\n            const numberOfSegmentToDelete = inventoryIndex - indexBefore;\n            if (numberOfSegmentToDelete > 0) {\n                const lastDeletedSegment = inventory[indexBefore + numberOfSegmentToDelete - 1]; // last garbage-collected segment\n                lastDeletedSegmentInfos = {\n                    end: (_b = lastDeletedSegment.bufferedEnd) !== null && _b !== void 0 ? _b : lastDeletedSegment.end,\n                    precizeEnd: lastDeletedSegment.precizeEnd,\n                };\n                log.debug(`SI: ${numberOfSegmentToDelete} segments GCed.`, bufferType);\n                const removed = inventory.splice(indexBefore, numberOfSegmentToDelete);\n                for (const seg of removed) {\n                    if (seg.bufferedStart === undefined &&\n                        seg.bufferedEnd === undefined &&\n                        seg.status !== 2 /* ChunkStatus.Failed */) {\n                        this._bufferedHistory.addBufferedSegment(seg.infos, null);\n                    }\n                }\n                inventoryIndex = indexBefore;\n            }\n            if (thisSegment === undefined) {\n                return;\n            }\n            // If the current segment is actually completely outside that range (it\n            // is contained in one of the next one), skip that part.\n            if (rangeEnd - ((_c = thisSegment.bufferedStart) !== null && _c !== void 0 ? _c : thisSegment.start) >=\n                MINIMUM_SEGMENT_SIZE) {\n                guessBufferedStartFromRangeStart(thisSegment, rangeStart, lastDeletedSegmentInfos, bufferType);\n                if (inventoryIndex === inventory.length - 1) {\n                    // This is the last segment in the inventory.\n                    // We can directly update the end as the end of the current range.\n                    guessBufferedEndFromRangeEnd(thisSegment, rangeEnd, bufferType);\n                    return;\n                }\n                thisSegment = inventory[++inventoryIndex];\n                // Make contiguous until first segment outside that range\n                let thisSegmentStart = (_d = thisSegment.bufferedStart) !== null && _d !== void 0 ? _d : thisSegment.start;\n                let thisSegmentEnd = (_e = thisSegment.bufferedEnd) !== null && _e !== void 0 ? _e : thisSegment.end;\n                const nextRangeStart = i < rangesLength - 1 ? ranges[i + 1].start : undefined;\n                while (thisSegment !== undefined) {\n                    if (rangeEnd < thisSegmentStart) {\n                        // `thisSegment` is part of the next range\n                        break;\n                    }\n                    if (rangeEnd - thisSegmentStart < MINIMUM_SEGMENT_SIZE &&\n                        thisSegmentEnd - rangeEnd >= MINIMUM_SEGMENT_SIZE) {\n                        // Ambiguous, but `thisSegment` seems more to come after the current\n                        // range than during it.\n                        break;\n                    }\n                    if (nextRangeStart !== undefined &&\n                        rangeEnd - thisSegmentStart < thisSegmentEnd - nextRangeStart) {\n                        // Ambiguous, but `thisSegment` has more chance to be part of the\n                        // next range than the current one\n                        break;\n                    }\n                    const prevSegment = inventory[inventoryIndex - 1];\n                    // those segments are contiguous, we have no way to infer their real\n                    // end\n                    if (prevSegment.bufferedEnd === undefined) {\n                        if (thisSegment.precizeStart) {\n                            prevSegment.bufferedEnd = thisSegment.start;\n                        }\n                        else if (prevSegment.infos.segment.complete) {\n                            prevSegment.bufferedEnd = prevSegment.end;\n                        }\n                        else {\n                            // We cannot truly trust the anounced end here as the segment was\n                            // potentially not complete at its time of announce.\n                            // Just assume the next's segment announced start is right - as\n                            // `start` is in that scenario more \"trustable\" than `end`.\n                            prevSegment.bufferedEnd = thisSegment.start;\n                        }\n                        log.debug(\"SI: calculating buffered end of contiguous segment\", bufferType, prevSegment.bufferedEnd, prevSegment.end);\n                    }\n                    thisSegment.bufferedStart = prevSegment.bufferedEnd;\n                    thisSegment = inventory[++inventoryIndex];\n                    if (thisSegment !== undefined) {\n                        thisSegmentStart = (_f = thisSegment.bufferedStart) !== null && _f !== void 0 ? _f : thisSegment.start;\n                        thisSegmentEnd = (_g = thisSegment.bufferedEnd) !== null && _g !== void 0 ? _g : thisSegment.end;\n                    }\n                }\n            }\n            // update the bufferedEnd of the last segment in that range\n            const lastSegmentInRange = inventory[inventoryIndex - 1];\n            if (lastSegmentInRange !== undefined) {\n                guessBufferedEndFromRangeEnd(lastSegmentInRange, rangeEnd, bufferType);\n            }\n        }\n        // if we still have segments left, they are not affiliated to any range.\n        // They might have been garbage collected, delete them from here.\n        if (!isNullOrUndefined(thisSegment)) {\n            const { SEGMENT_SYNCHRONIZATION_DELAY } = config.getCurrent();\n            const now = getMonotonicTimeStamp();\n            for (let i = inventoryIndex; i < inventory.length; i++) {\n                const segmentInfo = inventory[i];\n                if (now - segmentInfo.insertionTs >= SEGMENT_SYNCHRONIZATION_DELAY) {\n                    log.debug(\"SI: A segment at the end has been completely GCed\", bufferType, `${segmentInfo.start}-${segmentInfo.end}`);\n                    if (segmentInfo.bufferedStart === undefined &&\n                        segmentInfo.bufferedEnd === undefined &&\n                        segmentInfo.status !== 2 /* ChunkStatus.Failed */) {\n                        this._bufferedHistory.addBufferedSegment(segmentInfo.infos, null);\n                    }\n                    inventory.splice(i, 1);\n                    i--;\n                }\n            }\n        }\n        if (bufferType !== undefined && log.hasLevel(\"DEBUG\")) {\n            log.debug(`SI: current ${bufferType} inventory timeline:\\n` +\n                prettyPrintInventory(this._inventory));\n        }\n    }\n    /**\n     * Add a new chunk in the inventory.\n     *\n     * Chunks are decodable sub-parts of a whole segment. Once all chunks in a\n     * segment have been inserted, you should call the `completeSegment` method.\n     * @param {Object} chunkInformation\n     * @param {boolean} succeed - If `true` the insertion operation finished with\n     * success, if `false` an error arised while doing it.\n     * @param {number} insertionTs - The monotonically-increasing timestamp at the\n     * time the segment has been confirmed to be inserted by the buffer.\n     */\n    insertChunk({ period, adaptation, representation, segment, chunkSize, start, end, }, succeed, insertionTs) {\n        if (segment.isInit) {\n            return;\n        }\n        const bufferType = adaptation.type;\n        if (start >= end) {\n            log.warn(\"SI: Invalid chunked inserted: starts before it ends\", bufferType, start, end);\n            return;\n        }\n        const inventory = this._inventory;\n        const newSegment = {\n            status: succeed ? 0 /* ChunkStatus.PartiallyPushed */ : 2 /* ChunkStatus.Failed */,\n            insertionTs,\n            chunkSize,\n            splitted: false,\n            start,\n            end,\n            precizeStart: false,\n            precizeEnd: false,\n            bufferedStart: undefined,\n            bufferedEnd: undefined,\n            infos: { segment, period, adaptation, representation },\n        };\n        // begin by the end as in most use cases this will be faster\n        for (let i = inventory.length - 1; i >= 0; i--) {\n            const segmentI = inventory[i];\n            if (segmentI.start <= start) {\n                if (segmentI.end <= start) {\n                    // our segment is after, push it after this one\n                    //\n                    // Case 1:\n                    //   prevSegment  : |------|\n                    //   newSegment   :        |======|\n                    //   ===>         : |------|======|\n                    //\n                    // Case 2:\n                    //   prevSegment  : |------|\n                    //   newSegment   :          |======|\n                    //   ===>         : |------| |======|\n                    log.debug(\"SI: Pushing segment strictly after previous one.\", bufferType, start, segmentI.end);\n                    this._inventory.splice(i + 1, 0, newSegment);\n                    i += 2; // Go to segment immediately after newSegment\n                    while (i < inventory.length && inventory[i].start < newSegment.end) {\n                        if (inventory[i].end > newSegment.end) {\n                            // The next segment ends after newSegment.\n                            // Mutate the next segment.\n                            //\n                            // Case 1:\n                            //   prevSegment  : |------|\n                            //   newSegment   :        |======|\n                            //   nextSegment  :            |----|\n                            //   ===>         : |------|======|-|\n                            log.debug(\"SI: Segment pushed updates the start of the next one\", bufferType, newSegment.end, inventory[i].start);\n                            inventory[i].start = newSegment.end;\n                            inventory[i].bufferedStart = undefined;\n                            inventory[i].precizeStart =\n                                inventory[i].precizeStart && newSegment.precizeEnd;\n                            return;\n                        }\n                        // The next segment was completely contained in newSegment.\n                        // Remove it.\n                        //\n                        // Case 1:\n                        //   prevSegment  : |------|\n                        //   newSegment   :        |======|\n                        //   nextSegment  :          |---|\n                        //   ===>         : |------|======|\n                        //\n                        // Case 2:\n                        //   prevSegment  : |------|\n                        //   newSegment   :        |======|\n                        //   nextSegment  :          |----|\n                        //   ===>         : |------|======|\n                        log.debug(\"SI: Segment pushed removes the next one\", bufferType, start, end, inventory[i].start, inventory[i].end);\n                        inventory.splice(i, 1);\n                    }\n                    return;\n                }\n                else {\n                    if (segmentI.start === start) {\n                        if (segmentI.end <= end) {\n                            // In those cases, replace\n                            //\n                            // Case 1:\n                            //  prevSegment  : |-------|\n                            //  newSegment   : |=======|\n                            //  ===>         : |=======|\n                            //\n                            // Case 2:\n                            //  prevSegment  : |-------|\n                            //  newSegment   : |==========|\n                            //  ===>         : |==========|\n                            log.debug(\"SI: Segment pushed replace another one\", bufferType, start, end, segmentI.end);\n                            this._inventory.splice(i, 1, newSegment);\n                            i += 1; // Go to segment immediately after newSegment\n                            while (i < inventory.length && inventory[i].start < newSegment.end) {\n                                if (inventory[i].end > newSegment.end) {\n                                    // The next segment ends after newSegment.\n                                    // Mutate the next segment.\n                                    //\n                                    // Case 1:\n                                    //   newSegment   : |======|\n                                    //   nextSegment  :      |----|\n                                    //   ===>         : |======|--|\n                                    log.debug(\"SI: Segment pushed updates the start of the next one\", bufferType, newSegment.end, inventory[i].start);\n                                    inventory[i].start = newSegment.end;\n                                    inventory[i].bufferedStart = undefined;\n                                    inventory[i].precizeStart =\n                                        inventory[i].precizeStart && newSegment.precizeEnd;\n                                    return;\n                                }\n                                // The next segment was completely contained in newSegment.\n                                // Remove it.\n                                //\n                                // Case 1:\n                                //   newSegment   : |======|\n                                //   nextSegment  :   |---|\n                                //   ===>         : |======|\n                                //\n                                // Case 2:\n                                //   newSegment   : |======|\n                                //   nextSegment  :   |----|\n                                //   ===>         : |======|\n                                log.debug(\"SI: Segment pushed removes the next one\", bufferType, start, end, inventory[i].start, inventory[i].end);\n                                inventory.splice(i, 1);\n                            }\n                            return;\n                        }\n                        else {\n                            // The previous segment starts at the same time and finishes\n                            // after the new segment.\n                            // Update the start of the previous segment and put the new\n                            // segment before.\n                            //\n                            // Case 1:\n                            //  prevSegment  : |------------|\n                            //  newSegment   : |==========|\n                            //  ===>         : |==========|-|\n                            log.debug(\"SI: Segment pushed ends before another with the same start\", bufferType, start, end, segmentI.end);\n                            inventory.splice(i, 0, newSegment);\n                            segmentI.start = newSegment.end;\n                            segmentI.bufferedStart = undefined;\n                            segmentI.precizeStart = segmentI.precizeStart && newSegment.precizeEnd;\n                            return;\n                        }\n                    }\n                    else {\n                        if (segmentI.end <= newSegment.end) {\n                            // our segment has a \"complex\" relation with this one,\n                            // update the old one end and add this one after it.\n                            //\n                            // Case 1:\n                            //  prevSegment  : |-------|\n                            //  newSegment   :    |======|\n                            //  ===>         : |--|======|\n                            //\n                            // Case 2:\n                            //  prevSegment  : |-------|\n                            //  newSegment   :    |====|\n                            //  ===>         : |--|====|\n                            log.debug(\"SI: Segment pushed updates end of previous one\", bufferType, start, end, segmentI.start, segmentI.end);\n                            this._inventory.splice(i + 1, 0, newSegment);\n                            segmentI.end = newSegment.start;\n                            segmentI.bufferedEnd = undefined;\n                            segmentI.precizeEnd = segmentI.precizeEnd && newSegment.precizeStart;\n                            i += 2; // Go to segment immediately after newSegment\n                            while (i < inventory.length && inventory[i].start < newSegment.end) {\n                                if (inventory[i].end > newSegment.end) {\n                                    // The next segment ends after newSegment.\n                                    // Mutate the next segment.\n                                    //\n                                    // Case 1:\n                                    //   newSegment   : |======|\n                                    //   nextSegment  :      |----|\n                                    //   ===>         : |======|--|\n                                    log.debug(\"SI: Segment pushed updates the start of the next one\", bufferType, newSegment.end, inventory[i].start);\n                                    inventory[i].start = newSegment.end;\n                                    inventory[i].bufferedStart = undefined;\n                                    inventory[i].precizeStart =\n                                        inventory[i].precizeStart && newSegment.precizeEnd;\n                                    return;\n                                }\n                                // The next segment was completely contained in newSegment.\n                                // Remove it.\n                                //\n                                // Case 1:\n                                //   newSegment   : |======|\n                                //   nextSegment  :   |---|\n                                //   ===>         : |======|\n                                //\n                                // Case 2:\n                                //   newSegment   : |======|\n                                //   nextSegment  :   |----|\n                                //   ===>         : |======|\n                                log.debug(\"SI: Segment pushed removes the next one\", bufferType, start, end, inventory[i].start, inventory[i].end);\n                                inventory.splice(i, 1);\n                            }\n                            return;\n                        }\n                        else {\n                            // The previous segment completely recovers the new segment.\n                            // Split the previous segment into two segments, before and after\n                            // the new segment.\n                            //\n                            // Case 1:\n                            //  prevSegment  : |---------|\n                            //  newSegment   :    |====|\n                            //  ===>         : |--|====|-|\n                            log.warn(\"SI: Segment pushed is contained in a previous one\", bufferType, start, end, segmentI.start, segmentI.end);\n                            const nextSegment = {\n                                status: segmentI.status,\n                                insertionTs: segmentI.insertionTs,\n                                /**\n                                 * Note: this sadly means we're doing as if\n                                 * that chunk is present two times.\n                                 * Thankfully, this scenario should be\n                                 * fairly rare.\n                                 */\n                                chunkSize: segmentI.chunkSize,\n                                splitted: true,\n                                start: newSegment.end,\n                                end: segmentI.end,\n                                precizeStart: segmentI.precizeStart && segmentI.precizeEnd && newSegment.precizeEnd,\n                                precizeEnd: segmentI.precizeEnd,\n                                bufferedStart: undefined,\n                                bufferedEnd: segmentI.end,\n                                infos: segmentI.infos,\n                            };\n                            segmentI.end = newSegment.start;\n                            segmentI.splitted = true;\n                            segmentI.bufferedEnd = undefined;\n                            segmentI.precizeEnd = segmentI.precizeEnd && newSegment.precizeStart;\n                            inventory.splice(i + 1, 0, newSegment);\n                            inventory.splice(i + 2, 0, nextSegment);\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n        // if we got here, we are at the first segment\n        // check bounds of the previous first segment\n        const firstSegment = this._inventory[0];\n        if (firstSegment === undefined) {\n            // we do not have any segment yet\n            log.debug(\"SI: first segment pushed\", bufferType, start, end);\n            this._inventory.push(newSegment);\n            return;\n        }\n        if (firstSegment.start >= end) {\n            // our segment is before, put it before\n            //\n            // Case 1:\n            //  firstSegment :      |----|\n            //  newSegment   : |====|\n            //  ===>         : |====|----|\n            //\n            // Case 2:\n            //  firstSegment :        |----|\n            //  newSegment   : |====|\n            //  ===>         : |====| |----|\n            log.debug(\"SI: Segment pushed comes before all previous ones\", bufferType, start, end, firstSegment.start);\n            this._inventory.splice(0, 0, newSegment);\n        }\n        else if (firstSegment.end <= end) {\n            // Our segment is bigger, replace the first\n            //\n            // Case 1:\n            //  firstSegment :   |---|\n            //  newSegment   : |=======|\n            //  ===>         : |=======|\n            //\n            // Case 2:\n            //  firstSegment :   |-----|\n            //  newSegment   : |=======|\n            //  ===>         : |=======|\n            log.debug(\"SI: Segment pushed starts before and completely \" +\n                \"recovers the previous first one\", bufferType, start, end, firstSegment.start, firstSegment.end);\n            this._inventory.splice(0, 1, newSegment);\n            while (inventory.length > 1 && inventory[1].start < newSegment.end) {\n                if (inventory[1].end > newSegment.end) {\n                    // The next segment ends after newSegment.\n                    // Mutate the next segment.\n                    //\n                    // Case 1:\n                    //   newSegment   : |======|\n                    //   nextSegment  :      |----|\n                    //   ===>         : |======|--|\n                    log.debug(\"SI: Segment pushed updates the start of the next one\", bufferType, newSegment.end, inventory[1].start);\n                    inventory[1].start = newSegment.end;\n                    inventory[1].bufferedStart = undefined;\n                    inventory[1].precizeStart = newSegment.precizeEnd;\n                    return;\n                }\n                // The next segment was completely contained in newSegment.\n                // Remove it.\n                //\n                // Case 1:\n                //   newSegment   : |======|\n                //   nextSegment  :   |---|\n                //   ===>         : |======|\n                //\n                // Case 2:\n                //   newSegment   : |======|\n                //   nextSegment  :   |----|\n                //   ===>         : |======|\n                log.debug(\"SI: Segment pushed removes the next one\", bufferType, start, end, inventory[1].start, inventory[1].end);\n                inventory.splice(1, 1);\n            }\n            return;\n        }\n        else {\n            // our segment has a \"complex\" relation with the first one,\n            // update the old one start and add this one before it.\n            //\n            // Case 1:\n            //  firstSegment :    |------|\n            //  newSegment   : |======|\n            //  ===>         : |======|--|\n            log.debug(\"SI: Segment pushed start of the next one\", bufferType, start, end, firstSegment.start, firstSegment.end);\n            firstSegment.start = end;\n            firstSegment.bufferedStart = undefined;\n            firstSegment.precizeStart = newSegment.precizeEnd;\n            this._inventory.splice(0, 0, newSegment);\n            return;\n        }\n    }\n    /**\n     * Indicate that inserted chunks can now be considered as a fully-loaded\n     * segment.\n     * Take in argument the same content than what was given to `insertChunk` for\n     * the corresponding chunks.\n     * @param {Object} content\n     */\n    completeSegment(content) {\n        if (content.segment.isInit) {\n            return;\n        }\n        const inventory = this._inventory;\n        const resSegments = [];\n        for (let i = 0; i < inventory.length; i++) {\n            if (areSameContent(inventory[i].infos, content)) {\n                let splitted = false;\n                if (resSegments.length > 0) {\n                    splitted = true;\n                    if (resSegments.length === 1) {\n                        log.warn(\"SI: Completed Segment is splitted.\", content.segment.id, content.segment.time, content.segment.end);\n                        resSegments[0].splitted = true;\n                    }\n                }\n                const firstI = i;\n                let segmentSize = inventory[i].chunkSize;\n                i += 1;\n                while (i < inventory.length && areSameContent(inventory[i].infos, content)) {\n                    const chunkSize = inventory[i].chunkSize;\n                    if (segmentSize !== undefined && chunkSize !== undefined) {\n                        segmentSize += chunkSize;\n                    }\n                    i++;\n                }\n                const lastI = i - 1;\n                const length = lastI - firstI;\n                const lastEnd = inventory[lastI].end;\n                const lastBufferedEnd = inventory[lastI].bufferedEnd;\n                if (length > 0) {\n                    this._inventory.splice(firstI + 1, length);\n                    i -= length;\n                }\n                if (this._inventory[firstI].status === 0 /* ChunkStatus.PartiallyPushed */) {\n                    this._inventory[firstI].status = 1 /* ChunkStatus.FullyLoaded */;\n                }\n                this._inventory[firstI].chunkSize = segmentSize;\n                this._inventory[firstI].end = lastEnd;\n                this._inventory[firstI].bufferedEnd = lastBufferedEnd;\n                this._inventory[firstI].splitted = splitted;\n                resSegments.push(this._inventory[firstI]);\n            }\n        }\n        if (resSegments.length === 0) {\n            log.warn(\"SI: Completed Segment not found\", content.segment.id, content.segment.time);\n        }\n        else {\n            for (const seg of resSegments) {\n                if (seg.bufferedStart !== undefined && seg.bufferedEnd !== undefined) {\n                    if (seg.status !== 2 /* ChunkStatus.Failed */) {\n                        this._bufferedHistory.addBufferedSegment(seg.infos, {\n                            start: seg.bufferedStart,\n                            end: seg.bufferedEnd,\n                        });\n                    }\n                }\n                else {\n                    // TODO FIXME There might be a false positive here when the\n                    // `SEGMENT_SYNCHRONIZATION_DELAY` config value is at play\n                    log.debug(\"SI: buffered range not known after sync. Skipping history.\", seg.start, seg.end);\n                }\n            }\n        }\n    }\n    /**\n     * Returns the whole inventory.\n     *\n     * To get a list synchronized with what a media buffer actually has buffered\n     * you might want to call `synchronizeBuffered` before calling this method.\n     * @returns {Array.<Object>}\n     */\n    getInventory() {\n        return this._inventory;\n    }\n    /**\n     * Returns a recent history of registered operations performed and event\n     * received linked to the segment given in argument.\n     *\n     * Not all operations and events are registered in the returned history.\n     * Please check the return type for more information on what is available.\n     *\n     * Note that history is short-lived for memory usage and performance reasons.\n     * You may not receive any information on operations that happened too long\n     * ago.\n     * @param {Object} context\n     * @returns {Array.<Object>}\n     */\n    getHistoryFor(context) {\n        return this._bufferedHistory.getHistoryFor(context);\n    }\n}\n/**\n * Returns `true` if the buffered start of the given chunk looks coherent enough\n * relatively to what is announced in the Manifest.\n * @param {Object} thisSegment\n * @returns {Boolean}\n */\nfunction bufferedStartLooksCoherent(thisSegment) {\n    if (thisSegment.bufferedStart === undefined ||\n        thisSegment.status !== 1 /* ChunkStatus.FullyLoaded */) {\n        return false;\n    }\n    const { start, end } = thisSegment;\n    const duration = end - start;\n    const { MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE, MAX_MANIFEST_BUFFERED_DURATION_DIFFERENCE, } = config.getCurrent();\n    return (Math.abs(start - thisSegment.bufferedStart) <=\n        MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE &&\n        (thisSegment.bufferedEnd === undefined ||\n            (thisSegment.bufferedEnd > thisSegment.bufferedStart &&\n                Math.abs(thisSegment.bufferedEnd - thisSegment.bufferedStart - duration) <=\n                    Math.min(MAX_MANIFEST_BUFFERED_DURATION_DIFFERENCE, duration / 3))));\n}\n/**\n * Returns `true` if the buffered end of the given chunk looks coherent enough\n * relatively to what is announced in the Manifest.\n * @param {Object} thisSegment\n * @returns {Boolean}\n */\nfunction bufferedEndLooksCoherent(thisSegment) {\n    if (thisSegment.bufferedEnd === undefined ||\n        !thisSegment.infos.segment.complete ||\n        thisSegment.status !== 1 /* ChunkStatus.FullyLoaded */) {\n        return false;\n    }\n    const { start, end } = thisSegment;\n    const duration = end - start;\n    const { MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE, MAX_MANIFEST_BUFFERED_DURATION_DIFFERENCE, } = config.getCurrent();\n    return (Math.abs(end - thisSegment.bufferedEnd) <=\n        MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE &&\n        thisSegment.bufferedStart !== undefined &&\n        thisSegment.bufferedEnd > thisSegment.bufferedStart &&\n        Math.abs(thisSegment.bufferedEnd - thisSegment.bufferedStart - duration) <=\n            Math.min(MAX_MANIFEST_BUFFERED_DURATION_DIFFERENCE, duration / 3));\n}\n/**\n * Evaluate the given buffered Chunk's buffered start from its range's start,\n * considering that this chunk is the first one in it.\n * @param {Object} firstSegmentInRange\n * @param {number} rangeStart\n * @param {Object} lastDeletedSegmentInfos\n */\nfunction guessBufferedStartFromRangeStart(firstSegmentInRange, rangeStart, lastDeletedSegmentInfos, bufferType) {\n    const { MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE, MISSING_DATA_TRIGGER_SYNC_DELAY, SEGMENT_SYNCHRONIZATION_DELAY, } = config.getCurrent();\n    if (firstSegmentInRange.bufferedStart !== undefined) {\n        if (firstSegmentInRange.bufferedStart < rangeStart) {\n            log.debug(\"SI: Segment partially GCed at the start\", bufferType, firstSegmentInRange.bufferedStart, rangeStart);\n            firstSegmentInRange.bufferedStart = rangeStart;\n        }\n        if (!firstSegmentInRange.precizeStart &&\n            bufferedStartLooksCoherent(firstSegmentInRange)) {\n            firstSegmentInRange.start = firstSegmentInRange.bufferedStart;\n            firstSegmentInRange.precizeStart = true;\n        }\n    }\n    else if (firstSegmentInRange.precizeStart) {\n        log.debug(\"SI: buffered start is precize start\", bufferType, firstSegmentInRange.start);\n        firstSegmentInRange.bufferedStart = firstSegmentInRange.start;\n    }\n    else if (lastDeletedSegmentInfos !== null &&\n        lastDeletedSegmentInfos.end > rangeStart &&\n        (lastDeletedSegmentInfos.precizeEnd ||\n            firstSegmentInRange.start - lastDeletedSegmentInfos.end <=\n                MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE)) {\n        log.debug(\"SI: buffered start is end of previous segment\", bufferType, rangeStart, firstSegmentInRange.start, lastDeletedSegmentInfos.end);\n        firstSegmentInRange.bufferedStart = lastDeletedSegmentInfos.end;\n        if (bufferedStartLooksCoherent(firstSegmentInRange)) {\n            firstSegmentInRange.start = lastDeletedSegmentInfos.end;\n            firstSegmentInRange.precizeStart = true;\n        }\n    }\n    else if (firstSegmentInRange.start - rangeStart <=\n        MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE) {\n        const now = getMonotonicTimeStamp();\n        if (firstSegmentInRange.start - rangeStart >= MISSING_DATA_TRIGGER_SYNC_DELAY &&\n            now - firstSegmentInRange.insertionTs < SEGMENT_SYNCHRONIZATION_DELAY) {\n            log.debug(\"SI: Ignored bufferedStart synchronization\", bufferType, rangeStart, firstSegmentInRange.start, now - firstSegmentInRange.insertionTs);\n            return;\n        }\n        log.debug(\"SI: found true buffered start\", bufferType, rangeStart, firstSegmentInRange.start);\n        firstSegmentInRange.bufferedStart = rangeStart;\n        if (bufferedStartLooksCoherent(firstSegmentInRange)) {\n            firstSegmentInRange.start = rangeStart;\n            firstSegmentInRange.precizeStart = true;\n        }\n    }\n    else if (rangeStart < firstSegmentInRange.start) {\n        log.debug(\"SI: range start too far from expected start\", bufferType, rangeStart, firstSegmentInRange.start);\n        firstSegmentInRange.bufferedStart = firstSegmentInRange.start;\n    }\n    else {\n        const now = getMonotonicTimeStamp();\n        if (firstSegmentInRange.start - rangeStart >= MISSING_DATA_TRIGGER_SYNC_DELAY &&\n            now - firstSegmentInRange.insertionTs < SEGMENT_SYNCHRONIZATION_DELAY) {\n            log.debug(\"SI: Ignored bufferedStart synchronization\", bufferType, rangeStart, firstSegmentInRange.start, now - firstSegmentInRange.insertionTs);\n            return;\n        }\n        log.debug(\"SI: Segment appears immediately garbage collected at the start\", bufferType, rangeStart, firstSegmentInRange.start);\n        firstSegmentInRange.bufferedStart = rangeStart;\n    }\n}\n/**\n * Evaluate the given buffered Chunk's buffered end from its range's end,\n * considering that this chunk is the last one in it.\n * @param {Object} lastSegmentInRange\n * @param {number} rangeEnd\n * @param {string} bufferType\n */\nfunction guessBufferedEndFromRangeEnd(lastSegmentInRange, rangeEnd, bufferType) {\n    const { MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE, MISSING_DATA_TRIGGER_SYNC_DELAY, SEGMENT_SYNCHRONIZATION_DELAY, } = config.getCurrent();\n    if (lastSegmentInRange.bufferedEnd !== undefined) {\n        if (lastSegmentInRange.bufferedEnd > rangeEnd) {\n            log.debug(\"SI: Segment partially GCed at the end\", bufferType, lastSegmentInRange.bufferedEnd, rangeEnd);\n            lastSegmentInRange.bufferedEnd = rangeEnd;\n        }\n        if (!lastSegmentInRange.precizeEnd &&\n            rangeEnd - lastSegmentInRange.end <= MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE &&\n            bufferedEndLooksCoherent(lastSegmentInRange)) {\n            lastSegmentInRange.precizeEnd = true;\n            lastSegmentInRange.end = rangeEnd;\n        }\n    }\n    else if (lastSegmentInRange.precizeEnd) {\n        log.debug(\"SI: buffered end is precize end\", bufferType, lastSegmentInRange.end);\n        lastSegmentInRange.bufferedEnd = lastSegmentInRange.end;\n    }\n    else if (rangeEnd - lastSegmentInRange.end <= MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE ||\n        !lastSegmentInRange.infos.segment.complete) {\n        const now = getMonotonicTimeStamp();\n        if (rangeEnd - lastSegmentInRange.end >= MISSING_DATA_TRIGGER_SYNC_DELAY &&\n            now - lastSegmentInRange.insertionTs < SEGMENT_SYNCHRONIZATION_DELAY) {\n            log.debug(\"SI: Ignored bufferedEnd synchronization\", bufferType, rangeEnd, lastSegmentInRange.end, now - lastSegmentInRange.insertionTs);\n            return;\n        }\n        log.debug(\"SI: found true buffered end\", bufferType, rangeEnd, lastSegmentInRange.end);\n        lastSegmentInRange.bufferedEnd = rangeEnd;\n        if (bufferedEndLooksCoherent(lastSegmentInRange)) {\n            lastSegmentInRange.end = rangeEnd;\n            lastSegmentInRange.precizeEnd = true;\n        }\n    }\n    else if (rangeEnd > lastSegmentInRange.end) {\n        log.debug(\"SI: range end too far from expected end\", bufferType, rangeEnd, lastSegmentInRange.end);\n        lastSegmentInRange.bufferedEnd = lastSegmentInRange.end;\n    }\n    else {\n        const now = getMonotonicTimeStamp();\n        if (rangeEnd - lastSegmentInRange.end >= MISSING_DATA_TRIGGER_SYNC_DELAY &&\n            now - lastSegmentInRange.insertionTs < SEGMENT_SYNCHRONIZATION_DELAY) {\n            log.debug(\"SI: Ignored bufferedEnd synchronization\", bufferType, rangeEnd, lastSegmentInRange.end, now - lastSegmentInRange.insertionTs);\n            return;\n        }\n        log.debug(\"SI: Segment appears immediately garbage collected at the end\", bufferType, lastSegmentInRange.bufferedEnd, rangeEnd);\n        lastSegmentInRange.bufferedEnd = rangeEnd;\n    }\n}\n/**\n * Pretty print the inventory, to easily note which segments are where in the\n * current buffer.\n *\n * This is mostly useful when logging.\n *\n * @example\n * This function is called by giving it the inventory, such as:\n * ```js\n * prettyPrintInventory(inventory);\n * ```\n *\n * Let's consider this possible return:\n * ```\n * 0.00|A|9.00 ~ 9.00|B|45.08 ~ 282.08|B|318.08\n * [A] P: gen-dash-period-0 || R: video/5(2362822)\n * [B] P: gen-dash-period-0 || R: video/6(2470094)\n * ```\n * We have a first part, from 0 to 9 seconds, which contains segments for\n * the Representation with the id \"video/5\" and an associated bitrate of\n * 2362822 bits per seconds (in the Period with the id \"gen-dash-period-0\").\n *\n * Then from 9.00 seconds to 45.08 seconds, we have segments from another\n * Representation from the same Period (with the id \"video/6\" and a bitrate\n * of 2470094 bits per seconds).\n *\n * At last we have a long time between 45.08 and 282.08 with no segment followed\n * by a segment from that same Representation between 282.08 seconds and 318.08\n * seconds.\n * @param {Array.<Object>} inventory\n * @returns {string}\n */\nfunction prettyPrintInventory(inventory) {\n    const roundingError = 1 / 60;\n    const encounteredReps = {};\n    const letters = [];\n    let lastChunk = null;\n    let lastLetter = null;\n    function generateNewLetter(infos) {\n        const currentLetter = String.fromCharCode(letters.length + 65);\n        letters.push({\n            letter: currentLetter,\n            periodId: infos.period.id,\n            representationId: infos.representation.id,\n            bitrate: infos.representation.bitrate,\n        });\n        return currentLetter;\n    }\n    let str = \"\";\n    for (const chunk of inventory) {\n        if (chunk.bufferedStart !== undefined && chunk.bufferedEnd !== undefined) {\n            const periodId = chunk.infos.period.id;\n            const representationId = chunk.infos.representation.id;\n            const encounteredPeriod = encounteredReps[periodId];\n            let currentLetter;\n            if (encounteredPeriod === undefined) {\n                currentLetter = generateNewLetter(chunk.infos);\n                encounteredReps[periodId] = { [representationId]: currentLetter };\n            }\n            else {\n                const previousLetter = encounteredPeriod[representationId];\n                if (previousLetter === undefined) {\n                    currentLetter = generateNewLetter(chunk.infos);\n                    encounteredPeriod[representationId] = currentLetter;\n                }\n                else {\n                    currentLetter = previousLetter;\n                }\n            }\n            if (lastChunk === null) {\n                str += `${chunk.bufferedStart.toFixed(2)}|${currentLetter}|`;\n            }\n            else if (lastLetter === currentLetter) {\n                if (lastChunk.bufferedEnd + roundingError < chunk.bufferedStart) {\n                    str +=\n                        `${lastChunk.bufferedEnd.toFixed(2)} ~ ` +\n                            `${chunk.bufferedStart.toFixed(2)}|${currentLetter}|`;\n                }\n            }\n            else {\n                str +=\n                    `${lastChunk.bufferedEnd.toFixed(2)} ~ ` +\n                        `${chunk.bufferedStart.toFixed(2)}|${currentLetter}|`;\n            }\n            lastChunk = chunk;\n            lastLetter = currentLetter;\n        }\n    }\n    if (lastChunk !== null) {\n        str += String(lastChunk.end.toFixed(2));\n    }\n    letters.forEach((letterInfo) => {\n        var _a;\n        str +=\n            `\\n[${letterInfo.letter}] ` +\n                `P: ${letterInfo.periodId} || R: ${letterInfo.representationId}` +\n                `(${(_a = letterInfo.bitrate) !== null && _a !== void 0 ? _a : \"unknown bitrate\"})`;\n    });\n    return str;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Returns the last segment in the `inventory` which is linked to a Period\n * before `period`.\n * @param {Array.<Object>} inventory\n * @param {Object} period\n * @returns {Object|null}\n */\nexport function getLastSegmentBeforePeriod(inventory, period) {\n    for (let i = 0; i < inventory.length; i++) {\n        if (inventory[i].infos.period.start >= period.start) {\n            if (i > 0) {\n                return inventory[i - 1];\n            }\n            return null;\n        }\n    }\n    return inventory.length > 0 ? inventory[inventory.length - 1] : null;\n}\n/**\n * Returns the first segment in the `inventory` which is linked to a Period\n * after `period`.\n * @param {Array.<Object>} inventory\n * @param {Object} period\n * @returns {Object|null}\n */\nexport function getFirstSegmentAfterPeriod(inventory, period) {\n    for (const segment of inventory) {\n        if (segment.infos.period.start > period.start) {\n            return segment;\n        }\n    }\n    return null;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { MediaError } from \"../../errors\";\nimport log from \"../../log\";\nimport assert from \"../../utils/assert\";\nimport createCancellablePromise from \"../../utils/create_cancellable_promise\";\nimport isNullOrUndefined from \"../../utils/is_null_or_undefined\";\nimport noop from \"../../utils/noop\";\nimport { AudioVideoSegmentSink } from \"./implementations\";\nimport TextSegmentSink from \"./implementations/text\";\nconst POSSIBLE_BUFFER_TYPES = [\"audio\", \"video\", \"text\"];\n/**\n * Allows to easily create and dispose SegmentSinks, which are interfaces to\n * push and remove segments.\n *\n * Only one SegmentSink per type is allowed at the same time:\n *\n *   - SegmentSinks linked to a \"native\" media buffer (relying on a\n *     SourceBuffer: \"audio\" and \"video\" here) are reused if one is\n *     re-created.\n *\n *   - SegmentSinks for custom types (the other types of media) are aborted\n *     each time a new one of the same type is created.\n *\n * To be able to use a SegmentSink linked to a native media buffer, you\n * will first need to create it, but also wait until the other one is either\n * created or explicitely disabled through the `disableSegmentSink` method.\n * The Promise returned by `waitForUsableBuffers` will emit when\n * that is the case.\n *\n * @class SegmentSinksStore\n */\nexport default class SegmentSinksStore {\n    /**\n     * Returns true if the type is linked to a \"native\" media buffer (i.e. relying\n     * on a SourceBuffer object, native to the browser).\n     * Native media buffers needed for the current content must all be created\n     * before the content begins to be played and cannot be disposed during\n     * playback.\n     * @param {string} bufferType\n     * @returns {Boolean}\n     */\n    static isNative(bufferType) {\n        return shouldHaveNativeBuffer(bufferType);\n    }\n    /**\n     * @param {Object} mediaSource\n     * @constructor\n     */\n    constructor(mediaSource, hasVideo, textDisplayerInterface) {\n        this._mediaSource = mediaSource;\n        this._textInterface = textDisplayerInterface;\n        this._hasVideo = hasVideo;\n        this._initializedSegmentSinks = {};\n        this._onNativeBufferAddedOrDisabled = [];\n    }\n    /**\n     * Get all currently available buffer types.\n     * /!\\ This list can evolve at runtime depending on feature switching.\n     * @returns {Array.<string>}\n     */\n    getBufferTypes() {\n        const bufferTypes = this.getNativeBufferTypes();\n        if (this._textInterface !== null) {\n            bufferTypes.push(\"text\");\n        }\n        return bufferTypes;\n    }\n    /**\n     * Get all \"native\" buffer types that should be created before beginning to\n     * push contents.\n     * @returns {Array.<string>}\n     */\n    getNativeBufferTypes() {\n        return this._hasVideo ? [\"video\", \"audio\"] : [\"audio\"];\n    }\n    /**\n     * Returns the current \"status\" of the SegmentSink linked to the buffer\n     * type given.\n     *\n     * This function will return  an object containing a key named `type` which\n     * can be equal to either one of those three value:\n     *\n     *   - \"initialized\": A SegmentSink has been created for that type.\n     *     You will in this case also have a second key, `value`, which will\n     *     contain the related SegmentSink instance.\n     *     Please note that you will need to wait until\n     *     `this.waitForUsableBuffers()` has emitted before pushing segment\n     *     data to a SegmentSink relying on a SourceBuffer.\n     *\n     *   - \"disabled\": The SegmentSink has been explicitely disabled for this\n     *     type.\n     *\n     *   - \"uninitialized\": No action has yet been yet for that SegmentSink.\n     *\n     * @param {string} bufferType\n     * @returns {Object|null}\n     */\n    getStatus(bufferType) {\n        const initializedBuffer = this._initializedSegmentSinks[bufferType];\n        if (initializedBuffer === undefined) {\n            return { type: \"uninitialized\" };\n        }\n        if (initializedBuffer === null) {\n            return { type: \"disabled\" };\n        }\n        return { type: \"initialized\", value: initializedBuffer };\n    }\n    /**\n     * Native media buffers (audio and video) needed for playing the current\n     * content need to all be created (by creating SegmentSinks linked to them)\n     * before any one can be used.\n     *\n     * This function will return a Promise resolving when any and all native\n     * SourceBuffers can be used.\n     *\n     * From https://w3c.github.io/media-source/#methods\n     *   For example, a user agent may throw a QuotaExceededError\n     *   exception if the media element has reached the HAVE_METADATA\n     *   readyState. This can occur if the user agent's media engine\n     *   does not support adding more tracks during playback.\n     * @param {Object} cancelWaitSignal\n     * @return {Promise}\n     */\n    waitForUsableBuffers(cancelWaitSignal) {\n        if (this._areNativeBuffersUsable()) {\n            return Promise.resolve();\n        }\n        return createCancellablePromise(cancelWaitSignal, (res) => {\n            let onAddedOrDisabled = noop;\n            const removeCallback = () => {\n                const indexOf = this._onNativeBufferAddedOrDisabled.indexOf(onAddedOrDisabled);\n                if (indexOf >= 0) {\n                    this._onNativeBufferAddedOrDisabled.splice(indexOf, 1);\n                }\n            };\n            onAddedOrDisabled = () => {\n                if (this._areNativeBuffersUsable()) {\n                    removeCallback();\n                    res();\n                }\n            };\n            this._onNativeBufferAddedOrDisabled.push(onAddedOrDisabled);\n            return removeCallback;\n        });\n    }\n    /**\n     * Explicitely disable the SegmentSink for a given buffer type.\n     * A call to this function is needed at least for unused native buffer types\n     * (usually \"audio\" and \"video\"), to be able to emit through\n     * `waitForUsableBuffers` when conditions are met.\n     * @param {string} bufferType\n     */\n    disableSegmentSink(bufferType) {\n        const currentValue = this._initializedSegmentSinks[bufferType];\n        if (currentValue === null) {\n            log.warn(`SBS: The ${bufferType} SegmentSink was already disabled.`);\n            return;\n        }\n        if (currentValue !== undefined) {\n            throw new Error(\"Cannot disable an active SegmentSink.\");\n        }\n        this._initializedSegmentSinks[bufferType] = null;\n        if (SegmentSinksStore.isNative(bufferType)) {\n            this._onNativeBufferAddedOrDisabled.slice().forEach((cb) => cb());\n            assert(this._onNativeBufferAddedOrDisabled.length === 0);\n        }\n    }\n    /**\n     * Creates a new SegmentSink associated to a type.\n     * Reuse an already created one if a SegmentSink for the given type\n     * already exists.\n     *\n     * Please note that you will need to wait until `this.waitForUsableBuffers()`\n     * has emitted before pushing segment data to a SegmentSink of a native\n     * type.\n     * @param {string} bufferType\n     * @param {string} codec\n     * @returns {Object}\n     */\n    createSegmentSink(bufferType, codec) {\n        const memorizedSegmentSink = this._initializedSegmentSinks[bufferType];\n        if (shouldHaveNativeBuffer(bufferType)) {\n            if (!isNullOrUndefined(memorizedSegmentSink)) {\n                if (memorizedSegmentSink instanceof AudioVideoSegmentSink &&\n                    memorizedSegmentSink.codec !== codec) {\n                    log.warn(\"SB: Reusing native SegmentSink with codec\", memorizedSegmentSink.codec, \"for codec\", codec);\n                }\n                else {\n                    log.info(\"SB: Reusing native SegmentSink with codec\", codec);\n                }\n                return memorizedSegmentSink;\n            }\n            log.info(\"SB: Adding native SegmentSink with codec\", codec);\n            const sourceBufferType = bufferType === \"audio\" ? \"audio\" /* SourceBufferType.Audio */ : \"video\" /* SourceBufferType.Video */;\n            const nativeSegmentSink = new AudioVideoSegmentSink(sourceBufferType, codec, this._mediaSource);\n            this._initializedSegmentSinks[bufferType] = nativeSegmentSink;\n            this._onNativeBufferAddedOrDisabled.slice().forEach((cb) => cb());\n            assert(this._onNativeBufferAddedOrDisabled.length === 0);\n            return nativeSegmentSink;\n        }\n        if (!isNullOrUndefined(memorizedSegmentSink)) {\n            log.info(\"SB: Reusing a previous custom SegmentSink for the type\", bufferType);\n            return memorizedSegmentSink;\n        }\n        let segmentSink;\n        if (bufferType === \"text\") {\n            log.info(\"SB: Creating a new text SegmentSink\");\n            if (this._textInterface === null) {\n                throw new Error(\"HTML Text track feature not activated\");\n            }\n            segmentSink = new TextSegmentSink(this._textInterface);\n            this._initializedSegmentSinks.text = segmentSink;\n            return segmentSink;\n        }\n        log.error(\"SB: Unknown buffer type:\", bufferType);\n        throw new MediaError(\"BUFFER_TYPE_UNKNOWN\", \"The player wants to create a SegmentSink \" + \"of an unknown type.\");\n    }\n    /**\n     * Dispose of the active SegmentSink for the given type.\n     * @param {string} bufferType\n     */\n    disposeSegmentSink(bufferType) {\n        const memorizedSegmentSink = this._initializedSegmentSinks[bufferType];\n        if (isNullOrUndefined(memorizedSegmentSink)) {\n            log.warn(\"SB: Trying to dispose a SegmentSink that does not exist\");\n            return;\n        }\n        log.info(\"SB: Aborting SegmentSink\", bufferType);\n        memorizedSegmentSink.dispose();\n        delete this._initializedSegmentSinks[bufferType];\n    }\n    /**\n     * Dispose of all SegmentSink created on this SegmentSinksStore.\n     */\n    disposeAll() {\n        POSSIBLE_BUFFER_TYPES.forEach((bufferType) => {\n            if (this.getStatus(bufferType).type === \"initialized\") {\n                this.disposeSegmentSink(bufferType);\n            }\n        });\n    }\n    /**\n     * Returns `true` when we're ready to push and decode contents to\n     * SourceBuffers created by SegmentSinks of a native buffer type.\n     */\n    _areNativeBuffersUsable() {\n        const nativeBufferTypes = this.getNativeBufferTypes();\n        const hasUnitializedBuffers = nativeBufferTypes.some((sbType) => this._initializedSegmentSinks[sbType] === undefined);\n        if (hasUnitializedBuffers) {\n            // one is not yet initialized/disabled\n            return false;\n        }\n        const areAllDisabled = nativeBufferTypes.every((sbType) => this._initializedSegmentSinks[sbType] === null);\n        if (areAllDisabled) {\n            // they all are disabled: we can't play the content\n            return false;\n        }\n        return true;\n    }\n    createSegmentSinkMetricsForType(bufferType) {\n        var _a, _b;\n        const inventory = (_a = this._initializedSegmentSinks[bufferType]) === null || _a === void 0 ? void 0 : _a.getLastKnownInventory();\n        let sizeEstimate;\n        if (inventory !== undefined) {\n            sizeEstimate = 0;\n            for (const item of inventory) {\n                if (item.chunkSize === undefined || sizeEstimate === undefined) {\n                    sizeEstimate = undefined;\n                    break;\n                }\n                sizeEstimate += item.chunkSize;\n            }\n        }\n        return {\n            bufferType,\n            sizeEstimate,\n            codec: (_b = this._initializedSegmentSinks[bufferType]) === null || _b === void 0 ? void 0 : _b.codec,\n            segmentInventory: inventory === null || inventory === void 0 ? void 0 : inventory.map((chunk) => (Object.assign(Object.assign({}, chunk), { infos: getChunkContextSnapshot(chunk.infos) }))),\n        };\n    }\n    getSegmentSinksMetrics() {\n        return {\n            segmentSinks: {\n                audio: this.createSegmentSinkMetricsForType(\"audio\"),\n                video: this.createSegmentSinkMetricsForType(\"video\"),\n                text: this.createSegmentSinkMetricsForType(\"text\"),\n            },\n        };\n    }\n}\n/**\n * Returns true if the given buffeType has a linked SourceBuffer implementation,\n * false otherwise.\n * SourceBuffers are directly added to the MediaSource.\n * @param {string} bufferType\n * @returns {Boolean}\n */\nfunction shouldHaveNativeBuffer(bufferType) {\n    return bufferType === \"audio\" || bufferType === \"video\";\n}\nfunction getChunkContextSnapshot(context) {\n    return {\n        adaptation: context.adaptation.getMetadataSnapshot(),\n        period: context.period.getMetadataSnapshot(),\n        representation: context.representation.getMetadataSnapshot(),\n    };\n}\n","import config from \"../../../config\";\nimport { formatError } from \"../../../errors\";\nimport log from \"../../../log\";\nimport arrayIncludes from \"../../../utils/array_includes\";\nimport { assertUnreachable } from \"../../../utils/assert\";\nimport cancellableSleep from \"../../../utils/cancellable_sleep\";\nimport noop from \"../../../utils/noop\";\nimport objectAssign from \"../../../utils/object_assign\";\nimport queueMicrotask from \"../../../utils/queue_microtask\";\nimport SharedReference, { createMappedReference } from \"../../../utils/reference\";\nimport TaskCanceller from \"../../../utils/task_canceller\";\nimport RepresentationStream from \"../representation\";\nimport getRepresentationsSwitchingStrategy from \"./get_representations_switch_strategy\";\n/**\n * Create new `AdaptationStream` whose task will be to download the media data\n * for a given Adaptation (i.e. \"track\").\n *\n * It will rely on the IRepresentationEstimator to choose at any time the\n * best Representation for this Adaptation and then run the logic to download\n * and push the corresponding segments in the SegmentSink.\n *\n * @param {Object} args - Various arguments allowing the `AdaptationStream` to\n * determine which Representation to choose and which segments to load from it.\n * You can check the corresponding type for more information.\n * @param {Object} callbacks - The `AdaptationStream` relies on a system of\n * callbacks that it will call on various events.\n *\n * Depending on the event, the caller may be supposed to perform actions to\n * react upon some of them.\n *\n * This approach is taken instead of a more classical EventEmitter pattern to:\n *   - Allow callbacks to be called synchronously after the\n *     `AdaptationStream` is called.\n *   - Simplify bubbling events up, by just passing through callbacks\n *   - Force the caller to explicitely handle or not the different events.\n *\n * Callbacks may start being called immediately after the `AdaptationStream`\n * call and may be called until either the `parentCancelSignal` argument is\n * triggered, or until the `error` callback is called, whichever comes first.\n * @param {Object} parentCancelSignal - `CancellationSignal` allowing, when\n * triggered, to immediately stop all operations the `AdaptationStream` is\n * doing.\n */\nexport default function AdaptationStream({ playbackObserver, content, options, representationEstimator, segmentSink, segmentQueueCreator, wantedBufferAhead, maxVideoBufferSize, }, callbacks, parentCancelSignal) {\n    const { manifest, period, adaptation } = content;\n    /** Allows to cancel everything the `AdaptationStream` is doing. */\n    const adapStreamCanceller = new TaskCanceller();\n    adapStreamCanceller.linkToSignal(parentCancelSignal);\n    /**\n     * The buffer goal ratio base itself on the value given by `wantedBufferAhead`\n     * to determine a more dynamic buffer goal for a given Representation.\n     *\n     * It can help in cases such as : the current browser has issues with\n     * buffering and tells us that we should try to bufferize less data :\n     * https://developers.google.com/web/updates/2017/10/quotaexceedederror\n     */\n    const bufferGoalRatioMap = new Map();\n    /**\n     * Emit the currently chosen `Representation`.\n     * `null` if no Representation is chosen for now.\n     */\n    const currentRepresentation = new SharedReference(null, adapStreamCanceller.signal);\n    /** Stores the last emitted bitrate. */\n    let previouslyEmittedBitrate;\n    const initialRepIds = content.representations.getValue().representationIds;\n    const initialRepresentations = getRepresentationList(content.adaptation.representations, initialRepIds);\n    /** Emit the list of Representation for the adaptive logic. */\n    const representationsList = new SharedReference(initialRepresentations, adapStreamCanceller.signal);\n    // Start-up Adaptive logic\n    const { estimates: estimateRef, callbacks: abrCallbacks } = representationEstimator({ manifest, period, adaptation }, currentRepresentation, representationsList, playbackObserver, adapStreamCanceller.signal);\n    const isMediaSegmentQueueInterrupted = new SharedReference(false);\n    /** Update the `canLoad` ref on observation update */\n    playbackObserver.listen((observation) => {\n        var _a;\n        const observationCanStream = (_a = observation.canStream) !== null && _a !== void 0 ? _a : true;\n        if (isMediaSegmentQueueInterrupted.getValue() === observationCanStream) {\n            log.debug(\"Stream: isMediaSegmentQueueInterrupted updated to\", !observationCanStream);\n            isMediaSegmentQueueInterrupted.setValue(!observationCanStream);\n        }\n    }, { clearSignal: adapStreamCanceller.signal });\n    /** Allows a `RepresentationStream` to easily fetch media segments. */\n    const segmentQueue = segmentQueueCreator.createSegmentQueue(adaptation.type, \n    /* eslint-disable @typescript-eslint/unbound-method */\n    {\n        onRequestBegin: abrCallbacks.requestBegin,\n        onRequestEnd: abrCallbacks.requestEnd,\n        onProgress: abrCallbacks.requestProgress,\n        onMetrics: abrCallbacks.metrics,\n    }, isMediaSegmentQueueInterrupted);\n    /* eslint-enable @typescript-eslint/unbound-method */\n    /** Used to determine when \"fast-switching\" is possible. */\n    const fastSwitchThreshold = new SharedReference(0);\n    estimateRef.onUpdate(({ bitrate, knownStableBitrate }) => {\n        if (options.enableFastSwitching) {\n            fastSwitchThreshold.setValueIfChanged(knownStableBitrate);\n        }\n        if (bitrate === undefined || bitrate === previouslyEmittedBitrate) {\n            return;\n        }\n        previouslyEmittedBitrate = bitrate;\n        log.debug(`Stream: new ${adaptation.type} bitrate estimate`, bitrate);\n        callbacks.bitrateEstimateChange({ type: adaptation.type, bitrate });\n    }, { emitCurrentValue: true, clearSignal: adapStreamCanceller.signal });\n    /**\n     * When triggered, cancel all `RepresentationStream`s currently created.\n     * Set to `undefined` initially.\n     */\n    let cancelCurrentStreams;\n    // Each time the list of wanted Representations changes, we restart the logic\n    content.representations.onUpdate((val) => {\n        if (cancelCurrentStreams !== undefined) {\n            cancelCurrentStreams.cancel();\n        }\n        const newRepIds = content.representations.getValue().representationIds;\n        // NOTE: We expect that the rest of the RxPlayer code is already handling\n        // cases where the list of playable `Representation` changes:\n        // decipherability updates, \"`Representation` avoidance\" etc.\n        const newRepresentations = getRepresentationList(content.adaptation.representations, newRepIds);\n        representationsList.setValueIfChanged(newRepresentations);\n        cancelCurrentStreams = new TaskCanceller();\n        cancelCurrentStreams.linkToSignal(adapStreamCanceller.signal);\n        onRepresentationsChoiceChange(val, cancelCurrentStreams.signal).catch((err) => {\n            if ((cancelCurrentStreams === null || cancelCurrentStreams === void 0 ? void 0 : cancelCurrentStreams.isUsed()) === true &&\n                TaskCanceller.isCancellationError(err)) {\n                return;\n            }\n            adapStreamCanceller.cancel();\n            callbacks.error(err);\n        });\n    }, { clearSignal: adapStreamCanceller.signal, emitCurrentValue: true });\n    return;\n    /**\n     * Function called each time the list of wanted Representations is updated.\n     *\n     * Returns a Promise to profit from async/await syntax. The Promise resolution\n     * does not indicate anything. The Promise may reject however, either on some\n     * error or on some cancellation.\n     * @param {Object} choice - The last Representations choice that has been\n     * made.\n     * @param {Object} fnCancelSignal - `CancellationSignal` allowing to cancel\n     * everything this function is doing and free all related resources.\n     */\n    async function onRepresentationsChoiceChange(choice, fnCancelSignal) {\n        // First check if we should perform any action regarding what was previously\n        // in the buffer\n        const switchStrat = getRepresentationsSwitchingStrategy(period, adaptation, choice, segmentSink, playbackObserver);\n        switch (switchStrat.type) {\n            case \"continue\":\n                break; // nothing to do\n            case \"needs-reload\": // Just ask to reload\n                // We begin by scheduling a micro-task to reduce the possibility of race\n                // conditions where the inner logic would be called synchronously before\n                // the next observation (which may reflect very different playback conditions)\n                // is actually received.\n                return queueMicrotask(() => {\n                    playbackObserver.listen(() => {\n                        if (fnCancelSignal.isCancelled()) {\n                            return;\n                        }\n                        const { DELTA_POSITION_AFTER_RELOAD } = config.getCurrent();\n                        const timeOffset = DELTA_POSITION_AFTER_RELOAD.bitrateSwitch;\n                        return callbacks.waitingMediaSourceReload({\n                            bufferType: adaptation.type,\n                            period,\n                            timeOffset,\n                            stayInPeriod: true,\n                        });\n                    }, { includeLastObservation: true, clearSignal: fnCancelSignal });\n                });\n            case \"flush-buffer\": // Clean + flush\n            case \"clean-buffer\": // Just clean\n                for (const range of switchStrat.value) {\n                    await segmentSink.removeBuffer(range.start, range.end);\n                    if (fnCancelSignal.isCancelled()) {\n                        return;\n                    }\n                }\n                if (switchStrat.type === \"flush-buffer\") {\n                    callbacks.needsBufferFlush();\n                    if (fnCancelSignal.isCancelled()) {\n                        return;\n                    }\n                }\n                break;\n            default: // Should be impossible\n                assertUnreachable(switchStrat);\n        }\n        recursivelyCreateRepresentationStreams(fnCancelSignal);\n    }\n    /**\n     * Create `RepresentationStream`s starting with the Representation of the last\n     * estimate performed.\n     * Each time a new estimate is made, this function will create a new\n     * `RepresentationStream` corresponding to that new estimate.\n     * @param {Object} fnCancelSignal - `CancellationSignal` which will abort\n     * anything this function is doing and free allocated resources.\n     */\n    function recursivelyCreateRepresentationStreams(fnCancelSignal) {\n        /**\n         * `TaskCanceller` triggered when the current `RepresentationStream` is\n         * terminating and as such the next one might be immediately created\n         * recursively.\n         */\n        const repStreamTerminatingCanceller = new TaskCanceller();\n        repStreamTerminatingCanceller.linkToSignal(fnCancelSignal);\n        const { representation } = estimateRef.getValue();\n        if (representation === null) {\n            return;\n        }\n        /**\n         * Stores the last estimate emitted, starting with `null`.\n         * This allows to easily rely on that value in inner Observables which might also\n         * need the last already-considered value.\n         */\n        const terminateCurrentStream = new SharedReference(null, repStreamTerminatingCanceller.signal);\n        /** Allows to stop listening to estimateRef on the following line. */\n        estimateRef.onUpdate((estimate) => {\n            if (estimate.representation === null ||\n                estimate.representation.id === representation.id) {\n                return;\n            }\n            if (estimate.urgent) {\n                log.info(\"Stream: urgent Representation switch\", adaptation.type);\n                return terminateCurrentStream.setValue({ urgent: true });\n            }\n            else {\n                log.info(\"Stream: slow Representation switch\", adaptation.type);\n                return terminateCurrentStream.setValue({ urgent: false });\n            }\n        }, {\n            clearSignal: repStreamTerminatingCanceller.signal,\n            emitCurrentValue: true,\n        });\n        const repInfo = {\n            type: adaptation.type,\n            adaptation,\n            period,\n            representation,\n        };\n        currentRepresentation.setValue(representation);\n        if (fnCancelSignal.isCancelled()) {\n            return; // previous callback has stopped everything by side-effect\n        }\n        callbacks.representationChange(repInfo);\n        if (fnCancelSignal.isCancelled()) {\n            return; // previous callback has stopped everything by side-effect\n        }\n        const representationStreamCallbacks = {\n            streamStatusUpdate: callbacks.streamStatusUpdate,\n            encryptionDataEncountered: callbacks.encryptionDataEncountered,\n            manifestMightBeOufOfSync: callbacks.manifestMightBeOufOfSync,\n            needsManifestRefresh: callbacks.needsManifestRefresh,\n            inbandEvent: callbacks.inbandEvent,\n            warning: callbacks.warning,\n            error(err) {\n                adapStreamCanceller.cancel();\n                callbacks.error(err);\n            },\n            addedSegment(segmentInfo) {\n                abrCallbacks.addedSegment(segmentInfo);\n            },\n            terminating() {\n                if (repStreamTerminatingCanceller.isUsed()) {\n                    return; // Already handled\n                }\n                repStreamTerminatingCanceller.cancel();\n                return recursivelyCreateRepresentationStreams(fnCancelSignal);\n            },\n        };\n        createRepresentationStream(representation, terminateCurrentStream, representationStreamCallbacks, fnCancelSignal);\n    }\n    /**\n     * Create and returns a new `RepresentationStream`, linked to the\n     * given Representation.\n     * @param {Object} representation - The Representation the\n     * `RepresentationStream` has to be created for.\n     * @param {Object} terminateCurrentStream - Gives termination orders,\n     * indicating that the `RepresentationStream` should stop what it's doing.\n     * @param {Object} representationStreamCallbacks - Callbacks to call on\n     * various `RepresentationStream` events.\n     * @param {Object} fnCancelSignal - `CancellationSignal` which will abort\n     * anything this function is doing and free allocated resources.\n     */\n    function createRepresentationStream(representation, terminateCurrentStream, representationStreamCallbacks, fnCancelSignal) {\n        /** Set to `true` if we've encountered an error with this `RepresentationStream` */\n        let hasEncounteredError = false;\n        const bufferGoalCanceller = new TaskCanceller();\n        bufferGoalCanceller.linkToSignal(fnCancelSignal);\n        /** Actually built buffer size, in seconds. */\n        const bufferGoal = createMappedReference(wantedBufferAhead, (prev) => {\n            return getBufferGoal(representation, prev);\n        }, bufferGoalCanceller.signal);\n        const maxBufferSize = adaptation.type === \"video\" ? maxVideoBufferSize : new SharedReference(Infinity);\n        log.info(\"Stream: changing representation\", adaptation.type, representation.id, representation.bitrate);\n        const updatedCallbacks = objectAssign({}, representationStreamCallbacks, {\n            error(err) {\n                var _a;\n                if (hasEncounteredError) {\n                    // A RepresentationStream might trigger multiple Errors (for example\n                    // multiple segments it tried to push at once led to errors).\n                    // In that case, we'll only consider the first Error.\n                    //\n                    // That could mean that we're hiding legitimate issues but handling\n                    // multiple of those errors at once is too hard a task for now.\n                    log.warn(\"Stream: Ignoring RepresentationStream error\", err);\n                    return;\n                }\n                hasEncounteredError = true;\n                const formattedError = formatError(err, {\n                    defaultCode: \"NONE\",\n                    defaultReason: \"Unknown `RepresentationStream` error\",\n                });\n                if (formattedError.code !== \"BUFFER_FULL_ERROR\") {\n                    representationStreamCallbacks.error(err);\n                }\n                else {\n                    log.warn(\"Stream: received BUFFER_FULL_ERROR\", adaptation.type, representation.bitrate);\n                    const wba = wantedBufferAhead.getValue();\n                    const lastBufferGoalRatio = (_a = bufferGoalRatioMap.get(representation.id)) !== null && _a !== void 0 ? _a : 1;\n                    // 70%, 49%, 34.3%, 24%, 16.81%, 11.76%, 8.24% and 5.76%\n                    const newBufferGoalRatio = lastBufferGoalRatio * 0.7;\n                    bufferGoalRatioMap.set(representation.id, newBufferGoalRatio);\n                    if (newBufferGoalRatio <= 0.05 || getBufferGoal(representation, wba) <= 2) {\n                        representationStreamCallbacks.error(formattedError);\n                        return;\n                    }\n                    // We wait 4 seconds to let the situation evolve by itself before\n                    // retrying loading segments with a lower buffer goal\n                    cancellableSleep(4000, fnCancelSignal)\n                        .then(() => {\n                        return createRepresentationStream(representation, terminateCurrentStream, representationStreamCallbacks, fnCancelSignal);\n                    })\n                        .catch(noop);\n                }\n            },\n            terminating() {\n                bufferGoalCanceller.cancel();\n                representationStreamCallbacks.terminating();\n            },\n        });\n        RepresentationStream({\n            playbackObserver,\n            content: { representation, adaptation, period, manifest },\n            segmentSink,\n            segmentQueue,\n            terminate: terminateCurrentStream,\n            options: {\n                bufferGoal,\n                maxBufferSize,\n                drmSystemId: options.drmSystemId,\n                fastSwitchThreshold,\n            },\n        }, updatedCallbacks, fnCancelSignal);\n        // reload if the Representation disappears from the Manifest\n        manifest.addEventListener(\"manifestUpdate\", (updates) => {\n            for (const element of updates.updatedPeriods) {\n                if (element.period.id === period.id) {\n                    for (const updated of element.result.updatedAdaptations) {\n                        if (updated.adaptation === adaptation.id) {\n                            for (const rep of updated.removedRepresentations) {\n                                if (rep === representation.id) {\n                                    if (fnCancelSignal.isCancelled()) {\n                                        return;\n                                    }\n                                    return callbacks.waitingMediaSourceReload({\n                                        bufferType: adaptation.type,\n                                        period,\n                                        timeOffset: 0,\n                                        stayInPeriod: true,\n                                    });\n                                }\n                            }\n                        }\n                    }\n                }\n                else if (element.period.start > period.start) {\n                    break;\n                }\n            }\n        }, fnCancelSignal);\n    }\n    /**\n     * Returns how much media data should be pre-buffered for this\n     * `Representation`, according to the `wantedBufferAhead` setting and previous\n     * issues encountered with that `Representation`.\n     * @param {Object} representation - The `Representation` you want to buffer.\n     * @param {number} wba - The value of `wantedBufferAhead` set by the user.\n     * @returns {number}\n     */\n    function getBufferGoal(representation, wba) {\n        const oldBufferGoalRatio = bufferGoalRatioMap.get(representation.id);\n        const bufferGoalRatio = oldBufferGoalRatio !== undefined ? oldBufferGoalRatio : 1;\n        if (oldBufferGoalRatio === undefined) {\n            bufferGoalRatioMap.set(representation.id, bufferGoalRatio);\n        }\n        if (bufferGoalRatio < 1 && wba === Infinity) {\n            // When `wba` is equal to `Infinity`, dividing it will still make it equal\n            // to `Infinity`. To make the `bufferGoalRatio` still have an effect, we\n            // just starts from a `wba` set to the high value of 5 minutes.\n            return 5 * 60 * 1000 * bufferGoalRatio;\n        }\n        return wba * bufferGoalRatio;\n    }\n}\n/**\n * Construct the list of the `Representation` to play, based on what's supported\n * and what the API seem to authorize.\n * @param {Array.<Object>} availableRepresentations - All available\n * Representation in the current `Adaptation`, including unsupported ones.\n * @param {Array.<string>} authorizedRepIds - The subset of `Representation`\n * that the API authorize us to play.\n * @returns {Array.<Object>}\n */\nfunction getRepresentationList(availableRepresentations, authorizedRepIds) {\n    const filteredRepresentations = availableRepresentations.filter((r) => arrayIncludes(authorizedRepIds, r.id) &&\n        !r.shouldBeAvoided &&\n        r.isPlayable() !== false);\n    if (filteredRepresentations.length > 0) {\n        return filteredRepresentations;\n    }\n    // Retry without \"`Representation` avoidance\"\n    return availableRepresentations.filter((r) => arrayIncludes(authorizedRepIds, r.id) && r.isPlayable() !== false);\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport config from \"../../../config\";\nimport arrayIncludes from \"../../../utils/array_includes\";\nimport { excludeFromRanges, insertInto } from \"../../../utils/ranges\";\nimport { getFirstSegmentAfterPeriod, getLastSegmentBeforePeriod, SegmentSinkOperation, } from \"../../segment_sinks\";\nexport default function getRepresentationsSwitchingStrategy(period, adaptation, settings, segmentSink, playbackObserver) {\n    var _a, _b, _c, _d;\n    if (settings.switchingMode === \"lazy\") {\n        return { type: \"continue\", value: undefined };\n    }\n    const inventory = segmentSink.getLastKnownInventory();\n    const unwantedRange = [];\n    for (const elt of inventory) {\n        if (elt.infos.period.id === period.id &&\n            (elt.infos.adaptation.id !== adaptation.id ||\n                !arrayIncludes(settings.representationIds, elt.infos.representation.id))) {\n            insertInto(unwantedRange, {\n                start: (_a = elt.bufferedStart) !== null && _a !== void 0 ? _a : elt.start,\n                end: (_b = elt.bufferedEnd) !== null && _b !== void 0 ? _b : elt.end,\n            });\n        }\n    }\n    const pendingOperations = segmentSink.getPendingOperations();\n    for (const operation of pendingOperations) {\n        if (operation.type === SegmentSinkOperation.Push) {\n            const info = operation.value.inventoryInfos;\n            if (info.period.id === period.id &&\n                (info.adaptation.id !== adaptation.id ||\n                    !arrayIncludes(settings.representationIds, info.representation.id))) {\n                const start = info.segment.time;\n                const end = start + info.segment.duration;\n                insertInto(unwantedRange, { start, end });\n            }\n        }\n    }\n    // Continue if we have no other Adaptation buffered in the current Period\n    if (unwantedRange.length === 0) {\n        return { type: \"continue\", value: undefined };\n    }\n    if (settings.switchingMode === \"reload\") {\n        const readyState = playbackObserver.getReadyState();\n        if (readyState === undefined || readyState > 1) {\n            return { type: \"needs-reload\", value: undefined };\n        }\n    }\n    // From here, clean-up data from the previous Adaptation, if one\n    const shouldFlush = settings.switchingMode === \"direct\";\n    const rangesToExclude = [];\n    // First, we don't want to accidentally remove some segments from the previous\n    // Period (which overlap a little with this one)\n    /** Last segment before one for the current period. */\n    const lastSegmentBefore = getLastSegmentBeforePeriod(inventory, period);\n    if (lastSegmentBefore !== null &&\n        (lastSegmentBefore.bufferedEnd === undefined ||\n            period.start - lastSegmentBefore.bufferedEnd < 1)) {\n        // Close to Period's start\n        // Exclude data close to the period's start to avoid cleaning\n        // to much\n        rangesToExclude.push({ start: 0, end: period.start + 1 });\n    }\n    if (!shouldFlush) {\n        // exclude data around current position to avoid decoding issues\n        const { ADAP_REP_SWITCH_BUFFER_PADDINGS } = config.getCurrent();\n        const bufferType = adaptation.type;\n        /** Ranges that won't be cleaned from the current buffer. */\n        const paddingBefore = (_c = ADAP_REP_SWITCH_BUFFER_PADDINGS[bufferType].before) !== null && _c !== void 0 ? _c : 0;\n        const paddingAfter = (_d = ADAP_REP_SWITCH_BUFFER_PADDINGS[bufferType].after) !== null && _d !== void 0 ? _d : 0;\n        let currentTime = playbackObserver.getCurrentTime();\n        if (currentTime === undefined) {\n            // TODO current position might be old. A better solution should be found.\n            const lastObservation = playbackObserver.getReference().getValue();\n            currentTime = lastObservation.position.getPolled();\n        }\n        rangesToExclude.push({\n            start: currentTime - paddingBefore,\n            end: currentTime + paddingAfter,\n        });\n    }\n    // Now remove possible small range from the end if there is a segment from the\n    // next Period\n    if (period.end !== undefined) {\n        /** first segment after for the current period. */\n        const firstSegmentAfter = getFirstSegmentAfterPeriod(inventory, period);\n        if (firstSegmentAfter !== null &&\n            (firstSegmentAfter.bufferedStart === undefined ||\n                // Close to Period's end\n                firstSegmentAfter.bufferedStart - period.end < 1)) {\n            rangesToExclude.push({ start: period.end - 1, end: Number.MAX_VALUE });\n        }\n    }\n    const toRemove = excludeFromRanges(unwantedRange, rangesToExclude);\n    if (toRemove.length === 0) {\n        return { type: \"continue\", value: undefined };\n    }\n    return shouldFlush\n        ? { type: \"flush-buffer\", value: toRemove }\n        : { type: \"clean-buffer\", value: toRemove };\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport AdaptationStream from \"./adaptation_stream\";\nexport default AdaptationStream;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport StreamOrchestrator from \"./orchestrator\";\nexport default StreamOrchestrator;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../../log\";\n/**\n * Returns the buffered ranges which hold the given content.\n * Returns the whole buffered ranges if some of it is unknown.\n * @param {Object} segmentSink\n * @param {Array.<Object>} contents\n * @returns {Array.<Object>}\n */\nexport default function getTimeRangesForContent(segmentSink, contents) {\n    if (contents.length === 0) {\n        return [];\n    }\n    const accumulator = [];\n    const inventory = segmentSink.getLastKnownInventory();\n    for (const chunk of inventory) {\n        const hasContent = contents.some((content) => {\n            return (chunk.infos.period.id === content.period.id &&\n                chunk.infos.adaptation.id === content.adaptation.id &&\n                chunk.infos.representation.id === content.representation.id);\n        });\n        if (hasContent) {\n            const { bufferedStart, bufferedEnd } = chunk;\n            if (bufferedStart === undefined || bufferedEnd === undefined) {\n                log.warn(\"SO: No buffered start or end found from a segment.\");\n                return [{ start: 0, end: Number.MAX_VALUE }];\n            }\n            const previousLastElement = accumulator[accumulator.length - 1];\n            if (previousLastElement !== undefined &&\n                previousLastElement.end === bufferedStart) {\n                previousLastElement.end = bufferedEnd;\n            }\n            else {\n                accumulator.push({ start: bufferedStart, end: bufferedEnd });\n            }\n        }\n    }\n    return accumulator;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport StreamOrchestrator from \"./stream_orchestrator\";\nexport default StreamOrchestrator;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport config from \"../../../config\";\nimport { MediaError } from \"../../../errors\";\nimport log from \"../../../log\";\nimport isNullOrUndefined from \"../../../utils/is_null_or_undefined\";\nimport queueMicrotask from \"../../../utils/queue_microtask\";\nimport { createMappedReference } from \"../../../utils/reference\";\nimport SortedList from \"../../../utils/sorted_list\";\nimport TaskCanceller from \"../../../utils/task_canceller\";\nimport WeakMapMemory from \"../../../utils/weak_map_memory\";\nimport { BufferGarbageCollector } from \"../../segment_sinks\";\nimport PeriodStream from \"../period\";\nimport getTimeRangesForContent from \"./get_time_ranges_for_content\";\n/**\n * Create and manage the various \"Streams\" needed for the content to\n * play:\n *\n *   - Create or dispose SegmentSinks depending on the chosen Adaptations.\n *\n *   - Push the right segments to those SegmentSinks depending on the user's\n *     preferences, the current position, the bandwidth, the decryption\n *     conditions...\n *\n *   - Concatenate Streams for adaptation from separate Periods at the right\n *     time, to allow smooth transitions between periods.\n *\n *   - Call various callbacks to notify of its health and issues\n *\n * @param {Object} content\n * @param {Object} playbackObserver - Emit position information\n * @param {Object} representationEstimator - Emit bitrate estimates and best\n * Representation to play.\n * @param {Object} segmentSinksStore - Will be used to lazily create\n * SegmentSink instances associated with the current content.\n * @param {Object} segmentQueueCreator - Allow to download segments.\n * @param {Object} options\n * @param {Object} callbacks - The `StreamOrchestrator` relies on a system of\n * callbacks that it will call on various events.\n *\n * Depending on the event, the caller may be supposed to perform actions to\n * react upon some of them.\n *\n * This approach is taken instead of a more classical EventEmitter pattern to:\n *   - Allow callbacks to be called synchronously after the\n *     `StreamOrchestrator` is called.\n *   - Simplify bubbling events up, by just passing through callbacks\n *   - Force the caller to explicitely handle or not the different events.\n *\n * Callbacks may start being called immediately after the `StreamOrchestrator`\n * call and may be called until either the `parentCancelSignal` argument is\n * triggered, or until the `error` callback is called, whichever comes first.\n * @param {Object} orchestratorCancelSignal - `CancellationSignal` allowing,\n * when triggered, to immediately stop all operations the `PeriodStream` is\n * doing.\n */\nexport default function StreamOrchestrator(content, playbackObserver, representationEstimator, segmentSinksStore, segmentQueueCreator, options, callbacks, orchestratorCancelSignal) {\n    const { manifest, initialPeriod } = content;\n    const { maxBufferAhead, maxBufferBehind, wantedBufferAhead, maxVideoBufferSize } = options;\n    const { MINIMUM_MAX_BUFFER_AHEAD, MAXIMUM_MAX_BUFFER_AHEAD, MAXIMUM_MAX_BUFFER_BEHIND, } = config.getCurrent();\n    // Keep track of a unique BufferGarbageCollector created per\n    // SegmentSink.\n    const garbageCollectors = new WeakMapMemory((segmentSink) => {\n        var _a, _b;\n        const { bufferType } = segmentSink;\n        const defaultMaxBehind = (_a = MAXIMUM_MAX_BUFFER_BEHIND[bufferType]) !== null && _a !== void 0 ? _a : Infinity;\n        const maxAheadHigherBound = (_b = MAXIMUM_MAX_BUFFER_AHEAD[bufferType]) !== null && _b !== void 0 ? _b : Infinity;\n        return (gcCancelSignal) => {\n            BufferGarbageCollector({\n                segmentSink,\n                playbackObserver,\n                maxBufferBehind: createMappedReference(maxBufferBehind, (val) => Math.min(val, defaultMaxBehind), gcCancelSignal),\n                maxBufferAhead: createMappedReference(maxBufferAhead, (val) => {\n                    var _a;\n                    const lowerBound = Math.max(val, (_a = MINIMUM_MAX_BUFFER_AHEAD[bufferType]) !== null && _a !== void 0 ? _a : 0);\n                    return Math.min(lowerBound, maxAheadHigherBound);\n                }, gcCancelSignal),\n            }, gcCancelSignal);\n        };\n    });\n    // Create automatically the right `PeriodStream` for every possible types\n    for (const bufferType of segmentSinksStore.getBufferTypes()) {\n        manageEveryStreams(bufferType, initialPeriod);\n    }\n    /**\n     * Manage creation and removal of Streams for every Periods for a given type.\n     *\n     * Works by creating consecutive Streams through the\n     * `manageConsecutivePeriodStreams` function, and restarting it when the\n     * current position goes out of the bounds of these Streams.\n     * @param {string} bufferType - e.g. \"audio\" or \"video\"\n     * @param {Period} basePeriod - Initial Period downloaded.\n     */\n    function manageEveryStreams(bufferType, basePeriod) {\n        /** Each Period for which there is currently a Stream, chronologically */\n        const periodList = new SortedList((a, b) => a.start - b.start);\n        /**\n         * When set to `true`, all the currently active PeriodStream will be destroyed\n         * and re-created from the new current position if we detect it to be out of\n         * their bounds.\n         * This is set to false when we're in the process of creating the first\n         * PeriodStream, to avoid interferences while no PeriodStream is available.\n         */\n        let enableOutOfBoundsCheck = false;\n        /** Cancels currently created `PeriodStream`s. */\n        let currentCanceller = new TaskCanceller();\n        currentCanceller.linkToSignal(orchestratorCancelSignal);\n        // Restart the current Stream when the wanted time is in another period\n        // than the ones already considered\n        playbackObserver.listen(({ position }) => {\n            var _a;\n            const time = position.getWanted();\n            if (!enableOutOfBoundsCheck || !isOutOfPeriodList(time)) {\n                return;\n            }\n            log.info(\"Stream: Destroying all PeriodStreams due to out of bounds situation\", bufferType, time);\n            enableOutOfBoundsCheck = false;\n            while (periodList.length() > 0) {\n                const period = periodList.get(periodList.length() - 1);\n                periodList.removeElement(period);\n                callbacks.periodStreamCleared({ type: bufferType, manifest, period });\n            }\n            currentCanceller.cancel();\n            currentCanceller = new TaskCanceller();\n            currentCanceller.linkToSignal(orchestratorCancelSignal);\n            const nextPeriod = (_a = manifest.getPeriodForTime(time)) !== null && _a !== void 0 ? _a : manifest.getNextPeriod(time);\n            if (nextPeriod === undefined) {\n                log.warn(\"Stream: The wanted position is not found in the Manifest.\");\n                enableOutOfBoundsCheck = true;\n                return;\n            }\n            launchConsecutiveStreamsForPeriod(nextPeriod);\n        }, { clearSignal: orchestratorCancelSignal, includeLastObservation: true });\n        manifest.addEventListener(\"decipherabilityUpdate\", (evt) => {\n            if (orchestratorCancelSignal.isCancelled()) {\n                return;\n            }\n            onDecipherabilityUpdates(evt).catch((err) => {\n                if (orchestratorCancelSignal.isCancelled()) {\n                    return;\n                }\n                currentCanceller.cancel();\n                callbacks.error(err);\n            });\n        }, orchestratorCancelSignal);\n        return launchConsecutiveStreamsForPeriod(basePeriod);\n        /**\n         * @param {Object} period\n         */\n        function launchConsecutiveStreamsForPeriod(period) {\n            const consecutivePeriodStreamCb = Object.assign(Object.assign({}, callbacks), { waitingMediaSourceReload(payload) {\n                    // Only reload the MediaSource when the more immediately required\n                    // Period is the one it is asked for\n                    const firstPeriod = periodList.head();\n                    if (firstPeriod === undefined || firstPeriod.id !== payload.period.id) {\n                        callbacks.lockedStream({\n                            bufferType: payload.bufferType,\n                            period: payload.period,\n                        });\n                    }\n                    else {\n                        callbacks.needsMediaSourceReload({\n                            timeOffset: payload.timeOffset,\n                            minimumPosition: payload.stayInPeriod ? payload.period.start : undefined,\n                            maximumPosition: payload.stayInPeriod ? payload.period.end : undefined,\n                        });\n                    }\n                },\n                periodStreamReady(payload) {\n                    enableOutOfBoundsCheck = true;\n                    periodList.add(payload.period);\n                    callbacks.periodStreamReady(payload);\n                },\n                periodStreamCleared(payload) {\n                    periodList.removeElement(payload.period);\n                    callbacks.periodStreamCleared(payload);\n                },\n                error(err) {\n                    currentCanceller.cancel();\n                    callbacks.error(err);\n                } });\n            manageConsecutivePeriodStreams(bufferType, period, consecutivePeriodStreamCb, currentCanceller.signal);\n        }\n        /**\n         * Returns true if the given time is either:\n         *   - less than the start of the chronologically first Period\n         *   - more than the end of the chronologically last Period\n         * @param {number} time\n         * @returns {boolean}\n         */\n        function isOutOfPeriodList(time) {\n            const head = periodList.head();\n            const last = periodList.last();\n            if (head === undefined || last === undefined) {\n                // if no period\n                return true;\n            }\n            return (head.start > time || (isNullOrUndefined(last.end) ? Infinity : last.end) < time);\n        }\n        /**\n         * React to a Manifest's decipherability updates.\n         * @param {Array.<Object>} updates\n         * @returns {Promise}\n         */\n        async function onDecipherabilityUpdates(updates) {\n            const segmentSinkStatus = segmentSinksStore.getStatus(bufferType);\n            const ofCurrentType = updates.filter((update) => update.adaptation.type === bufferType);\n            if (\n            // No update concerns the current type of data\n            ofCurrentType.length === 0 ||\n                segmentSinkStatus.type !== \"initialized\" ||\n                // The update only notifies of now-decipherable streams\n                ofCurrentType.every((x) => x.representation.decipherable === true)) {\n                // Data won't have to be removed from the buffers, no need to stop the\n                // current Streams.\n                return;\n            }\n            const segmentSink = segmentSinkStatus.value;\n            const resettedContent = ofCurrentType.filter((update) => update.representation.decipherable === undefined);\n            const undecipherableContent = ofCurrentType.filter((update) => update.representation.decipherable === false);\n            /**\n             * Time ranges now containing undecipherable content.\n             * Those should first be removed and, depending on the platform, may\n             * need Supplementary actions as playback issues may remain even after\n             * removal.\n             */\n            const undecipherableRanges = getTimeRangesForContent(segmentSink, undecipherableContent);\n            /**\n             * Time ranges now containing content whose decipherability status came\n             * back to being unknown.\n             * To simplify its handling, those are just removed from the buffer.\n             * Less considerations have to be taken than for the `undecipherableRanges`.\n             */\n            const rangesToRemove = getTimeRangesForContent(segmentSink, resettedContent);\n            // First close all Stream currently active so they don't continue to\n            // load and push segments.\n            enableOutOfBoundsCheck = false;\n            log.info(\"Stream: Destroying all PeriodStreams for decipherability matters\", bufferType);\n            while (periodList.length() > 0) {\n                const period = periodList.get(periodList.length() - 1);\n                periodList.removeElement(period);\n                callbacks.periodStreamCleared({ type: bufferType, manifest, period });\n            }\n            currentCanceller.cancel();\n            currentCanceller = new TaskCanceller();\n            currentCanceller.linkToSignal(orchestratorCancelSignal);\n            /** Remove from the `SegmentSink` all the concerned time ranges. */\n            for (const { start, end } of [...undecipherableRanges, ...rangesToRemove]) {\n                if (orchestratorCancelSignal.isCancelled()) {\n                    return;\n                }\n                if (start < end) {\n                    if (orchestratorCancelSignal.isCancelled()) {\n                        return;\n                    }\n                    await segmentSink.removeBuffer(start, end);\n                }\n            }\n            // Schedule micro task before checking the last playback observation\n            // to reduce the risk of race conditions where the next observation\n            // was going to be emitted synchronously.\n            queueMicrotask(() => {\n                if (orchestratorCancelSignal.isCancelled()) {\n                    return;\n                }\n                const observation = playbackObserver.getReference().getValue();\n                if (needsFlushingAfterClean(observation, undecipherableRanges)) {\n                    // Bind to Period start and end\n                    callbacks.needsDecipherabilityFlush();\n                    if (orchestratorCancelSignal.isCancelled()) {\n                        return;\n                    }\n                }\n                else if (needsFlushingAfterClean(observation, rangesToRemove)) {\n                    callbacks.needsBufferFlush();\n                    if (orchestratorCancelSignal.isCancelled()) {\n                        return;\n                    }\n                }\n                const lastPosition = observation.position.getWanted();\n                const newInitialPeriod = manifest.getPeriodForTime(lastPosition);\n                if (newInitialPeriod === undefined) {\n                    callbacks.error(new MediaError(\"MEDIA_TIME_NOT_FOUND\", \"The wanted position is not found in the Manifest.\"));\n                    return;\n                }\n                launchConsecutiveStreamsForPeriod(newInitialPeriod);\n            });\n        }\n    }\n    /**\n     * Create lazily consecutive PeriodStreams:\n     *\n     * It first creates the `PeriodStream` for `basePeriod` and - once it becomes\n     * full - automatically creates the next chronological one.\n     * This process repeats until the `PeriodStream` linked to the last Period is\n     * full.\n     *\n     * If an \"old\" `PeriodStream` becomes active again, it destroys all\n     * `PeriodStream` coming after it (from the last chronological one to the\n     * first).\n     *\n     * To clean-up PeriodStreams, each one of them are also automatically\n     * destroyed once the current position is superior or equal to the end of\n     * the concerned Period.\n     *\n     * The \"periodStreamReady\" callback is alled each times a new `PeriodStream`\n     * is created.\n     *\n     * The \"periodStreamCleared\" callback is called each times a PeriodStream is\n     * destroyed (this callback is though not called if it was destroyed due to\n     * the given `cancelSignal` emitting or due to a fatal error).\n     * @param {string} bufferType - e.g. \"audio\" or \"video\"\n     * @param {Period} basePeriod - Initial Period downloaded.\n     * @param {Object} consecutivePeriodStreamCb - Callbacks called on various\n     * events. See type for more information.\n     * @param {Object} cancelSignal - `CancellationSignal` allowing to stop\n     * everything that this function was doing. Callbacks in\n     * `consecutivePeriodStreamCb` might still be sent as a consequence of this\n     * signal emitting.\n     */\n    function manageConsecutivePeriodStreams(bufferType, basePeriod, consecutivePeriodStreamCb, cancelSignal) {\n        log.info(\"Stream: Creating new Stream for\", bufferType, basePeriod.start);\n        /**\n         * Contains properties linnked to the next chronological `PeriodStream` that\n         * may be created here.\n         */\n        let nextStreamInfo = null;\n        /** Emits when the `PeriodStream` linked to `basePeriod` should be destroyed. */\n        const currentStreamCanceller = new TaskCanceller();\n        currentStreamCanceller.linkToSignal(cancelSignal);\n        // Stop current PeriodStream when the current position goes over the end of\n        // that Period.\n        playbackObserver.listen(({ position }, stopListeningObservations) => {\n            if (basePeriod.end !== undefined && position.getWanted() >= basePeriod.end) {\n                const nextPeriod = manifest.getPeriodAfter(basePeriod);\n                // Handle special wantedPosition === basePeriod.end cases\n                if (basePeriod.containsTime(position.getWanted(), nextPeriod)) {\n                    return;\n                }\n                log.info(\"Stream: Destroying PeriodStream as the current playhead moved above it\", bufferType, basePeriod.start, position.getWanted(), basePeriod.end);\n                stopListeningObservations();\n                consecutivePeriodStreamCb.periodStreamCleared({\n                    type: bufferType,\n                    manifest,\n                    period: basePeriod,\n                });\n                currentStreamCanceller.cancel();\n            }\n        }, { clearSignal: cancelSignal, includeLastObservation: true });\n        const periodStreamArgs = {\n            bufferType,\n            content: { manifest, period: basePeriod },\n            garbageCollectors,\n            maxVideoBufferSize,\n            segmentQueueCreator,\n            segmentSinksStore,\n            options,\n            playbackObserver,\n            representationEstimator,\n            wantedBufferAhead,\n        };\n        const periodStreamCallbacks = Object.assign(Object.assign({}, consecutivePeriodStreamCb), { streamStatusUpdate(value) {\n                if (value.hasFinishedLoading) {\n                    const nextPeriod = manifest.getPeriodAfter(basePeriod);\n                    if (nextPeriod !== null) {\n                        // current Stream is full, create the next one if not\n                        checkOrCreateNextPeriodStream(nextPeriod);\n                    }\n                }\n                else if (nextStreamInfo !== null) {\n                    // current Stream is active, destroy next Stream if created\n                    log.info(\"Stream: Destroying next PeriodStream due to current one being active\", bufferType, nextStreamInfo.period.start);\n                    consecutivePeriodStreamCb.periodStreamCleared({\n                        type: bufferType,\n                        manifest,\n                        period: nextStreamInfo.period,\n                    });\n                    nextStreamInfo.canceller.cancel();\n                    nextStreamInfo = null;\n                }\n                consecutivePeriodStreamCb.streamStatusUpdate(value);\n            },\n            error(err) {\n                if (nextStreamInfo !== null) {\n                    nextStreamInfo.canceller.cancel();\n                    nextStreamInfo = null;\n                }\n                currentStreamCanceller.cancel();\n                consecutivePeriodStreamCb.error(err);\n            } });\n        PeriodStream(periodStreamArgs, periodStreamCallbacks, currentStreamCanceller.signal);\n        handleUnexpectedManifestUpdates(currentStreamCanceller.signal);\n        /**\n         * Create `PeriodStream` for the next Period, specified under `nextPeriod`.\n         * @param {Object} nextPeriod\n         */\n        function checkOrCreateNextPeriodStream(nextPeriod) {\n            if (nextStreamInfo !== null) {\n                if (nextStreamInfo.period.id === nextPeriod.id) {\n                    return;\n                }\n                log.warn(\"Stream: Creating next `PeriodStream` while one was already created.\", bufferType, nextPeriod.id, nextStreamInfo.period.id);\n                consecutivePeriodStreamCb.periodStreamCleared({\n                    type: bufferType,\n                    manifest,\n                    period: nextStreamInfo.period,\n                });\n                nextStreamInfo.canceller.cancel();\n            }\n            const nextStreamCanceller = new TaskCanceller();\n            nextStreamCanceller.linkToSignal(cancelSignal);\n            nextStreamInfo = { canceller: nextStreamCanceller, period: nextPeriod };\n            manageConsecutivePeriodStreams(bufferType, nextPeriod, consecutivePeriodStreamCb, nextStreamInfo.canceller.signal);\n        }\n        /**\n         * Check on Manifest updates that the Manifest still appears coherent\n         * regarding its internal Period structure to what we created for now,\n         * handling cases where it does not.\n         * @param {Object} innerCancelSignal - When that cancel signal emits, stop\n         * performing checks.\n         */\n        function handleUnexpectedManifestUpdates(innerCancelSignal) {\n            manifest.addEventListener(\"manifestUpdate\", (updates) => {\n                // If current period has been unexpectedly removed, ask to reload\n                for (const period of updates.removedPeriods) {\n                    if (period.id === basePeriod.id) {\n                        // Check that this was not just one  of the earliests Periods that\n                        // was removed, in which case this is a normal cleanup scenario\n                        if (manifest.periods.length > 0 &&\n                            manifest.periods[0].start <= period.start) {\n                            // We begin by scheduling a micro-task to reduce the possibility of race\n                            // conditions where the inner logic would be called synchronously before\n                            // the next observation (which may reflect very different playback\n                            // conditions) is actually received.\n                            return queueMicrotask(() => {\n                                if (innerCancelSignal.isCancelled()) {\n                                    return;\n                                }\n                                return callbacks.needsMediaSourceReload({\n                                    timeOffset: 0,\n                                    minimumPosition: undefined,\n                                    maximumPosition: undefined,\n                                });\n                            });\n                        }\n                    }\n                    else if (period.start > basePeriod.start) {\n                        break;\n                    }\n                }\n                if (updates.addedPeriods.length > 0) {\n                    // If the next period changed, cancel the next created one if one\n                    if (nextStreamInfo !== null) {\n                        const newNextPeriod = manifest.getPeriodAfter(basePeriod);\n                        if (newNextPeriod === null ||\n                            nextStreamInfo.period.id !== newNextPeriod.id) {\n                            log.warn(\"Stream: Destroying next PeriodStream due to new one being added\", bufferType, nextStreamInfo.period.start);\n                            consecutivePeriodStreamCb.periodStreamCleared({\n                                type: bufferType,\n                                manifest,\n                                period: nextStreamInfo.period,\n                            });\n                            nextStreamInfo.canceller.cancel();\n                            nextStreamInfo = null;\n                        }\n                    }\n                }\n            }, innerCancelSignal);\n        }\n    }\n}\n/**\n * Returns `true` if low-level buffers have to be \"flushed\" after the given\n * `cleanedRanges` time ranges have been removed from an audio or video\n * SourceBuffer, to prevent playback issues.\n * @param {Object} observation\n * @param {Array.<Object>} cleanedRanges\n * @returns {boolean}\n */\nfunction needsFlushingAfterClean(observation, cleanedRanges) {\n    if (cleanedRanges.length === 0) {\n        return false;\n    }\n    const curPos = observation.position.getPolled();\n    // Based on the playback direction, we just check whether we may encounter\n    // the corresponding ranges, without seeking or re-switching playback\n    // direction which is expected to lead to a low-level flush anyway.\n    // There's a 5 seconds security, just to be sure.\n    return observation.speed >= 0\n        ? cleanedRanges[cleanedRanges.length - 1].end >= curPos - 5\n        : cleanedRanges[0].start <= curPos + 5;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport PeriodStream from \"./period_stream\";\nexport default PeriodStream;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport config from \"../../../config\";\nimport { formatError, MediaError } from \"../../../errors\";\nimport log from \"../../../log\";\nimport { toTaggedTrack } from \"../../../manifest\";\nimport arrayFind from \"../../../utils/array_find\";\nimport objectAssign from \"../../../utils/object_assign\";\nimport queueMicrotask from \"../../../utils/queue_microtask\";\nimport { getLeftSizeOfRange } from \"../../../utils/ranges\";\nimport SharedReference from \"../../../utils/reference\";\nimport TaskCanceller, { CancellationError } from \"../../../utils/task_canceller\";\nimport SegmentSinksStore from \"../../segment_sinks\";\nimport AdaptationStream from \"../adaptation\";\nimport getAdaptationSwitchStrategy from \"./utils/get_adaptation_switch_strategy\";\n/**\n * Create a single PeriodStream:\n *   - Lazily create (or reuse) a SegmentSink for the given type.\n *   - Create a Stream linked to an Adaptation each time it changes, to\n *     download and append the corresponding segments to the SegmentSink.\n *   - Announce when the Stream is full or is awaiting new Segments through\n *     events\n *\n * @param {Object} args - Various arguments allowing the `PeriodStream` to\n * determine which Adaptation and which Representation to choose, as well as\n * which segments to load from it.\n * You can check the corresponding type for more information.\n * @param {Object} callbacks - The `PeriodStream` relies on a system of\n * callbacks that it will call on various events.\n *\n * Depending on the event, the caller may be supposed to perform actions to\n * react upon some of them.\n *\n * This approach is taken instead of a more classical EventEmitter pattern to:\n *   - Allow callbacks to be called synchronously after the\n *     `AdaptationStream` is called.\n *   - Simplify bubbling events up, by just passing through callbacks\n *   - Force the caller to explicitely handle or not the different events.\n *\n * Callbacks may start being called immediately after the `AdaptationStream`\n * call and may be called until either the `parentCancelSignal` argument is\n * triggered, or until the `error` callback is called, whichever comes first.\n * @param {Object} parentCancelSignal - `CancellationSignal` allowing, when\n * triggered, to immediately stop all operations the `PeriodStream` is\n * doing.\n */\nexport default function PeriodStream({ bufferType, content, garbageCollectors, playbackObserver, representationEstimator, segmentQueueCreator, segmentSinksStore, options, wantedBufferAhead, maxVideoBufferSize, }, callbacks, parentCancelSignal) {\n    const { manifest, period } = content;\n    /**\n     * Emits the chosen Adaptation and Representations for the current type.\n     * `null` when no Adaptation is chosen (e.g. no subtitles)\n     * `undefined` at the beginning (it can be ignored.).\n     */\n    const adaptationRef = new SharedReference(undefined, parentCancelSignal);\n    callbacks.periodStreamReady({\n        type: bufferType,\n        manifest,\n        period,\n        adaptationRef,\n    });\n    if (parentCancelSignal.isCancelled()) {\n        return;\n    }\n    let currentStreamCanceller;\n    let isFirstAdaptationSwitch = true;\n    adaptationRef.onUpdate((choice) => {\n        // As an IIFE to profit from async/await while respecting onUpdate's signature\n        (async () => {\n            var _a;\n            if (choice === undefined) {\n                return;\n            }\n            const streamCanceller = new TaskCanceller();\n            streamCanceller.linkToSignal(parentCancelSignal);\n            currentStreamCanceller === null || currentStreamCanceller === void 0 ? void 0 : currentStreamCanceller.cancel(); // Cancel oreviously created stream if one\n            currentStreamCanceller = streamCanceller;\n            if (choice === null) {\n                // Current type is disabled for that Period\n                log.info(`Stream: Set no ${bufferType} Adaptation. P:`, period.start);\n                const segmentSinkStatus = segmentSinksStore.getStatus(bufferType);\n                if (segmentSinkStatus.type === \"initialized\") {\n                    log.info(`Stream: Clearing previous ${bufferType} SegmentSink`);\n                    if (SegmentSinksStore.isNative(bufferType)) {\n                        return askForMediaSourceReload(0, true, streamCanceller.signal);\n                    }\n                    else {\n                        const periodEnd = (_a = period.end) !== null && _a !== void 0 ? _a : Infinity;\n                        if (period.start > periodEnd) {\n                            log.warn(\"Stream: Can't free buffer: period's start is after its end\");\n                        }\n                        else {\n                            await segmentSinkStatus.value.removeBuffer(period.start, periodEnd);\n                            if (streamCanceller.isUsed()) {\n                                return; // The stream has been cancelled\n                            }\n                        }\n                    }\n                }\n                else if (segmentSinkStatus.type === \"uninitialized\") {\n                    segmentSinksStore.disableSegmentSink(bufferType);\n                    if (streamCanceller.isUsed()) {\n                        return; // The stream has been cancelled\n                    }\n                }\n                callbacks.adaptationChange({\n                    type: bufferType,\n                    adaptation: null,\n                    period,\n                });\n                if (streamCanceller.isUsed()) {\n                    return; // Previous call has provoken Stream cancellation by side-effect\n                }\n                return createEmptyAdaptationStream(playbackObserver, wantedBufferAhead, bufferType, { period }, callbacks, streamCanceller.signal);\n            }\n            const adaptations = period.adaptations[bufferType];\n            const adaptation = arrayFind(adaptations !== null && adaptations !== void 0 ? adaptations : [], (a) => a.id === choice.adaptationId);\n            if (adaptation === undefined) {\n                currentStreamCanceller.cancel();\n                log.warn(\"Stream: Unfound chosen Adaptation choice\", choice.adaptationId);\n                return;\n            }\n            /**\n             * If this is not the first Adaptation choice, we might want to apply a\n             * delta to the current position so we can re-play back some media in the\n             * new Adaptation to give some context back.\n             * This value contains this relative position, in seconds.\n             * @see createMediaSourceReloadRequester\n             */\n            const { DELTA_POSITION_AFTER_RELOAD } = config.getCurrent();\n            let relativePosHasBeenDefaulted = false;\n            let relativePosAfterSwitch;\n            if (isFirstAdaptationSwitch) {\n                relativePosAfterSwitch = 0;\n            }\n            else if (choice.relativeResumingPosition !== undefined) {\n                relativePosAfterSwitch = choice.relativeResumingPosition;\n            }\n            else {\n                relativePosHasBeenDefaulted = true;\n                switch (bufferType) {\n                    case \"audio\":\n                        relativePosAfterSwitch = DELTA_POSITION_AFTER_RELOAD.trackSwitch.audio;\n                        break;\n                    case \"video\":\n                        relativePosAfterSwitch = DELTA_POSITION_AFTER_RELOAD.trackSwitch.video;\n                        break;\n                    default:\n                        relativePosAfterSwitch = DELTA_POSITION_AFTER_RELOAD.trackSwitch.other;\n                        break;\n                }\n            }\n            isFirstAdaptationSwitch = false;\n            if (SegmentSinksStore.isNative(bufferType) &&\n                segmentSinksStore.getStatus(bufferType).type === \"disabled\") {\n                return askForMediaSourceReload(relativePosAfterSwitch, true, streamCanceller.signal);\n            }\n            // Reload if the Adaptation disappears from the manifest\n            manifest.addEventListener(\"manifestUpdate\", (updates) => {\n                // If current period has been unexpectedly removed, ask to reload\n                for (const element of updates.updatedPeriods) {\n                    if (element.period.id === period.id) {\n                        for (const adap of element.result.removedAdaptations) {\n                            if (adap.id === adaptation.id) {\n                                return askForMediaSourceReload(relativePosAfterSwitch, true, streamCanceller.signal);\n                            }\n                        }\n                    }\n                    else if (element.period.start > period.start) {\n                        break;\n                    }\n                }\n            }, currentStreamCanceller.signal);\n            const { representations } = choice;\n            log.info(`Stream: Updating ${bufferType} adaptation`, `A: ${adaptation.id}`, `P: ${period.start}`);\n            callbacks.adaptationChange({ type: bufferType, adaptation, period });\n            if (streamCanceller.isUsed()) {\n                return; // Previous call has provoken cancellation by side-effect\n            }\n            const segmentSink = createOrReuseSegmentSink(segmentSinksStore, bufferType, adaptation);\n            const strategy = getAdaptationSwitchStrategy(segmentSink, period, adaptation, choice.switchingMode, playbackObserver, options);\n            if (strategy.type === \"needs-reload\") {\n                return askForMediaSourceReload(relativePosAfterSwitch, true, streamCanceller.signal);\n            }\n            await segmentSinksStore.waitForUsableBuffers(streamCanceller.signal);\n            if (streamCanceller.isUsed()) {\n                return; // The Stream has since been cancelled\n            }\n            if (strategy.type === \"flush-buffer\" || strategy.type === \"clean-buffer\") {\n                for (const { start, end } of strategy.value) {\n                    await segmentSink.removeBuffer(start, end);\n                    if (streamCanceller.isUsed()) {\n                        return; // The Stream has since been cancelled\n                    }\n                }\n                if (strategy.type === \"flush-buffer\") {\n                    // The seek to `relativePosAfterSwitch` is only performed if strategy.type\n                    // is \"flush-buffer\" because there should be no interuption when playing in\n                    // with `clean-buffer` strategy\n                    callbacks.needsBufferFlush({\n                        relativeResumingPosition: relativePosAfterSwitch,\n                        relativePosHasBeenDefaulted,\n                    });\n                    if (streamCanceller.isUsed()) {\n                        return; // Previous callback cancelled the Stream by side-effect\n                    }\n                }\n            }\n            garbageCollectors.get(segmentSink)(streamCanceller.signal);\n            createAdaptationStream(adaptation, representations, segmentSink, streamCanceller.signal);\n        })().catch((err) => {\n            if (err instanceof CancellationError) {\n                return;\n            }\n            currentStreamCanceller === null || currentStreamCanceller === void 0 ? void 0 : currentStreamCanceller.cancel();\n            callbacks.error(err);\n        });\n    }, { clearSignal: parentCancelSignal, emitCurrentValue: true });\n    /**\n     * @param {Object} adaptation\n     * @param {Object} representations\n     * @param {Object} segmentSink\n     * @param {Object} cancelSignal\n     */\n    function createAdaptationStream(adaptation, representations, segmentSink, cancelSignal) {\n        const adaptationPlaybackObserver = createAdaptationStreamPlaybackObserver(playbackObserver, adaptation.type);\n        AdaptationStream({\n            content: { manifest, period, adaptation, representations },\n            options,\n            playbackObserver: adaptationPlaybackObserver,\n            representationEstimator,\n            segmentSink,\n            segmentQueueCreator,\n            wantedBufferAhead,\n            maxVideoBufferSize,\n        }, Object.assign(Object.assign({}, callbacks), { error: onAdaptationStreamError }), cancelSignal);\n        function onAdaptationStreamError(error) {\n            // Stream linked to a non-native media buffer should not impact the\n            // stability of the player. ie: if a text buffer sends an error, we want\n            // to continue playing without any subtitles\n            if (!SegmentSinksStore.isNative(bufferType)) {\n                log.error(`Stream: ${bufferType} Stream crashed. Aborting it.`, error instanceof Error ? error : \"\");\n                segmentSinksStore.disposeSegmentSink(bufferType);\n                const formattedError = formatError(error, {\n                    defaultCode: \"NONE\",\n                    defaultReason: \"Unknown `AdaptationStream` error\",\n                });\n                callbacks.warning(formattedError);\n                if (cancelSignal.isCancelled()) {\n                    return; // Previous callback cancelled the Stream by side-effect\n                }\n                return createEmptyAdaptationStream(playbackObserver, wantedBufferAhead, bufferType, { period }, callbacks, cancelSignal);\n            }\n            log.error(`Stream: ${bufferType} Stream crashed. Stopping playback.`, error instanceof Error ? error : \"\");\n            callbacks.error(error);\n        }\n    }\n    /**\n     * Regularly ask to reload the MediaSource on each playback observation\n     * performed by the playback observer.\n     *\n     * @param {number} timeOffset - Relative position, compared to the current\n     * playhead, at which we should restart playback after reloading.\n     * For example `-2` will reload 2 seconds before the current position.\n     * @param {boolean} stayInPeriod - If `true`, we will control that the position\n     * we reload at, after applying `timeOffset`, is still part of the Period\n     * `period`.\n     *\n     * If it isn't we will re-calculate that reloaded position to be:\n     *   - either the Period's start if the calculated position is before the\n     *     Period's start.\n     *   - either the Period'end start if the calculated position is after the\n     *     Period's end.\n     * @param {Object} cancelSignal\n     */\n    function askForMediaSourceReload(timeOffset, stayInPeriod, cancelSignal) {\n        // We begin by scheduling a micro-task to reduce the possibility of race\n        // conditions where `askForMediaSourceReload` would be called synchronously before\n        // the next observation (which may reflect very different playback conditions)\n        // is actually received.\n        // It can happen when `askForMediaSourceReload` is called as a side-effect of\n        // the same event that triggers the playback observation to be emitted.\n        queueMicrotask(() => {\n            playbackObserver.listen(() => {\n                if (cancelSignal.isCancelled()) {\n                    return;\n                }\n                callbacks.waitingMediaSourceReload({\n                    bufferType,\n                    period,\n                    timeOffset,\n                    stayInPeriod,\n                });\n            }, { includeLastObservation: true, clearSignal: cancelSignal });\n        });\n    }\n}\n/**\n * @param {string} bufferType\n * @param {Object} adaptation\n * @returns {Object}\n */\nfunction createOrReuseSegmentSink(segmentSinksStore, bufferType, adaptation) {\n    const segmentSinkStatus = segmentSinksStore.getStatus(bufferType);\n    if (segmentSinkStatus.type === \"initialized\") {\n        log.info(\"Stream: Reusing a previous SegmentSink for the type\", bufferType);\n        return segmentSinkStatus.value;\n    }\n    const codec = getFirstDeclaredMimeType(adaptation);\n    return segmentSinksStore.createSegmentSink(bufferType, codec);\n}\n/**\n * Get mime-type string of the first representation declared in the given\n * adaptation.\n * @param {Adaptation} adaptation\n * @returns {string}\n */\nfunction getFirstDeclaredMimeType(adaptation) {\n    const representations = adaptation.representations.filter((r) => r.isPlayable() !== false);\n    if (representations.length === 0) {\n        const noRepErr = new MediaError(\"NO_PLAYABLE_REPRESENTATION\", \"No Representation in the chosen \" + adaptation.type + \" Adaptation can be played\", { tracks: [toTaggedTrack(adaptation)] });\n        throw noRepErr;\n    }\n    return representations[0].getMimeTypeString();\n}\n/**\n * Create AdaptationStream's version of a playback observer.\n * @param {Object} initialPlaybackObserver\n * @param {string} trackType\n * @returns {Object}\n */\nfunction createAdaptationStreamPlaybackObserver(initialPlaybackObserver, trackType) {\n    return initialPlaybackObserver.deriveReadOnlyObserver(function transform(observationRef, cancellationSignal) {\n        const newRef = new SharedReference(constructAdaptationStreamPlaybackObservation(), cancellationSignal);\n        observationRef.onUpdate(emitAdaptationStreamPlaybackObservation, {\n            clearSignal: cancellationSignal,\n            emitCurrentValue: false,\n        });\n        return newRef;\n        function constructAdaptationStreamPlaybackObservation() {\n            const baseObservation = observationRef.getValue();\n            const buffered = baseObservation.buffered[trackType];\n            const bufferGap = buffered !== null\n                ? getLeftSizeOfRange(buffered, baseObservation.position.getWanted())\n                : 0;\n            return objectAssign({}, baseObservation, { bufferGap, buffered });\n        }\n        function emitAdaptationStreamPlaybackObservation() {\n            newRef.setValue(constructAdaptationStreamPlaybackObservation());\n        }\n    });\n}\n/**\n * Create empty AdaptationStream, linked to a Period.\n * This AdaptationStream will never download any segment and just emit a \"full\"\n * event when reaching the end.\n * @param {Object} playbackObserver\n * @param {Object} wantedBufferAhead\n * @param {string} bufferType\n * @param {Object} content\n * @param {Object} callbacks\n * @param {Object} cancelSignal\n */\nfunction createEmptyAdaptationStream(playbackObserver, wantedBufferAhead, bufferType, content, callbacks, cancelSignal) {\n    const { period } = content;\n    let hasFinishedLoading = false;\n    wantedBufferAhead.onUpdate(sendStatus, {\n        emitCurrentValue: false,\n        clearSignal: cancelSignal,\n    });\n    playbackObserver.listen(sendStatus, {\n        includeLastObservation: false,\n        clearSignal: cancelSignal,\n    });\n    sendStatus();\n    function sendStatus() {\n        const observation = playbackObserver.getReference().getValue();\n        const wba = wantedBufferAhead.getValue();\n        const position = observation.position.getWanted();\n        if (period.end !== undefined && position + wba >= period.end) {\n            log.debug('Stream: full \"empty\" AdaptationStream', bufferType);\n            hasFinishedLoading = true;\n        }\n        callbacks.streamStatusUpdate({\n            period,\n            bufferType,\n            imminentDiscontinuity: null,\n            position,\n            isEmptyStream: true,\n            hasFinishedLoading,\n            neededSegments: [],\n        });\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport config from \"../../../../config\";\nimport areCodecsCompatible from \"../../../../utils/are_codecs_compatible\";\nimport { excludeFromRanges, insertInto } from \"../../../../utils/ranges\";\nimport { getFirstSegmentAfterPeriod, getLastSegmentBeforePeriod, SegmentSinkOperation, } from \"../../../segment_sinks\";\n/**\n * Find out what to do when switching Adaptation, based on the current\n * situation.\n * @param {Object} segmentSink\n * @param {Object} period\n * @param {Object} adaptation\n * @param {Object} playbackObserver\n * @returns {Object}\n */\nexport default function getAdaptationSwitchStrategy(segmentSink, period, adaptation, switchingMode, playbackObserver, options) {\n    var _a, _b, _c, _d;\n    if (segmentSink.codec !== undefined &&\n        options.onCodecSwitch === \"reload\" &&\n        !hasCompatibleCodec(adaptation, segmentSink.codec)) {\n        return { type: \"needs-reload\", value: undefined };\n    }\n    const inventory = segmentSink.getLastKnownInventory();\n    const unwantedRange = [];\n    for (const elt of inventory) {\n        if (elt.infos.period.id === period.id && elt.infos.adaptation.id !== adaptation.id) {\n            insertInto(unwantedRange, {\n                start: (_a = elt.bufferedStart) !== null && _a !== void 0 ? _a : elt.start,\n                end: (_b = elt.bufferedEnd) !== null && _b !== void 0 ? _b : elt.end,\n            });\n        }\n    }\n    const pendingOperations = segmentSink.getPendingOperations();\n    for (const operation of pendingOperations) {\n        if (operation.type === SegmentSinkOperation.Push) {\n            const info = operation.value.inventoryInfos;\n            if (info.period.id === period.id && info.adaptation.id !== adaptation.id) {\n                const start = info.segment.time;\n                const end = start + info.segment.duration;\n                insertInto(unwantedRange, { start, end });\n            }\n        }\n    }\n    // Continue if we have no other Adaptation buffered in the current Period\n    if (unwantedRange.length === 0) {\n        return { type: \"continue\", value: undefined };\n    }\n    if (switchingMode === \"reload\") {\n        const readyState = playbackObserver.getReadyState();\n        if (readyState === undefined || readyState > 1) {\n            return { type: \"needs-reload\", value: undefined };\n        }\n    }\n    // From here, clean-up data from the previous Adaptation, if one\n    const shouldCleanAll = switchingMode === \"direct\";\n    const rangesToExclude = [];\n    // First, we don't want to accidentally remove some segments from the previous\n    // Period (which overlap a little with this one)\n    /** Last segment before one for the current period. */\n    const lastSegmentBefore = getLastSegmentBeforePeriod(inventory, period);\n    if (lastSegmentBefore !== null &&\n        (lastSegmentBefore.bufferedEnd === undefined ||\n            period.start - lastSegmentBefore.bufferedEnd < 1)) {\n        // Close to Period's start\n        // Exclude data close to the period's start to avoid cleaning\n        // to much\n        rangesToExclude.push({ start: 0, end: period.start + 1 });\n    }\n    if (!shouldCleanAll) {\n        // Exclude data around current position to avoid decoding issues\n        const bufferType = adaptation.type;\n        const { ADAP_REP_SWITCH_BUFFER_PADDINGS } = config.getCurrent();\n        /** Ranges that won't be cleaned from the current buffer. */\n        const paddingBefore = (_c = ADAP_REP_SWITCH_BUFFER_PADDINGS[bufferType].before) !== null && _c !== void 0 ? _c : 0;\n        const paddingAfter = (_d = ADAP_REP_SWITCH_BUFFER_PADDINGS[bufferType].after) !== null && _d !== void 0 ? _d : 0;\n        let currentTime = playbackObserver.getCurrentTime();\n        if (currentTime === undefined) {\n            // TODO current position might be old. A better solution should be found.\n            const lastObservation = playbackObserver.getReference().getValue();\n            currentTime = lastObservation.position.getPolled();\n        }\n        rangesToExclude.push({\n            start: currentTime - paddingBefore,\n            end: currentTime + paddingAfter,\n        });\n    }\n    // Now remove possible small range from the end if there is a segment from the\n    // next Period\n    if (period.end !== undefined) {\n        /** first segment after for the current period. */\n        const firstSegmentAfter = getFirstSegmentAfterPeriod(inventory, period);\n        if (firstSegmentAfter !== null &&\n            (firstSegmentAfter.bufferedStart === undefined ||\n                firstSegmentAfter.bufferedStart - period.end < 1)) {\n            // Close to Period's end\n            rangesToExclude.push({ start: period.end - 1, end: Number.MAX_VALUE });\n        }\n    }\n    const toRemove = excludeFromRanges(unwantedRange, rangesToExclude);\n    if (toRemove.length === 0) {\n        return { type: \"continue\", value: undefined };\n    }\n    return shouldCleanAll && adaptation.type !== \"text\"\n        ? { type: \"flush-buffer\", value: toRemove }\n        : { type: \"clean-buffer\", value: toRemove };\n}\n/**\n * Returns `true` if at least one codec of the Representations in the given\n * Adaptation has a codec compatible with the given SegmentSink's codec.\n * @param {Object} adaptation\n * @param {string} segmentSinkCodec\n * @returns {boolean}\n */\nfunction hasCompatibleCodec(adaptation, segmentSinkCodec) {\n    return adaptation.representations.some((rep) => rep.isPlayable() === true &&\n        areCodecsCompatible(rep.getMimeTypeString(), segmentSinkCodec));\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport RepresentationStream from \"./representation_stream\";\nexport default RepresentationStream;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * This file allows to create RepresentationStreams.\n *\n * A RepresentationStream downloads and push segment for a single\n * Representation (e.g. a single video stream of a given quality).\n * It chooses which segments should be downloaded according to the current\n * position and what is currently buffered.\n */\nimport config from \"../../../config\";\nimport log from \"../../../log\";\nimport objectAssign from \"../../../utils/object_assign\";\nimport TaskCanceller, { CancellationError } from \"../../../utils/task_canceller\";\nimport getBufferStatus from \"./utils/get_buffer_status\";\nimport getSegmentPriority from \"./utils/get_segment_priority\";\nimport pushInitSegment from \"./utils/push_init_segment\";\nimport pushMediaSegment from \"./utils/push_media_segment\";\n/**\n * Perform the logic to load the right segments for the given Representation and\n * push them to the given `SegmentSink`.\n *\n * In essence, this is the entry point of the core streaming logic of the\n * RxPlayer, the one actually responsible for finding which are the current\n * right segments to load, loading them, and pushing them so they can be decoded.\n *\n * Multiple RepresentationStream can run on the same SegmentSink.\n * This allows for example smooth transitions between multiple periods.\n *\n * @param {Object} args - Various arguments allowing to know which segments to\n * load, loading them and pushing them.\n * You can check the corresponding type for more information.\n * @param {Object} callbacks - The `RepresentationStream` relies on a system of\n * callbacks that it will call on various events.\n *\n * Depending on the event, the caller may be supposed to perform actions to\n * react upon some of them.\n *\n * This approach is taken instead of a more classical EventEmitter pattern to:\n *   - Allow callbacks to be called synchronously after the\n *     `RepresentationStream` is called.\n *   - Simplify bubbling events up, by just passing through callbacks\n *   - Force the caller to explicitely handle or not the different events.\n *\n * Callbacks may start being called immediately after the `RepresentationStream`\n * call and may be called until either the `parentCancelSignal` argument is\n * triggered, until the `terminating` callback has been triggered AND all loaded\n * segments have been pushed, or until the `error` callback is called, whichever\n * comes first.\n * @param {Object} parentCancelSignal - `CancellationSignal` allowing, when\n * triggered, to immediately stop all operations the `RepresentationStream` is\n * doing.\n */\nexport default function RepresentationStream({ content, options, playbackObserver, segmentSink, segmentQueue, terminate, }, callbacks, parentCancelSignal) {\n    log.debug(\"Stream: Creating RepresentationStream\", content.adaptation.type, content.representation.bitrate);\n    const { period, adaptation, representation } = content;\n    const { bufferGoal, maxBufferSize, drmSystemId, fastSwitchThreshold } = options;\n    const bufferType = adaptation.type;\n    /** `TaskCanceller` stopping operations performed by the `RepresentationStream` */\n    const canceller = new TaskCanceller();\n    canceller.linkToSignal(parentCancelSignal);\n    /** Saved initialization segment state for this representation. */\n    const initSegmentState = {\n        segment: representation.index.getInitSegment(),\n        uniqueId: null,\n        isLoaded: false,\n    };\n    canceller.signal.register(() => {\n        // Free initialization segment if one has been declared\n        if (initSegmentState.uniqueId !== null) {\n            segmentSink.freeInitSegment(initSegmentState.uniqueId);\n        }\n    });\n    /** If `true`, the current Representation has a linked initialization segment. */\n    const hasInitSegment = initSegmentState.segment !== null;\n    if (!hasInitSegment) {\n        initSegmentState.isLoaded = true;\n    }\n    /**\n     * `true` if the event notifying about encryption data has already been\n     * constructed.\n     * Allows to avoid sending multiple times protection events.\n     */\n    let hasSentEncryptionData = false;\n    // If the DRM system id is already known, and if we already have encryption data\n    // for it, we may not need to wait until the initialization segment is loaded to\n    // signal required protection data, thus performing License negotiations sooner\n    if (drmSystemId !== undefined) {\n        const encryptionData = representation.getEncryptionData(drmSystemId);\n        // If some key ids are not known yet, it may be safer to wait for this initialization\n        // segment to be loaded first\n        if (encryptionData.length > 0 &&\n            encryptionData.every((e) => e.keyIds !== undefined)) {\n            hasSentEncryptionData = true;\n            callbacks.encryptionDataEncountered(encryptionData.map((d) => objectAssign({ content }, d)));\n            if (canceller.isUsed()) {\n                return; // previous callback has stopped everything by side-effect\n            }\n        }\n    }\n    segmentQueue.addEventListener(\"error\", (err) => {\n        if (canceller.signal.isCancelled()) {\n            return; // ignore post requests-cancellation loading-related errors,\n        }\n        canceller.cancel(); // Stop every operations\n        callbacks.error(err);\n    });\n    segmentQueue.addEventListener(\"parsedInitSegment\", onParsedChunk, canceller.signal);\n    segmentQueue.addEventListener(\"parsedMediaSegment\", onParsedChunk, canceller.signal);\n    segmentQueue.addEventListener(\"emptyQueue\", checkStatus, canceller.signal);\n    segmentQueue.addEventListener(\"requestRetry\", (payload) => {\n        callbacks.warning(payload.error);\n        if (canceller.signal.isCancelled()) {\n            return; // If the previous callback led to loading operations being stopped, skip\n        }\n        const retriedSegment = payload.segment;\n        const { index } = representation;\n        if (index.isSegmentStillAvailable(retriedSegment) === false) {\n            checkStatus();\n        }\n        else if (index.canBeOutOfSyncError(payload.error, retriedSegment)) {\n            callbacks.manifestMightBeOufOfSync();\n        }\n    }, canceller.signal);\n    segmentQueue.addEventListener(\"fullyLoadedSegment\", (segment) => {\n        segmentSink\n            .signalSegmentComplete(objectAssign({ segment }, content))\n            .catch(onFatalBufferError);\n    }, canceller.signal);\n    /** Emit the last scheduled downloading queue for segments. */\n    const segmentsToLoadRef = segmentQueue.resetForContent(content, hasInitSegment);\n    canceller.signal.register(() => {\n        segmentQueue.stop();\n    });\n    playbackObserver.listen(checkStatus, {\n        includeLastObservation: false,\n        clearSignal: canceller.signal,\n    });\n    content.manifest.addEventListener(\"manifestUpdate\", checkStatus, canceller.signal);\n    bufferGoal.onUpdate(checkStatus, {\n        emitCurrentValue: false,\n        clearSignal: canceller.signal,\n    });\n    maxBufferSize.onUpdate(checkStatus, {\n        emitCurrentValue: false,\n        clearSignal: canceller.signal,\n    });\n    terminate.onUpdate(checkStatus, {\n        emitCurrentValue: false,\n        clearSignal: canceller.signal,\n    });\n    checkStatus();\n    return;\n    /**\n     * Produce a buffer status update synchronously on call, update the list\n     * of current segments to update and check various buffer and manifest related\n     * issues at the current time, calling the right callbacks if necessary.\n     */\n    function checkStatus() {\n        if (canceller.isUsed()) {\n            return; // Stop all buffer status checking if load operations are stopped\n        }\n        const observation = playbackObserver.getReference().getValue();\n        const initialWantedTime = observation.position.getWanted();\n        const status = getBufferStatus(content, initialWantedTime, playbackObserver, fastSwitchThreshold.getValue(), bufferGoal.getValue(), maxBufferSize.getValue(), segmentSink);\n        const { neededSegments } = status;\n        let neededInitSegment = null;\n        // Add initialization segment if required\n        if (!representation.index.isInitialized()) {\n            if (initSegmentState.segment === null) {\n                log.warn(\"Stream: Uninitialized index without an initialization segment\");\n            }\n            else if (initSegmentState.isLoaded) {\n                log.warn(\"Stream: Uninitialized index with an already loaded \" +\n                    \"initialization segment\");\n            }\n            else {\n                const wantedStart = observation.position.getWanted();\n                neededInitSegment = {\n                    segment: initSegmentState.segment,\n                    priority: getSegmentPriority(period.start, wantedStart),\n                };\n            }\n        }\n        else if (neededSegments.length > 0 &&\n            !initSegmentState.isLoaded &&\n            initSegmentState.segment !== null) {\n            const initSegmentPriority = neededSegments[0].priority;\n            neededInitSegment = {\n                segment: initSegmentState.segment,\n                priority: initSegmentPriority,\n            };\n        }\n        const terminateVal = terminate.getValue();\n        if (terminateVal === null) {\n            segmentsToLoadRef.setValue({\n                initSegment: neededInitSegment,\n                segmentQueue: neededSegments,\n            });\n        }\n        else if (terminateVal.urgent) {\n            log.debug(\"Stream: Urgent switch, terminate now.\", bufferType);\n            segmentsToLoadRef.setValue({ initSegment: null, segmentQueue: [] });\n            segmentsToLoadRef.finish();\n            canceller.cancel();\n            callbacks.terminating();\n            return;\n        }\n        else {\n            // Non-urgent termination wanted:\n            // End the download of the current media segment if pending and\n            // terminate once either that request is finished or another segment\n            // is wanted instead, whichever comes first.\n            const mostNeededSegment = neededSegments[0];\n            const initSegmentRequest = segmentQueue.getRequestedInitSegment();\n            const currentSegmentRequest = segmentQueue.getRequestedMediaSegment();\n            const nextQueue = currentSegmentRequest === null ||\n                mostNeededSegment === undefined ||\n                currentSegmentRequest.id !== mostNeededSegment.segment.id\n                ? []\n                : [mostNeededSegment];\n            const nextInit = initSegmentRequest === null ? null : neededInitSegment;\n            segmentsToLoadRef.setValue({\n                initSegment: nextInit,\n                segmentQueue: nextQueue,\n            });\n            if (nextQueue.length === 0 && nextInit === null) {\n                log.debug(\"Stream: No request left, terminate\", bufferType);\n                segmentsToLoadRef.finish();\n                canceller.cancel();\n                callbacks.terminating();\n                return;\n            }\n        }\n        callbacks.streamStatusUpdate({\n            period,\n            position: observation.position.getWanted(),\n            bufferType,\n            imminentDiscontinuity: status.imminentDiscontinuity,\n            isEmptyStream: false,\n            hasFinishedLoading: status.hasFinishedLoading,\n            neededSegments: status.neededSegments,\n        });\n        if (canceller.signal.isCancelled()) {\n            return; // previous callback has stopped loading operations by side-effect\n        }\n        const { UPTO_CURRENT_POSITION_CLEANUP } = config.getCurrent();\n        if (status.isBufferFull) {\n            const gcedPosition = Math.max(0, initialWantedTime - UPTO_CURRENT_POSITION_CLEANUP);\n            if (gcedPosition > 0) {\n                segmentSink.removeBuffer(0, gcedPosition).catch(onFatalBufferError);\n            }\n        }\n        if (status.shouldRefreshManifest) {\n            callbacks.needsManifestRefresh();\n        }\n    }\n    /**\n     * Process a chunk that has just been parsed by pushing it to the\n     * SegmentSink and emitting the right events.\n     * @param {Object} evt\n     */\n    function onParsedChunk(evt) {\n        // Supplementary encryption information might have been parsed.\n        for (const protInfo of evt.protectionData) {\n            // TODO better handle use cases like key rotation by not always grouping\n            // every protection data together? To check.\n            representation.addProtectionData(protInfo.initDataType, protInfo.keyId, protInfo.initData);\n        }\n        // Now that the initialization segment has been parsed - which may have\n        // included encryption information - take care of the encryption event\n        // if not already done.\n        if (!hasSentEncryptionData) {\n            const allEncryptionData = representation.getAllEncryptionData();\n            if (allEncryptionData.length > 0) {\n                callbacks.encryptionDataEncountered(allEncryptionData.map((p) => objectAssign({ content }, p)));\n                hasSentEncryptionData = true;\n            }\n        }\n        if (evt.segmentType === \"init\") {\n            if (!representation.index.isInitialized() && evt.segmentList !== undefined) {\n                representation.index.initialize(evt.segmentList);\n            }\n            initSegmentState.isLoaded = true;\n            if (evt.initializationData !== null) {\n                const initSegmentUniqueId = representation.uniqueId;\n                initSegmentState.uniqueId = initSegmentUniqueId;\n                segmentSink.declareInitSegment(initSegmentUniqueId, evt.initializationData);\n                pushInitSegment({\n                    playbackObserver,\n                    bufferGoal,\n                    content,\n                    initSegmentUniqueId,\n                    segment: evt.segment,\n                    segmentData: evt.initializationData,\n                    segmentSink,\n                }, canceller.signal)\n                    .then((result) => {\n                    if (result !== null) {\n                        callbacks.addedSegment(result);\n                    }\n                })\n                    .catch(onFatalBufferError);\n            }\n            // Sometimes the segment list is only known once the initialization segment\n            // is parsed. Thus we immediately re-check if there's new segments to load.\n            checkStatus();\n            return;\n        }\n        else {\n            const { inbandEvents, predictedSegments, needsManifestRefresh } = evt;\n            if (predictedSegments !== undefined) {\n                representation.index.addPredictedSegments(predictedSegments, evt.segment);\n            }\n            if (needsManifestRefresh === true) {\n                callbacks.needsManifestRefresh();\n                if (canceller.isUsed()) {\n                    return; // previous callback has stopped everything by side-effect\n                }\n            }\n            if (inbandEvents !== undefined && inbandEvents.length > 0) {\n                callbacks.inbandEvent(inbandEvents);\n                if (canceller.isUsed()) {\n                    return; // previous callback has stopped everything by side-effect\n                }\n            }\n            const initSegmentUniqueId = initSegmentState.uniqueId;\n            pushMediaSegment({\n                playbackObserver,\n                bufferGoal,\n                content,\n                initSegmentUniqueId,\n                parsedSegment: evt,\n                segment: evt.segment,\n                segmentSink,\n            }, canceller.signal)\n                .then((result) => {\n                if (result !== null) {\n                    callbacks.addedSegment(result);\n                }\n            })\n                .catch(onFatalBufferError);\n        }\n    }\n    /**\n     * Handle Buffer-related fatal errors by cancelling everything the\n     * `RepresentationStream` is doing and calling the error callback with the\n     * corresponding error.\n     * @param {*} err\n     */\n    function onFatalBufferError(err) {\n        if (canceller.isUsed() && err instanceof CancellationError) {\n            // The error is linked to cancellation AND we explicitely cancelled buffer\n            // operations.\n            // We can thus ignore it, it is very unlikely to lead to true buffer issues.\n            return;\n        }\n        log.warn(\"Stream: Received fatal buffer error\", adaptation.type, representation.bitrate, err instanceof Error ? err : null);\n        canceller.cancel();\n        callbacks.error(err);\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * This file allows any Stream to push data to a SegmentSink.\n */\nimport { MediaError, SourceBufferError } from \"../../../../errors\";\nimport log from \"../../../../log\";\nimport { toTaggedTrack } from \"../../../../manifest\";\nimport sleep from \"../../../../utils/sleep\";\nimport { CancellationError } from \"../../../../utils/task_canceller\";\n/**\n * Append a segment to the given segmentSink.\n * If it leads to an Error due to a full buffer, try to run our custom range\n * _garbage collector_ then retry.\n * @param {Object} playbackObserver\n * @param {Object} segmentSink\n * @param {Object} dataInfos\n * @param {number} bufferGoal\n * @param {Object} cancellationSignal\n * @returns {Promise}\n */\nexport default async function appendSegmentToBuffer(playbackObserver, segmentSink, dataInfos, bufferGoal, cancellationSignal) {\n    try {\n        return await segmentSink.pushChunk(dataInfos);\n    }\n    catch (appendError) {\n        if (cancellationSignal.isCancelled() && appendError instanceof CancellationError) {\n            throw appendError;\n        }\n        else if (!(appendError instanceof SourceBufferError) || !appendError.isBufferFull) {\n            const reason = appendError instanceof Error\n                ? appendError.toString()\n                : \"An unknown error happened when pushing content\";\n            throw new MediaError(\"BUFFER_APPEND_ERROR\", reason, {\n                tracks: [toTaggedTrack(dataInfos.inventoryInfos.adaptation)],\n            });\n        }\n        const { position } = playbackObserver.getReference().getValue();\n        const currentPos = position.getWanted();\n        try {\n            log.warn(\"Stream: Running garbage collector\");\n            const start = Math.max(currentPos - 5, 0);\n            const end = currentPos + bufferGoal.getValue() + 12;\n            if (start > 0) {\n                await segmentSink.removeBuffer(0, start);\n            }\n            if (end < Number.MAX_VALUE) {\n                await segmentSink.removeBuffer(end, Number.MAX_VALUE);\n            }\n            await sleep(200);\n            if (cancellationSignal.cancellationError !== null) {\n                throw cancellationSignal.cancellationError;\n            }\n            return await segmentSink.pushChunk(dataInfos);\n        }\n        catch (err2) {\n            if (err2 instanceof CancellationError) {\n                throw err2;\n            }\n            const reason = err2 instanceof Error ? err2.toString() : \"Could not clean the buffer\";\n            throw new MediaError(\"BUFFER_FULL_ERROR\", reason, {\n                tracks: [toTaggedTrack(dataInfos.inventoryInfos.adaptation)],\n            });\n        }\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../../../log\";\n/**\n * Check if there is a soon-to-be-encountered discontinuity in the buffer that\n * won't be filled by any future segment.\n * This function will only check discontinuities for the given `checkedRange`.\n *\n * @param {Object} content - The content we are currently loading.\n * @param {Object} checkedRange - The time range that will be checked for\n * discontinuities.\n * Both `nextSegmentStart` and `bufferedSegments` arguments can only refer to\n * that range.\n * @param {number|null} nextSegmentStart - The start time in seconds of the next\n * not-yet-pushed segment that can be pushed, in the limits of `checkedRange`.\n * This includes segments which have not been loaded or pushed yet, but also\n * segments which might be re-downloaded because currently incomplete in the\n * buffer, the point being to know what is the earliest time in the buffer where\n * a segment might be pushed in the future.\n * `null` if no segment in `checkedRange` will be pushed under current buffer's\n * conditions.\n * @param {boolean} hasFinishedLoading - if `true`, all segments for the current\n * Period have been loaded and none will be loaded in the future under the\n * current buffer's state.\n * @param {Array.<Object>} bufferedSegments - Information about every segments\n * currently in the buffer, in chronological order.\n * Only segments overlapping with the given `checkedRange` will be looked at,\n * though the array given can be larger.\n */\nexport default function checkForDiscontinuity(content, checkedRange, nextSegmentStart, hasFinishedLoading, bufferedSegments) {\n    const { period, adaptation, representation } = content;\n    // `bufferedSegments` might also contains segments which are before\n    // `checkedRange`.\n    // Here we want the first one that goes over `checkedRange.start`, to  see\n    // if there's a discontinuity at the beginning in the buffer\n    const nextBufferedInRangeIdx = getIndexOfFirstChunkInRange(bufferedSegments, checkedRange);\n    if (nextBufferedInRangeIdx === null) {\n        // There's no segment currently buffered for the current range.\n        if (nextSegmentStart === null) {\n            // No segment to load in that range\n            // Check if we are in a discontinuity at the end of the current Period\n            if (hasFinishedLoading &&\n                period.end !== undefined &&\n                checkedRange.end >= period.end) {\n                return { start: undefined, end: null }; // discontinuity to Period's end\n            }\n            // Check that there is a discontinuity announced in the Manifest there\n            const discontinuityEnd = representation.index.checkDiscontinuity(checkedRange.start);\n            if (discontinuityEnd !== null) {\n                return { start: undefined, end: discontinuityEnd };\n            }\n        }\n        return null;\n    }\n    const nextBufferedSegment = bufferedSegments[nextBufferedInRangeIdx];\n    // Check if there is a hole that won't be filled before `nextSegmentStart`\n    if (\n    // Next buffered segment starts after the start of the current range\n    nextBufferedSegment.bufferedStart !== undefined &&\n        nextBufferedSegment.bufferedStart > checkedRange.start &&\n        // and no segment will fill in that hole\n        (nextSegmentStart === null ||\n            nextBufferedSegment.infos.segment.end <= nextSegmentStart)) {\n        const discontinuityEnd = nextBufferedSegment.bufferedStart;\n        if (!hasFinishedLoading &&\n            representation.index.awaitSegmentBetween(checkedRange.start, discontinuityEnd) !==\n                false) {\n            return null;\n        }\n        log.debug(\"RS: current discontinuity encountered\", adaptation.type, nextBufferedSegment.bufferedStart);\n        return { start: undefined, end: discontinuityEnd };\n    }\n    // Check if there's a discontinuity BETWEEN segments of the current range\n    const nextHoleIdx = getIndexOfFirstDiscontinuityBetweenChunks(bufferedSegments, checkedRange, nextBufferedInRangeIdx + 1);\n    // If there was a hole between two consecutives segments, and if this hole\n    // comes before the next segment to load, there is a discontinuity (that hole!)\n    if (nextHoleIdx !== null) {\n        const segmentInfoBeforeHole = bufferedSegments[nextHoleIdx - 1];\n        const segmentInfoAfterHole = bufferedSegments[nextHoleIdx];\n        if (nextSegmentStart === null ||\n            segmentInfoAfterHole.infos.segment.end <= nextSegmentStart) {\n            if (!hasFinishedLoading &&\n                representation.index.awaitSegmentBetween(segmentInfoBeforeHole.infos.segment.end, segmentInfoAfterHole.infos.segment.time) !== false) {\n                return null;\n            }\n            const start = segmentInfoBeforeHole.bufferedEnd;\n            const end = segmentInfoAfterHole.bufferedStart;\n            log.debug(\"RS: future discontinuity encountered\", adaptation.type, start, end);\n            return { start, end };\n        }\n    }\n    if (nextSegmentStart === null) {\n        // If no hole between segments and no segment to load, check for a\n        // discontinuity at the end of the Period\n        if (hasFinishedLoading && period.end !== undefined) {\n            // Period is finished\n            if (checkedRange.end < period.end) {\n                // We've not reached the Period's end yet\n                return null;\n            }\n            // Check if the last buffered segment ends before this Period's end\n            // In which case there is a discontinuity between those\n            const lastBufferedInPeriodIdx = getIndexOfLastChunkInPeriod(bufferedSegments, period.end);\n            if (lastBufferedInPeriodIdx !== null) {\n                const lastSegment = bufferedSegments[lastBufferedInPeriodIdx];\n                if (lastSegment.bufferedEnd !== undefined &&\n                    lastSegment.bufferedEnd < period.end) {\n                    log.debug(\"RS: discontinuity encountered at the end of the current period\", adaptation.type, lastSegment.bufferedEnd, period.end);\n                    return { start: lastSegment.bufferedEnd, end: null };\n                }\n            }\n        }\n        // At last, check if we don't have a discontinuity at the end of the current\n        // range, announced in the Manifest, that is too big to be detected through\n        // the previous checks.\n        if (period.end !== undefined && checkedRange.end >= period.end) {\n            return null; // The previous checks should have taken care of those\n        }\n        for (let bufIdx = bufferedSegments.length - 1; bufIdx >= 0; bufIdx--) {\n            const bufSeg = bufferedSegments[bufIdx];\n            if (bufSeg.bufferedStart === undefined) {\n                break;\n            }\n            if (bufSeg.bufferedStart < checkedRange.end) {\n                if (bufSeg.bufferedEnd !== undefined && bufSeg.bufferedEnd < checkedRange.end) {\n                    const discontinuityEnd = representation.index.checkDiscontinuity(checkedRange.end);\n                    if (discontinuityEnd !== null) {\n                        return { start: bufSeg.bufferedEnd, end: discontinuityEnd };\n                    }\n                }\n                return null;\n            }\n        }\n    }\n    return null;\n}\n/**\n * Returns the index of the first element in `bufferedChunks` that is part of\n * `range` (starts before it ends and ends after it starts).\n *\n * Returns `null` if no element is found in that range or if we cannot know the\n * index of the first element in it.\n * @param {Array.<Object>} bufferedChunks\n * @param {Object} range\n * @returns {number|null}\n */\nfunction getIndexOfFirstChunkInRange(bufferedChunks, range) {\n    for (let bufIdx = 0; bufIdx < bufferedChunks.length; bufIdx++) {\n        const bufSeg = bufferedChunks[bufIdx];\n        if (bufSeg.bufferedStart === undefined ||\n            bufSeg.bufferedEnd === undefined ||\n            bufSeg.bufferedStart >= range.end) {\n            return null;\n        }\n        if (bufSeg.bufferedEnd > range.start) {\n            return bufIdx;\n        }\n    }\n    return null;\n}\n/**\n * Returns the index of the first element in `bufferedChunks` which is not\n * immediately consecutive to the one before it.\n *\n * `startFromIndex` is the index of the first segment that will be checked with\n * the element coming before it. As such, it has to be superior to 0.\n *\n * If the element at `startFromIndex` comes immediately after the one before it,\n * the element at `startFromIndex + 1` will be checked instead and so on until a\n * segment completely out of `checkedRange` (which starts after it) is detected.\n *\n * If no hole between elements is found, `null` is returned.\n * @param {Array.<Object>} bufferedChunks\n * @param {Object} range\n * @param {number} startFromIndex\n * @returns {number|null}\n */\nfunction getIndexOfFirstDiscontinuityBetweenChunks(bufferedChunks, range, startFromIndex) {\n    if (startFromIndex <= 0) {\n        log.error(\"RS: Asked to check a discontinuity before the first chunk.\");\n        return null;\n    }\n    for (let bufIdx = startFromIndex; bufIdx < bufferedChunks.length; bufIdx++) {\n        const currSegment = bufferedChunks[bufIdx];\n        const prevSegment = bufferedChunks[bufIdx - 1];\n        // Exit as soon we miss information or when we go further than `checkedRange`\n        if (currSegment.bufferedStart === undefined ||\n            prevSegment.bufferedEnd === undefined ||\n            currSegment.bufferedStart >= range.end) {\n            return null;\n        }\n        // If there is a hole between two consecutive buffered segment\n        if (currSegment.bufferedStart - prevSegment.bufferedEnd > 0) {\n            return bufIdx;\n        }\n    }\n    return null;\n}\n/**\n * Returns the index of the last element in `bufferedChunks` that is part of\n * `range` (starts before it ends and ends after it starts).\n *\n * Returns `null` if no element is found in that range or if we cannot know the\n * index of the last element in it.\n * @param {Array.<Object>} bufferedChunks\n * @param {number} periodEnd\n * @returns {number|null}\n */\nfunction getIndexOfLastChunkInPeriod(bufferedChunks, periodEnd) {\n    for (let bufIdx = bufferedChunks.length - 1; bufIdx >= 0; bufIdx--) {\n        const bufSeg = bufferedChunks[bufIdx];\n        if (bufSeg.bufferedStart === undefined) {\n            return null;\n        }\n        if (bufSeg.bufferedStart < periodEnd) {\n            return bufIdx;\n        }\n    }\n    return null;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport isNullOrUndefined from \"../../../../utils/is_null_or_undefined\";\nimport SegmentSinksStore, { SegmentSinkOperation } from \"../../../segment_sinks\";\nimport checkForDiscontinuity from \"./check_for_discontinuity\";\nimport getNeededSegments from \"./get_needed_segments\";\nimport getSegmentPriority from \"./get_segment_priority\";\n/**\n * Checks on the current buffered data for the given type and Period\n * and returns what should be done to fill the buffer according to the buffer\n * goal, the Representation chosen, etc.\n * Also emits discontinuities if found, which are parts of the buffer that won't\n * be filled by any segment, even in the future.\n *\n * @param {Object} content\n * @param {number} initialWantedTime\n * @param {Object} playbackObserver\n * @param {number|undefined} fastSwitchThreshold\n * @param {number} bufferGoal\n * @param {number} maxBufferSize\n * @param {Object} segmentSink\n * @returns {Object}\n */\nexport default function getBufferStatus(content, initialWantedTime, playbackObserver, fastSwitchThreshold, bufferGoal, maxBufferSize, segmentSink) {\n    var _a, _b, _c;\n    const { representation } = content;\n    const isPaused = (_b = (_a = playbackObserver.getIsPaused()) !== null && _a !== void 0 ? _a : playbackObserver.getReference().getValue().paused.pending) !== null && _b !== void 0 ? _b : playbackObserver.getReference().getValue().paused.last;\n    const playbackRate = (_c = playbackObserver.getPlaybackRate()) !== null && _c !== void 0 ? _c : playbackObserver.getReference().getValue().speed;\n    let askedStart = initialWantedTime;\n    if (isPaused === undefined ||\n        playbackRate === undefined ||\n        isPaused ||\n        playbackRate <= 0) {\n        askedStart -= 0.1;\n    }\n    const neededRange = getRangeOfNeededSegments(content, askedStart, bufferGoal);\n    const shouldRefreshManifest = representation.index.shouldRefresh(neededRange.start, neededRange.end);\n    /**\n     * Every segment awaiting an \"SignalSegmentComplete\" operation, which\n     * indicates that a completely-loaded segment is still being pushed to the\n     * SegmentSink.\n     */\n    const segmentsBeingPushed = segmentSink\n        .getPendingOperations()\n        .filter((operation) => operation.type === SegmentSinkOperation.SignalSegmentComplete)\n        .map((operation) => operation.value);\n    /** Data on every segments buffered around `neededRange`. */\n    const bufferedSegments = segmentSink.getLastKnownInventory();\n    let currentPlaybackTime = playbackObserver.getCurrentTime();\n    if (currentPlaybackTime === undefined) {\n        // We're in a WebWorker, just consider the last known position\n        currentPlaybackTime = playbackObserver.getReference().getValue().position.getWanted();\n    }\n    /** Callback allowing to retrieve a segment's history in the buffer. */\n    const getBufferedHistory = segmentSink.getSegmentHistory.bind(segmentSink);\n    /** List of segments we will need to download. */\n    const { segmentsToLoad, segmentsOnHold, isBufferFull } = getNeededSegments({\n        content,\n        bufferedSegments,\n        currentPlaybackTime,\n        fastSwitchThreshold,\n        getBufferedHistory,\n        neededRange,\n        segmentsBeingPushed,\n        maxBufferSize,\n    });\n    const prioritizedNeededSegments = segmentsToLoad.map((segment) => ({\n        priority: getSegmentPriority(segment.time, askedStart),\n        segment,\n    }));\n    /**\n     * `true` if the current `RepresentationStream` has loaded all the\n     * needed segments for this Representation until the end of the Period.\n     */\n    const hasFinishedLoading = representation.index.isInitialized() &&\n        !representation.index.isStillAwaitingFutureSegments() &&\n        neededRange.hasReachedPeriodEnd &&\n        prioritizedNeededSegments.length === 0 &&\n        segmentsOnHold.length === 0;\n    /**\n     * Start time in seconds of the next available not-yet pushed segment.\n     * `null` if no segment is wanted for the current wanted range.\n     */\n    let nextSegmentStart = null;\n    if (segmentsBeingPushed.length > 0) {\n        nextSegmentStart = Math.min(...segmentsBeingPushed.map((info) => info.segment.time));\n    }\n    if (segmentsOnHold.length > 0) {\n        nextSegmentStart =\n            nextSegmentStart !== null\n                ? Math.min(nextSegmentStart, segmentsOnHold[0].time)\n                : segmentsOnHold[0].time;\n    }\n    if (prioritizedNeededSegments.length > 0) {\n        nextSegmentStart =\n            nextSegmentStart !== null\n                ? Math.min(nextSegmentStart, prioritizedNeededSegments[0].segment.time)\n                : prioritizedNeededSegments[0].segment.time;\n    }\n    const imminentDiscontinuity = checkForDiscontinuity(content, neededRange, nextSegmentStart, hasFinishedLoading, bufferedSegments);\n    return {\n        imminentDiscontinuity,\n        hasFinishedLoading,\n        neededSegments: prioritizedNeededSegments,\n        isBufferFull,\n        shouldRefreshManifest,\n    };\n}\n/**\n * Returns both the time range of segments that should be loaded (from a\n * starting position to an ending position) and whether the end of the Period is\n * reached by that range.\n * @param {Object} content\n * @param {number} initialWantedTime\n * @param {number} bufferGoal\n * @returns {Object}\n */\nfunction getRangeOfNeededSegments(content, initialWantedTime, bufferGoal) {\n    var _a;\n    let wantedStartPosition;\n    const { manifest, period, representation } = content;\n    const lastIndexPosition = representation.index.getLastAvailablePosition();\n    const representationIndex = representation.index;\n    // There is an exception for when the current initially wanted time is already\n    // after the last position with segments AND when we're playing the absolute\n    // last Period in the Manifest.\n    // In that case, we want to actually request at least the last segment to\n    // avoid ending the last Period - and by extension the content - with a\n    // segment which isn't the last one.\n    if (!isNullOrUndefined(lastIndexPosition) &&\n        SegmentSinksStore.isNative(content.adaptation.type) &&\n        initialWantedTime >= lastIndexPosition &&\n        representationIndex.isInitialized() &&\n        !representationIndex.isStillAwaitingFutureSegments() &&\n        isPeriodTheCurrentAndLastOne(manifest, period, initialWantedTime)) {\n        wantedStartPosition = lastIndexPosition - 1;\n    }\n    else {\n        wantedStartPosition = initialWantedTime - 0.1;\n    }\n    const wantedEndPosition = wantedStartPosition + bufferGoal;\n    let hasReachedPeriodEnd;\n    if (!representation.index.isInitialized() ||\n        representation.index.isStillAwaitingFutureSegments() ||\n        period.end === undefined) {\n        hasReachedPeriodEnd = false;\n    }\n    else if (lastIndexPosition === undefined) {\n        // We do not know the end of this index.\n        hasReachedPeriodEnd = wantedEndPosition >= period.end;\n    }\n    else if (lastIndexPosition === null) {\n        // There is no available segment in the index currently.\n        hasReachedPeriodEnd = true;\n    }\n    else {\n        // We have a declared end. Check that our range went until the last\n        // position available in the index. If that's the case and we're left\n        // with no segments after filtering them, it means we already have\n        // downloaded the last segments and have nothing left to do: full.\n        hasReachedPeriodEnd = wantedEndPosition >= lastIndexPosition;\n    }\n    return {\n        start: Math.max(wantedStartPosition, period.start),\n        end: Math.min(wantedEndPosition, (_a = period.end) !== null && _a !== void 0 ? _a : Infinity),\n        hasReachedPeriodEnd,\n    };\n}\n/**\n * Returns `true` if the given Period is both:\n *   - the one being played (the current position is known from `time`)\n *   - the absolute last one in the Manifest (that is, there will never be a\n *     Period after it).\n * @param {Object} manifest\n * @param {Object} period\n * @param {number} time\n * @returns {boolean}\n */\nfunction isPeriodTheCurrentAndLastOne(manifest, period, time) {\n    var _a;\n    const nextPeriod = manifest.getPeriodAfter(period);\n    return (period.containsTime(time, nextPeriod) &&\n        manifest.isLastPeriodKnown &&\n        period.id === ((_a = manifest.periods[manifest.periods.length - 1]) === null || _a === void 0 ? void 0 : _a.id));\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport config from \"../../../../config\";\nimport log from \"../../../../log\";\nimport { areSameContent } from \"../../../../manifest\";\nimport objectAssign from \"../../../../utils/object_assign\";\n/**\n * Return the list of segments that can currently be downloaded to fill holes\n * in the buffer in the given range, including already-pushed segments currently\n * incomplete in the buffer.\n * This list might also include already-loaded segments in a higher bitrate,\n * according to the given configuration.\n * Excludes segment that are already being pushed.\n * @param {Object} args\n * @returns {Array.<Object>}\n */\nexport default function getNeededSegments({ bufferedSegments, content, currentPlaybackTime, fastSwitchThreshold, getBufferedHistory, neededRange, segmentsBeingPushed, maxBufferSize, }) {\n    const { adaptation, representation } = content;\n    let availableBufferSize = getAvailableBufferSize(bufferedSegments, segmentsBeingPushed, maxBufferSize);\n    const availableSegmentsForRange = representation.index.getSegments(neededRange.start, neededRange.end - neededRange.start);\n    // Remove from `bufferedSegments` any segments in the wrong track / bad quality\n    const segmentsToKeep = bufferedSegments.filter((bufferedSegment) => !shouldContentBeReplaced(bufferedSegment.infos, content, currentPlaybackTime, fastSwitchThreshold));\n    // Remove any segments that are not usable because they have been garbage collected\n    const reusableSegments = filterOutGCedSegments(segmentsToKeep, neededRange, getBufferedHistory);\n    const { MINIMUM_SEGMENT_SIZE, MIN_BUFFER_AHEAD } = config.getCurrent();\n    let shouldStopLoadingSegments = false;\n    /**\n     * Epsilon compensating for rounding errors when comparing the start and end\n     * time of multiple segments.\n     */\n    const ROUNDING_ERROR = Math.min(1 / 60, MINIMUM_SEGMENT_SIZE);\n    let isBufferFull = false;\n    const segmentsOnHold = [];\n    const segmentsToLoad = availableSegmentsForRange.filter((segment) => {\n        const contentObject = objectAssign({ segment }, content);\n        // First, check that the segment is not already being pushed\n        if (segmentsBeingPushed.length > 0) {\n            const isAlreadyBeingPushed = segmentsBeingPushed.some((pendingSegment) => areSameContent(contentObject, pendingSegment));\n            if (isAlreadyBeingPushed) {\n                return false;\n            }\n        }\n        const { duration, time, end } = segment;\n        if (segment.isInit) {\n            return true; // never skip initialization segments\n        }\n        if (shouldStopLoadingSegments) {\n            segmentsOnHold.push(segment);\n            return false;\n        }\n        if (segment.complete && duration < MINIMUM_SEGMENT_SIZE) {\n            return false; // too small, don't download\n        }\n        // Check if the same segment from another Representation is not already\n        // being pushed.\n        if (segmentsBeingPushed.length > 0) {\n            const waitForPushedSegment = segmentsBeingPushed.some((pendingSegment) => {\n                if (pendingSegment.period.id !== content.period.id ||\n                    pendingSegment.adaptation.id !== content.adaptation.id) {\n                    return false;\n                }\n                const { segment: oldSegment } = pendingSegment;\n                if (oldSegment.time - ROUNDING_ERROR > time) {\n                    return false;\n                }\n                if (oldSegment.complete) {\n                    if (oldSegment.end + ROUNDING_ERROR < end) {\n                        return false;\n                    }\n                }\n                else if (Math.abs(time - oldSegment.time) > time) {\n                    return false;\n                }\n                return !shouldContentBeReplaced(pendingSegment, contentObject, currentPlaybackTime, fastSwitchThreshold);\n            });\n            if (waitForPushedSegment) {\n                return false;\n            }\n        }\n        // check if the segment is already downloaded\n        for (const completeSeg of reusableSegments) {\n            const areFromSamePeriod = completeSeg.infos.period.id === content.period.id;\n            // Check if content are from same period, as there can't be overlapping\n            // periods, we should consider a segment as already downloaded if\n            // it is from same period (but can be from different adaptation or\n            // representation)\n            if (completeSeg.status === 1 /* ChunkStatus.FullyLoaded */ && areFromSamePeriod) {\n                const completeSegInfos = completeSeg.infos.segment;\n                if (time - completeSegInfos.time > -ROUNDING_ERROR) {\n                    if (completeSegInfos.complete) {\n                        if (completeSegInfos.end - end > -ROUNDING_ERROR) {\n                            return false; // Same segment's characteristics: already downloaded\n                        }\n                    }\n                    else if (Math.abs(time - completeSegInfos.time) < ROUNDING_ERROR) {\n                        // same start (special case for non-complete segments): already downloaded\n                        return false;\n                    }\n                }\n            }\n        }\n        const estimatedSegmentSize = duration * content.representation.bitrate; // in bits\n        if (availableBufferSize - estimatedSegmentSize < 0) {\n            isBufferFull = true;\n            if (time > neededRange.start + MIN_BUFFER_AHEAD) {\n                shouldStopLoadingSegments = true;\n                segmentsOnHold.push(segment);\n                return false;\n            }\n        }\n        // check if the browser is not just garbage collecting it\n        const segmentHistory = getBufferedHistory(contentObject);\n        if (segmentHistory.length > 1) {\n            const lastTimeItWasPushed = segmentHistory[segmentHistory.length - 1];\n            const beforeLastTimeItWasPushed = segmentHistory[segmentHistory.length - 2];\n            if (lastTimeItWasPushed.buffered === null &&\n                beforeLastTimeItWasPushed.buffered === null) {\n                log.warn(\"Stream: Segment GCed multiple times in a row, ignoring it.\", \"If this happens a lot and lead to unpleasant experience, please \" +\n                    \" check your device's available memory. If it's low when this message \" +\n                    \"is emitted, you might want to update the RxPlayer's settings (\" +\n                    \"`maxBufferAhead`, `maxVideoBufferSize` etc.) so less memory is used \" +\n                    \"by regular media data buffering.\" +\n                    adaptation.type, representation.id, segment.time);\n                return false;\n            }\n        }\n        // check if there is an hole in place of the segment currently\n        for (let i = 0; i < reusableSegments.length; i++) {\n            const completeSeg = reusableSegments[i];\n            // For the first already-loaded segment, take the first one ending after\n            // this one' s start\n            if (completeSeg.end + ROUNDING_ERROR > time) {\n                const shouldLoad = completeSeg.start > time + ROUNDING_ERROR ||\n                    getLastContiguousSegment(reusableSegments, i).end < end - ROUNDING_ERROR;\n                if (shouldLoad) {\n                    availableBufferSize -= estimatedSegmentSize;\n                }\n                return shouldLoad;\n            }\n        }\n        availableBufferSize -= estimatedSegmentSize;\n        return true;\n    });\n    return { segmentsToLoad, segmentsOnHold, isBufferFull };\n}\n/**\n * Compute the estimated available buffer size in memory in kilobytes\n * @param bufferedSegments\n * @param segmentsBeingPushed\n * @param maxVideoBufferSize\n * @returns availableBufferSize in bits\n */\nfunction getAvailableBufferSize(bufferedSegments, segmentsBeingPushed, maxVideoBufferSize) {\n    let availableBufferSize = maxVideoBufferSize * 8000; // in bits\n    availableBufferSize -= segmentsBeingPushed.reduce((size, segment) => {\n        const { bitrate } = segment.representation;\n        // Not taking into account the fact that the segment\n        // can still be generated and the duration not fully exact\n        const { duration } = segment.segment;\n        return size + bitrate * duration;\n    }, 0);\n    return bufferedSegments.reduce((size, chunk) => {\n        if (chunk.chunkSize !== undefined) {\n            return size - chunk.chunkSize * 8; // in bits\n        }\n        else {\n            return size;\n        }\n    }, availableBufferSize);\n}\n/**\n * From the given array of buffered chunks (`bufferedSegments`) returns the last\n * buffered chunk contiguous with the one at the `startIndex` index given.\n * @param {Array.<Object>}\n * @param {number} startIndex\n * @returns {Object}\n */\nfunction getLastContiguousSegment(bufferedSegments, startIndex) {\n    let j = startIndex + 1;\n    const { MINIMUM_SEGMENT_SIZE } = config.getCurrent();\n    /**\n     * Epsilon compensating for rounding errors when comparing the start and end\n     * time of multiple segments.\n     */\n    const ROUNDING_ERROR = Math.min(1 / 60, MINIMUM_SEGMENT_SIZE);\n    // go through all contiguous segments and take the last one\n    while (j < bufferedSegments.length - 1 &&\n        bufferedSegments[j - 1].end + ROUNDING_ERROR > bufferedSegments[j].start) {\n        j++;\n    }\n    j--; // index of last contiguous segment\n    return bufferedSegments[j];\n}\n/**\n * Returns `true` if segments linked to the given `oldContent` currently present\n * in the buffer should be replaced by segments coming from `currentContent`.\n * @param {Object} oldContent\n * @param {Object} currentContent\n * @param {number} currentPlaybackTime\n * @param {number} [fastSwitchThreshold]\n * @returns {boolean}\n */\nfunction shouldContentBeReplaced(oldContent, currentContent, currentPlaybackTime, fastSwitchThreshold) {\n    const { CONTENT_REPLACEMENT_PADDING } = config.getCurrent();\n    if (oldContent.period.id !== currentContent.period.id) {\n        return false; // keep segments from another Period by default.\n    }\n    const { segment } = oldContent;\n    if (segment.time < currentPlaybackTime + CONTENT_REPLACEMENT_PADDING) {\n        return false;\n    }\n    if (oldContent.adaptation.id !== currentContent.adaptation.id) {\n        return true; // replace segments from another Adaptation\n    }\n    return canFastSwitch(oldContent.representation, currentContent.representation, fastSwitchThreshold);\n}\n/**\n * Returns `true` if segments from the new Representation can replace\n * previously-loaded segments from the old Representation given.\n *\n * This behavior is called \"fast-switching\".\n * @param {Object} oldSegmentRepresentation\n * @param {Object} newSegmentRepresentation\n * @param {number|undefined} fastSwitchThreshold\n * @returns {boolean}\n */\nfunction canFastSwitch(oldSegmentRepresentation, newSegmentRepresentation, fastSwitchThreshold) {\n    const oldContentBitrate = oldSegmentRepresentation.bitrate;\n    const { BITRATE_REBUFFERING_RATIO } = config.getCurrent();\n    if (fastSwitchThreshold === undefined) {\n        // only re-load comparatively-poor bitrates for the same Adaptation.\n        const bitrateCeil = oldContentBitrate * BITRATE_REBUFFERING_RATIO;\n        return newSegmentRepresentation.bitrate > bitrateCeil;\n    }\n    return (oldContentBitrate < fastSwitchThreshold &&\n        newSegmentRepresentation.bitrate > oldContentBitrate);\n}\n/**\n * From buffered segment information, return `true` if the given `currentSeg`\n * might have been garbage collected at the start.\n * Return `false` if the segment is complete at least from `maximumStartTime`.\n * @param {Object} currentSeg - The segment information for the segment in\n * question.\n * @param {Object|null} prevSeg - The segment information for the previous\n * buffered segment, if one (`null` if none).\n * @param {number} maximumStartTime - Only consider the data after that time.\n * If `currentSeg` has only been garbage collected for some data which is before\n * that time, we will return `false`.\n */\nfunction doesStartSeemGarbageCollected(currentSeg, prevSeg, maximumStartTime) {\n    const { MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT } = config.getCurrent();\n    if (currentSeg.bufferedStart === undefined) {\n        return false;\n    }\n    if (prevSeg !== null &&\n        prevSeg.bufferedEnd !== undefined &&\n        currentSeg.bufferedStart - prevSeg.bufferedEnd < 0.1) {\n        return false;\n    }\n    if (maximumStartTime < currentSeg.bufferedStart &&\n        currentSeg.bufferedStart - currentSeg.start > MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT) {\n        log.info(\"Stream: The start of the wanted segment has been garbage collected\", currentSeg.start, currentSeg.bufferedStart);\n        return true;\n    }\n    return false;\n}\n/**\n * From buffered segment information, return `true` if the given `currentSeg`\n * might have been garbage collected at the end.\n * Return `false` if the segment is complete at least until `minimumEndTime`.\n * @param {Object} currentSeg - The segment information for the segment in\n * question.\n * @param {Object|null} nextSeg - The segment information for the next buffered\n * segment, if one (`null` if none).\n * @param {number} minimumEndTime - Only consider the data before that time.\n * If `currentSeg` has only been garbage collected for some data which is after\n * that time, we will return `false`.\n */\nfunction doesEndSeemGarbageCollected(currentSeg, nextSeg, minimumEndTime) {\n    const { MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT } = config.getCurrent();\n    if (currentSeg.bufferedEnd === undefined) {\n        return false;\n    }\n    if (nextSeg !== null &&\n        nextSeg.bufferedStart !== undefined &&\n        nextSeg.bufferedStart - currentSeg.bufferedEnd < 0.1) {\n        return false;\n    }\n    if (minimumEndTime > currentSeg.bufferedEnd &&\n        currentSeg.end - currentSeg.bufferedEnd > MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT) {\n        log.info(\"Stream: The end of the wanted segment has been garbage collected\", currentSeg.end, currentSeg.bufferedEnd);\n        return true;\n    }\n    return false;\n}\n/**\n * Returns `true` if a segment that has been garbage-collected at the start\n * might profit from being re-loaded.\n *\n * Returns `false` if we have a high chance of staying in the same situation\n * after re-loading the segment.\n *\n * This function takes in argument the entries of a SegmentSink's history\n * related to the corresponding segment and check if the segment appeared\n * garbage-collected at the start directly after the last few times it was\n * pushed, indicating that the issue might be sourced at a browser issue instead\n * of classical garbage collection.\n *\n * @param {Array.<Object>} segmentEntries\n * @param {number|undefined} currentBufferedStart\n * @returns {boolean}\n */\nfunction shouldReloadSegmentGCedAtTheStart(segmentEntries, currentBufferedStart) {\n    var _a, _b;\n    if (segmentEntries.length < 2) {\n        return true;\n    }\n    const lastEntry = segmentEntries[segmentEntries.length - 1];\n    const lastBufferedStart = (_a = lastEntry.buffered) === null || _a === void 0 ? void 0 : _a.start;\n    // If the current segment's buffered start is much higher than what it\n    // initially was when we pushed it, the segment has a very high chance of\n    // having been truly garbage-collected.\n    if (currentBufferedStart !== undefined &&\n        lastBufferedStart !== undefined &&\n        currentBufferedStart - lastBufferedStart > 0.05) {\n        return true;\n    }\n    const prevEntry = segmentEntries[segmentEntries.length - 2];\n    const prevBufferedStart = (_b = prevEntry.buffered) === null || _b === void 0 ? void 0 : _b.start;\n    if (prevBufferedStart === undefined || lastBufferedStart === undefined) {\n        return true;\n    }\n    // Compare `bufferedStart` from the last time this segment was pushed\n    // (`entry.bufferedStart`) to the previous time it was pushed\n    // (`prevSegEntry.bufferedStart`).\n    //\n    // If in both cases, we notice that their initial `bufferedStart` are close,\n    // it means that in recent history the same segment has been accused to be\n    // garbage collected two times at roughly the same positions just after being\n    // pushed.\n    // This is very unlikely and might be linked to either a content or browser\n    // issue. In that case, don't try to reload.\n    return Math.abs(prevBufferedStart - lastBufferedStart) > 0.01;\n}\n/**\n * Returns `true` if a segment that has been garbage-collected at the end\n * might profit from being re-loaded.\n *\n * Returns `false` if we have a high chance of staying in the same situation\n * after re-loading the segment.\n *\n * This function takes in argument the entries of a SegmentSink's history\n * related to the corresponding segment and check if the segment appeared\n * garbage-collected at the end directly after the last few times it was\n * pushed, indicating that the issue might be sourced at a browser issue instead\n * of classical garbage collection.\n *\n * @param {Array.<Object>} segmentEntries\n * @param {number|undefined} currentBufferedEnd\n * @returns {boolean}\n */\nfunction shouldReloadSegmentGCedAtTheEnd(segmentEntries, currentBufferedEnd) {\n    var _a, _b;\n    if (segmentEntries.length < 2) {\n        return true;\n    }\n    const lastEntry = segmentEntries[segmentEntries.length - 1];\n    const lastBufferedEnd = (_a = lastEntry.buffered) === null || _a === void 0 ? void 0 : _a.end;\n    // If the current segment's buffered end is much lower than what it\n    // initially was when we pushed it, the segment has a very high chance of\n    // having been truly garbage-collected.\n    if (currentBufferedEnd !== undefined &&\n        lastBufferedEnd !== undefined &&\n        lastBufferedEnd - currentBufferedEnd > 0.05) {\n        return true;\n    }\n    const prevEntry = segmentEntries[segmentEntries.length - 2];\n    const prevBufferedEnd = (_b = prevEntry.buffered) === null || _b === void 0 ? void 0 : _b.end;\n    if (prevBufferedEnd === undefined || lastBufferedEnd === undefined) {\n        return true;\n    }\n    // Compare `bufferedEnd` from the last time this segment was pushed\n    // (`entry.bufferedEnd`) to the previous time it was pushed\n    // (`prevSegEntry.bufferedEnd`).\n    //\n    // If in both cases, we notice that their initial `bufferedEnd` are close,\n    // it means that in recent history the same segment has been accused to be\n    // garbage collected two times at roughly the same positions just after being\n    // pushed.\n    // This is very unlikely and might be linked to either a content or browser\n    // issue. In that case, don't try to reload.\n    return Math.abs(prevBufferedEnd - lastBufferedEnd) > 0.01;\n}\n/**\n * Returns the list of segments, minus those that have been garbage collected.\n * @param {IBufferedChunk[]} segments - The segments list to filter.\n * @param {Object} neededRange - The range we want to fill with segments.\n * @param getBufferedHistory - Callback allowing to retrieve a segment's history in the buffer\n * @returns The segments list including only reusable segments.\n */\nfunction filterOutGCedSegments(segments, neededRange, getBufferedHistory) {\n    return segments.filter((currentSeg, i, consideredSegments) => {\n        const prevSeg = i === 0 ? null : consideredSegments[i - 1];\n        const nextSeg = i >= consideredSegments.length - 1 ? null : consideredSegments[i + 1];\n        let lazySegmentHistory = null;\n        if (doesStartSeemGarbageCollected(currentSeg, prevSeg, neededRange.start)) {\n            lazySegmentHistory = getBufferedHistory(currentSeg.infos);\n            if (shouldReloadSegmentGCedAtTheStart(lazySegmentHistory, currentSeg.bufferedStart)) {\n                return false;\n            }\n            log.debug(\"Stream: skipping segment gc-ed at the start\", currentSeg.start, currentSeg.bufferedStart);\n        }\n        if (doesEndSeemGarbageCollected(currentSeg, nextSeg, neededRange.end)) {\n            lazySegmentHistory = lazySegmentHistory !== null && lazySegmentHistory !== void 0 ? lazySegmentHistory : getBufferedHistory(currentSeg.infos);\n            if (shouldReloadSegmentGCedAtTheEnd(lazySegmentHistory, currentSeg.bufferedEnd)) {\n                return false;\n            }\n            log.debug(\"Stream: skipping segment gc-ed at the end\", currentSeg.end, currentSeg.bufferedEnd);\n        }\n        return true;\n    });\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport config from \"../../../../config\";\n/**\n * Calculate the priority number for a given segment start time, in function of\n * the distance with the wanted starting timestamp.\n *\n * The lower is this number, the higher should be the priority of the request.\n *\n * Note that a `segmentTime` given behind the current time will always have the\n * highest priority.\n * @param {number} segmentTime\n * @param {Object} wantedStartTimestamp\n * @returns {number}\n */\nexport default function getSegmentPriority(segmentTime, wantedStartTimestamp) {\n    const distance = segmentTime - wantedStartTimestamp;\n    const { SEGMENT_PRIORITIES_STEPS } = config.getCurrent();\n    for (let priority = 0; priority < SEGMENT_PRIORITIES_STEPS.length; priority++) {\n        if (distance < SEGMENT_PRIORITIES_STEPS[priority]) {\n            return priority;\n        }\n    }\n    return SEGMENT_PRIORITIES_STEPS.length;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport objectAssign from \"../../../../utils/object_assign\";\nimport appendSegmentToBuffer from \"./append_segment_to_buffer\";\n/**\n * Push the initialization segment to the SegmentSink.\n * @param {Object} args\n * @param {Object} cancelSignal\n * @returns {Promise}\n */\nexport default async function pushInitSegment({ playbackObserver, content, initSegmentUniqueId, segment, segmentSink, bufferGoal, }, cancelSignal) {\n    const codec = content.representation.getMimeTypeString();\n    const data = {\n        initSegmentUniqueId,\n        chunk: null,\n        timestampOffset: 0,\n        appendWindow: [undefined, undefined],\n        codec,\n    };\n    const inventoryInfos = objectAssign({ segment, chunkSize: undefined, start: 0, end: 0 }, content);\n    const buffered = await appendSegmentToBuffer(playbackObserver, segmentSink, { data, inventoryInfos }, bufferGoal, cancelSignal);\n    return { content, segment, buffered };\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport config from \"../../../../config\";\nimport objectAssign from \"../../../../utils/object_assign\";\nimport appendSegmentToBuffer from \"./append_segment_to_buffer\";\n/**\n * Push a given media segment (non-init segment) to a SegmentSink.\n * @param {Object} args\n * @param {Object} cancelSignal\n * @returns {Promise}\n */\nexport default async function pushMediaSegment({ playbackObserver, bufferGoal, content, initSegmentUniqueId, parsedSegment, segment, segmentSink, }, cancelSignal) {\n    var _a, _b;\n    if (parsedSegment.chunkData === null) {\n        return null;\n    }\n    const { chunkData, chunkInfos, chunkOffset, chunkSize, appendWindow } = parsedSegment;\n    const codec = content.representation.getMimeTypeString();\n    const { APPEND_WINDOW_SECURITIES } = config.getCurrent();\n    // Cutting exactly at the start or end of the appendWindow can lead to\n    // cases of infinite rebuffering due to how browser handle such windows.\n    // To work-around that, we add a small offset before and after those.\n    const safeAppendWindow = [\n        appendWindow[0] !== undefined\n            ? Math.max(0, appendWindow[0] - APPEND_WINDOW_SECURITIES.START)\n            : undefined,\n        appendWindow[1] !== undefined\n            ? appendWindow[1] + APPEND_WINDOW_SECURITIES.END\n            : undefined,\n    ];\n    const data = {\n        initSegmentUniqueId,\n        chunk: chunkData,\n        timestampOffset: chunkOffset,\n        appendWindow: safeAppendWindow,\n        codec,\n    };\n    let estimatedStart = (_a = chunkInfos === null || chunkInfos === void 0 ? void 0 : chunkInfos.time) !== null && _a !== void 0 ? _a : segment.time;\n    const estimatedDuration = (_b = chunkInfos === null || chunkInfos === void 0 ? void 0 : chunkInfos.duration) !== null && _b !== void 0 ? _b : segment.duration;\n    let estimatedEnd = estimatedStart + estimatedDuration;\n    if (safeAppendWindow[0] !== undefined) {\n        estimatedStart = Math.max(estimatedStart, safeAppendWindow[0]);\n    }\n    if (safeAppendWindow[1] !== undefined) {\n        estimatedEnd = Math.min(estimatedEnd, safeAppendWindow[1]);\n    }\n    const inventoryInfos = objectAssign({ segment, chunkSize, start: estimatedStart, end: estimatedEnd }, content);\n    const buffered = await appendSegmentToBuffer(playbackObserver, segmentSink, { data, inventoryInfos }, bufferGoal, cancelSignal);\n    return { content, segment, buffered };\n}\n","/**\n * Configuration file for the whole player.\n * Feel free to tweak those values if you know what you're doing.\n *\n * Please not that you will need to re-build the whole project to take these\n * modifications into account.\n *\n * @type {Object}\n */\nconst DEFAULT_CONFIG = {\n    /**\n     * Default time interval after which a request will timeout, in ms.\n     * @type {Number}\n     */\n    DEFAULT_REQUEST_TIMEOUT: 30 * 1000,\n    /**\n     * Default connection time after which a request will timeout, in ms.\n     * @type {Number}\n     */\n    DEFAULT_CONNECTION_TIMEOUT: 15 * 1000,\n    /**\n     * Can be either:\n     *   - \"native\": Subtitles are all displayed in a <track> element\n     *   - \"html\": Subtitles are all displayed in a <div> separated from the video\n     *     element. Can be useful to display richer TTML subtitles, for example.\n     * @type {Object|null}\n     */\n    DEFAULT_TEXT_TRACK_MODE: \"native\",\n    /**\n     * Default behavior for the `enableFastSwitching` loadVideo options.\n     *\n     * Fast-switching allows to provide quicker transitions from lower quality\n     * segments to higher quality segments but might be badly supported on some\n     * devices.\n     * When enabled, the RxPlayer might replace segments of a lower-quality\n     * (with a lower bitrate) with segments of a higher quality (with a higher\n     * bitrate). This allows to have a fast transition when network conditions\n     * improve.\n     * When disabled, segments of a lower-quality will not be replaced.\n     */\n    DEFAULT_ENABLE_FAST_SWITCHING: true,\n    /**\n     * In some cases after switching the current track or bitrate, the RxPlayer\n     * could be led to go into the `\"RELOADING\"` state, which corresponds to\n     * visually a black screen (with nothing audible) before restarting playback.\n     *\n     * We could want to seek back some milliseconds when doing that.\n     * For example, when switching the current audio track, it might make sense\n     * to restart some time before, so the beginning of the sentence can be heard\n     * again in the new language.\n     *\n     * This config property allows to set the relative position the RxPlayer will\n     * seek to after reloading, in seconds.\n     *\n     * For example: a value of `-0.7` means that will seek back 700 milliseconds\n     * when reloading due to a track or bitrate switch with necessitated a\n     * reloading.\n     */\n    DELTA_POSITION_AFTER_RELOAD: {\n        /** Relative position when switching the bitrate */\n        bitrateSwitch: -0.1,\n        /**\n         * Relative position when switching the track.\n         *\n         * From tests, I noticed that seeking back was only really \"pleasant\" when\n         * switching the audio track.\n         *\n         * E.g. switching the video track often means changing the camera angle or\n         * even totally changing what is being seen and rely much less on temporal\n         * context than when an audio track is switched.\n         * As such, I decided to only set a sensible seek-back behavior when\n         * switching the audio track, and only a minimal one (to still ensure\n         * nothing was missed) for video.\n         *\n         * \"Other\" mainly concern text track, where seeking back could even be\n         * annoying, so that behavior has been disabled in that case.\n         */\n        trackSwitch: { audio: 0, video: 0, other: 0 },\n    },\n    /**\n     * Behavior of the RxPlayer when encountering a whole other codec on a already\n     * existing audio or video SourceBuffer.\n     *\n     * Can be either:\n     *\n     *    - \"continue\": Segments linked to the new codec will continue to be\n     *      pushed to that same SourceBuffer. The RxPlayer will still try to call\n     *      the `changeType` API on the SourceBuffer before pushing those\n     *      segments but continue even if this call failed.\n     *\n     *    - \"reload\": Every time a new incompatible codec is encountered on a\n     *      given SourceBuffer, we will reload the MediaSource.\n     */\n    DEFAULT_CODEC_SWITCHING_BEHAVIOR: \"continue\",\n    /**\n     * If set to true, video through loadVideo will auto play by default\n     * @type {Boolean}\n     */\n    DEFAULT_AUTO_PLAY: false,\n    /**\n     * Default buffer goal in seconds.\n     * Once enough content has been downloaded to fill the buffer up to\n     * ``current position + DEFAULT_WANTED_BUFFER_AHEAD\", we will stop downloading\n     * content.\n     * @type {Number}\n     */\n    DEFAULT_WANTED_BUFFER_AHEAD: 30,\n    /**\n     * Default max buffer size ahead of the current position in seconds.\n     * The buffer _after_ this limit will be garbage collected.\n     * Set to Infinity for no limit.\n     * @type {Number}\n     */\n    DEFAULT_MAX_BUFFER_AHEAD: Infinity,\n    /**\n     * Default max buffer size ahead of the current position in seconds.\n     * The buffer _before_ this limit will be garbage collected.\n     * Set to Infinity for no limit.\n     * @type {Number}\n     */\n    DEFAULT_MAX_BUFFER_BEHIND: Infinity,\n    /**\n     * Default video buffer memory limit in kilobytes.\n     * Once enough video content has been downloaded to fill the buffer up to\n     * DEFAULT_MAX_VIDEO_BUFFER_SIZE , we will stop downloading\n     * content.\n     * @type {Number}\n     */\n    DEFAULT_MAX_VIDEO_BUFFER_SIZE: Infinity,\n    /**\n     * Maximum possible buffer ahead for each type of buffer, to avoid too much\n     * memory usage when playing for a long time.\n     * Equal to Infinity if not defined here.\n     * @type {Object}\n     */\n    MAXIMUM_MAX_BUFFER_AHEAD: {\n        text: 5 * 60 * 60,\n    },\n    /**\n     * Minimum possible buffer ahead for each type of buffer, to avoid Garbage\n     * Collecting too much data when it would have adverse effects.\n     * Equal to `0` if not defined here.\n     * @type {Object}\n     */\n    MINIMUM_MAX_BUFFER_AHEAD: {\n        // Text segments are both much lighter on resources and might\n        // actually be much larger than other types of segments in terms\n        // of duration. Let's make an exception here by authorizing a\n        // larger text buffer ahead, to avoid unnecesarily reloading the\n        // same text track.\n        text: 2 * 60,\n    },\n    /**\n     * Maximum possible buffer behind for each type of buffer, to avoid too much\n     * memory usage when playing for a long time.\n     * Equal to Infinity if not defined here.\n     * @type {Object}\n     */\n    MAXIMUM_MAX_BUFFER_BEHIND: {\n        text: 5 * 60 * 60,\n    },\n    /**\n     * Default bitrate ceils initially set as the first content begins.\n     *\n     * If no track is found with a bitrate inferior or equal to the\n     * bitrate there, the one with the lowest bitrate will be taken instead.\n     *\n     * Set to 0 for the lowest bitrate, Infinity for the highest.\n     *\n     * These values are only useful for the first content played, as consecutive\n     * play will always take the last set one.\n     * @type {Object}\n     */\n    DEFAULT_BASE_BANDWIDTH: 0,\n    /**\n     * Delay after which, if the page is hidden, the user is considered inactive\n     * on the current video.\n     *\n     * Allow to enforce specific optimizations when the page is not shown.\n     * @see DEFAULT_THROTTLE_WHEN_HIDDEN\n     * @type {Number}\n     */\n    INACTIVITY_DELAY: 60 * 1000,\n    /**\n     * If true, if the video is considered in a \"hidden\" state for a delay specified by\n     * the INACTIVITY DELAY config property, we throttle automatically to the video\n     * representation with the lowest bitrate.\n     * @type {Boolean}\n     */\n    DEFAULT_THROTTLE_VIDEO_BITRATE_WHEN_HIDDEN: false,\n    /**\n     * Default video resolution limit behavior.\n     *\n     * This option allows for example to throttle the video resolution so it\n     * does not exceed the screen resolution.\n     *\n     * Here set to \"none\" by default to disable throttling.\n     * @type {Boolean}\n     */\n    DEFAULT_VIDEO_RESOLUTION_LIMIT: \"none\",\n    /**\n     * Default initial live gap considered if no presentation delay has been\n     * suggested, in seconds.\n     * @type {Number}\n     */\n    DEFAULT_LIVE_GAP: {\n        DEFAULT: 10,\n        LOW_LATENCY: 3.5,\n    },\n    /**\n     * Maximum time, in seconds, the player should automatically skip when stalled\n     * because of a current hole in the buffer.\n     * Bear in mind that this might seek over not-yet-downloaded/pushed segments.\n     * @type {Number}\n     */\n    BUFFER_DISCONTINUITY_THRESHOLD: 0.2,\n    /**\n     * Ratio used to know if an already loaded segment should be re-buffered.\n     * We re-load the given segment if the current one times that ratio is\n     * inferior to the new one.\n     * @type {Number}\n     */\n    BITRATE_REBUFFERING_RATIO: 1.5,\n    /**\n     * The default number of times a manifest request will be re-performed\n     * when loaded/refreshed if the request finishes on an error which\n     * justify an retry.\n     *\n     * Note that some errors do not use this counter:\n     *   - if the error is not due to the xhr, no retry will be peformed\n     *   - if the error is an HTTP error code, but not a 500-smthg or a 404, no\n     *     retry will be performed.\n     * @type Number\n     */\n    DEFAULT_MAX_MANIFEST_REQUEST_RETRY: 4,\n    /**\n     * Default delay, in seconds, during which a CDN will be \"downgraded\".\n     *\n     * For example in case of media content being available on multiple CDNs, the\n     * RxPlayer may decide that a CDN is less reliable (for example, it returned a\n     * server error) and should thus be avoided, at least for some time\n     *\n     * This value is the amount of time this CDN will be \"less considered\" than the\n     * alternatives.\n     */\n    DEFAULT_CDN_DOWNGRADE_TIME: 60,\n    /**\n     * The default number of times a segment request will be re-performed when\n     * on error which justify a retry.\n     *\n     * Note that some errors do not use this counter:\n     *   - if the error is not due to the xhr, no retry will be peformed\n     *   - if the error is an HTTP error code, but not a 500-smthg or a 404, no\n     *     retry will be performed.\n     * @type Number\n     */\n    DEFAULT_MAX_REQUESTS_RETRY_ON_ERROR: 4,\n    /**\n     * Initial backoff delay when a segment / manifest download fails, in\n     * milliseconds.\n     *\n     * This delay will then grow exponentally by power of twos (200, 400, 800\n     * etc.)\n     *\n     * Please note that this delay is not exact, as it will be fuzzed.\n     * @type {Number}\n     */\n    INITIAL_BACKOFF_DELAY_BASE: {\n        REGULAR: 200,\n        LOW_LATENCY: 50,\n    },\n    /**\n     * Maximum backoff delay when a segment / manifest download fails, in\n     * milliseconds.\n     *\n     * Please note that this delay is not exact, as it will be fuzzed.\n     * @type {Number}\n     */\n    MAX_BACKOFF_DELAY_BASE: {\n        REGULAR: 3000,\n        LOW_LATENCY: 1000,\n    },\n    /**\n     * Minimum interval at which playback information samples will be taken. This\n     * variable is for the \"regular\" mediasource strategy (that is, not for the\n     * directfile API.\n     *\n     * At each of these interval, various different modules in the RxPlayer will\n     * run based on the information communicated.\n     *\n     * Keep in mind this is the minimum interval. This logic will also be\n     * triggered when various events of the media element are received.\n     * @type {Number}\n     */\n    SAMPLING_INTERVAL_MEDIASOURCE: 1000,\n    /**\n     * Same than SAMPLING_INTERVAL_MEDIASOURCE but for lowLatency mode.\n     * @type {Number}\n     */\n    SAMPLING_INTERVAL_LOW_LATENCY: 500,\n    /**\n     * Same than SAMPLING_INTERVAL_MEDIASOURCE but for the directfile API.\n     * @type {Number}\n     */\n    SAMPLING_INTERVAL_NO_MEDIASOURCE: 500,\n    /**\n     * Amount of buffer to have ahead of the current position before we may\n     * consider buffer-based adaptive estimates, in seconds.\n     *\n     * For example setting it to `10` means that we need to have ten seconds of\n     * buffer ahead of the current position before relying on buffer-based\n     * adaptive estimates.\n     *\n     * To avoid getting in-and-out of the buffer-based logic all the time, it\n     * should be set higher than `ABR_EXIT_BUFFER_BASED_ALGO`.\n     */\n    ABR_ENTER_BUFFER_BASED_ALGO: 10,\n    /**\n     * Below this amount of buffer ahead of the current position, in seconds, we\n     * will stop using buffer-based estimate in our adaptive logic to select a\n     * quality.\n     *\n     * For example setting it to `5` means that if we have less than 5 seconds of\n     * buffer ahead of the current position, we should stop relying on\n     * buffer-based estimates to choose a quality.\n     *\n     * To avoid getting in-and-out of the buffer-based logic all the time, it\n     * should be set lower than `ABR_ENTER_BUFFER_BASED_ALGO`.\n     */\n    ABR_EXIT_BUFFER_BASED_ALGO: 5,\n    /**\n     * Minimum number of bytes sampled before we trust the estimate.\n     * If we have not sampled much data, our estimate may not be accurate\n     * enough to trust.\n     * If the total of bytes sampled is less than this value, we use a\n     * default estimate.\n     * This specific value is based on experimentations.\n     * @type {Number}\n     */\n    ABR_MINIMUM_TOTAL_BYTES: 150e3,\n    /**\n     * Minimum number of bytes, under which samples are discarded.\n     * Our models do not include latency information, so connection startup time\n     * (time to first byte) is considered part of the download time.\n     * Because of this, we should ignore very small downloads which would cause\n     * our estimate to be too low.\n     * This specific value is based on experimentation.\n     * @type {Number}\n     */\n    ABR_MINIMUM_CHUNK_SIZE: 16e3,\n    /**\n     * Factor with which is multiplied the bandwidth estimate when the ABR is in\n     * starvation mode.\n     * @type {Object}\n     */\n    ABR_STARVATION_FACTOR: {\n        DEFAULT: 0.72,\n        LOW_LATENCY: 0.72,\n    },\n    /**\n     * Factor with which is multiplied the bandwidth estimate when the ABR is not\n     * in starvation mode.\n     * @type {Object}\n     */\n    ABR_REGULAR_FACTOR: {\n        DEFAULT: 0.72,\n        LOW_LATENCY: 0.72,\n    },\n    /**\n     * If a media buffer has less than ABR_STARVATION_GAP in seconds ahead of the\n     * current position in its buffer, the adaptive logic will go into starvation\n     * mode.\n     *\n     * It gets out of starvation mode when the OUT_OF_STARVATION_GAP value is\n     * reached.\n     *\n     * Under this starvation mode:\n     *\n     *   - the bandwidth considered will be a little lower than the one estimated\n     *\n     *   - the time the next important request take will be checked\n     *     multiple times to detect when/if it takes too much time.\n     *     If the request is considered too long, the bitrate will be hastily\n     *     re-calculated from this single request.\n     *\n     * @type {Object}\n     */\n    ABR_STARVATION_GAP: {\n        DEFAULT: 5,\n        LOW_LATENCY: 5,\n    },\n    OUT_OF_STARVATION_GAP: {\n        DEFAULT: 7,\n        LOW_LATENCY: 7,\n    },\n    /**\n     * This is a security to avoid going into starvation mode when the content is\n     * ending (@see ABR_STARVATION_GAP).\n     * Basically, we subtract that value from the global duration of the content\n     * and we never enter \"starvation mode\" if the currently available buffer\n     * (which equals to the current position + the available buffer ahead of it)\n     * is equal or higher than this value.\n     * @type {Number}\n     */\n    ABR_STARVATION_DURATION_DELTA: 0.1,\n    /**\n     * Half-life, in seconds for a fastly-evolving exponential weighted moving\n     * average.\n     * The lower it is, the faster the ABR logic will react to the bandwidth\n     * falling quickly.\n     * Should be kept to a lower number than ABR_SLOW_EMA for coherency reasons.\n     * @type {Number}\n     */\n    ABR_FAST_EMA: 2,\n    /**\n     * Half-life, in seconds for a slowly-evolving exponential weighted moving\n     * average.\n     * The lower it is, the faster the ABR logic is going to react to recent\n     * bandwidth variation, on the higher and on the lower side.\n     * Should be kept to a higher number than ABR_FAST_EMA for coherency reasons.\n     * @type {Number}\n     */\n    ABR_SLOW_EMA: 10,\n    /**\n     * Number of seconds ahead in the buffer after which playback will resume when\n     * seeking on an unbuffered part of the content.\n     * @type {Number}\n     */\n    RESUME_GAP_AFTER_SEEKING: {\n        DEFAULT: 1.5,\n        LOW_LATENCY: 0.5,\n    },\n    /**\n     * Number of seconds ahead in the buffer after which playback will resume when\n     * the player was rebuffering due to a low readyState.\n     * @type {Number}\n     */\n    RESUME_GAP_AFTER_NOT_ENOUGH_DATA: {\n        DEFAULT: 0.5,\n        LOW_LATENCY: 0.5,\n    },\n    /**\n     * Number of seconds ahead in the buffer after which playback will resume\n     * after the player went through a buffering step.\n     * @type {Number}\n     */\n    RESUME_GAP_AFTER_BUFFERING: {\n        DEFAULT: 5,\n        LOW_LATENCY: 0.5,\n    },\n    /**\n     * Maximum number of seconds in the buffer based on which a \"rebuffering\"\n     * strategy will be considered:\n     * The player will pause playback to get enough time building a sufficient\n     * buffer. This mostly happen when seeking in an unbuffered part or when not\n     * enough buffer is ahead of the current position.\n     * @type {Number}\n     */\n    REBUFFERING_GAP: {\n        DEFAULT: 0.5,\n        LOW_LATENCY: 0.2,\n    },\n    /**\n     * Amount of time (in seconds) with data ahead of the current position, at\n     * which we always consider the browser to be able to play.\n     *\n     * If the media element has this amount of data in advance or more but\n     * playback cannot begin, the player will consider it \"freezing\".\n     */\n    MINIMUM_BUFFER_AMOUNT_BEFORE_FREEZING: 2,\n    /**\n     * A media whose position inexplicably does not increment despite playing is\n     * called as \"freezing\" in the RxPlayer.\n     *\n     * If the media is still \"freezing\" after waiting for `UNFREEZING_SEEK_DELAY`\n     * milliseconds, the RxPlayer will try to un-freeze the situation by interacting\n     * with the media element.\n     *\n     * Those interactions can be costly in time before playback continue, so it\n     * should be set at a sufficiently high value to avoid false positives.\n     */\n    UNFREEZING_SEEK_DELAY: 6000,\n    /**\n     * A media whose position inexplicably does not increment despite playing is\n     * called as \"freezing\" in the RxPlayer.\n     *\n     * A small freezing interval may be normal as the browser may take time before\n     * playing, e.g. after a seek.\n     *\n     * If the media is still \"freezing\" after waiting for `FREEZING_STALLED_DELAY`\n     * milliseconds, the RxPlayer will emit a BUFFERING state through its API to\n     * notify that the player cannot currently advance.\n     */\n    FREEZING_STALLED_DELAY: 600,\n    /**\n     * A media whose position inexplicably does not increment despite playing is\n     * called as \"freezing\" in the RxPlayer.\n     *\n     * If the media is frozen for a sufficiently large time\n     * (@see UNFREEZING_SEEK_DELAY), the RxPlayer will perform a seek corresponding\n     * to its current position plus `UNFREEZING_DELTA_POSITION` seconds.\n     *\n     * This should be kept short enough as the goal is just to un-freeze lower-level\n     * buffers.\n     */\n    UNFREEZING_DELTA_POSITION: 0.001,\n    /**\n     * `FREEZING` is a situation where the playback does not seem to advance despite\n     * all web indicators telling us we can.\n     * Those may be linked to device issues, but sometimes are just linked to\n     * performance or it may be just decryption negotiations taking more time than\n     * expected.\n     *\n     * Anyway we might in the RxPlayer \"flush\" the buffer in that situation to\n     * un-stuck playback (this is usually done by seeking close to the current\n     * position),\n     *\n     * Yet that \"flush\" attempt may not in the end be succesful.\n     *\n     * If a flush was performed more than `FREEZING_FLUSH_FAILURE_DELAY.MINIMUM`\n     * milliseconds ago and less than `FREEZING_FLUSH_FAILURE_DELAY.MAXIMUM`\n     * milliseconds ago, yet a `FREEZING` situation at roughly the same playback\n     * position (deviating from less than\n     * `FREEZING_FLUSH_FAILURE_DELAY.POSITION_DELTA` seconds from it) is\n     * encountered again, we will consider that the flushing attempt was unsuccesful\n     * and try more agressive solutions (such as reloading the content).\n     */\n    FREEZING_FLUSH_FAILURE_DELAY: {\n        MAXIMUM: 20000,\n        MINIMUM: 4000,\n        POSITION_DELTA: 1,\n    },\n    /**\n     * The RxPlayer has a recurring logic which will synchronize the browser's\n     * buffers' buffered time ranges with its internal representation in the\n     * RxPlayer to then rely on that internal representation to determine where\n     * segments are technically present in the browser's buffer.\n     *\n     * We found out that when inserting a new segment to the buffer, the browser\n     * may actually take time before actually considering the full segment in its\n     * advertised buffered time ranges.\n     *\n     * This value thus set an amount of milliseconds we might want to wait before\n     * being sure that the buffered time ranges should have considered a segment\n     * that has been pushed.\n     */\n    SEGMENT_SYNCHRONIZATION_DELAY: 1500,\n    /**\n     * The `SEGMENT_SYNCHRONIZATION_DELAY` defined in this same configuration\n     * object only needs to be used if it appears that the current buffered\n     * time ranges do not reflect the full data of a pushed segment yet.\n     *\n     * The `MISSING_DATA_TRIGGER_SYNC_DELAY` value thus allows to define a\n     * minimum time difference in seconds between what's buffered and what the\n     * segment's ranges should have been, from which we might consider that we may\n     * want to wait the `SEGMENT_SYNCHRONIZATION_DELAY` before trusting the buffered\n     * time ranges for that segment.\n     * If what's missing from that segment is however less than that value in\n     * seconds, we can begin to trust the reported buffered time ranges.\n     *\n     * Should generally be inferior to `MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT`.\n     */\n    MISSING_DATA_TRIGGER_SYNC_DELAY: 0.1,\n    /**\n     * Maximum authorized difference between what we calculated to be the\n     * beginning or end of the segment in a media buffer and what we\n     * actually are noticing now.\n     *\n     * If the segment seems to have removed more than this size in seconds, we\n     * will infer that the segment has been garbage collected and we might try to\n     * re-download it.\n     * @type {Number}\n     */\n    MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT: 0.15,\n    /**\n     * The maximum authorized difference, in seconds, between the real buffered\n     * time of a given chunk and what the segment information of the Manifest\n     * tells us.\n     *\n     * Setting a value too high can lead to parts of the media buffer being\n     * linked to the wrong segments and to segments wrongly believed to be still\n     * complete (instead of garbage collected).\n     *\n     * Setting a value too low can lead to parts of the media buffer not being\n     * linked to the concerned segment and to segments wrongly believed to be\n     * partly garbage collected (instead of complete segments).\n     * @type {Number}\n     */\n    MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE: 0.4,\n    /**\n     * The maximum authorized difference, in seconds, between the duration a\n     * segment should have according to the Manifest and the actual duration it\n     * seems to have once pushed to the media buffer.\n     *\n     * Setting a value too high can lead to parts of the media buffer being\n     * linked to the wrong segments and to segments wrongly believed to be still\n     * complete (instead of garbage collected).\n     *\n     * Setting a value too low can lead to parts of the media buffer not being\n     * linked to the concerned segment and to segments wrongly believed to be\n     * partly garbage collected (instead of complete segments). This last point\n     * could lead to unnecessary segment re-downloading.\n     * @type {Number}\n     */\n    MAX_MANIFEST_BUFFERED_DURATION_DIFFERENCE: 0.3,\n    /**\n     * Minimum duration in seconds a segment should be into a buffered range to be\n     * considered as part of that range.\n     * Segments which have less than this amount of time \"linked\" to a buffered\n     * range will be deleted.\n     *\n     * Setting a value too low can lead in worst-case scenarios to segments being\n     * wrongly linked to the next or previous range it is truly linked too (if\n     * those ranges are too close).\n     *\n     * Setting a value too high can lead to part of the buffer not being assigned\n     * any segment. It also limits the minimum duration a segment can be.\n     *\n     * TODO As of now, this limits the minimum size a complete segment can be. A\n     * better logic would be to also consider the duration of a segment. Though\n     * this logic could lead to bugs with the current code.\n     * @type {Number}\n     */\n    MINIMUM_SEGMENT_SIZE: 0.001,\n    /**\n     * Append windows allow to filter media data from segments if they are outside\n     * a given limit.\n     * Coded frames with presentation timestamp within this range are allowed to\n     * be appended to the media buffer while coded frames outside this range are\n     * filtered out.\n     *\n     * Those are often set to be the start and end of the \"Period\" the segment is\n     * in.\n     * However, we noticed that some browsers were too aggressive when the exact\n     * limits were set: more data than needed was removed, often leading to\n     * discontinuities.\n     *\n     * Those securities are added to the set windows (substracted from the window\n     * start and added to the window end) to avoid those problems.\n     * @type {Object}\n     */\n    APPEND_WINDOW_SECURITIES: {\n        START: 0.2,\n        END: 0.1,\n    },\n    /**\n     * Maximum interval at which text tracks are refreshed in an \"html\"\n     * textTrackMode.\n     *\n     * The text tracks are also refreshed on various video events, this interval\n     * will only trigger a refresh if none of those events was received during\n     * that timespan.\n     *\n     * Note that if the TextTrack cue did not change between two intervals or\n     * events, the DOM won't be refreshed.\n     * The TextTrack cues structure is also optimized for fast retrieval.\n     * We should thus not have much of a performance impact here if we set a low\n     * interval.\n     *\n     * @type {Number}\n     */\n    MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL: 50,\n    /**\n     * On browsers with no ResizeObserver API, this will be the interval in\n     * milliseconds at which we should check if the text track element has\n     * changed its size, and updates proportional text-track data accordingly\n     * (like a proportional font-size).\n     *\n     * This is only used:\n     *   - in an \"html\" textTrackMode\n     *   - when some styling is proportional in the text track data\n     *\n     * Putting a value too low will render faster but might use to much proc time.\n     * Putting a value too high might provoke a re-render too late after the user\n     * changed the element's size (e.g. when going to fullscreen mode).\n     *\n     * @type {Number}\n     */\n    TEXT_TRACK_SIZE_CHECKS_INTERVAL: 250,\n    /**\n     * The Buffer padding is a time offset from the current time that affects\n     * the buffer.\n     *\n     * Basically, from a given time, if the current buffer gap number (time\n     * between the current time and the end of the downloaded buffer) is above\n     * the padding described here (of the corresponding type), we won't\n     * reschedule segments for that range.\n     *\n     * This is to avoid excessive re-buffering.\n     *\n     * Keeping the padding too low would increase the risk of re-bufferings.\n     *\n     * Keeping the padding too high would delay visible quality increase.\n     *\n     * @type {Object}\n     */\n    BUFFER_PADDING: {\n        audio: 1, // only \"audio\" segments\n        video: 3, // only \"video\" segments\n        other: 1, // tracks which are not audio/video (like text).\n    },\n    /**\n     * Segments of different types are downloaded by steps:\n     *\n     *   - first the audio/video/text Segments which are immediately needed\n     *\n     *   - then once every of those Segments have been downloaded, less-needed\n     *     Segments\n     *\n     *   - then once every of those less-needed Segments have been downloaded,\n     *     even less-needed Segments\n     *\n     *   - etc.\n     *\n     * This stepped download strategy allows to make a better use of network\n     * ressources.\n     *\n     * For example, if more than sufficient audio buffer has been downloaded but\n     * the immediately-needed video Segment is still pending its request, we might\n     * be in a situation of rebuffering.\n     * In that case, a better strategy would be to make sure every network\n     * ressource is allocated for this video Segment before rebuffering happens.\n     *\n     * This is where those steps become useful.\n     *\n     * --\n     *\n     * The numbers defined in this Array describe what the steps are.\n     *\n     * Each number is linked to a distance from the current playing position, in\n     * seconds.\n     * Distances which will be used as limit points, from which a new step is\n     * reached (see example).\n     *\n     * In the RxPlayer's code, each step is then translated in to a priority\n     * number.\n     * The lower is that number, the lower is the step and the lower is the step,\n     * the higher is the priority.\n     *\n     * Note: You can set an empty array to deactivate the steps feature (every\n     * Segments have the same priority).\n     *\n     * @example\n     *\n     * let's imagine the following SEGMENT_PRIORITIES_STEPS array:\n     * [5, 11, 17, 25]\n     *\n     * To link each Segments to a corresponding priority number (and thus to a\n     * specific step), we have to consider the distance between the current\n     * position and the start time of the Segment.\n     *\n     * We have in our example 5 groups, which correspond to the following possible\n     * distances:\n     *   1. inferior to 5 => first step (priority number = 0)\n     *   2. between 5 and 11 => second step (priority number = 1)\n     *   3. between 11 and 17 => third step (priority number = 2)\n     *   4. between 17 and 25 => fourth step (priority number = 3)\n     *   5. superior to 25 => fifth step (priority number = 4)\n     *\n     * Segments corresponding to a lower-step will need to all be downloaded\n     * before Segments of a newer step begin.\n     *\n     * @type {Array.<Number>}\n     */\n    SEGMENT_PRIORITIES_STEPS: [\n        2, // 1st Step (priority number = 0):  < 2\n        4, // 2nd Step (priority number = 1):  2-4\n        8, // 3rd Step (priority number = 2):  4-8\n        12, // 4th Step (priority number = 3):  8-12\n        18, // 5th Step (priority number = 4):  12-18\n        25,\n    ], // 6th Step (priority number = 5):  18-25\n    // 7th Step (priority number = 6):  >= 25\n    /**\n     * Some segment requests are said to be \"high priority\".\n     *\n     * Requests in that category once done will cancel any segment request that\n     * has a low priority number (see `SEGMENT_PRIORITIES_STEPS`) - meaning a\n     * priority number equal to `MIN_CANCELABLE_PRIORITY` or more.\n     *\n     * Enter here the last priority number that is considered high priority\n     * (beginning by the first step, which has the priority number `0`).\n     * @type {number}\n     */\n    MAX_HIGH_PRIORITY_LEVEL: 1, // priority number 1 and lower is high priority\n    /**\n     * Enter here the first priority step (see `SEGMENT_PRIORITIES_STEPS`) that\n     * will be considered as low priority.\n     *\n     * Segment requests with a low priority will be cancelled if a high priority\n     * segment request (see MAX_HIGH_PRIORITY_LEVEL) is scheduled while they are\n     * pending.\n     *\n     * This number should be strictly superior to the value indicated in\n     * `MAX_HIGH_PRIORITY_LEVEL`.\n     * @type {number}\n     */\n    MIN_CANCELABLE_PRIORITY: 3, // priority number 3 onward can be cancelled\n    /**\n     * Codecs used in the videoCapabilities of the MediaKeySystemConfiguration\n     * (DRM).\n     *\n     * Defined in order of importance (first will be tested first etc.)\n     * @type {Array.<string>}\n     */\n    EME_DEFAULT_VIDEO_CODECS: [\n        'video/mp4;codecs=\"avc1.4d401e\"',\n        'video/mp4;codecs=\"avc1.42e01e\"',\n        'video/mp4;codecs=\"hvc1.1.6.L93.B0\"',\n        'video/webm;codecs=\"vp8\"',\n    ],\n    /**\n     * Codecs used in the audioCapabilities of the MediaKeySystemConfiguration\n     * (DRM).\n     *\n     * Defined in order of importance (first will be tested first etc.)\n     * @type {Array.<string>}\n     */\n    EME_DEFAULT_AUDIO_CODECS: [\n        'audio/mp4;codecs=\"mp4a.40.2\"',\n        'audio/webm;codecs=\"opus\"',\n        'audio/mp4;codecs=\"ec-3\"',\n    ],\n    /**\n     * Robustnesses used in the {audio,video}Capabilities of the\n     * MediaKeySystemConfiguration (DRM).\n     *\n     * Only used for widevine keysystems.\n     *\n     * Defined in order of importance (first will be tested first etc.)\n     * @type {Array.<string>}\n     */\n    EME_DEFAULT_WIDEVINE_ROBUSTNESSES: [\n        \"HW_SECURE_ALL\",\n        \"HW_SECURE_DECODE\",\n        \"HW_SECURE_CRYPTO\",\n        \"SW_SECURE_DECODE\",\n        \"SW_SECURE_CRYPTO\",\n    ],\n    /**\n     * Robustnesses used in the {audio,video}Capabilities of the\n     * MediaKeySystemConfiguration (DRM).\n     *\n     * Only used for \"com.microsoft.playready.recommendation\" keysystems.\n     *\n     * Defined in order of importance (first will be tested first etc.)\n     * @type {Array.<string>}\n     */\n    EME_DEFAULT_PLAYREADY_RECOMMENDATION_ROBUSTNESSES: [\"3000\", \"2000\"],\n    /**\n     * Link canonical key systems names to their respective reverse domain name,\n     * used in the EME APIs.\n     * This allows to have a simpler API, where users just need to set \"widevine\"\n     * or \"playready\" as a keySystem.\n     * @type {Object}\n     */\n    EME_KEY_SYSTEMS: {\n        clearkey: [\"webkit-org.w3.clearkey\", \"org.w3.clearkey\"],\n        widevine: [\"com.widevine.alpha\"],\n        playready: [\n            \"com.microsoft.playready.recommendation\",\n            \"com.microsoft.playready\",\n            \"com.chromecast.playready\",\n            \"com.youtube.playready\",\n        ],\n        fairplay: [\"com.apple.fps.1_0\"],\n    },\n    /**\n     * The Manifest parsing logic has a notion of \"unsafeMode\" which allows to\n     * speed-up this process a lot with a small risk of de-synchronization with\n     * what actually is on the server.\n     * Because using that mode is risky, and can lead to all sort of problems, we\n     * regularly should fall back to a regular \"safe\" parsing every once in a\n     * while.\n     * This value defines how many consecutive time maximum the \"unsafeMode\"\n     * parsing can be done.\n     */\n    MAX_CONSECUTIVE_MANIFEST_PARSING_IN_UNSAFE_MODE: 10,\n    /**\n     * Minimum time spent parsing the Manifest before we can authorize parsing\n     * it in an \"unsafeMode\", to speed-up the process with a little risk.\n     * Please note that this parsing time also sometimes includes idle time such\n     * as when the parser is waiting for a request to finish.\n     */\n    MIN_MANIFEST_PARSING_TIME_TO_ENTER_UNSAFE_MODE: 200,\n    /**\n     * Minimum amount of <S> elements in a DASH MPD's <SegmentTimeline> element\n     * necessary to begin parsing the current SegmentTimeline element in an\n     * unsafe manner (meaning: with risks of de-synchronization).\n     * This is only done when the \"unsafeMode\" parsing mode is enabled.\n     */\n    MIN_DASH_S_ELEMENTS_TO_PARSE_UNSAFELY: 300,\n    /**\n     * When we detect that the local Manifest might be out-of-sync with the\n     * server's one, we schedule a Manifest refresh.\n     * However, as this \"unsynchronization\" is only a theory and as we do not want\n     * to send too many Manifest requests, we keep a delay between the last\n     * Manifest refresh done and that one.\n     * This value indicates which delay we want. Note that the Manifest could\n     * still be refreshed before this delay for other reasons.\n     * @type {Number}\n     */\n    OUT_OF_SYNC_MANIFEST_REFRESH_DELAY: 3000,\n    /**\n     * When a partial Manifest update (that is an update with a partial sub-set\n     * of the Manifest) fails, we will perform an update with the whole Manifest\n     * instead.\n     * To not overload the client - as parsing a Manifest can be resource heavy -\n     * we set a minimum delay to wait before doing the corresponding request.\n     * @type {Number}\n     */\n    FAILED_PARTIAL_UPDATE_MANIFEST_REFRESH_DELAY: 3000,\n    /**\n     * DASH Manifest based on a SegmentTimeline should normally have an\n     * MPD@minimumUpdatePeriod attribute which should be sufficient to\n     * know when to refresh it.\n     * However, there is a specific case, for when it is equal to 0.\n     * As of DASH-IF IOP (valid in v4.3), when a DASH's MPD set a\n     * MPD@minimumUpdatePeriod to `0`, a client should not refresh the MPD\n     * unless told to do so through inband events, in the stream.\n     * In reality however, we found it to not always be the case (even with\n     * DASH-IF own streams) and moreover to not always be the best thing to do.\n     * We prefer to refresh in average at a regular interval when we do not have\n     * this information.\n     * /!\\ This value is expressed in seconds.\n     */\n    DASH_FALLBACK_LIFETIME_WHEN_MINIMUM_UPDATE_PERIOD_EQUAL_0: 3,\n    /**\n     * Default value for the maximum number of simultaneous MediaKeySessions that\n     * will be kept in a cache (linked to the MediaKeys instance) to avoid doing\n     * superfluous license requests.\n     *\n     * If this number is reached, any new session creation will close the oldest\n     * one.\n     * Another value can be configured through the API, in which case this default\n     * will be overwritten.\n     * @type {Number}\n     */\n    EME_DEFAULT_MAX_SIMULTANEOUS_MEDIA_KEY_SESSIONS: 15,\n    /**\n     * When playing contents with a persistent license, we will usually store some\n     * information related to that MediaKeySession, to be able to play it at a\n     * later time.\n     *\n     * Those information are removed once a MediaKeySession is not considered\n     * as \"usable\" anymore. But to know that, the RxPlayer has to load it.\n     *\n     * But the RxPlayer does not re-load every persisted MediaKeySession every\n     * time to check each one of them one by one, as this would not be a\n     * performant thing to do.\n     *\n     * So this is only done when and if the corresponding content is encountered\n     * again and only if it contains the same initialization data.\n     *\n     * We have to consider that those \"information\" contain binary data which can\n     * be of arbitrary length. Size taken by an array of them can relatively\n     * rapidly take a lot of space in JS memory.\n     *\n     * So to avoid this storage to take too much space (would it be in the chosen\n     * browser's storage or in JS memory), we now set a higher bound for the\n     * amount of MediaKeySession information that can be stored at the same time.\n     *\n     * I set the value of 1000 here, as it seems big enough to not be considered a\n     * problem (though it can become one, when contents have a lot of keys per\n     * content), and still low enough so it should not cause much problem (my\n     * method to choose that number was to work with power of 10s and choosing the\n     * amount which seemed the most sensible one).\n     *\n     * This wasn't battle-tested however.\n     */\n    EME_MAX_STORED_PERSISTENT_SESSION_INFORMATION: 1000,\n    /**\n     * After loading a persistent MediaKeySession, the RxPlayer needs to ensure\n     * that its keys still allow to decrypt a content.\n     *\n     * However on some browsers, the `keyStatuses` property that we used to check\n     * the keys' satuses linked to that session can be empty for some time after\n     * the loading operation is done.\n     *\n     * This value allows to configure a delay in milliseconds that will be the\n     * maximum time we will wait after a persistent session is loaded.\n     * If after that time, the `keyStatuses` property is still empty, we will\n     * consider that session as not usable.\n     */\n    EME_WAITING_DELAY_LOADED_SESSION_EMPTY_KEYSTATUSES: 100,\n    /**\n     * The player relies on browser events and properties to update its status to\n     * \"ENDED\".\n     *\n     * Sadly in some cases, like in Chrome 54, this event is never triggered on\n     * some contents probably due to a browser bug.\n     *\n     * This threshold resolves this issue by forcing the status to \"ENDED\" when:\n     *   1. the player is stalling\n     *   2. the absolute difference between current playback time and duration is\n     *      under this value\n     *\n     * If set to null, this workaround is disabled and the player only relies on\n     * browser events.\n     *\n     * @type {Number|null}\n     */\n    FORCED_ENDED_THRESHOLD: 0.0008,\n    /**\n     * Maximum duration from the current position we will let in the buffer when\n     * switching an Adaptation/Representations of a given type.\n     *\n     * For example, if we have ``text: { before: 1, after: 4 }``, it means that\n     * when switching subtitles, we will let 1 second before and 4 second after\n     * the current position in the previous language (until the new segments\n     * overwrite it).\n     * This is to allow smooth transitions and avoid de-synchronization that\n     * can happen when removing the content being decoded.\n     * @type {Object}\n     */\n    ADAP_REP_SWITCH_BUFFER_PADDINGS: {\n        video: { before: 5, after: 5 },\n        audio: { before: 2, after: 2.5 },\n        text: { before: 0, after: 0 }, // not managed natively, so no problem here\n    },\n    /**\n     * Interval, in milliseconds, at which we should manually flush\n     * SourceBuffers.\n     * Some browsers (happened with firefox 66) sometimes \"forget\" to send us\n     * `update` or `updateend` events.\n     * In that case, we're completely unable to continue the queue here and\n     * stay locked in a waiting state.\n     * This interval is here to check at regular intervals if the underlying\n     * SourceBuffer is currently updating.\n     * @type {Number}\n     */\n    SOURCE_BUFFER_FLUSHING_INTERVAL: 500,\n    /**\n     * Any already-pushed segment starting before or at the current position +\n     * CONTENT_REPLACEMENT_PADDING won't be replaced by new segments.\n     *\n     * This allows to avoid overwriting segments that are currently being decoded\n     * as we encountered many decoding issues when doing so.\n     * @type {Number} - in seconds\n     */\n    CONTENT_REPLACEMENT_PADDING: 1.2,\n    /**\n     * For video and audio segments, determines two thresholds below which :\n     * - The segment is considered as loaded from cache\n     * - The segment may be loaded from cache depending on the previous request\n     */\n    CACHE_LOAD_DURATION_THRESHOLDS: {\n        video: 50,\n        audio: 10,\n    },\n    /** Interval we will use to poll for checking if an event shall be emitted */\n    STREAM_EVENT_EMITTER_POLL_INTERVAL: 250,\n    /**\n     * In Javascript, numbers are encoded in a way that a floating number may be\n     * represented internally with a rounding error. When multiplying times in\n     * seconds by the timescale, we've encoutered cases were the rounding error\n     * was amplified by a factor which is about the timescale.\n     * Example :\n     * (192797480.641122).toFixed(20) = 192797480.64112201333045959473\n     * (error is 0.0000000133...)\n     * 192797480.641122 * 10000000 = 1927974806411220.2 (error is 0.2)\n     * 192797480.641122 * 10000000 * 4 = 7711899225644881 (error is 1)\n     * The error is much more significant here, once the timescale has been\n     * applied.\n     * Thus, we consider that our max tolerable rounding error is 1ms.\n     * It is much more than max rounding errors when seen into practice,\n     * and not significant from the media loss perspective.\n     */\n    DEFAULT_MAXIMUM_TIME_ROUNDING_ERROR: 1 / 1000,\n    /**\n     * RxPlayer's media buffers have a linked history registering recent events\n     * that happened on those.\n     * The reason is to implement various heuristics in case of weird browser\n     * behavior.\n     *\n     * The `BUFFERED_HISTORY_RETENTION_TIME` is the minimum age an entry of\n     * that history can have before being removed from the history.\n     */\n    BUFFERED_HISTORY_RETENTION_TIME: 60000,\n    /**\n     * RxPlayer's media buffers have a linked history registering recent events\n     * that happened on those.\n     * The reason is to implement various heuristics in case of weird browser\n     * behavior.\n     *\n     * The `BUFFERED_HISTORY_RETENTION_TIME` is the maximum number of entries\n     * there can be in that history.\n     */\n    BUFFERED_HISTORY_MAXIMUM_ENTRIES: 200,\n    /**\n     * Minimum buffer in seconds ahead relative to current time\n     * we should be able to download, even in cases of saturated memory.\n     */\n    MIN_BUFFER_AHEAD: 5,\n    /**\n     * Distance in seconds behind the current position\n     * the player will free up to in the case we agressively free up memory\n     * It is set to avoid playback issues\n     */\n    UPTO_CURRENT_POSITION_CLEANUP: 5,\n    /**\n     * Default \"switching mode\" used when locking video Representations.\n     * That is, which behavior the RxPlayer should have by default when\n     * explicitely and manually switching from a previous set of video\n     * Representations to a new one.\n     */\n    DEFAULT_VIDEO_REPRESENTATIONS_SWITCHING_MODE: \"seamless\",\n    /**\n     * Default \"switching mode\" used when locking audio Representations.\n     * That is, which behavior the RxPlayer should have by default when\n     * explicitely and manually switching from a previous set of audio\n     * Representations to a new one.\n     */\n    DEFAULT_AUDIO_REPRESENTATIONS_SWITCHING_MODE: \"seamless\",\n    /**\n     * Default \"switching mode\" used when switching between video tracks.\n     * That is, which behavior the RxPlayer should have by default when\n     * explicitely and manually switching from a previous video track to a new\n     * one.\n     */\n    DEFAULT_VIDEO_TRACK_SWITCHING_MODE: \"reload\",\n    /**\n     * Default \"switching mode\" used when switching between audio tracks.\n     * That is, which behavior the RxPlayer should have by default when\n     * explicitely and manually switching from a previous audio track to a new\n     * one.\n     */\n    DEFAULT_AUDIO_TRACK_SWITCHING_MODE: \"seamless\",\n    /**\n     * The default number of times a thumbnail request will be re-performed when\n     * on error which justify a retry.\n     *\n     * Note that some errors do not use this counter:\n     *   - if the error is not due to the xhr, no retry will be peformed\n     *   - if the error is an HTTP error code, but not a 500-smthg or a 404, no\n     *     retry will be performed.\n     * @type Number\n     */\n    DEFAULT_MAX_THUMBNAIL_REQUESTS_RETRY_ON_ERROR: 1,\n    /**\n     * Default time interval after which a thumbnail request will timeout, in ms.\n     * @type {Number}\n     */\n    DEFAULT_THUMBNAIL_REQUEST_TIMEOUT: 10 * 1000,\n    /**\n     * Default connection time after which a thumbnail request conncection will\n     * timeout, in ms.\n     * @type {Number}\n     */\n    DEFAULT_THUMBNAIL_CONNECTION_TIMEOUT: 7 * 1000,\n};\nexport default DEFAULT_CONFIG;\nfunction checkIsSerializable(_conf) {\n    // noop\n}\ncheckIsSerializable(DEFAULT_CONFIG);\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Internal error used to better handle errors happening when a custom\n * `segmentLoader` or `manifestLoader` has been used.\n *\n * It is not part of the API, as such it is only a temporary error which is\n * later converted to another Error instance (e.g. NETWORK_ERROR).\n * @class CustomLoaderError\n * @extends Error\n */\nexport default class CustomLoaderError extends Error {\n    /**\n     * @param {string} message\n     * @param {boolean} canRetry\n     * @param {XMLHttpRequest} xhr\n     */\n    constructor(message, canRetry, xhr) {\n        super(message);\n        // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class\n        Object.setPrototypeOf(this, CustomLoaderError.prototype);\n        this.name = \"CustomLoaderError\";\n        this.canRetry = canRetry;\n        this.xhr = xhr;\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ErrorTypes } from \"./error_codes\";\nimport errorMessage from \"./error_message\";\n/**\n * Error linked to the encryption of the media.\n *\n * @class EncryptedMediaError\n * @extends Error\n */\nexport default class EncryptedMediaError extends Error {\n    constructor(code, reason, supplementaryInfos) {\n        super(errorMessage(code, reason));\n        // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class\n        Object.setPrototypeOf(this, EncryptedMediaError.prototype);\n        this.name = \"EncryptedMediaError\";\n        this.type = ErrorTypes.ENCRYPTED_MEDIA_ERROR;\n        this.code = code;\n        this._originalMessage = reason;\n        this.fatal = false;\n        if (typeof (supplementaryInfos === null || supplementaryInfos === void 0 ? void 0 : supplementaryInfos.keyStatuses) === \"string\") {\n            this.keyStatuses = supplementaryInfos.keyStatuses;\n        }\n    }\n    /**\n     * If that error has to be communicated through another thread, this method\n     * allows to obtain its main defining properties in an Object so the Error can\n     * be reconstructed in the other thread.\n     * @returns {Object}\n     */\n    serialize() {\n        return {\n            name: this.name,\n            code: this.code,\n            reason: this._originalMessage,\n            keyStatuses: this.keyStatuses,\n        };\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { RequestErrorTypes } from \"../utils/request\";\nexport const NetworkErrorTypes = RequestErrorTypes;\nconst ErrorTypes = {\n    NETWORK_ERROR: \"NETWORK_ERROR\",\n    MEDIA_ERROR: \"MEDIA_ERROR\",\n    ENCRYPTED_MEDIA_ERROR: \"ENCRYPTED_MEDIA_ERROR\",\n    OTHER_ERROR: \"OTHER_ERROR\",\n};\nconst ErrorCodes = {\n    PIPELINE_LOAD_ERROR: \"PIPELINE_LOAD_ERROR\",\n    PIPELINE_PARSE_ERROR: \"PIPELINE_PARSE_ERROR\",\n    INTEGRITY_ERROR: \"INTEGRITY_ERROR\",\n    MANIFEST_PARSE_ERROR: \"MANIFEST_PARSE_ERROR\",\n    MANIFEST_INCOMPATIBLE_CODECS_ERROR: \"MANIFEST_INCOMPATIBLE_CODECS_ERROR\",\n    MANIFEST_UPDATE_ERROR: \"MANIFEST_UPDATE_ERROR\",\n    MANIFEST_UNSUPPORTED_ADAPTATION_TYPE: \"MANIFEST_UNSUPPORTED_ADAPTATION_TYPE\",\n    MEDIA_STARTING_TIME_NOT_FOUND: \"MEDIA_STARTING_TIME_NOT_FOUND\",\n    MEDIA_TIME_BEFORE_MANIFEST: \"MEDIA_TIME_BEFORE_MANIFEST\",\n    MEDIA_TIME_AFTER_MANIFEST: \"MEDIA_TIME_AFTER_MANIFEST\",\n    MEDIA_TIME_NOT_FOUND: \"MEDIA_TIME_NOT_FOUND\",\n    NO_PLAYABLE_REPRESENTATION: \"NO_PLAYABLE_REPRESENTATION\",\n    MEDIA_IS_ENCRYPTED_ERROR: \"MEDIA_IS_ENCRYPTED_ERROR\",\n    CREATE_MEDIA_KEYS_ERROR: \"CREATE_MEDIA_KEYS_ERROR\",\n    MEDIA_KEYS_ATTACHMENT_ERROR: \"MEDIA_KEYS_ATTACHMENT_ERROR\",\n    KEY_ERROR: \"KEY_ERROR\",\n    KEY_STATUS_CHANGE_ERROR: \"KEY_STATUS_CHANGE_ERROR\",\n    KEY_UPDATE_ERROR: \"KEY_UPDATE_ERROR\",\n    KEY_LOAD_ERROR: \"KEY_LOAD_ERROR\",\n    KEY_LOAD_TIMEOUT: \"KEY_LOAD_TIMEOUT\",\n    KEY_GENERATE_REQUEST_ERROR: \"KEY_GENERATE_REQUEST_ERROR\",\n    INCOMPATIBLE_KEYSYSTEMS: \"INCOMPATIBLE_KEYSYSTEMS\",\n    INVALID_ENCRYPTED_EVENT: \"INVALID_ENCRYPTED_EVENT\",\n    INVALID_KEY_SYSTEM: \"INVALID_KEY_SYSTEM\",\n    LICENSE_SERVER_CERTIFICATE_ERROR: \"LICENSE_SERVER_CERTIFICATE_ERROR\",\n    MULTIPLE_SESSIONS_SAME_INIT_DATA: \"MULTIPLE_SESSIONS_SAME_INIT_DATA\",\n    BUFFER_APPEND_ERROR: \"BUFFER_APPEND_ERROR\",\n    BUFFER_FULL_ERROR: \"BUFFER_FULL_ERROR\",\n    BUFFER_TYPE_UNKNOWN: \"BUFFER_TYPE_UNKNOWN\",\n    MEDIA_ERR_BLOCKED_AUTOPLAY: \"MEDIA_ERR_BLOCKED_AUTOPLAY\",\n    MEDIA_ERR_PLAY_NOT_ALLOWED: \"MEDIA_ERR_PLAY_NOT_ALLOWED\",\n    MEDIA_ERR_NOT_LOADED_METADATA: \"MEDIA_ERR_NOT_LOADED_METADATA\",\n    MEDIA_ERR_ABORTED: \"MEDIA_ERR_ABORTED\",\n    MEDIA_ERR_NETWORK: \"MEDIA_ERR_NETWORK\",\n    MEDIA_ERR_DECODE: \"MEDIA_ERR_DECODE\",\n    MEDIA_ERR_SRC_NOT_SUPPORTED: \"MEDIA_ERR_SRC_NOT_SUPPORTED\",\n    MEDIA_ERR_UNKNOWN: \"MEDIA_ERR_UNKNOWN\",\n    MEDIA_SOURCE_NOT_SUPPORTED: \"MEDIA_SOURCE_NOT_SUPPORTED\",\n    MEDIA_KEYS_NOT_SUPPORTED: \"MEDIA_KEYS_NOT_SUPPORTED\",\n    DISCONTINUITY_ENCOUNTERED: \"DISCONTINUITY_ENCOUNTERED\",\n    NONE: \"NONE\",\n};\nexport { ErrorTypes, ErrorCodes };\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Generate a normalized error message.\n * @param {string} code\n * @param {Error|string|Event|null} [reason]\n * @returns {string}\n */\nexport default function errorMessage(code, reason) {\n    return `${code}: ${reason}`;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport isKnownError from \"./is_known_error\";\nimport OtherError from \"./other_error\";\n/*\n * Format an unknown error into an API-defined error.\n * @param {*} error\n * @returns {Error}\n */\nexport default function formatError(error, { defaultCode, defaultReason, }) {\n    if (isKnownError(error)) {\n        return error;\n    }\n    const reason = error instanceof Error ? error.toString() : defaultReason;\n    return new OtherError(defaultCode, reason);\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport EncryptedMediaError from \"./encrypted_media_error\";\nimport { ErrorTypes } from \"./error_codes\";\nimport MediaError from \"./media_error\";\nimport NetworkError from \"./network_error\";\nimport OtherError from \"./other_error\";\n/**\n * Whether the error given is a ICustomError.\n * @param {Error} error\n * @returns {Boolean}\n */\nexport default function isKnownError(error) {\n    return ((error instanceof EncryptedMediaError ||\n        error instanceof MediaError ||\n        error instanceof OtherError ||\n        error instanceof NetworkError) &&\n        Object.keys(ErrorTypes).indexOf(error.type) >= 0);\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ErrorTypes } from \"./error_codes\";\nimport errorMessage from \"./error_message\";\n/**\n * Error linked to the media Playback.\n *\n * @class MediaError\n * @extends Error\n */\nexport default class MediaError extends Error {\n    constructor(code, reason, context) {\n        super(errorMessage(code, reason));\n        // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class\n        Object.setPrototypeOf(this, MediaError.prototype);\n        this.name = \"MediaError\";\n        this.type = ErrorTypes.MEDIA_ERROR;\n        this._originalMessage = reason;\n        this.code = code;\n        this.fatal = false;\n        if ((context === null || context === void 0 ? void 0 : context.tracks) !== undefined && (context === null || context === void 0 ? void 0 : context.tracks.length) > 0) {\n            this.tracksInfo = context.tracks;\n        }\n    }\n    /**\n     * If that error has to be communicated through another thread, this method\n     * allows to obtain its main defining properties in an Object so the Error can\n     * be reconstructed in the other thread.\n     * @returns {Object}\n     */\n    serialize() {\n        return {\n            name: this.name,\n            code: this.code,\n            reason: this._originalMessage,\n            tracks: this.tracksInfo,\n        };\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ErrorTypes, NetworkErrorTypes } from \"./error_codes\";\nimport errorMessage from \"./error_message\";\n/**\n * Error linked to network interactions (requests).\n *\n * @class NetworkError\n * @extends Error\n */\nexport default class NetworkError extends Error {\n    /**\n     * @param {string} code\n     * @param {Error} baseError\n     */\n    constructor(code, baseError) {\n        super(errorMessage(code, baseError.message));\n        // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class\n        Object.setPrototypeOf(this, NetworkError.prototype);\n        this.name = \"NetworkError\";\n        this.type = ErrorTypes.NETWORK_ERROR;\n        this.url = baseError.url;\n        this.status = baseError.status;\n        this.errorType = baseError.type;\n        this._baseError = baseError;\n        this.code = code;\n        this.fatal = false;\n    }\n    /**\n     * Returns true if the NetworkError is due to the given http error code\n     * @param {number} httpErrorCode\n     * @returns {Boolean}\n     */\n    isHttpError(httpErrorCode) {\n        return (this.errorType === NetworkErrorTypes.ERROR_HTTP_CODE &&\n            this.status === httpErrorCode);\n    }\n    /**\n     * If that error has to be communicated through another thread, this method\n     * allows to obtain its main defining properties in an Object so the Error can\n     * be reconstructed in the other thread.\n     * @returns {Object}\n     */\n    serialize() {\n        return {\n            name: this.name,\n            code: this.code,\n            baseError: this._baseError.serialize(),\n        };\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ErrorTypes } from \"./error_codes\";\nimport errorMessage from \"./error_message\";\n/**\n * @class OtherError\n * @extends Error\n */\nexport default class OtherError extends Error {\n    /**\n     * @param {string} code\n     * @param {string} reason\n     */\n    constructor(code, reason) {\n        super(errorMessage(code, reason));\n        // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class\n        Object.setPrototypeOf(this, OtherError.prototype);\n        this.name = \"OtherError\";\n        this.type = ErrorTypes.OTHER_ERROR;\n        this.code = code;\n        this.fatal = false;\n        this._originalMessage = reason;\n    }\n    /**\n     * If that error has to be communicated through another thread, this method\n     * allows to obtain its main defining properties in an Object so the Error can\n     * be reconstructed in the other thread.\n     * @returns {Object}\n     */\n    serialize() {\n        return { name: this.name, code: this.code, reason: this._originalMessage };\n    }\n}\n","/**\n * Error encountered when doing an operation on a `SourceBuffer`.\n * @class SourceBufferError\n * @extends Error\n */\nexport default class SourceBufferError extends Error {\n    /**\n     * @param {string} errorName - The original Error's name.\n     * @param {string} message - The original Error's message.\n     * @param {boolean} isBufferFull - If `true`, the Error is due to the fact\n     * that the `SourceBuffer` was full.\n     */\n    constructor(errorName, message, isBufferFull) {\n        super(message);\n        // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class\n        Object.setPrototypeOf(this, SourceBufferError.prototype);\n        this.name = \"SourceBufferError\";\n        this.errorName = errorName;\n        this.isBufferFull = isBufferFull;\n    }\n    /**\n     * If that error has to be communicated through another thread, this method\n     * allows to obtain its main defining properties in an Object so the Error can\n     * be reconstructed in the other thread.\n     * @returns {Object}\n     */\n    serialize() {\n        return {\n            errorName: this.name,\n            message: this.message,\n            isBufferFull: this.isBufferFull,\n        };\n    }\n    /**\n     * When stringified, just try to replicate the original error as it may be\n     * more informative.\n     * @returns {string}\n     */\n    toString() {\n        return `${this.errorName}: ${this.message}`;\n    }\n}\n","import errorMessage from \"./error_message\";\n/**\n * Error linked to the WebWorker initialization.\n *\n * @class WorkerInitializationError\n * @extends Error\n */\nexport default class WorkerInitializationError extends Error {\n    /**\n     * @param {string} code\n     * @param {string} message\n     */\n    constructor(code, message) {\n        super(errorMessage(code, message));\n        // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class\n        Object.setPrototypeOf(this, WorkerInitializationError.prototype);\n        this.name = \"WorkerInitializationError\";\n        this.type = \"WORKER_INITIALIZATION_ERROR\";\n        this.code = code;\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIE OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport isNullOrUndefined from \"../utils/is_null_or_undefined\";\nimport features from \"./features_object\";\n/**\n * @param {Array.<Object>} featureFuncList\n */\nexport default function addFeatures(featureFuncList) {\n    for (const addFeature of featureFuncList) {\n        if (typeof addFeature === \"function\") {\n            addFeature(features);\n        }\n        else if (!isNullOrUndefined(addFeature) &&\n            typeof addFeature._addFeature === \"function\") {\n            addFeature._addFeature(features);\n        }\n        else {\n            throw new Error(\"Unrecognized feature\");\n        }\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Initial features object, with no feature activated by default.\n * @type {Object}\n */\nconst features = {\n    dashParsers: { wasm: null, native: null, fastJs: null },\n    createDebugElement: null,\n    directfile: null,\n    decrypt: null,\n    htmlTextDisplayer: null,\n    htmlTextTracksParsers: {},\n    mainThreadMediaSourceInit: null,\n    multithread: null,\n    nativeTextDisplayer: null,\n    nativeTextTracksParsers: {},\n    transports: {},\n};\nexport default features;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * File allowing feature-switching.\n *\n * Every optional feature is included here.\n * They all should subsequently be accessed in the code through the exported\n * `features` object.\n *\n * The then exported features object will be used dynamically to know which\n * features are activated.\n *\n * This also lazy-feature loading, where this exported object can be updated\n * at runtime, to allow some new features even if the player instance has\n * already have been instanciated.\n */\nimport addFeatures from \"./add_features\";\nimport features from \"./features_object\";\nexport default features;\nexport { addFeatures };\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport MediaSourceContentInitializer from \"../../main_thread/init/media_source_content_initializer\";\nimport dashJsParser from \"../../parsers/manifest/dash/native-parser\";\nimport dash from \"../../transports/dash\";\n/**\n * Add ability to play DASH contents.\n * @param {Object} features\n */\nfunction addDASHFeature(features) {\n    if (features.transports.dash === undefined) {\n        features.transports.dash = dash;\n    }\n    features.dashParsers.native = dashJsParser;\n    features.mainThreadMediaSourceInit = MediaSourceContentInitializer;\n}\nexport { addDASHFeature as DASH };\nexport default addDASHFeature;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport directfile from \"../../main_thread/init/directfile_content_initializer\";\nimport mediaElementTracksStore from \"../../main_thread/tracks_store/media_element_tracks_store\";\n/**\n * Add ability to play file natively played by the browser\n * (`directfile` transport)\n * @param {Object} features\n */\nfunction addDirectfileFeature(features) {\n    features.directfile = { initDirectFile: directfile, mediaElementTracksStore };\n}\nexport { addDirectfileFeature as DIRECTFILE };\nexport default addDirectfileFeature;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport ContentDecryptor from \"../../main_thread/decrypt\";\n/**\n * Add ability to play encrypted contents\n * @param {Object} features\n */\nfunction addEMEFeature(features) {\n    features.decrypt = ContentDecryptor;\n}\nexport { addEMEFeature as EME };\nexport default addEMEFeature;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport HTMLTextDisplayer from \"../../main_thread/text_displayer/html\";\nimport samiParser from \"../../parsers/texttracks/sami/html\";\n/**\n * Add ability to parse SAMI text tracks in an HTML textrack mode.\n * @param {Object} features\n */\nfunction addHTMLSAMIFeature(features) {\n    features.htmlTextTracksParsers.sami = samiParser;\n    features.htmlTextDisplayer = HTMLTextDisplayer;\n}\nexport { addHTMLSAMIFeature as HTML_SAMI_PARSER };\nexport default addHTMLSAMIFeature;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport HTMLTextDisplayer from \"../../main_thread/text_displayer/html\";\nimport srtParser from \"../../parsers/texttracks/srt/html\";\n/**\n * Add ability to parse SRT text tracks in an HTML textrack mode.\n * @param {Object} features\n */\nfunction addHTMLSRTFeature(features) {\n    features.htmlTextTracksParsers.srt = srtParser;\n    features.htmlTextDisplayer = HTMLTextDisplayer;\n}\nexport { addHTMLSRTFeature as HTML_SRT_PARSER };\nexport default addHTMLSRTFeature;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport HTMLTextDisplayer from \"../../main_thread/text_displayer/html\";\nimport ttmlParser from \"../../parsers/texttracks/ttml/html\";\n/**\n * Add ability to parse TTML text tracks in an HTML textrack mode.\n * @param {Object} features\n */\nfunction addHTMLTTMLFeature(features) {\n    features.htmlTextTracksParsers.ttml = ttmlParser;\n    features.htmlTextDisplayer = HTMLTextDisplayer;\n}\nexport { addHTMLTTMLFeature as HTML_TTML_PARSER };\nexport default addHTMLTTMLFeature;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport HTMLTextDisplayer from \"../../main_thread/text_displayer/html\";\nimport vttParser from \"../../parsers/texttracks/webvtt/html\";\n/**\n * Add ability to parse WebVTT text tracks in an HTML textrack mode.\n * @param {Object} features\n */\nfunction addHTMLVTTFeature(features) {\n    features.htmlTextTracksParsers.vtt = vttParser;\n    features.htmlTextDisplayer = HTMLTextDisplayer;\n}\nexport { addHTMLVTTFeature as HTML_VTT_PARSER };\nexport default addHTMLVTTFeature;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport NativeTextDisplayer from \"../../main_thread/text_displayer/native\";\nimport samiParser from \"../../parsers/texttracks/sami/native\";\n/**\n * Add ability to parse SAMI text tracks in a native textrack mode.\n * @param {Object} features\n */\nfunction addNativeSAMIFeature(features) {\n    features.nativeTextTracksParsers.sami = samiParser;\n    features.nativeTextDisplayer = NativeTextDisplayer;\n}\nexport { addNativeSAMIFeature as NATIVE_SAMI_PARSER };\nexport default addNativeSAMIFeature;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport NativeTextDisplayer from \"../../main_thread/text_displayer/native\";\nimport srtParser from \"../../parsers/texttracks/srt/native\";\n/**\n * Add ability to parse SRT text tracks in a native textrack mode.\n * @param {Object} features\n */\nfunction addNativeSRTFeature(features) {\n    features.nativeTextTracksParsers.srt = srtParser;\n    features.nativeTextDisplayer = NativeTextDisplayer;\n}\nexport { addNativeSRTFeature as NATIVE_SRT_PARSER };\nexport default addNativeSRTFeature;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport NativeTextDisplayer from \"../../main_thread/text_displayer/native\";\nimport ttmlParser from \"../../parsers/texttracks/ttml/native\";\n/**\n * Add ability to parse TTML text tracks in a native textrack mode.\n * @param {Object} features\n */\nfunction addNativeTTMLFeature(features) {\n    features.nativeTextTracksParsers.ttml = ttmlParser;\n    features.nativeTextDisplayer = NativeTextDisplayer;\n}\nexport { addNativeTTMLFeature as NATIVE_TTML_PARSER };\nexport default addNativeTTMLFeature;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport NativeTextDisplayer from \"../../main_thread/text_displayer/native\";\nimport vttParser from \"../../parsers/texttracks/webvtt/native\";\n/**\n * Add ability to parse WebVTT text tracks in a native textrack mode.\n * @param {Object} features\n */\nfunction addNativeVTTFeature(features) {\n    features.nativeTextTracksParsers.vtt = vttParser;\n    features.nativeTextDisplayer = NativeTextDisplayer;\n}\nexport { addNativeVTTFeature as NATIVE_VTT_PARSER };\nexport default addNativeVTTFeature;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport MediaSourceContentInitializer from \"../../main_thread/init/media_source_content_initializer\";\nimport smooth from \"../../transports/smooth\";\n/**\n * Add ability to play smooth contents.\n * @param {Object} features\n */\nfunction addSmoothFeature(features) {\n    if (features.transports.smooth === undefined) {\n        features.transports.smooth = smooth;\n    }\n    features.mainThreadMediaSourceInit = MediaSourceContentInitializer;\n}\nexport { addSmoothFeature as SMOOTH };\nexport default addSmoothFeature;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * This file exports a Player class with a default feature set.\n * This is the class used from a regular build.\n */\nimport isDebugModeEnabled from \"./compat/is_debug_mode_enabled\";\nimport patchWebkitSourceBuffer from \"./compat/patch_webkit_source_buffer\";\nimport { DASH, DIRECTFILE, EME, HTML_SAMI_PARSER, HTML_SRT_PARSER, HTML_TTML_PARSER, HTML_VTT_PARSER, NATIVE_SAMI_PARSER, NATIVE_SRT_PARSER, NATIVE_TTML_PARSER, NATIVE_VTT_PARSER, SMOOTH, } from \"./features/list\";\nimport logger from \"./log\";\nimport Player from \"./main_thread/api\";\nimport globalScope from \"./utils/global_scope\";\npatchWebkitSourceBuffer();\nPlayer.addFeatures([\n    SMOOTH,\n    DASH,\n    DIRECTFILE,\n    EME,\n    NATIVE_TTML_PARSER,\n    NATIVE_SAMI_PARSER,\n    NATIVE_VTT_PARSER,\n    NATIVE_SRT_PARSER,\n    HTML_TTML_PARSER,\n    HTML_SAMI_PARSER,\n    HTML_VTT_PARSER,\n    HTML_SRT_PARSER,\n]);\nif (isDebugModeEnabled()) {\n    logger.setLevel(\"DEBUG\", \"full\");\n}\nelse if (0 /* __ENVIRONMENT__.CURRENT_ENV */ === 1 /* __ENVIRONMENT__.DEV */) {\n    logger.setLevel(\"NONE\" /* __LOGGER_LEVEL__.CURRENT_LEVEL */, \"standard\");\n}\nexport default Player;\nif (typeof __GLOBAL_SCOPE__ === \"boolean\" && __GLOBAL_SCOPE__) {\n    globalScope.RxPlayer = Player;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport Logger from \"./utils/logger\";\n// create a logger specifically for the RxPlayer.\nconst logger = new Logger();\nexport default logger;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport Player from \"./public_api\";\nexport default Player;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport config from \"../../config\";\nimport log from \"../../log\";\nimport arrayIncludes from \"../../utils/array_includes\";\nimport isNullOrUndefined from \"../../utils/is_null_or_undefined\";\nimport objectAssign from \"../../utils/object_assign\";\n/**\n * Parse options given to the API constructor and set default options as found\n * in the config.\n *\n * Do not mutate anything, only cross the given options and sane default options\n * (most coming from the config).\n * @param {Object|undefined} options\n * @returns {Object}\n */\nfunction parseConstructorOptions(options) {\n    let maxBufferAhead;\n    let maxBufferBehind;\n    let wantedBufferAhead;\n    let maxVideoBufferSize;\n    let videoElement;\n    let baseBandwidth;\n    const { DEFAULT_BASE_BANDWIDTH, DEFAULT_VIDEO_RESOLUTION_LIMIT, DEFAULT_MAX_BUFFER_AHEAD, DEFAULT_MAX_BUFFER_BEHIND, DEFAULT_MAX_VIDEO_BUFFER_SIZE, DEFAULT_THROTTLE_VIDEO_BITRATE_WHEN_HIDDEN, DEFAULT_WANTED_BUFFER_AHEAD, } = config.getCurrent();\n    if (isNullOrUndefined(options.maxBufferAhead)) {\n        maxBufferAhead = DEFAULT_MAX_BUFFER_AHEAD;\n    }\n    else {\n        maxBufferAhead = Number(options.maxBufferAhead);\n        if (isNaN(maxBufferAhead)) {\n            throw new Error(\"Invalid maxBufferAhead parameter. Should be a number.\");\n        }\n    }\n    if (isNullOrUndefined(options.maxBufferBehind)) {\n        maxBufferBehind = DEFAULT_MAX_BUFFER_BEHIND;\n    }\n    else {\n        maxBufferBehind = Number(options.maxBufferBehind);\n        if (isNaN(maxBufferBehind)) {\n            throw new Error(\"Invalid maxBufferBehind parameter. Should be a number.\");\n        }\n    }\n    if (isNullOrUndefined(options.wantedBufferAhead)) {\n        wantedBufferAhead = DEFAULT_WANTED_BUFFER_AHEAD;\n    }\n    else {\n        wantedBufferAhead = Number(options.wantedBufferAhead);\n        if (isNaN(wantedBufferAhead)) {\n            throw new Error(\"Invalid wantedBufferAhead parameter. Should be a number.\");\n        }\n    }\n    if (isNullOrUndefined(options.maxVideoBufferSize)) {\n        maxVideoBufferSize = DEFAULT_MAX_VIDEO_BUFFER_SIZE;\n    }\n    else {\n        maxVideoBufferSize = Number(options.maxVideoBufferSize);\n        if (isNaN(maxVideoBufferSize)) {\n            throw new Error(\"Invalid maxVideoBufferSize parameter. Should be a number.\");\n        }\n    }\n    const videoResolutionLimit = isNullOrUndefined(options.videoResolutionLimit)\n        ? DEFAULT_VIDEO_RESOLUTION_LIMIT\n        : options.videoResolutionLimit;\n    const throttleVideoBitrateWhenHidden = isNullOrUndefined(options.throttleVideoBitrateWhenHidden)\n        ? DEFAULT_THROTTLE_VIDEO_BITRATE_WHEN_HIDDEN\n        : !!options.throttleVideoBitrateWhenHidden;\n    if (isNullOrUndefined(options.videoElement)) {\n        videoElement = document.createElement(\"video\");\n    }\n    else if (options.videoElement.nodeName.toLowerCase() === \"video\" ||\n        options.videoElement.nodeName.toLowerCase() === \"audio\") {\n        videoElement = options.videoElement;\n    }\n    else {\n        throw new Error(\"Invalid videoElement parameter. Should be a HTMLMediaElement.\");\n    }\n    if (isNullOrUndefined(options.baseBandwidth)) {\n        baseBandwidth = DEFAULT_BASE_BANDWIDTH;\n    }\n    else {\n        baseBandwidth = Number(options.baseBandwidth);\n        if (isNaN(baseBandwidth)) {\n            throw new Error(\"Invalid baseBandwidth parameter. Should be a number.\");\n        }\n    }\n    return {\n        maxBufferAhead,\n        maxBufferBehind,\n        videoResolutionLimit,\n        videoElement,\n        wantedBufferAhead,\n        maxVideoBufferSize,\n        throttleVideoBitrateWhenHidden,\n        baseBandwidth,\n    };\n}\n/**\n * Check the format of given reload options.\n * Throw if format in invalid.\n * @param {object | undefined} options\n */\nfunction checkReloadOptions(options) {\n    var _a, _b, _c, _d;\n    if (options === null || (typeof options !== \"object\" && options !== undefined)) {\n        throw new Error(\"API: reload - Invalid options format.\");\n    }\n    if ((options === null || options === void 0 ? void 0 : options.reloadAt) === null ||\n        (typeof (options === null || options === void 0 ? void 0 : options.reloadAt) !== \"object\" && (options === null || options === void 0 ? void 0 : options.reloadAt) !== undefined)) {\n        throw new Error(\"API: reload - Invalid 'reloadAt' option format.\");\n    }\n    if (typeof ((_a = options === null || options === void 0 ? void 0 : options.reloadAt) === null || _a === void 0 ? void 0 : _a.position) !== \"number\" &&\n        ((_b = options === null || options === void 0 ? void 0 : options.reloadAt) === null || _b === void 0 ? void 0 : _b.position) !== undefined) {\n        throw new Error(\"API: reload - Invalid 'reloadAt.position' option format.\");\n    }\n    if (typeof ((_c = options === null || options === void 0 ? void 0 : options.reloadAt) === null || _c === void 0 ? void 0 : _c.relative) !== \"number\" &&\n        ((_d = options === null || options === void 0 ? void 0 : options.reloadAt) === null || _d === void 0 ? void 0 : _d.relative) !== undefined) {\n        throw new Error(\"API: reload - Invalid 'reloadAt.relative' option format.\");\n    }\n    if (!Array.isArray(options === null || options === void 0 ? void 0 : options.keySystems) && (options === null || options === void 0 ? void 0 : options.keySystems) !== undefined) {\n        throw new Error(\"API: reload - Invalid 'keySystems' option format.\");\n    }\n    if ((options === null || options === void 0 ? void 0 : options.autoPlay) !== undefined && typeof options.autoPlay !== \"boolean\") {\n        throw new Error(\"API: reload - Invalid 'autoPlay' option format.\");\n    }\n}\n/**\n * Parse options given to loadVideo and set default options as found\n * in the config.\n *\n * Do not mutate anything, only cross the given options and sane default options\n * (most coming from the config).\n *\n * Throws if any mandatory option is not set.\n * @param {Object|undefined} options\n * @returns {Object}\n */\nfunction parseLoadVideoOptions(options) {\n    var _a, _b, _c, _d;\n    let url;\n    let transport;\n    let keySystems;\n    let textTrackMode;\n    let mode;\n    let textTrackElement;\n    let startAt;\n    const { DEFAULT_AUTO_PLAY, DEFAULT_CODEC_SWITCHING_BEHAVIOR, DEFAULT_ENABLE_FAST_SWITCHING, DEFAULT_TEXT_TRACK_MODE, } = config.getCurrent();\n    if (isNullOrUndefined(options)) {\n        throw new Error(\"No option set on loadVideo\");\n    }\n    if (!isNullOrUndefined(options.url)) {\n        url = String(options.url);\n    }\n    else if (isNullOrUndefined(options.initialManifest) &&\n        isNullOrUndefined(options.manifestLoader)) {\n        throw new Error(\"Unable to load a content: no url set on loadVideo.\\n\" +\n            \"Please provide at least either an `url` argument, a \" +\n            \"`initialManifest` option or a \" +\n            \"`manifestLoader` option so the RxPlayer \" +\n            \"can load the content.\");\n    }\n    if (isNullOrUndefined(options.transport)) {\n        throw new Error(\"No transport set on loadVideo\");\n    }\n    else {\n        transport = String(options.transport);\n    }\n    const autoPlay = isNullOrUndefined(options.autoPlay)\n        ? DEFAULT_AUTO_PLAY\n        : !!options.autoPlay;\n    if (isNullOrUndefined(options.keySystems)) {\n        keySystems = [];\n    }\n    else {\n        keySystems = Array.isArray(options.keySystems)\n            ? options.keySystems\n            : [options.keySystems];\n        for (const keySystem of keySystems) {\n            if (typeof keySystem.type !== \"string\" ||\n                typeof keySystem.getLicense !== \"function\") {\n                throw new Error(\"Invalid key system given: Missing type string or \" + \"getLicense callback\");\n            }\n        }\n    }\n    const lowLatencyMode = options.lowLatencyMode === undefined ? false : !!options.lowLatencyMode;\n    const initialManifest = options.initialManifest;\n    const minimumManifestUpdateInterval = (_a = options.minimumManifestUpdateInterval) !== null && _a !== void 0 ? _a : 0;\n    let defaultAudioTrackSwitchingMode = (_b = options.defaultAudioTrackSwitchingMode) !== null && _b !== void 0 ? _b : undefined;\n    if (defaultAudioTrackSwitchingMode !== undefined &&\n        !arrayIncludes([\"seamless\", \"direct\", \"reload\"], defaultAudioTrackSwitchingMode)) {\n        log.warn(\"The `defaultAudioTrackSwitchingMode` loadVideo option must match one of \" +\n            \"the following strategy name:\\n\" +\n            \"- `seamless`\\n\" +\n            \"- `direct`\\n\" +\n            \"- `reload`\");\n        defaultAudioTrackSwitchingMode = undefined;\n    }\n    let onCodecSwitch = isNullOrUndefined(options.onCodecSwitch)\n        ? DEFAULT_CODEC_SWITCHING_BEHAVIOR\n        : options.onCodecSwitch;\n    if (!arrayIncludes([\"continue\", \"reload\"], onCodecSwitch)) {\n        log.warn(\"The `onCodecSwitch` loadVideo option must match one of \" +\n            \"the following string:\\n\" +\n            \"- `continue`\\n\" +\n            \"- `reload`\\n\" +\n            \"If badly set, \" +\n            DEFAULT_CODEC_SWITCHING_BEHAVIOR +\n            \" will be used as default\");\n        onCodecSwitch = DEFAULT_CODEC_SWITCHING_BEHAVIOR;\n    }\n    if (isNullOrUndefined(options.textTrackMode)) {\n        textTrackMode = DEFAULT_TEXT_TRACK_MODE;\n    }\n    else {\n        if (options.textTrackMode !== \"native\" && options.textTrackMode !== \"html\") {\n            throw new Error(\"Invalid textTrackMode.\");\n        }\n        textTrackMode = options.textTrackMode;\n    }\n    if (textTrackMode === \"html\") {\n        // TODO Better way to express that in TypeScript?\n        if (isNullOrUndefined(options.textTrackElement)) {\n            throw new Error(\"You have to provide a textTrackElement \" + 'in \"html\" textTrackMode.');\n        }\n        else if (!(options.textTrackElement instanceof HTMLElement)) {\n            throw new Error(\"textTrackElement should be an HTMLElement.\");\n        }\n        else {\n            textTrackElement = options.textTrackElement;\n        }\n    }\n    else if (!isNullOrUndefined(options.textTrackElement)) {\n        log.warn(\"API: You have set a textTrackElement without being in \" +\n            'an \"html\" textTrackMode. It will be ignored.');\n    }\n    if (isNullOrUndefined(options.mode)) {\n        mode = \"auto\";\n    }\n    else {\n        if (!arrayIncludes([\"auto\", \"multithread\", \"main\"], options.mode)) {\n            throw new Error(\"Invalid `mode` option.\");\n        }\n        mode = options.mode;\n    }\n    const enableFastSwitching = isNullOrUndefined(options.enableFastSwitching)\n        ? DEFAULT_ENABLE_FAST_SWITCHING\n        : options.enableFastSwitching;\n    if (!isNullOrUndefined(options.startAt)) {\n        if (\"wallClockTime\" in options.startAt &&\n            options.startAt.wallClockTime instanceof Date) {\n            const wallClockTime = options.startAt.wallClockTime.getTime() / 1000;\n            startAt = objectAssign({}, options.startAt, { wallClockTime });\n        }\n        else {\n            startAt = options.startAt;\n        }\n    }\n    const requestConfig = (_c = options.requestConfig) !== null && _c !== void 0 ? _c : {};\n    // All those eslint disable are needed because the option is voluntarily\n    // hidden from the base type to limit discovery of this hidden API.\n    return {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n        __priv_patchLastSegmentInSidx: options.__priv_patchLastSegmentInSidx,\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n        __priv_manifestUpdateUrl: options.__priv_manifestUpdateUrl,\n        checkMediaSegmentIntegrity: options.checkMediaSegmentIntegrity,\n        checkManifestIntegrity: options.checkManifestIntegrity,\n        autoPlay,\n        defaultAudioTrackSwitchingMode,\n        enableFastSwitching,\n        initialManifest,\n        keySystems,\n        lowLatencyMode,\n        manifestLoader: options.manifestLoader,\n        minimumManifestUpdateInterval,\n        requestConfig,\n        onCodecSwitch,\n        referenceDateTime: options.referenceDateTime,\n        representationFilter: options.representationFilter,\n        segmentLoader: options.segmentLoader,\n        serverSyncInfos: options.serverSyncInfos,\n        startAt,\n        textTrackElement: textTrackElement,\n        textTrackMode,\n        transport,\n        mode,\n        url,\n        cmcd: options.cmcd,\n        experimentalOptions: {\n            enableRepresentationAvoidance: ((_d = options.experimentalOptions) === null || _d === void 0 ? void 0 : _d.enableRepresentationAvoidance) === true,\n        },\n    };\n}\nexport { checkReloadOptions, parseConstructorOptions, parseLoadVideoOptions };\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");publicapi\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport canRelyOnVideoVisibilityAndSize from \"../../compat/can_rely_on_video_visibility_and_size\";\nimport { getPictureOnPictureStateRef, getVideoVisibilityRef, getElementResolutionRef, getScreenResolutionRef, } from \"../../compat/event_listeners\";\nimport getStartDate from \"../../compat/get_start_date\";\nimport hasMseInWorker from \"../../compat/has_mse_in_worker\";\nimport hasWorkerApi from \"../../compat/has_worker_api\";\nimport isDebugModeEnabled from \"../../compat/is_debug_mode_enabled\";\nimport config from \"../../config\";\nimport { ErrorCodes, ErrorTypes, formatError, MediaError } from \"../../errors\";\nimport WorkerInitializationError from \"../../errors/worker_initialization_error\";\nimport features, { addFeatures } from \"../../features\";\nimport log from \"../../log\";\nimport { getLivePosition, getMaximumSafePosition, getMinimumSafePosition, createRepresentationFilterFromFnString, getPeriodForTime, } from \"../../manifest\";\nimport MediaElementPlaybackObserver from \"../../playback_observer/media_element_playback_observer\";\nimport arrayFind from \"../../utils/array_find\";\nimport arrayIncludes from \"../../utils/array_includes\";\nimport assert, { assertUnreachable } from \"../../utils/assert\";\nimport EventEmitter from \"../../utils/event_emitter\";\nimport idGenerator from \"../../utils/id_generator\";\nimport isNullOrUndefined from \"../../utils/is_null_or_undefined\";\nimport getMonotonicTimeStamp from \"../../utils/monotonic_timestamp\";\nimport objectAssign from \"../../utils/object_assign\";\nimport { getLeftSizeOfBufferedTimeRange } from \"../../utils/ranges\";\nimport SharedReference, { createMappedReference } from \"../../utils/reference\";\nimport TaskCanceller from \"../../utils/task_canceller\";\nimport { clearOnStop, disposeDecryptionResources, getKeySystemConfiguration, } from \"../decrypt\";\nimport renderThumbnail from \"../render_thumbnail\";\nimport TracksStore from \"../tracks_store\";\nimport { checkReloadOptions, parseConstructorOptions, parseLoadVideoOptions, } from \"./option_utils\";\nimport { constructPlayerStateReference, emitPlayPauseEvents, emitSeekEvents, isLoadedState, } from \"./utils\";\n/* eslint-disable @typescript-eslint/naming-convention */\nconst generateContentId = idGenerator();\n/**\n * Options of a `loadVideo` call which are for now not supported when running\n * in a \"multithread\" mode.\n *\n * TODO support those?\n */\nconst MULTI_THREAD_UNSUPPORTED_LOAD_VIDEO_OPTIONS = [\n    \"manifestLoader\",\n    \"segmentLoader\",\n];\n/**\n * @class Player\n * @extends EventEmitter\n */\nclass Player extends EventEmitter {\n    /** All possible Error types emitted by the RxPlayer. */\n    static get ErrorTypes() {\n        return ErrorTypes;\n    }\n    /** All possible Error codes emitted by the RxPlayer. */\n    static get ErrorCodes() {\n        return ErrorCodes;\n    }\n    /**\n     * Current log level.\n     * Update current log level.\n     * Should be either (by verbosity ascending):\n     *   - \"NONE\"\n     *   - \"ERROR\"\n     *   - \"WARNING\"\n     *   - \"INFO\"\n     *   - \"DEBUG\"\n     * Any other value will be translated to \"NONE\".\n     */\n    static get LogLevel() {\n        return log.getLevel();\n    }\n    static set LogLevel(logLevel) {\n        log.setLevel(logLevel, log.getFormat());\n    }\n    /**\n     * Current log format.\n     * Should be either (by verbosity ascending):\n     *   - \"standard\": Regular log messages.\n     *   - \"full\": More verbose format, including a timestamp and a namespace.\n     * Any other value will be translated to \"standard\".\n     */\n    static get LogFormat() {\n        return log.getFormat();\n    }\n    static set LogFormat(format) {\n        log.setLevel(log.getLevel(), format);\n    }\n    /**\n     * Add feature(s) to the RxPlayer.\n     * @param {Array.<Object>} featureList - Features wanted.\n     */\n    static addFeatures(featureList) {\n        addFeatures(featureList);\n    }\n    /**\n     * Register the video element to the set of elements currently in use.\n     * @param videoElement the video element to register.\n     * @throws Error - Throws if the element is already used by another player instance.\n     */\n    static _priv_registerVideoElement(videoElement) {\n        if (Player._priv_currentlyUsedVideoElements.has(videoElement)) {\n            const errorMessage = \"The video element is already attached to another RxPlayer instance.\" +\n                \"\\nMake sure to dispose the previous instance with player.dispose() before creating\" +\n                \" a new player instance attaching that video element.\";\n            // eslint-disable-next-line no-console\n            console.warn(errorMessage);\n            /*\n             * TODO: for next major version 5.0: this need to throw an error instead of just logging\n             * this was not done for minor version as it could be considerated a breaking change.\n             *\n             * throw new Error(errorMessage);\n             */\n        }\n        Player._priv_currentlyUsedVideoElements.add(videoElement);\n    }\n    /**\n     * Deregister the video element of the set of elements currently in use.\n     * @param videoElement the video element to deregister.\n     */\n    static _priv_deregisterVideoElement(videoElement) {\n        if (Player._priv_currentlyUsedVideoElements.has(videoElement)) {\n            Player._priv_currentlyUsedVideoElements.delete(videoElement);\n        }\n    }\n    /**\n     * @constructor\n     * @param {Object} options\n     */\n    constructor(options = {}) {\n        super();\n        const { baseBandwidth, videoResolutionLimit, maxBufferAhead, maxBufferBehind, throttleVideoBitrateWhenHidden, videoElement, wantedBufferAhead, maxVideoBufferSize, } = parseConstructorOptions(options);\n        // Workaround to support Firefox autoplay on FF 42.\n        // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1194624\n        videoElement.preload = \"auto\";\n        this.version = /* PLAYER_VERSION */ \"4.3.0\";\n        this.log = log;\n        this.state = \"STOPPED\";\n        this.videoElement = videoElement;\n        Player._priv_registerVideoElement(this.videoElement);\n        const destroyCanceller = new TaskCanceller();\n        this._destroyCanceller = destroyCanceller;\n        this._priv_pictureInPictureRef = getPictureOnPictureStateRef(videoElement, destroyCanceller.signal);\n        this._priv_speed = new SharedReference(videoElement.playbackRate, this._destroyCanceller.signal);\n        this._priv_preferTrickModeTracks = false;\n        this._priv_contentLock = new SharedReference(false, this._destroyCanceller.signal);\n        this._priv_bufferOptions = {\n            wantedBufferAhead: new SharedReference(wantedBufferAhead, this._destroyCanceller.signal),\n            maxBufferAhead: new SharedReference(maxBufferAhead, this._destroyCanceller.signal),\n            maxBufferBehind: new SharedReference(maxBufferBehind, this._destroyCanceller.signal),\n            maxVideoBufferSize: new SharedReference(maxVideoBufferSize, this._destroyCanceller.signal),\n        };\n        this._priv_bitrateInfos = {\n            lastBitrates: { audio: baseBandwidth, video: baseBandwidth },\n        };\n        this._priv_throttleVideoBitrateWhenHidden = throttleVideoBitrateWhenHidden;\n        this._priv_videoResolutionLimit = videoResolutionLimit;\n        this._priv_currentError = null;\n        this._priv_contentInfos = null;\n        this._priv_contentEventsMemory = {};\n        this._priv_reloadingMetadata = {};\n        this._priv_lastAutoPlay = false;\n        this._priv_worker = null;\n        const onVolumeChange = () => {\n            this.trigger(\"volumeChange\", {\n                volume: videoElement.volume,\n                muted: videoElement.muted,\n            });\n        };\n        videoElement.addEventListener(\"volumechange\", onVolumeChange);\n        destroyCanceller.signal.register(() => {\n            videoElement.removeEventListener(\"volumechange\", onVolumeChange);\n        });\n    }\n    /**\n     * TODO returns promise?\n     * @param {Object} workerSettings\n     */\n    attachWorker(workerSettings) {\n        return new Promise((res, rej) => {\n            var _a;\n            if (!hasWorkerApi()) {\n                log.warn(\"API: Cannot rely on a WebWorker: Worker API unavailable\");\n                return rej(new WorkerInitializationError(\"INCOMPATIBLE_ERROR\", \"Worker unavailable\"));\n            }\n            if (typeof workerSettings.workerUrl === \"string\") {\n                this._priv_worker = new Worker(workerSettings.workerUrl);\n            }\n            else {\n                const blobUrl = URL.createObjectURL(workerSettings.workerUrl);\n                this._priv_worker = new Worker(blobUrl);\n                URL.revokeObjectURL(blobUrl);\n            }\n            this._priv_worker.onerror = (evt) => {\n                if (this._priv_worker !== null) {\n                    this._priv_worker.terminate();\n                    this._priv_worker = null;\n                }\n                log.error(\"API: Unexpected worker error\", evt.error instanceof Error ? evt.error : undefined);\n                rej(new WorkerInitializationError(\"UNKNOWN_ERROR\", 'Unexpected Worker \"error\" event'));\n            };\n            const handleInitMessages = (msg) => {\n                const msgData = msg.data;\n                if (msgData.type === \"init-error\" /* WorkerMessageType.InitError */) {\n                    log.warn(\"API: Processing InitError worker message: detaching worker\");\n                    if (this._priv_worker !== null) {\n                        this._priv_worker.removeEventListener(\"message\", handleInitMessages);\n                        this._priv_worker.terminate();\n                        this._priv_worker = null;\n                    }\n                    rej(new WorkerInitializationError(\"SETUP_ERROR\", \"Worker parser initialization failed: \" + msgData.value.errorMessage));\n                }\n                else if (msgData.type === \"init-success\" /* WorkerMessageType.InitSuccess */) {\n                    log.info(\"API: InitSuccess received from worker.\");\n                    if (this._priv_worker !== null) {\n                        this._priv_worker.removeEventListener(\"message\", handleInitMessages);\n                    }\n                    res();\n                }\n            };\n            this._priv_worker.addEventListener(\"message\", handleInitMessages);\n            log.debug(\"---> Sending To Worker:\", \"init\" /* MainThreadMessageType.Init */);\n            this._priv_worker.postMessage({\n                type: \"init\" /* MainThreadMessageType.Init */,\n                value: {\n                    dashWasmUrl: workerSettings.dashWasmUrl,\n                    logLevel: log.getLevel(),\n                    logFormat: log.getFormat(),\n                    sendBackLogs: isDebugModeEnabled(),\n                    date: Date.now(),\n                    timestamp: getMonotonicTimeStamp(),\n                    hasVideo: ((_a = this.videoElement) === null || _a === void 0 ? void 0 : _a.nodeName.toLowerCase()) === \"video\",\n                    hasMseInWorker,\n                },\n            });\n            log.addEventListener(\"onLogLevelChange\", (logInfo) => {\n                if (this._priv_worker === null) {\n                    return;\n                }\n                log.debug(\"---> Sending To Worker:\", \"log-level-update\" /* MainThreadMessageType.LogLevelUpdate */);\n                this._priv_worker.postMessage({\n                    type: \"log-level-update\" /* MainThreadMessageType.LogLevelUpdate */,\n                    value: {\n                        logLevel: logInfo.level,\n                        logFormat: logInfo.format,\n                        sendBackLogs: isDebugModeEnabled(),\n                    },\n                });\n            }, this._destroyCanceller.signal);\n            const sendConfigUpdates = (updates) => {\n                if (this._priv_worker === null) {\n                    return;\n                }\n                log.debug(\"---> Sending To Worker:\", \"config-update\" /* MainThreadMessageType.ConfigUpdate */);\n                this._priv_worker.postMessage({\n                    type: \"config-update\" /* MainThreadMessageType.ConfigUpdate */,\n                    value: updates,\n                });\n            };\n            if (config.updated) {\n                sendConfigUpdates(config.getCurrent());\n            }\n            config.addEventListener(\"update\", sendConfigUpdates, this._destroyCanceller.signal);\n        });\n    }\n    /**\n     * Returns information on which \"mode\" the RxPlayer is running for the current\n     * content (e.g. main logic running in a WebWorker or not, are we in\n     * directfile mode...).\n     *\n     * Returns `null` if no content is loaded.\n     * @returns {Object|null}\n     */\n    getCurrentModeInformation() {\n        if (this._priv_contentInfos === null) {\n            return null;\n        }\n        return {\n            isDirectFile: this._priv_contentInfos.isDirectFile,\n            useWorker: this._priv_contentInfos.useWorker,\n        };\n    }\n    /**\n     * Register a new callback for a player event event.\n     *\n     * @param {string} evt - The event to register a callback to\n     * @param {Function} fn - The callback to call as that event is triggered.\n     * The callback will take as argument the eventual payload of the event\n     * (single argument).\n     */\n    addEventListener(evt, fn) {\n        // The EventEmitter's `addEventListener` method takes an optional third\n        // argument that we do not want to expose in the public API.\n        // We thus overwrite that function to remove any possible usage of that\n        // third argument.\n        return super.addEventListener(evt, fn);\n    }\n    /**\n     * Stop the playback for the current content.\n     */\n    stop() {\n        if (this._priv_contentInfos !== null) {\n            this._priv_contentInfos.currentContentCanceller.cancel();\n        }\n        this._priv_cleanUpCurrentContentState();\n        if (this.state !== \"STOPPED\" /* PLAYER_STATES.STOPPED */) {\n            this._priv_setPlayerState(\"STOPPED\" /* PLAYER_STATES.STOPPED */);\n        }\n    }\n    /**\n     * Free the resources used by the player.\n     * /!\\ The player cannot be \"used\" anymore after this method has been called.\n     */\n    dispose() {\n        // free resources linked to the loaded content\n        this.stop();\n        if (this.videoElement !== null) {\n            Player._priv_deregisterVideoElement(this.videoElement);\n            // free resources used for decryption management\n            disposeDecryptionResources(this.videoElement).catch((err) => {\n                const message = err instanceof Error ? err.message : \"Unknown error\";\n                log.error(\"API: Could not dispose decryption resources: \" + message);\n            });\n        }\n        // free resources linked to the Player instance\n        this._destroyCanceller.cancel();\n        this._priv_reloadingMetadata = {};\n        // un-attach video element\n        this.videoElement = null;\n        if (this._priv_worker !== null) {\n            this._priv_worker.terminate();\n            this._priv_worker = null;\n        }\n    }\n    /**\n     * Load a new video.\n     * @param {Object} opts\n     */\n    loadVideo(opts) {\n        const options = parseLoadVideoOptions(opts);\n        log.info(\"API: Calling loadvideo\", options.url, options.transport);\n        this._priv_reloadingMetadata = { options };\n        this._priv_initializeContentPlayback(options);\n        this._priv_lastAutoPlay = options.autoPlay;\n    }\n    /**\n     * Reload the last loaded content.\n     * @param {Object} reloadOpts\n     */\n    reload(reloadOpts) {\n        var _a, _b, _c;\n        const { options, manifest, reloadPosition, reloadInPause } = this._priv_reloadingMetadata;\n        if (options === undefined) {\n            throw new Error(\"API: Can't reload without having previously loaded a content.\");\n        }\n        checkReloadOptions(reloadOpts);\n        let startAt;\n        if (((_a = reloadOpts === null || reloadOpts === void 0 ? void 0 : reloadOpts.reloadAt) === null || _a === void 0 ? void 0 : _a.position) !== undefined) {\n            startAt = { position: reloadOpts.reloadAt.position };\n        }\n        else if (((_b = reloadOpts === null || reloadOpts === void 0 ? void 0 : reloadOpts.reloadAt) === null || _b === void 0 ? void 0 : _b.relative) !== undefined) {\n            if (reloadPosition === undefined) {\n                throw new Error(\"Can't reload to a relative position when previous content was not loaded.\");\n            }\n            else {\n                startAt = { position: reloadOpts.reloadAt.relative + reloadPosition };\n            }\n        }\n        else if (reloadPosition !== undefined) {\n            startAt = { position: reloadPosition };\n        }\n        let autoPlay;\n        if ((reloadOpts === null || reloadOpts === void 0 ? void 0 : reloadOpts.autoPlay) !== undefined) {\n            autoPlay = reloadOpts.autoPlay;\n        }\n        else if (reloadInPause !== undefined) {\n            autoPlay = !reloadInPause;\n        }\n        let keySystems;\n        if ((reloadOpts === null || reloadOpts === void 0 ? void 0 : reloadOpts.keySystems) !== undefined) {\n            keySystems = reloadOpts.keySystems;\n        }\n        else if (((_c = this._priv_reloadingMetadata.options) === null || _c === void 0 ? void 0 : _c.keySystems) !== undefined) {\n            keySystems = this._priv_reloadingMetadata.options.keySystems;\n        }\n        const newOptions = Object.assign(Object.assign({}, options), { initialManifest: manifest });\n        if (startAt !== undefined) {\n            newOptions.startAt = startAt;\n        }\n        if (autoPlay !== undefined) {\n            newOptions.autoPlay = autoPlay;\n        }\n        if (keySystems !== undefined) {\n            newOptions.keySystems = keySystems;\n        }\n        this._priv_initializeContentPlayback(newOptions);\n    }\n    createDebugElement(element) {\n        if (features.createDebugElement === null) {\n            throw new Error(\"Feature `DEBUG_ELEMENT` not added to the RxPlayer\");\n        }\n        const canceller = new TaskCanceller();\n        features.createDebugElement(element, this, canceller.signal);\n        return {\n            dispose() {\n                canceller.cancel();\n            },\n        };\n    }\n    /**\n     * Returns an array decribing the various thumbnail tracks that can be\n     * encountered at the wanted time or Period.\n     * @param {Object} arg\n     * @param {number|undefined} [arg.time] - The position to check for thumbnail\n     * tracks, in seconds.\n     * @param {string|undefined} [arg.periodId] - The Period to check for\n     * thumbnail tracks.\n     * If not set and if `arg.time` is also not set, the current Period will be\n     * considered.\n     * @returns {Array.<Object>}\n     */\n    getAvailableThumbnailTracks({ time, periodId, } = {}) {\n        if (this._priv_contentInfos === null || this._priv_contentInfos.manifest === null) {\n            return [];\n        }\n        const { manifest } = this._priv_contentInfos;\n        let period;\n        if (time !== undefined) {\n            period = getPeriodForTime(this._priv_contentInfos.manifest, time);\n            if (period === undefined || period.thumbnailTracks.length === 0) {\n                return [];\n            }\n        }\n        else if (periodId !== undefined) {\n            period = arrayFind(manifest.periods, (p) => p.id === periodId);\n            if (period === undefined) {\n                log.error(\"API: getAvailableThumbnailTracks: periodId not found\");\n                return [];\n            }\n        }\n        else {\n            const { currentPeriod } = this._priv_contentInfos;\n            if (currentPeriod === null) {\n                return [];\n            }\n            period = currentPeriod;\n        }\n        return period.thumbnailTracks.map((t) => {\n            return {\n                id: t.id,\n                width: Math.floor(t.width / t.horizontalTiles),\n                height: Math.floor(t.height / t.verticalTiles),\n                mimeType: t.mimeType,\n            };\n        });\n    }\n    /**\n     * Render inside the given `container` the thumbnail corresponding to the\n     * given time.\n     *\n     * If no thumbnail is available at that time or if the RxPlayer does not succeed\n     * to load or render it, reject the corresponding Promise and remove the\n     * potential previous thumbnail from the container.\n     *\n     * If a new `renderThumbnail` call is made with the same `container` before it\n     * had time to finish, the Promise is also rejected but the previous thumbnail\n     * potentially found in the container is untouched.\n     *\n     * @param {Object|undefined} options\n     * @returns {Promise}\n     */\n    async renderThumbnail(options) {\n        if (isNullOrUndefined(options.time)) {\n            throw new Error(\"You have to provide a `time` property to `renderThumbnail`, indicating the wanted thumbnail time in seconds.\");\n        }\n        if (isNullOrUndefined(options.container)) {\n            throw new Error(\"You have to provide a `container` property to `renderThumbnail`, specifying the HTML Element in which the thumbnail should be inserted.\");\n        }\n        return renderThumbnail(this._priv_contentInfos, options);\n    }\n    /**\n     * From given options, initialize content playback.\n     * @param {Object} options\n     */\n    _priv_initializeContentPlayback(options) {\n        var _a, _b, _c, _d, _f, _g;\n        const { autoPlay, cmcd, defaultAudioTrackSwitchingMode, enableFastSwitching, initialManifest, keySystems, lowLatencyMode, minimumManifestUpdateInterval, requestConfig, onCodecSwitch, startAt, transport, checkMediaSegmentIntegrity, checkManifestIntegrity, manifestLoader, referenceDateTime, segmentLoader, serverSyncInfos, mode, experimentalOptions, __priv_manifestUpdateUrl, __priv_patchLastSegmentInSidx, url, } = options;\n        // Perform multiple checks on the given options\n        if (this.videoElement === null) {\n            throw new Error(\"the attached video element is disposed\");\n        }\n        const isDirectFile = transport === \"directfile\";\n        /** Emit to stop the current content. */\n        const currentContentCanceller = new TaskCanceller();\n        const videoElement = this.videoElement;\n        let initializer;\n        let useWorker = false;\n        let mediaElementTracksStore = null;\n        if (!isDirectFile) {\n            /** Interface used to load and refresh the Manifest. */\n            const manifestRequestSettings = {\n                lowLatencyMode,\n                maxRetry: (_a = requestConfig.manifest) === null || _a === void 0 ? void 0 : _a.maxRetry,\n                requestTimeout: (_b = requestConfig.manifest) === null || _b === void 0 ? void 0 : _b.timeout,\n                connectionTimeout: (_c = requestConfig.manifest) === null || _c === void 0 ? void 0 : _c.connectionTimeout,\n                minimumManifestUpdateInterval,\n                initialManifest,\n            };\n            const relyOnVideoVisibilityAndSize = canRelyOnVideoVisibilityAndSize();\n            const throttlers = {\n                throttleBitrate: {},\n                limitResolution: {},\n            };\n            if (this._priv_throttleVideoBitrateWhenHidden) {\n                if (!relyOnVideoVisibilityAndSize) {\n                    log.warn(\"API: Can't apply throttleVideoBitrateWhenHidden because \" +\n                        \"browser can't be trusted for visibility.\");\n                }\n                else {\n                    throttlers.throttleBitrate = {\n                        video: createMappedReference(getVideoVisibilityRef(this._priv_pictureInPictureRef, currentContentCanceller.signal), (isActive) => (isActive ? Infinity : 0), currentContentCanceller.signal),\n                    };\n                }\n            }\n            if (this._priv_videoResolutionLimit === \"videoElement\") {\n                if (!relyOnVideoVisibilityAndSize) {\n                    log.warn(\"API: Can't apply videoResolutionLimit because browser can't be \" +\n                        \"trusted for video size.\");\n                }\n                else {\n                    throttlers.limitResolution = {\n                        video: getElementResolutionRef(videoElement, this._priv_pictureInPictureRef, currentContentCanceller.signal),\n                    };\n                }\n            }\n            else if (this._priv_videoResolutionLimit === \"screen\") {\n                throttlers.limitResolution = {\n                    video: getScreenResolutionRef(currentContentCanceller.signal),\n                };\n            }\n            /** Options used by the adaptive logic. */\n            const adaptiveOptions = {\n                initialBitrates: this._priv_bitrateInfos.lastBitrates,\n                lowLatencyMode,\n                throttlers,\n            };\n            /** Options used by the TextTrack SegmentSink. */\n            const textTrackOptions = options.textTrackMode === \"native\"\n                ? { textTrackMode: \"native\" }\n                : {\n                    textTrackMode: \"html\",\n                    textTrackElement: options.textTrackElement,\n                };\n            const bufferOptions = objectAssign({ enableFastSwitching, onCodecSwitch }, this._priv_bufferOptions);\n            const segmentRequestOptions = {\n                lowLatencyMode,\n                maxRetry: (_d = requestConfig.segment) === null || _d === void 0 ? void 0 : _d.maxRetry,\n                requestTimeout: (_f = requestConfig.segment) === null || _f === void 0 ? void 0 : _f.timeout,\n                connectionTimeout: (_g = requestConfig.segment) === null || _g === void 0 ? void 0 : _g.connectionTimeout,\n            };\n            const canRunInMultiThread = features.multithread !== null &&\n                this._priv_worker !== null &&\n                transport === \"dash\" &&\n                MULTI_THREAD_UNSUPPORTED_LOAD_VIDEO_OPTIONS.every((option) => isNullOrUndefined(options[option])) &&\n                typeof options.representationFilter !== \"function\";\n            if (mode === \"main\" || (mode === \"auto\" && !canRunInMultiThread)) {\n                if (features.mainThreadMediaSourceInit === null) {\n                    throw new Error(\"Cannot load video, neither in a WebWorker nor with the \" +\n                        \"`MEDIA_SOURCE_MAIN` feature\");\n                }\n                const transportFn = features.transports[transport];\n                if (typeof transportFn !== \"function\") {\n                    // Stop previous content and reset its state\n                    this.stop();\n                    this._priv_currentError = null;\n                    throw new Error(`transport \"${transport}\" not supported`);\n                }\n                const representationFilter = typeof options.representationFilter === \"string\"\n                    ? createRepresentationFilterFromFnString(options.representationFilter)\n                    : options.representationFilter;\n                log.info(\"API: Initializing MediaSource mode in the main thread\");\n                const transportPipelines = transportFn({\n                    lowLatencyMode,\n                    checkMediaSegmentIntegrity,\n                    checkManifestIntegrity,\n                    manifestLoader,\n                    referenceDateTime,\n                    representationFilter,\n                    segmentLoader,\n                    serverSyncInfos,\n                    __priv_manifestUpdateUrl,\n                    __priv_patchLastSegmentInSidx,\n                });\n                initializer = new features.mainThreadMediaSourceInit({\n                    adaptiveOptions,\n                    autoPlay,\n                    bufferOptions,\n                    cmcd,\n                    enableRepresentationAvoidance: experimentalOptions.enableRepresentationAvoidance,\n                    keySystems,\n                    lowLatencyMode,\n                    transport: transportPipelines,\n                    manifestRequestSettings,\n                    segmentRequestOptions,\n                    speed: this._priv_speed,\n                    startAt,\n                    textTrackOptions,\n                    url,\n                });\n            }\n            else {\n                if (features.multithread === null) {\n                    throw new Error(\"Cannot load video in multithread mode: `MULTI_THREAD` \" +\n                        \"feature not imported.\");\n                }\n                else if (this._priv_worker === null) {\n                    throw new Error(\"Cannot load video in multithread mode: `attachWorker` \" +\n                        \"method not called.\");\n                }\n                assert(typeof options.representationFilter !== \"function\");\n                useWorker = true;\n                log.info(\"API: Initializing MediaSource mode in a WebWorker\");\n                const transportOptions = {\n                    lowLatencyMode,\n                    checkMediaSegmentIntegrity,\n                    checkManifestIntegrity,\n                    referenceDateTime,\n                    serverSyncInfos,\n                    manifestLoader: undefined,\n                    segmentLoader: undefined,\n                    representationFilter: options.representationFilter,\n                    __priv_manifestUpdateUrl,\n                    __priv_patchLastSegmentInSidx,\n                };\n                initializer = new features.multithread.init({\n                    adaptiveOptions,\n                    autoPlay,\n                    bufferOptions,\n                    cmcd,\n                    enableRepresentationAvoidance: experimentalOptions.enableRepresentationAvoidance,\n                    keySystems,\n                    lowLatencyMode,\n                    transportOptions,\n                    manifestRequestSettings,\n                    segmentRequestOptions,\n                    speed: this._priv_speed,\n                    startAt,\n                    textTrackOptions,\n                    worker: this._priv_worker,\n                    url,\n                });\n            }\n        }\n        else {\n            if (features.directfile === null) {\n                this.stop();\n                this._priv_currentError = null;\n                throw new Error(\"DirectFile feature not activated in your build.\");\n            }\n            else if (isNullOrUndefined(url)) {\n                throw new Error(\"No URL for a DirectFile content\");\n            }\n            log.info(\"API: Initializing DirectFile mode in the main thread\");\n            mediaElementTracksStore = this._priv_initializeMediaElementTracksStore(currentContentCanceller.signal);\n            if (currentContentCanceller.isUsed()) {\n                return;\n            }\n            initializer = new features.directfile.initDirectFile({\n                autoPlay,\n                keySystems,\n                speed: this._priv_speed,\n                startAt,\n                url,\n            });\n        }\n        /** Future `this._priv_contentInfos` related to this content. */\n        const contentInfos = {\n            contentId: generateContentId(),\n            originalUrl: url,\n            currentContentCanceller,\n            defaultAudioTrackSwitchingMode,\n            initializer,\n            isDirectFile,\n            manifest: null,\n            currentPeriod: null,\n            activeAdaptations: null,\n            activeRepresentations: null,\n            tracksStore: null,\n            mediaElementTracksStore,\n            useWorker,\n            segmentSinkMetricsCallback: null,\n            fetchThumbnailDataCallback: null,\n            thumbnailRequestsInfo: {\n                pendingRequests: new WeakMap(),\n                lastResponse: null,\n            },\n        };\n        // Bind events\n        initializer.addEventListener(\"error\", (error) => {\n            this._priv_onFatalError(error, contentInfos);\n        });\n        initializer.addEventListener(\"warning\", (error) => {\n            const formattedError = formatError(error, {\n                defaultCode: \"NONE\",\n                defaultReason: \"An unknown error happened.\",\n            });\n            log.warn(\"API: Sending warning:\", formattedError);\n            this.trigger(\"warning\", formattedError);\n        });\n        initializer.addEventListener(\"reloadingMediaSource\", (payload) => {\n            if (contentInfos.tracksStore !== null) {\n                contentInfos.tracksStore.resetPeriodObjects();\n            }\n            if (this._priv_contentInfos !== null) {\n                this._priv_contentInfos.segmentSinkMetricsCallback = null;\n            }\n            this._priv_lastAutoPlay = payload.autoPlay;\n        });\n        initializer.addEventListener(\"inbandEvents\", (inbandEvents) => this.trigger(\"inbandEvents\", inbandEvents));\n        initializer.addEventListener(\"streamEvent\", (streamEvent) => this.trigger(\"streamEvent\", streamEvent));\n        initializer.addEventListener(\"streamEventSkip\", (streamEventSkip) => this.trigger(\"streamEventSkip\", streamEventSkip));\n        initializer.addEventListener(\"activePeriodChanged\", (periodInfo) => this._priv_onActivePeriodChanged(contentInfos, periodInfo));\n        initializer.addEventListener(\"periodStreamReady\", (periodReadyInfo) => this._priv_onPeriodStreamReady(contentInfos, periodReadyInfo));\n        initializer.addEventListener(\"periodStreamCleared\", (periodClearedInfo) => this._priv_onPeriodStreamCleared(contentInfos, periodClearedInfo));\n        initializer.addEventListener(\"representationChange\", (representationInfo) => this._priv_onRepresentationChange(contentInfos, representationInfo));\n        initializer.addEventListener(\"adaptationChange\", (adaptationInfo) => this._priv_onAdaptationChange(contentInfos, adaptationInfo));\n        initializer.addEventListener(\"bitrateEstimateChange\", (bitrateEstimateInfo) => this._priv_onBitrateEstimateChange(bitrateEstimateInfo));\n        initializer.addEventListener(\"manifestReady\", (manifest) => this._priv_onManifestReady(contentInfos, manifest));\n        initializer.addEventListener(\"manifestUpdate\", (updates) => this._priv_onManifestUpdate(contentInfos, updates));\n        initializer.addEventListener(\"codecSupportUpdate\", () => this._priv_onCodecSupportUpdate(contentInfos));\n        initializer.addEventListener(\"decipherabilityUpdate\", (updates) => this._priv_onDecipherabilityUpdate(contentInfos, updates));\n        initializer.addEventListener(\"loaded\", (evt) => {\n            if (this._priv_contentInfos !== null) {\n                this._priv_contentInfos.segmentSinkMetricsCallback = evt.getSegmentSinkMetrics;\n                this._priv_contentInfos.fetchThumbnailDataCallback = evt.getThumbnailData;\n            }\n        });\n        // Now, that most events are linked, prepare the next content.\n        initializer.prepare();\n        // Now that the content is prepared, stop previous content and reset state\n        // This is done after content preparation as `stop` could technically have\n        // a long and synchronous blocking time.\n        // Note that this call is done **synchronously** after all events linking.\n        // This is **VERY** important so:\n        //   - the `STOPPED` state is switched to synchronously after loading a new\n        //     content.\n        //   - we can avoid involontarily catching events linked to the previous\n        //     content.\n        this.stop();\n        /** Global \"playback observer\" which will emit playback conditions */\n        const playbackObserver = new MediaElementPlaybackObserver(videoElement, {\n            withMediaSource: !isDirectFile,\n            lowLatencyMode,\n        });\n        currentContentCanceller.signal.register(() => {\n            playbackObserver.stop();\n        });\n        // Update the RxPlayer's state at the right events\n        const playerStateRef = constructPlayerStateReference(initializer, videoElement, playbackObserver, currentContentCanceller.signal);\n        currentContentCanceller.signal.register(() => {\n            initializer.dispose();\n        });\n        /**\n         * Function updating `this._priv_reloadingMetadata` in function of the\n         * current state and playback conditions.\n         * To call when either might change.\n         * @param {string} state - The player state we're about to switch to.\n         */\n        const updateReloadingMetadata = (state) => {\n            switch (state) {\n                case \"STOPPED\":\n                case \"RELOADING\":\n                case \"LOADING\":\n                    break; // keep previous metadata\n                case \"ENDED\":\n                    this._priv_reloadingMetadata.reloadInPause = true;\n                    this._priv_reloadingMetadata.reloadPosition = playbackObserver\n                        .getReference()\n                        .getValue()\n                        .position.getPolled();\n                    break;\n                default: {\n                    const o = playbackObserver.getReference().getValue();\n                    this._priv_reloadingMetadata.reloadInPause = o.paused;\n                    this._priv_reloadingMetadata.reloadPosition = o.position.getWanted();\n                    break;\n                }\n            }\n        };\n        /**\n         * `TaskCanceller` allowing to stop emitting `\"play\"` and `\"pause\"`\n         * events.\n         * `null` when such events are not emitted currently.\n         */\n        let playPauseEventsCanceller = null;\n        /**\n         * Callback emitting `\"play\"` and `\"pause`\" events once the content is\n         * loaded, starting from the state indicated in argument.\n         * @param {boolean} willAutoPlay - If `false`, we're currently paused.\n         */\n        const triggerPlayPauseEventsWhenReady = (willAutoPlay) => {\n            if (playPauseEventsCanceller !== null) {\n                playPauseEventsCanceller.cancel(); // cancel previous logic\n                playPauseEventsCanceller = null;\n            }\n            playerStateRef.onUpdate((val, stopListeningToStateUpdates) => {\n                if (!isLoadedState(val)) {\n                    return; // content not loaded yet: no event\n                }\n                stopListeningToStateUpdates();\n                if (playPauseEventsCanceller !== null) {\n                    playPauseEventsCanceller.cancel();\n                }\n                playPauseEventsCanceller = new TaskCanceller();\n                playPauseEventsCanceller.linkToSignal(currentContentCanceller.signal);\n                if (willAutoPlay !== !videoElement.paused) {\n                    // paused status is not at the expected value on load: emit event\n                    if (videoElement.paused) {\n                        this.trigger(\"pause\", null);\n                    }\n                    else {\n                        this.trigger(\"play\", null);\n                    }\n                }\n                emitPlayPauseEvents(videoElement, () => this.trigger(\"play\", null), () => this.trigger(\"pause\", null), currentContentCanceller.signal);\n            }, {\n                emitCurrentValue: false,\n                clearSignal: currentContentCanceller.signal,\n            });\n        };\n        triggerPlayPauseEventsWhenReady(autoPlay);\n        initializer.addEventListener(\"reloadingMediaSource\", (payload) => {\n            triggerPlayPauseEventsWhenReady(payload.autoPlay);\n        });\n        this._priv_currentError = null;\n        this._priv_contentInfos = contentInfos;\n        /**\n         * `TaskCanceller` allowing to stop emitting `\"seeking\"` and `\"seeked\"`\n         * events.\n         * `null` when such events are not emitted currently.\n         */\n        let seekEventsCanceller = null;\n        // React to player state change\n        playerStateRef.onUpdate((newState) => {\n            updateReloadingMetadata(newState);\n            this._priv_setPlayerState(newState);\n            if (currentContentCanceller.isUsed()) {\n                return;\n            }\n            if (seekEventsCanceller !== null) {\n                if (!isLoadedState(this.state)) {\n                    seekEventsCanceller.cancel();\n                    seekEventsCanceller = null;\n                }\n            }\n            else if (isLoadedState(this.state)) {\n                seekEventsCanceller = new TaskCanceller();\n                seekEventsCanceller.linkToSignal(currentContentCanceller.signal);\n                emitSeekEvents(playbackObserver, () => this.trigger(\"seeking\", null), () => this.trigger(\"seeked\", null), seekEventsCanceller.signal);\n            }\n        }, { emitCurrentValue: true, clearSignal: currentContentCanceller.signal });\n        // React to playback conditions change\n        playbackObserver.listen((observation) => {\n            updateReloadingMetadata(this.state);\n            this._priv_triggerPositionUpdate(contentInfos, observation);\n        }, { clearSignal: currentContentCanceller.signal });\n        currentContentCanceller.signal.register(() => {\n            initializer.removeEventListener();\n        });\n        // initialize the content only when the lock is inactive\n        this._priv_contentLock.onUpdate((isLocked, stopListeningToLock) => {\n            if (!isLocked) {\n                stopListeningToLock();\n                // start playback!\n                initializer.start(videoElement, playbackObserver);\n            }\n        }, { emitCurrentValue: true, clearSignal: currentContentCanceller.signal });\n    }\n    /**\n     * Returns fatal error if one for the current content.\n     * null otherwise.\n     * @returns {Object|null} - The current Error (`null` when no error).\n     */\n    getError() {\n        return this._priv_currentError;\n    }\n    /**\n     * Returns the media DOM element used by the player.\n     * You should not its HTML5 API directly and use the player's method instead,\n     * to ensure a well-behaved player.\n     * @returns {HTMLMediaElement|null} - The HTMLMediaElement used (`null` when\n     * disposed)\n     */\n    // eslint-disable-next-line @typescript-eslint/no-restricted-types\n    getVideoElement() {\n        // eslint-disable-next-line @typescript-eslint/no-restricted-types\n        return this.videoElement;\n    }\n    /**\n     * Returns the player's current state.\n     * @returns {string} - The current Player's state\n     */\n    getPlayerState() {\n        return this.state;\n    }\n    /**\n     * Returns true if a content is loaded.\n     * @returns {Boolean} - `true` if a content is loaded, `false` otherwise.\n     */\n    isContentLoaded() {\n        return !arrayIncludes([\"LOADING\", \"RELOADING\", \"STOPPED\"], this.state);\n    }\n    /**\n     * Returns true if the player is buffering.\n     * @returns {Boolean} - `true` if the player is buffering, `false` otherwise.\n     */\n    isBuffering() {\n        return arrayIncludes([\"BUFFERING\", \"SEEKING\", \"LOADING\", \"RELOADING\"], this.state);\n    }\n    /**\n     * Returns the play/pause status of the player :\n     *   - when `LOADING` or `RELOADING`, returns the scheduled play/pause condition\n     *     for when loading is over,\n     *   - in other states, returns the `<video>` element .paused value,\n     *   - if the player is disposed, returns `true`.\n     * @returns {Boolean} - `true` if the player is paused or will be after loading,\n     * `false` otherwise.\n     */\n    isPaused() {\n        if (this.videoElement !== null) {\n            if (arrayIncludes([\"LOADING\", \"RELOADING\"], this.state)) {\n                return !this._priv_lastAutoPlay;\n            }\n            else {\n                return this.videoElement.paused;\n            }\n        }\n        return true;\n    }\n    /**\n     * Returns true if both:\n     *   - a content is loaded\n     *   - the content loaded is a live content\n     * @returns {Boolean} - `true` if we're playing a live content, `false` otherwise.\n     */\n    isLive() {\n        if (this._priv_contentInfos === null) {\n            return false;\n        }\n        const { isDirectFile, manifest } = this._priv_contentInfos;\n        if (isDirectFile || manifest === null) {\n            return false;\n        }\n        return manifest.isLive;\n    }\n    /**\n     * Returns `true` if trickmode playback is active (usually through the usage\n     * of the `setPlaybackRate` method), which means that the RxPlayer selects\n     * \"trickmode\" video tracks in priority.\n     * @returns {Boolean}\n     */\n    areTrickModeTracksEnabled() {\n        return this._priv_preferTrickModeTracks;\n    }\n    /**\n     * Returns the URL(s) of the currently considered Manifest, or of the content for\n     * directfile content.\n     * @returns {Array.<string>|undefined} - Current URL. `undefined` if not known\n     * or no URL yet.\n     */\n    getContentUrls() {\n        if (this._priv_contentInfos === null) {\n            return undefined;\n        }\n        const { isDirectFile, manifest, originalUrl } = this._priv_contentInfos;\n        if (isDirectFile) {\n            return originalUrl === undefined ? undefined : [originalUrl];\n        }\n        if (manifest !== null) {\n            return manifest.uris;\n        }\n        return undefined;\n    }\n    /**\n     * Update URL of the content currently being played (e.g. DASH's MPD).\n     * @param {Array.<string>|undefined} urls - URLs to reach that content /\n     * Manifest from the most prioritized URL to the least prioritized URL.\n     * @param {Object|undefined} [params]\n     * @param {boolean} params.refresh - If `true` the resource in question\n     * (e.g. DASH's MPD) will be refreshed immediately.\n     */\n    updateContentUrls(urls, params) {\n        if (this._priv_contentInfos === null) {\n            throw new Error(\"No content loaded\");\n        }\n        const refreshNow = (params === null || params === void 0 ? void 0 : params.refresh) === true;\n        this._priv_contentInfos.initializer.updateContentUrls(urls, refreshNow);\n    }\n    /**\n     * Returns the video duration, in seconds.\n     * NaN if no video is playing.\n     * @returns {Number}\n     */\n    getMediaDuration() {\n        if (this.videoElement === null) {\n            throw new Error(\"Disposed player\");\n        }\n        return this.videoElement.duration;\n    }\n    /**\n     * Returns in seconds the difference between:\n     *   - the end of the current contiguous loaded range.\n     *   - the current time\n     * @returns {Number}\n     */\n    getCurrentBufferGap() {\n        if (this.videoElement === null) {\n            throw new Error(\"Disposed player\");\n        }\n        const videoElement = this.videoElement;\n        const bufferGap = getLeftSizeOfBufferedTimeRange(videoElement.buffered, videoElement.currentTime);\n        if (bufferGap === Infinity) {\n            return 0;\n        }\n        return bufferGap;\n    }\n    /**\n     * Get the current position, in s, in wall-clock time.\n     * That is:\n     *   - for live content, get a timestamp, in s, of the current played content.\n     *   - for static content, returns the position from beginning in s.\n     *\n     * If you do not know if you want to use this method or getPosition:\n     *   - If what you want is to display the current time to the user, use this\n     *     one.\n     *   - If what you want is to interact with the player's API or perform other\n     *     actions (like statistics) with the real player data, use getPosition.\n     *\n     * @returns {Number}\n     */\n    getWallClockTime() {\n        var _a;\n        if (this.videoElement === null) {\n            throw new Error(\"Disposed player\");\n        }\n        if (this._priv_contentInfos === null) {\n            return this.videoElement.currentTime;\n        }\n        const { isDirectFile, manifest } = this._priv_contentInfos;\n        if (isDirectFile) {\n            const startDate = getStartDate(this.videoElement);\n            return (startDate !== null && startDate !== void 0 ? startDate : 0) + this.videoElement.currentTime;\n        }\n        if (manifest !== null) {\n            const currentTime = this.videoElement.currentTime;\n            const ast = (_a = manifest.availabilityStartTime) !== null && _a !== void 0 ? _a : 0;\n            return currentTime + ast;\n        }\n        return 0;\n    }\n    /**\n     * Get the current position, in seconds, of the video element.\n     *\n     * If you do not know if you want to use this method or getWallClockTime:\n     *   - If what you want is to display the current time to the user, use\n     *     getWallClockTime.\n     *   - If what you want is to interact with the player's API or perform other\n     *     actions (like statistics) with the real player data, use this one.\n     *\n     * @returns {Number}\n     */\n    getPosition() {\n        if (this.videoElement === null) {\n            throw new Error(\"Disposed player\");\n        }\n        return this.videoElement.currentTime;\n    }\n    /**\n     * Returns the last stored content position, in seconds.\n     *\n     * @returns {number|undefined}\n     */\n    getLastStoredContentPosition() {\n        return this._priv_reloadingMetadata.reloadPosition;\n    }\n    /**\n     * Returns the current playback rate at which the video plays.\n     * @returns {Number}\n     */\n    getPlaybackRate() {\n        return this._priv_speed.getValue();\n    }\n    /**\n     * Update the playback rate of the video.\n     *\n     * This method's effect is persisted from content to content, and can be\n     * called even when no content is playing (it will still have an effect for\n     * the next contents).\n     *\n     * If you want to reverse effects provoked by `setPlaybackRate` before playing\n     * another content, you will have to call `setPlaybackRate` first with the\n     * default settings you want to set.\n     *\n     * As an example, to reset the speed to \"normal\" (x1) speed and to disable\n     * trickMode video tracks (which may have been enabled by a previous\n     * `setPlaybackRate` call), you can call:\n     * ```js\n     * player.setPlaybackRate(1, { preferTrickModeTracks: false });\n     * ```\n     *\n     * --\n     *\n     * This method can be used to switch to or exit from \"trickMode\" video tracks,\n     * which are tracks specifically defined to mimic the visual aspect of a VCR's\n     * fast forward/rewind feature, by only displaying a few video frames during\n     * playback.\n     *\n     * This behavior is configurable through the second argument, by adding a\n     * property named `preferTrickModeTracks` to that object.\n     *\n     * You can set that value to `true` to switch to trickMode video tracks when\n     * available, and set it to `false` when you want to disable that logic.\n     * Note that like any configuration given to `setPlaybackRate`, this setting\n     * is persisted through all future contents played by the player.\n     *\n     * If you want to stop enabling trickMode tracks, you will have to call\n     * `setPlaybackRate` again with `preferTrickModeTracks` set to `false`.\n     *\n     * You can know at any moment whether this behavior is enabled by calling\n     * the `areTrickModeTracksEnabled` method. This will only means that the\n     * RxPlayer will select in priority trickmode video tracks, not that the\n     * currently chosen video tracks is a trickmode track (for example, some\n     * contents may have no trickmode tracks available).\n     *\n     * If you want to know about the latter instead, you can call `getVideoTrack`\n     * and/or listen to `videoTrackChange` events. The track returned may have an\n     * `isTrickModeTrack` property set to `true`, indicating that it is a\n     * trickmode track.\n     *\n     * Note that switching to or getting out of a trickmode video track may\n     * lead to the player being a brief instant in a `\"RELOADING\"` state (notified\n     * through `playerStateChange` events and the `getLoadedContentState` method).\n     * When in that state, a black screen may be displayed and multiple RxPlayer\n     * APIs will not be usable.\n     *\n     * @param {Number} rate\n     * @param {Object} opts\n     */\n    setPlaybackRate(rate, opts) {\n        var _a;\n        if (rate !== this._priv_speed.getValue()) {\n            this._priv_speed.setValue(rate);\n        }\n        const preferTrickModeTracks = opts === null || opts === void 0 ? void 0 : opts.preferTrickModeTracks;\n        if (typeof preferTrickModeTracks !== \"boolean\") {\n            return;\n        }\n        this._priv_preferTrickModeTracks = preferTrickModeTracks;\n        const tracksStore = (_a = this._priv_contentInfos) === null || _a === void 0 ? void 0 : _a.tracksStore;\n        if (!isNullOrUndefined(tracksStore)) {\n            if (preferTrickModeTracks && !tracksStore.isTrickModeEnabled()) {\n                tracksStore.enableVideoTrickModeTracks();\n            }\n            else if (!preferTrickModeTracks && tracksStore.isTrickModeEnabled()) {\n                tracksStore.disableVideoTrickModeTracks();\n            }\n        }\n    }\n    /**\n     * Returns video Representation currently considered for the current Period.\n     *\n     * Returns `null` if no video track is playing for the current Period.\n     *\n     * Returns `undefined` either when are not currently playing any Period or\n     * when we don't know which Representation is playing.\n     * @returns {Object|null|undefined}\n     */\n    getVideoRepresentation() {\n        const representations = this.__priv_getCurrentRepresentations();\n        if (representations === null) {\n            return undefined;\n        }\n        return representations.video;\n    }\n    /**\n     * Returns audio Representation currently considered for the current Period.\n     *\n     * Returns `null` if no audio track is playing for the current Period.\n     *\n     * Returns `undefined` either when are not currently playing any Period or\n     * when we don't know which Representation is playing.\n     * @returns {Object|null|undefined}\n     */\n    getAudioRepresentation() {\n        const representations = this.__priv_getCurrentRepresentations();\n        if (representations === null) {\n            return undefined;\n        }\n        return representations.audio;\n    }\n    /**\n     * Play/Resume the current video.\n     * @returns {Promise}\n     */\n    play() {\n        if (this.videoElement === null) {\n            throw new Error(\"Disposed player\");\n        }\n        const playPromise = this.videoElement.play();\n        if (isNullOrUndefined(playPromise) || typeof playPromise.catch !== \"function\") {\n            return Promise.resolve();\n        }\n        return playPromise.catch((error) => {\n            if (error.name === \"NotAllowedError\") {\n                const warning = new MediaError(\"MEDIA_ERR_PLAY_NOT_ALLOWED\", error.toString());\n                this.trigger(\"warning\", warning);\n            }\n            throw error;\n        });\n    }\n    /**\n     * Pause the current video.\n     */\n    pause() {\n        if (this.videoElement === null) {\n            throw new Error(\"Disposed player\");\n        }\n        this.videoElement.pause();\n    }\n    /**\n     * Seek to a given absolute position.\n     * @param {Number|Object} time\n     * @returns {Number} - The time the player has seek to\n     */\n    seekTo(time) {\n        var _a;\n        if (this.videoElement === null) {\n            throw new Error(\"Disposed player\");\n        }\n        if (this._priv_contentInfos === null) {\n            throw new Error(\"player: no content loaded\");\n        }\n        const { isDirectFile, manifest } = this._priv_contentInfos;\n        if (!isDirectFile && manifest === null) {\n            throw new Error(\"player: the content did not load yet\");\n        }\n        let positionWanted;\n        if (typeof time === \"number\") {\n            positionWanted = time;\n        }\n        else if (typeof time === \"object\") {\n            const timeObj = time;\n            const currentTs = this.videoElement.currentTime;\n            if (!isNullOrUndefined(timeObj.relative)) {\n                positionWanted = currentTs + timeObj.relative;\n            }\n            else if (!isNullOrUndefined(timeObj.position)) {\n                positionWanted = timeObj.position;\n            }\n            else if (!isNullOrUndefined(timeObj.wallClockTime)) {\n                if (manifest !== null) {\n                    positionWanted = timeObj.wallClockTime - ((_a = manifest.availabilityStartTime) !== null && _a !== void 0 ? _a : 0);\n                }\n                else if (isDirectFile && this.videoElement !== null) {\n                    const startDate = getStartDate(this.videoElement);\n                    if (startDate !== undefined) {\n                        positionWanted = timeObj.wallClockTime - startDate;\n                    }\n                }\n                if (positionWanted === undefined) {\n                    positionWanted = timeObj.wallClockTime;\n                }\n            }\n            else {\n                throw new Error(\"invalid time object. You must set one of the \" +\n                    'following properties: \"relative\", \"position\" or ' +\n                    '\"wallClockTime\"');\n            }\n        }\n        if (positionWanted === undefined) {\n            throw new Error(\"invalid time given\");\n        }\n        log.info(\"API: API Seek to\", positionWanted);\n        this.videoElement.currentTime = positionWanted;\n        return positionWanted;\n    }\n    /**\n     * Returns the current player's audio volume on the media element.\n     * From 0 (no audio) to 1 (maximum volume).\n     * @returns {Number}\n     */\n    getVolume() {\n        if (this.videoElement === null) {\n            throw new Error(\"Disposed player\");\n        }\n        return this.videoElement.volume;\n    }\n    /**\n     * Set the player's audio volume. From 0 (no volume) to 1 (maximum volume).\n     * @param {Number} volume\n     */\n    setVolume(volume) {\n        if (this.videoElement === null) {\n            throw new Error(\"Disposed player\");\n        }\n        const videoElement = this.videoElement;\n        if (volume !== videoElement.volume) {\n            videoElement.volume = volume;\n        }\n    }\n    /**\n     * Returns `true` if audio is currently muted.\n     * @returns {Boolean}\n     */\n    isMute() {\n        var _a;\n        return ((_a = this.videoElement) === null || _a === void 0 ? void 0 : _a.muted) === true;\n    }\n    /**\n     * Mute audio.\n     */\n    mute() {\n        if (this.videoElement === null) {\n            throw new Error(\"Disposed player\");\n        }\n        if (!this.videoElement.muted) {\n            this.videoElement.muted = true;\n        }\n    }\n    /**\n     * Unmute audio.\n     */\n    unMute() {\n        if (this.videoElement === null) {\n            throw new Error(\"Disposed player\");\n        }\n        if (this.videoElement.muted) {\n            this.videoElement.muted = false;\n        }\n    }\n    /**\n     * Set the max buffer size for the buffer behind the current position.\n     * Every buffer data before will be removed.\n     * @param {Number} depthInSeconds\n     */\n    setMaxBufferBehind(depthInSeconds) {\n        this._priv_bufferOptions.maxBufferBehind.setValue(depthInSeconds);\n    }\n    /**\n     * Set the max buffer size for the buffer behind the current position.\n     * Every buffer data before will be removed.\n     * @param {Number} depthInSeconds\n     */\n    setMaxBufferAhead(depthInSeconds) {\n        this._priv_bufferOptions.maxBufferAhead.setValue(depthInSeconds);\n    }\n    /**\n     * Set the max buffer size for the buffer ahead of the current position.\n     * The player will stop downloading chunks when this size is reached.\n     * @param {Number} sizeInSeconds\n     */\n    setWantedBufferAhead(sizeInSeconds) {\n        this._priv_bufferOptions.wantedBufferAhead.setValue(sizeInSeconds);\n    }\n    /**\n     * Set the max buffer size the buffer should take in memory\n     * The player . will stop downloading chunks when this size is reached.\n     * @param {Number} sizeInKBytes\n     */\n    setMaxVideoBufferSize(sizeInKBytes) {\n        this._priv_bufferOptions.maxVideoBufferSize.setValue(sizeInKBytes);\n    }\n    /**\n     * Returns the max buffer size for the buffer behind the current position.\n     * @returns {Number}\n     */\n    getMaxBufferBehind() {\n        return this._priv_bufferOptions.maxBufferBehind.getValue();\n    }\n    /**\n     * Returns the max buffer size for the buffer behind the current position.\n     * @returns {Number}\n     */\n    getMaxBufferAhead() {\n        return this._priv_bufferOptions.maxBufferAhead.getValue();\n    }\n    /**\n     * Returns the max buffer size for the buffer ahead of the current position.\n     * @returns {Number}\n     */\n    getWantedBufferAhead() {\n        return this._priv_bufferOptions.wantedBufferAhead.getValue();\n    }\n    /**\n     * Returns the max buffer memory size for the buffer in kilobytes\n     * @returns {Number}\n     */\n    getMaxVideoBufferSize() {\n        return this._priv_bufferOptions.maxVideoBufferSize.getValue();\n    }\n    getCurrentPeriod() {\n        var _a;\n        const currentPeriod = (_a = this._priv_contentInfos) === null || _a === void 0 ? void 0 : _a.currentPeriod;\n        if (isNullOrUndefined(currentPeriod)) {\n            return null;\n        }\n        return {\n            id: currentPeriod.id,\n            start: currentPeriod.start,\n            end: currentPeriod.end,\n        };\n    }\n    /**\n     * Returns both the name of the key system (e.g. `\"com.widevine.alpha\"`) and\n     * the `MediaKeySystemConfiguration` currently associated to the\n     * HTMLMediaElement linked to the RxPlayer.\n     *\n     * Returns `null` if no such capabilities is associated or if unknown.\n     * @returns {Object|null}\n     */\n    getKeySystemConfiguration() {\n        if (this.videoElement === null) {\n            throw new Error(\"Disposed player\");\n        }\n        const values = getKeySystemConfiguration(this.videoElement);\n        if (values === null) {\n            return null;\n        }\n        return { keySystem: values[0], configuration: values[1] };\n    }\n    /**\n     * Returns the list of available Periods for which the current audio, video or\n     * text track can now be changed.\n     * @returns {Array.<Object>}\n     */\n    getAvailablePeriods() {\n        if (this._priv_contentInfos === null) {\n            return [];\n        }\n        const { isDirectFile, tracksStore } = this._priv_contentInfos;\n        if (isDirectFile) {\n            return [];\n        }\n        if (tracksStore === null) {\n            return [];\n        }\n        return tracksStore.getAvailablePeriods().slice();\n    }\n    /**\n     * Returns every available audio tracks for a given Period - or the current\n     * one if no `periodId` is given.\n     * @param {string|Object|undefined} [arg]\n     * @returns {Array.<Object>}\n     */\n    getAvailableAudioTracks(arg) {\n        var _a, _b;\n        if (this._priv_contentInfos === null) {\n            return [];\n        }\n        const { isDirectFile, mediaElementTracksStore } = this._priv_contentInfos;\n        if (isDirectFile) {\n            return (_a = mediaElementTracksStore === null || mediaElementTracksStore === void 0 ? void 0 : mediaElementTracksStore.getAvailableAudioTracks()) !== null && _a !== void 0 ? _a : [];\n        }\n        let periodId;\n        let filterPlayableRepresentations = true;\n        if (typeof arg === \"string\") {\n            periodId = arg;\n        }\n        else {\n            periodId = arg === null || arg === void 0 ? void 0 : arg.periodId;\n            filterPlayableRepresentations = (_b = arg === null || arg === void 0 ? void 0 : arg.filterPlayableRepresentations) !== null && _b !== void 0 ? _b : true;\n        }\n        return this._priv_callTracksStoreGetterSetter(periodId, [], (tcm, periodRef) => { var _a; return (_a = tcm.getAvailableAudioTracks(periodRef, filterPlayableRepresentations)) !== null && _a !== void 0 ? _a : []; });\n    }\n    /**\n     * Returns every available text tracks for a given Period - or the current\n     * one if no `periodId` is given.\n     * @param {string|undefined} [periodId]\n     * @returns {Array.<Object>}\n     */\n    getAvailableTextTracks(periodId) {\n        var _a;\n        if (this._priv_contentInfos === null) {\n            return [];\n        }\n        const { isDirectFile, mediaElementTracksStore } = this._priv_contentInfos;\n        if (isDirectFile) {\n            return (_a = mediaElementTracksStore === null || mediaElementTracksStore === void 0 ? void 0 : mediaElementTracksStore.getAvailableTextTracks()) !== null && _a !== void 0 ? _a : [];\n        }\n        return this._priv_callTracksStoreGetterSetter(periodId, [], (tcm, periodRef) => { var _a; return (_a = tcm.getAvailableTextTracks(periodRef)) !== null && _a !== void 0 ? _a : []; });\n    }\n    /**\n     * Returns every available video tracks for the current Period.\n     * @param {string|Object|undefined} [arg]\n     * @returns {Array.<Object>}\n     */\n    getAvailableVideoTracks(arg) {\n        var _a, _b;\n        if (this._priv_contentInfos === null) {\n            return [];\n        }\n        const { isDirectFile, mediaElementTracksStore } = this._priv_contentInfos;\n        if (isDirectFile) {\n            return (_a = mediaElementTracksStore === null || mediaElementTracksStore === void 0 ? void 0 : mediaElementTracksStore.getAvailableVideoTracks()) !== null && _a !== void 0 ? _a : [];\n        }\n        let periodId;\n        let filterPlayableRepresentations = true;\n        if (typeof arg === \"string\") {\n            periodId = arg;\n        }\n        else {\n            periodId = arg === null || arg === void 0 ? void 0 : arg.periodId;\n            filterPlayableRepresentations = (_b = arg === null || arg === void 0 ? void 0 : arg.filterPlayableRepresentations) !== null && _b !== void 0 ? _b : true;\n        }\n        return this._priv_callTracksStoreGetterSetter(periodId, [], (tcm, periodRef) => { var _a; return (_a = tcm.getAvailableVideoTracks(periodRef, filterPlayableRepresentations)) !== null && _a !== void 0 ? _a : []; });\n    }\n    /**\n     * Returns currently chosen audio language for the current Period.\n     * @param {string|Object|undefined} [arg]\n     * @returns {Object|null|undefined}\n     */\n    getAudioTrack(arg) {\n        var _a;\n        if (this._priv_contentInfos === null) {\n            return undefined;\n        }\n        const { isDirectFile, mediaElementTracksStore } = this._priv_contentInfos;\n        if (isDirectFile) {\n            if (mediaElementTracksStore === null) {\n                return undefined;\n            }\n            return mediaElementTracksStore.getChosenAudioTrack();\n        }\n        let periodId;\n        let filterPlayableRepresentations = true;\n        if (typeof arg === \"string\") {\n            periodId = arg;\n        }\n        else {\n            periodId = arg === null || arg === void 0 ? void 0 : arg.periodId;\n            filterPlayableRepresentations = (_a = arg === null || arg === void 0 ? void 0 : arg.filterPlayableRepresentations) !== null && _a !== void 0 ? _a : true;\n        }\n        return this._priv_callTracksStoreGetterSetter(periodId, undefined, (tcm, periodRef) => tcm.getChosenAudioTrack(periodRef, filterPlayableRepresentations));\n    }\n    /**\n     * Returns currently chosen subtitle for the current Period.\n     * @param {string|undefined} [periodId]\n     * @returns {Object|null|undefined}\n     */\n    getTextTrack(periodId) {\n        if (this._priv_contentInfos === null) {\n            return undefined;\n        }\n        const { isDirectFile, mediaElementTracksStore } = this._priv_contentInfos;\n        if (isDirectFile) {\n            if (mediaElementTracksStore === null) {\n                return undefined;\n            }\n            return mediaElementTracksStore.getChosenTextTrack();\n        }\n        return this._priv_callTracksStoreGetterSetter(periodId, undefined, (tcm, periodRef) => tcm.getChosenTextTrack(periodRef));\n    }\n    /**\n     * Returns currently chosen video track for the current Period.\n     * @param {string|Object|undefined} [arg]\n     * @returns {Object|null|undefined}\n     */\n    getVideoTrack(arg) {\n        var _a;\n        if (this._priv_contentInfos === null) {\n            return undefined;\n        }\n        const { isDirectFile, mediaElementTracksStore } = this._priv_contentInfos;\n        if (isDirectFile) {\n            if (mediaElementTracksStore === null) {\n                return undefined;\n            }\n            return mediaElementTracksStore.getChosenVideoTrack();\n        }\n        let periodId;\n        let filterPlayableRepresentations = true;\n        if (typeof arg === \"string\") {\n            periodId = arg;\n        }\n        else {\n            periodId = arg === null || arg === void 0 ? void 0 : arg.periodId;\n            filterPlayableRepresentations = (_a = arg === null || arg === void 0 ? void 0 : arg.filterPlayableRepresentations) !== null && _a !== void 0 ? _a : true;\n        }\n        return this._priv_callTracksStoreGetterSetter(periodId, undefined, (tcm, periodRef) => tcm.getChosenVideoTrack(periodRef, filterPlayableRepresentations));\n    }\n    /**\n     * Update the audio language for the current Period.\n     * @param {string | object} arg\n     * @throws Error - the current content has no TracksStore.\n     * @throws Error - the given id is linked to no audio track.\n     */\n    setAudioTrack(arg) {\n        var _a;\n        if (this._priv_contentInfos === null) {\n            throw new Error(\"No content loaded\");\n        }\n        const { isDirectFile, mediaElementTracksStore } = this._priv_contentInfos;\n        if (isDirectFile) {\n            try {\n                const audioId = typeof arg === \"string\" ? arg : arg.trackId;\n                mediaElementTracksStore === null || mediaElementTracksStore === void 0 ? void 0 : mediaElementTracksStore.setAudioTrackById(audioId);\n                return;\n            }\n            catch (_e) {\n                throw new Error(\"player: unknown audio track\");\n            }\n        }\n        let periodId;\n        let trackId;\n        let switchingMode;\n        let lockedRepresentations = null;\n        let relativeResumingPosition;\n        if (typeof arg === \"string\") {\n            trackId = arg;\n        }\n        else {\n            trackId = arg.trackId;\n            periodId = arg.periodId;\n            switchingMode = arg.switchingMode;\n            lockedRepresentations = (_a = arg.lockedRepresentations) !== null && _a !== void 0 ? _a : null;\n            relativeResumingPosition = arg.relativeResumingPosition;\n        }\n        return this._priv_callTracksStoreGetterSetter(periodId, undefined, (tcm, periodRef) => tcm.setAudioTrack({\n            periodRef,\n            trackId,\n            switchingMode,\n            lockedRepresentations,\n            relativeResumingPosition,\n        }));\n    }\n    /**\n     * Update the text language for the current Period.\n     * @param {string | Object} arg\n     * @throws Error - the current content has no TracksStore.\n     * @throws Error - the given id is linked to no text track.\n     */\n    setTextTrack(arg) {\n        if (this._priv_contentInfos === null) {\n            throw new Error(\"No content loaded\");\n        }\n        const { isDirectFile, mediaElementTracksStore } = this._priv_contentInfos;\n        if (isDirectFile) {\n            try {\n                const textId = typeof arg === \"string\" ? arg : arg.trackId;\n                mediaElementTracksStore === null || mediaElementTracksStore === void 0 ? void 0 : mediaElementTracksStore.setTextTrackById(textId);\n                return;\n            }\n            catch (_e) {\n                throw new Error(\"player: unknown text track\");\n            }\n        }\n        let periodId;\n        let trackId;\n        if (typeof arg === \"string\") {\n            trackId = arg;\n        }\n        else {\n            trackId = arg.trackId;\n            periodId = arg.periodId;\n        }\n        return this._priv_callTracksStoreGetterSetter(periodId, undefined, (tcm, periodRef) => tcm.setTextTrack(periodRef, trackId));\n    }\n    /**\n     * Disable subtitles for the current content.\n     * @param {string|undefined} [periodId]\n     */\n    disableTextTrack(periodId) {\n        if (this._priv_contentInfos === null) {\n            return;\n        }\n        const { isDirectFile, mediaElementTracksStore } = this._priv_contentInfos;\n        if (isDirectFile) {\n            mediaElementTracksStore === null || mediaElementTracksStore === void 0 ? void 0 : mediaElementTracksStore.disableTextTrack();\n            return;\n        }\n        return this._priv_callTracksStoreGetterSetter(periodId, undefined, (tcm, periodRef) => tcm.disableTrack(periodRef, \"text\"));\n    }\n    /**\n     * Update the video track for the current Period.\n     * @param {string | Object} arg\n     * @throws Error - the current content has no TracksStore.\n     * @throws Error - the given id is linked to no video track.\n     */\n    setVideoTrack(arg) {\n        var _a;\n        if (this._priv_contentInfos === null) {\n            throw new Error(\"No content loaded\");\n        }\n        const { isDirectFile, mediaElementTracksStore } = this._priv_contentInfos;\n        if (isDirectFile) {\n            try {\n                const videoId = typeof arg === \"string\" ? arg : arg.trackId;\n                mediaElementTracksStore === null || mediaElementTracksStore === void 0 ? void 0 : mediaElementTracksStore.setVideoTrackById(videoId);\n                return;\n            }\n            catch (_e) {\n                throw new Error(\"player: unknown video track\");\n            }\n        }\n        let periodId;\n        let trackId;\n        let switchingMode;\n        let lockedRepresentations = null;\n        let relativeResumingPosition;\n        if (typeof arg === \"string\") {\n            trackId = arg;\n        }\n        else {\n            trackId = arg.trackId;\n            periodId = arg.periodId;\n            switchingMode = arg.switchingMode;\n            lockedRepresentations = (_a = arg.lockedRepresentations) !== null && _a !== void 0 ? _a : null;\n            relativeResumingPosition = arg.relativeResumingPosition;\n        }\n        return this._priv_callTracksStoreGetterSetter(periodId, undefined, (tcm, periodRef) => tcm.setVideoTrack({\n            periodRef,\n            trackId,\n            switchingMode,\n            lockedRepresentations,\n            relativeResumingPosition,\n        }));\n    }\n    /**\n     * Disable video track for the current content.\n     * @param {string|undefined} [periodId]\n     */\n    disableVideoTrack(periodId) {\n        if (this._priv_contentInfos === null) {\n            return;\n        }\n        const { isDirectFile, mediaElementTracksStore } = this._priv_contentInfos;\n        if (isDirectFile && mediaElementTracksStore !== null) {\n            return mediaElementTracksStore.disableVideoTrack();\n        }\n        return this._priv_callTracksStoreGetterSetter(periodId, undefined, (tcm, periodRef) => tcm.disableTrack(periodRef, \"video\"));\n    }\n    lockVideoRepresentations(arg) {\n        if (this._priv_contentInfos === null) {\n            throw new Error(\"No content loaded\");\n        }\n        const { isDirectFile } = this._priv_contentInfos;\n        if (isDirectFile) {\n            throw new Error(\"Cannot lock video Representations in directfile mode.\");\n        }\n        let repsId;\n        let periodId;\n        let switchingMode;\n        if (Array.isArray(arg)) {\n            repsId = arg;\n            periodId = undefined;\n        }\n        else {\n            repsId = arg.representations;\n            periodId = arg.periodId;\n            switchingMode = arg.switchingMode;\n        }\n        return this._priv_callTracksStoreGetterSetter(periodId, undefined, (tcm, periodRef) => tcm.lockVideoRepresentations(periodRef, {\n            representations: repsId,\n            switchingMode,\n        }));\n    }\n    lockAudioRepresentations(arg) {\n        if (this._priv_contentInfos === null) {\n            throw new Error(\"No content loaded\");\n        }\n        const { isDirectFile } = this._priv_contentInfos;\n        if (isDirectFile) {\n            throw new Error(\"Cannot lock audio Representations in directfile mode.\");\n        }\n        let repsId;\n        let periodId;\n        let switchingMode;\n        if (Array.isArray(arg)) {\n            repsId = arg;\n            periodId = undefined;\n        }\n        else {\n            repsId = arg.representations;\n            periodId = arg.periodId;\n            switchingMode = arg.switchingMode;\n        }\n        return this._priv_callTracksStoreGetterSetter(periodId, undefined, (tcm, periodRef) => tcm.lockAudioRepresentations(periodRef, {\n            representations: repsId,\n            switchingMode,\n        }));\n    }\n    getLockedVideoRepresentations(periodId) {\n        if (this._priv_contentInfos === null) {\n            return null;\n        }\n        const { isDirectFile } = this._priv_contentInfos;\n        if (isDirectFile) {\n            return null;\n        }\n        return this._priv_callTracksStoreGetterSetter(periodId, null, (tcm, periodRef) => tcm.getLockedVideoRepresentations(periodRef));\n    }\n    getLockedAudioRepresentations(periodId) {\n        if (this._priv_contentInfos === null) {\n            return null;\n        }\n        const { isDirectFile } = this._priv_contentInfos;\n        if (isDirectFile) {\n            return null;\n        }\n        return this._priv_callTracksStoreGetterSetter(periodId, null, (tcm, periodRef) => tcm.getLockedAudioRepresentations(periodRef));\n    }\n    unlockVideoRepresentations(periodId) {\n        if (this._priv_contentInfos === null) {\n            return;\n        }\n        const { isDirectFile } = this._priv_contentInfos;\n        if (isDirectFile) {\n            return;\n        }\n        return this._priv_callTracksStoreGetterSetter(periodId, undefined, (tcm, periodRef) => tcm.unlockVideoRepresentations(periodRef));\n    }\n    unlockAudioRepresentations(periodId) {\n        if (this._priv_contentInfos === null) {\n            return;\n        }\n        const { isDirectFile } = this._priv_contentInfos;\n        if (isDirectFile) {\n            return;\n        }\n        return this._priv_callTracksStoreGetterSetter(periodId, undefined, (tcm, periodRef) => tcm.unlockAudioRepresentations(periodRef));\n    }\n    /**\n     * Get minimum seek-able position.\n     * @returns {number}\n     */\n    getMinimumPosition() {\n        if (this._priv_contentInfos === null) {\n            return null;\n        }\n        if (this._priv_contentInfos.isDirectFile) {\n            return 0;\n        }\n        const { manifest } = this._priv_contentInfos;\n        if (manifest !== null) {\n            return getMinimumSafePosition(manifest);\n        }\n        return null;\n    }\n    /**\n     * Returns the current position for live contents.\n     *\n     * Returns `null` if no content is loaded or if the current loaded content is\n     * not considered as a live content.\n     * Returns `undefined` if that live position is currently unknown.\n     * @returns {number}\n     */\n    getLivePosition() {\n        if (this._priv_contentInfos === null) {\n            return null;\n        }\n        const { isDirectFile, manifest } = this._priv_contentInfos;\n        if (isDirectFile) {\n            return undefined;\n        }\n        if ((manifest === null || manifest === void 0 ? void 0 : manifest.isLive) !== true) {\n            return null;\n        }\n        return getLivePosition(manifest);\n    }\n    /**\n     * Get maximum seek-able position.\n     * @returns {number}\n     */\n    getMaximumPosition() {\n        if (this._priv_contentInfos === null) {\n            return null;\n        }\n        const { isDirectFile, manifest } = this._priv_contentInfos;\n        if (isDirectFile) {\n            if (this.videoElement === null) {\n                throw new Error(\"Disposed player\");\n            }\n            return this.videoElement.duration;\n        }\n        if (manifest !== null) {\n            if (!manifest.isDynamic && this.videoElement !== null) {\n                return this.videoElement.duration;\n            }\n            return getMaximumSafePosition(manifest);\n        }\n        return null;\n    }\n    // ---- Undocumented Private methods. ----\n    //\n    // Those methods are just here either to allow some tools relying on the\n    // RxPlayer instance to work or to improve the RxPlayer's demo.\n    //\n    // They should not be used by any external code.\n    /**\n     * Used for the display of segmentSink metrics for the debug element\n     * @param fn\n     * @param cancellationSignal\n     * @returns\n     */\n    async __priv_getSegmentSinkMetrics() {\n        var _a, _b;\n        return (_b = (_a = this._priv_contentInfos) === null || _a === void 0 ? void 0 : _a.segmentSinkMetricsCallback) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    /**\n     * /!\\ For tools use only! Do not touch!\n     *\n     * Returns manifest/playlist object.\n     * null if the player is STOPPED.\n     * @returns {Manifest|null} - The current Manifest (`null` when not known).\n     */\n    // TODO remove the need for that public method\n    __priv_getManifest() {\n        if (this._priv_contentInfos === null) {\n            return null;\n        }\n        return this._priv_contentInfos.manifest;\n    }\n    // TODO remove the need for that public method\n    __priv_getCurrentAdaptation() {\n        if (this._priv_contentInfos === null) {\n            return null;\n        }\n        const { currentPeriod, activeAdaptations } = this._priv_contentInfos;\n        if (currentPeriod === null ||\n            activeAdaptations === null ||\n            isNullOrUndefined(activeAdaptations[currentPeriod.id])) {\n            return null;\n        }\n        return activeAdaptations[currentPeriod.id];\n    }\n    // TODO remove the need for that public method\n    __priv_getCurrentRepresentations() {\n        if (this._priv_contentInfos === null) {\n            return null;\n        }\n        const { currentPeriod, activeRepresentations } = this._priv_contentInfos;\n        if (currentPeriod === null ||\n            activeRepresentations === null ||\n            isNullOrUndefined(activeRepresentations[currentPeriod.id])) {\n            return null;\n        }\n        return activeRepresentations[currentPeriod.id];\n    }\n    // ---- Private methods ----\n    /**\n     * Reset all state properties relative to a playing content.\n     */\n    _priv_cleanUpCurrentContentState() {\n        var _a, _b, _c, _d;\n        log.debug(\"Locking `contentLock` to clean-up the current content.\");\n        // lock playback of new contents while cleaning up is pending\n        this._priv_contentLock.setValue(true);\n        (_b = (_a = this._priv_contentInfos) === null || _a === void 0 ? void 0 : _a.tracksStore) === null || _b === void 0 ? void 0 : _b.dispose();\n        (_d = (_c = this._priv_contentInfos) === null || _c === void 0 ? void 0 : _c.mediaElementTracksStore) === null || _d === void 0 ? void 0 : _d.dispose();\n        this._priv_contentInfos = null;\n        this._priv_contentEventsMemory = {};\n        // DRM-related clean-up\n        const freeUpContentLock = () => {\n            if (this.videoElement !== null) {\n                // If not disposed\n                log.debug(\"Unlocking `contentLock`. Next content can begin.\");\n                this._priv_contentLock.setValue(false);\n            }\n        };\n        if (!isNullOrUndefined(this.videoElement)) {\n            clearOnStop(this.videoElement).then(() => {\n                log.debug(\"API: DRM session cleaned-up with success!\");\n                freeUpContentLock();\n            }, (err) => {\n                log.error(\"API: An error arised when trying to clean-up the DRM session:\" +\n                    (err instanceof Error ? err.toString() : \"Unknown Error\"));\n                freeUpContentLock();\n            });\n        }\n        else {\n            freeUpContentLock();\n        }\n    }\n    /**\n     * Triggered when the Manifest has been loaded for the current content.\n     * Initialize various private properties and emit initial event.\n     * @param {Object} contentInfos\n     * @param {Object} manifest\n     */\n    _priv_onManifestReady(contentInfos, manifest) {\n        var _a;\n        if (contentInfos.contentId !== ((_a = this._priv_contentInfos) === null || _a === void 0 ? void 0 : _a.contentId)) {\n            return; // Event for another content\n        }\n        contentInfos.manifest = manifest;\n        if (manifest.manifestFormat === 0 /* ManifestMetadataFormat.Class */) {\n            this._priv_reloadingMetadata.manifest = manifest;\n        }\n        const tracksStore = new TracksStore({\n            preferTrickModeTracks: this._priv_preferTrickModeTracks,\n            defaultAudioTrackSwitchingMode: contentInfos.defaultAudioTrackSwitchingMode,\n        });\n        contentInfos.tracksStore = tracksStore;\n        tracksStore.addEventListener(\"newAvailablePeriods\", (p) => {\n            this.trigger(\"newAvailablePeriods\", p);\n        });\n        tracksStore.addEventListener(\"brokenRepresentationsLock\", (e) => {\n            this.trigger(\"brokenRepresentationsLock\", e);\n        });\n        tracksStore.addEventListener(\"trackUpdate\", (e) => {\n            var _a, _b;\n            this.trigger(\"trackUpdate\", e);\n            const currentPeriod = (_b = (_a = this._priv_contentInfos) === null || _a === void 0 ? void 0 : _a.currentPeriod) !== null && _b !== void 0 ? _b : undefined;\n            if (e.reason === \"no-playable-representation\" &&\n                e.period.id === (currentPeriod === null || currentPeriod === void 0 ? void 0 : currentPeriod.id)) {\n                this._priv_onAvailableTracksMayHaveChanged(e.trackType);\n            }\n        });\n        contentInfos.tracksStore.addEventListener(\"warning\", (err) => {\n            this.trigger(\"warning\", err);\n        });\n        contentInfos.tracksStore.addEventListener(\"error\", (err) => {\n            this._priv_onFatalError(err, contentInfos);\n        });\n        contentInfos.tracksStore.onManifestUpdate(manifest);\n    }\n    /**\n     * Triggered when the Manifest has been updated for the current content.\n     * Initialize various private properties and emit initial event.\n     * @param {Object} contentInfos\n     * @param {Object} updates\n     */\n    _priv_onManifestUpdate(contentInfos, updates) {\n        var _a, _b, _c;\n        if (this._priv_contentInfos === null || this._priv_contentInfos.manifest === null) {\n            return;\n        }\n        // Update the tracks chosen if it changed\n        if (!isNullOrUndefined(contentInfos === null || contentInfos === void 0 ? void 0 : contentInfos.tracksStore)) {\n            contentInfos.tracksStore.onManifestUpdate(this._priv_contentInfos.manifest);\n        }\n        const currentPeriod = (_b = (_a = this._priv_contentInfos) === null || _a === void 0 ? void 0 : _a.currentPeriod) !== null && _b !== void 0 ? _b : undefined;\n        const currTracksStore = (_c = this._priv_contentInfos) === null || _c === void 0 ? void 0 : _c.tracksStore;\n        if (currentPeriod === undefined || isNullOrUndefined(currTracksStore)) {\n            return;\n        }\n        for (const update of updates.updatedPeriods) {\n            if (update.period.id === currentPeriod.id) {\n                if (update.result.addedAdaptations.length > 0 ||\n                    update.result.removedAdaptations.length > 0) {\n                    // We might have new (or less) tracks, send events just to be sure\n                    const periodRef = currTracksStore.getPeriodObjectFromPeriod(currentPeriod);\n                    if (periodRef === undefined) {\n                        return;\n                    }\n                    this._priv_onAvailableTracksMayHaveChanged(\"audio\");\n                    this._priv_onAvailableTracksMayHaveChanged(\"text\");\n                    this._priv_onAvailableTracksMayHaveChanged(\"video\");\n                }\n            }\n        }\n    }\n    /**\n     * Triggered each times the support for a codec has changed in the manifest.\n     * When triggered, the track store may need to consider selecting a new track.\n     *\n     * @param {Object} contentInfos\n     */\n    _priv_onCodecSupportUpdate(contentInfos) {\n        const tStore = contentInfos === null || contentInfos === void 0 ? void 0 : contentInfos.tracksStore;\n        if (isNullOrUndefined(tStore)) {\n            return;\n        }\n        tStore.onManifestCodecSupportUpdate();\n    }\n    _priv_onDecipherabilityUpdate(contentInfos, elts) {\n        if (contentInfos === null || contentInfos.manifest === null) {\n            return;\n        }\n        if (!isNullOrUndefined(contentInfos === null || contentInfos === void 0 ? void 0 : contentInfos.tracksStore)) {\n            contentInfos.tracksStore.onDecipherabilityUpdates();\n        }\n        /**\n         * Array of tuples only including once the Period/Track combination, and\n         * only when it concerns the currently-selected track.\n         */\n        const periodsAndTrackTypes = elts.reduce((acc, elt) => {\n            var _a, _b, _c;\n            const isFound = arrayFind(acc, (x) => x[0].id === elt.period.id && x[1] === elt.adaptation.type) !== undefined;\n            if (!isFound) {\n                // Only consider the currently-selected tracks.\n                // NOTE: Maybe there's room for optimizations? Unclear.\n                const tStore = contentInfos.tracksStore;\n                if (tStore === null) {\n                    return acc;\n                }\n                let isCurrent = false;\n                const periodRef = tStore.getPeriodObjectFromPeriod(elt.period);\n                if (periodRef === undefined) {\n                    return acc;\n                }\n                switch (elt.adaptation.type) {\n                    case \"audio\":\n                        isCurrent =\n                            ((_a = tStore.getChosenAudioTrack(periodRef, false)) === null || _a === void 0 ? void 0 : _a.id) === elt.adaptation.id;\n                        break;\n                    case \"video\":\n                        isCurrent =\n                            ((_b = tStore.getChosenVideoTrack(periodRef, false)) === null || _b === void 0 ? void 0 : _b.id) === elt.adaptation.id;\n                        break;\n                    case \"text\":\n                        isCurrent = ((_c = tStore.getChosenTextTrack(periodRef)) === null || _c === void 0 ? void 0 : _c.id) === elt.adaptation.id;\n                        break;\n                }\n                if (isCurrent) {\n                    acc.push([elt.period, elt.adaptation.type]);\n                }\n            }\n            return acc;\n        }, []);\n        for (const [period, trackType] of periodsAndTrackTypes) {\n            this._priv_triggerEventIfNotStopped(\"representationListUpdate\", {\n                period: { start: period.start, end: period.end, id: period.id },\n                trackType,\n                reason: \"decipherability-update\",\n            }, contentInfos.currentContentCanceller.signal);\n        }\n    }\n    /**\n     * Triggered each times the current Period Changed.\n     * Store and emit initial state for the Period.\n     *\n     * @param {Object} contentInfos\n     * @param {Object} periodInfo\n     */\n    _priv_onActivePeriodChanged(contentInfos, { period }) {\n        var _a, _b, _c, _d, _f, _g;\n        if (contentInfos.contentId !== ((_a = this._priv_contentInfos) === null || _a === void 0 ? void 0 : _a.contentId)) {\n            return; // Event for another content\n        }\n        contentInfos.currentPeriod = period;\n        const cancelSignal = contentInfos.currentContentCanceller.signal;\n        if (this._priv_contentEventsMemory.periodChange !== period) {\n            this._priv_contentEventsMemory.periodChange = period;\n            this._priv_triggerEventIfNotStopped(\"periodChange\", { start: period.start, end: period.end, id: period.id }, cancelSignal);\n        }\n        this._priv_triggerEventIfNotStopped(\"availableAudioTracksChange\", this.getAvailableAudioTracks(), cancelSignal);\n        this._priv_triggerEventIfNotStopped(\"availableTextTracksChange\", this.getAvailableTextTracks(), cancelSignal);\n        this._priv_triggerEventIfNotStopped(\"availableVideoTracksChange\", this.getAvailableVideoTracks(), cancelSignal);\n        const tracksStore = (_b = this._priv_contentInfos) === null || _b === void 0 ? void 0 : _b.tracksStore;\n        // Emit initial events for the Period\n        if (!isNullOrUndefined(tracksStore)) {\n            const periodRef = tracksStore.getPeriodObjectFromPeriod(period);\n            if (periodRef !== undefined) {\n                const audioTrack = tracksStore.getChosenAudioTrack(periodRef, true);\n                this._priv_triggerEventIfNotStopped(\"audioTrackChange\", audioTrack, cancelSignal);\n                const textTrack = tracksStore.getChosenTextTrack(periodRef);\n                this._priv_triggerEventIfNotStopped(\"textTrackChange\", textTrack, cancelSignal);\n                const videoTrack = tracksStore.getChosenVideoTrack(periodRef, true);\n                this._priv_triggerEventIfNotStopped(\"videoTrackChange\", videoTrack, cancelSignal);\n            }\n        }\n        else {\n            this._priv_triggerEventIfNotStopped(\"audioTrackChange\", null, cancelSignal);\n            this._priv_triggerEventIfNotStopped(\"textTrackChange\", null, cancelSignal);\n            this._priv_triggerEventIfNotStopped(\"videoTrackChange\", null, cancelSignal);\n        }\n        const audioRepresentation = (_d = (_c = this.__priv_getCurrentRepresentations()) === null || _c === void 0 ? void 0 : _c.audio) !== null && _d !== void 0 ? _d : null;\n        this._priv_triggerEventIfNotStopped(\"audioRepresentationChange\", audioRepresentation, cancelSignal);\n        const videoRepresentation = (_g = (_f = this.__priv_getCurrentRepresentations()) === null || _f === void 0 ? void 0 : _f.video) !== null && _g !== void 0 ? _g : null;\n        this._priv_triggerEventIfNotStopped(\"videoRepresentationChange\", videoRepresentation, cancelSignal);\n    }\n    /**\n     * Triggered each times a new \"PeriodStream\" is ready.\n     * Choose the right Adaptation for the Period and emit it.\n     * @param {Object} contentInfos\n     * @param {Object} value\n     */\n    _priv_onPeriodStreamReady(contentInfos, value) {\n        var _a;\n        if (contentInfos.contentId !== ((_a = this._priv_contentInfos) === null || _a === void 0 ? void 0 : _a.contentId)) {\n            return; // Event for another content\n        }\n        const { type, period, adaptationRef } = value;\n        const tracksStore = contentInfos.tracksStore;\n        switch (type) {\n            case \"video\":\n            case \"audio\":\n            case \"text\":\n                if (isNullOrUndefined(tracksStore)) {\n                    log.error(`API: TracksStore not instanciated for a new ${type} period`);\n                    adaptationRef.setValue(null);\n                }\n                else {\n                    tracksStore.addTrackReference(type, period, adaptationRef);\n                }\n                break;\n            default:\n                assertUnreachable(type);\n        }\n    }\n    /**\n     * Triggered each times we \"remove\" a PeriodStream.\n     * @param {Object} contentInfos\n     * @param {Object} value\n     */\n    _priv_onPeriodStreamCleared(contentInfos, value) {\n        var _a;\n        if (contentInfos.contentId !== ((_a = this._priv_contentInfos) === null || _a === void 0 ? void 0 : _a.contentId)) {\n            return; // Event for another content\n        }\n        const { type, periodId } = value;\n        const tracksStore = contentInfos.tracksStore;\n        // Clean-up track choices from TracksStore\n        switch (type) {\n            case \"audio\":\n            case \"text\":\n            case \"video\":\n                if (!isNullOrUndefined(tracksStore)) {\n                    tracksStore.removeTrackReference(type, periodId);\n                }\n                break;\n        }\n        // Clean-up stored Representation and Adaptation information\n        const { activeAdaptations, activeRepresentations } = contentInfos;\n        if (!isNullOrUndefined(activeAdaptations) &&\n            !isNullOrUndefined(activeAdaptations[periodId])) {\n            const activePeriodAdaptations = activeAdaptations[periodId];\n            delete activePeriodAdaptations[type];\n            if (Object.keys(activePeriodAdaptations).length === 0) {\n                delete activeAdaptations[periodId];\n            }\n        }\n        if (!isNullOrUndefined(activeRepresentations) &&\n            !isNullOrUndefined(activeRepresentations[periodId])) {\n            const activePeriodRepresentations = activeRepresentations[periodId];\n            delete activePeriodRepresentations[type];\n            if (Object.keys(activePeriodRepresentations).length === 0) {\n                delete activeRepresentations[periodId];\n            }\n        }\n    }\n    /**\n     * Triggered each times a new Adaptation is considered for the current\n     * content.\n     * Store given Adaptation and emit it if from the current Period.\n     * @param {Object} contentInfos\n     * @param {Object} value\n     */\n    _priv_onAdaptationChange(contentInfos, { type, adaptation, period, }) {\n        var _a;\n        if (contentInfos.contentId !== ((_a = this._priv_contentInfos) === null || _a === void 0 ? void 0 : _a.contentId)) {\n            return; // Event for another content\n        }\n        // lazily create contentInfos.activeAdaptations\n        if (contentInfos.activeAdaptations === null) {\n            contentInfos.activeAdaptations = {};\n        }\n        const { activeAdaptations, currentPeriod } = contentInfos;\n        const activePeriodAdaptations = activeAdaptations[period.id];\n        if (isNullOrUndefined(activePeriodAdaptations)) {\n            activeAdaptations[period.id] = { [type]: adaptation };\n        }\n        else {\n            activePeriodAdaptations[type] = adaptation;\n        }\n        const { tracksStore } = contentInfos;\n        const cancelSignal = contentInfos.currentContentCanceller.signal;\n        if (tracksStore !== null &&\n            currentPeriod !== null &&\n            !isNullOrUndefined(period) &&\n            period.id === currentPeriod.id) {\n            const periodRef = tracksStore.getPeriodObjectFromPeriod(period);\n            if (periodRef === undefined) {\n                return;\n            }\n            switch (type) {\n                case \"audio\": {\n                    const audioTrack = tracksStore.getChosenAudioTrack(periodRef, true);\n                    this._priv_triggerEventIfNotStopped(\"audioTrackChange\", audioTrack, cancelSignal);\n                    break;\n                }\n                case \"text\": {\n                    const textTrack = tracksStore.getChosenTextTrack(periodRef);\n                    this._priv_triggerEventIfNotStopped(\"textTrackChange\", textTrack, cancelSignal);\n                    break;\n                }\n                case \"video\": {\n                    const videoTrack = tracksStore.getChosenVideoTrack(periodRef, true);\n                    this._priv_triggerEventIfNotStopped(\"videoTrackChange\", videoTrack, cancelSignal);\n                    break;\n                }\n            }\n        }\n    }\n    /**\n     * Triggered each times a new Representation is considered during playback.\n     *\n     * Store given Representation and emit it if from the current Period.\n     *\n     * @param {Object} contentInfos\n     * @param {Object} obj\n     */\n    _priv_onRepresentationChange(contentInfos, { type, period, representation, }) {\n        var _a;\n        if (contentInfos.contentId !== ((_a = this._priv_contentInfos) === null || _a === void 0 ? void 0 : _a.contentId)) {\n            return; // Event for another content\n        }\n        // lazily create contentInfos.activeRepresentations\n        if (contentInfos.activeRepresentations === null) {\n            contentInfos.activeRepresentations = {};\n        }\n        const { activeRepresentations, currentPeriod } = contentInfos;\n        const activePeriodRepresentations = activeRepresentations[period.id];\n        if (isNullOrUndefined(activePeriodRepresentations)) {\n            activeRepresentations[period.id] = { [type]: representation };\n        }\n        else {\n            activePeriodRepresentations[type] = representation;\n        }\n        if (!isNullOrUndefined(period) &&\n            currentPeriod !== null &&\n            currentPeriod.id === period.id) {\n            const cancelSignal = this._priv_contentInfos.currentContentCanceller.signal;\n            if (type === \"video\") {\n                this._priv_triggerEventIfNotStopped(\"videoRepresentationChange\", representation, cancelSignal);\n            }\n            else if (type === \"audio\") {\n                this._priv_triggerEventIfNotStopped(\"audioRepresentationChange\", representation, cancelSignal);\n            }\n        }\n    }\n    /**\n     * Triggered each time a bitrate estimate is calculated.\n     *\n     * Emit it.\n     *\n     * @param {Object} value\n     */\n    _priv_onBitrateEstimateChange({ type, bitrate, }) {\n        if (bitrate !== undefined) {\n            this._priv_bitrateInfos.lastBitrates[type] = bitrate;\n        }\n        this.trigger(\n        // !!! undocumented API :O !!!\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        \"__priv_bitrateEstimateChange\", \n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        { type, bitrate });\n    }\n    /**\n     * Triggered each time the player state updates.\n     *\n     * Trigger the right Player Event.\n     *\n     * @param {string} newState\n     */\n    _priv_setPlayerState(newState) {\n        if (this.state !== newState) {\n            this.state = newState;\n            log.info(\"API: playerStateChange event\", newState);\n            this.trigger(\"playerStateChange\", newState);\n        }\n    }\n    /**\n     * Triggered each time a playback observation.\n     *\n     * Trigger the right Player Event\n     *\n     * @param {Object} contentInfos\n     * @param {Object} observation\n     */\n    _priv_triggerPositionUpdate(contentInfos, observation) {\n        var _a, _b;\n        if (contentInfos.contentId !== ((_a = this._priv_contentInfos) === null || _a === void 0 ? void 0 : _a.contentId)) {\n            return; // Event for another content\n        }\n        const { isDirectFile, manifest } = contentInfos;\n        if ((!isDirectFile && manifest === null) || isNullOrUndefined(observation)) {\n            return;\n        }\n        const maximumPosition = manifest !== null ? getMaximumSafePosition(manifest) : undefined;\n        const positionData = {\n            position: observation.position.getPolled(),\n            duration: observation.duration,\n            playbackRate: observation.playbackRate,\n            maximumPosition,\n            // TODO bufferGap may be undefined\n            bufferGap: observation.bufferGap === undefined || !isFinite(observation.bufferGap)\n                ? 0\n                : observation.bufferGap,\n        };\n        if (manifest !== null && manifest.isLive && observation.position.getPolled() > 0) {\n            const ast = (_b = manifest.availabilityStartTime) !== null && _b !== void 0 ? _b : 0;\n            positionData.wallClockTime = observation.position.getPolled() + ast;\n            const livePosition = getLivePosition(manifest);\n            if (livePosition !== undefined) {\n                positionData.liveGap = livePosition - observation.position.getPolled();\n            }\n        }\n        else if (isDirectFile && this.videoElement !== null) {\n            const startDate = getStartDate(this.videoElement);\n            if (startDate !== undefined) {\n                positionData.wallClockTime = startDate + observation.position.getPolled();\n            }\n        }\n        this.trigger(\"positionUpdate\", positionData);\n    }\n    /**\n     * @param {string} evt\n     * @param {*} arg\n     * @param {Object} currentContentCancelSignal\n     */\n    _priv_triggerEventIfNotStopped(evt, arg, currentContentCancelSignal) {\n        if (!currentContentCancelSignal.isCancelled()) {\n            this.trigger(evt, arg);\n        }\n    }\n    /**\n     * @param {Object} cancelSignal\n     * @returns {Object}\n     */\n    _priv_initializeMediaElementTracksStore(cancelSignal) {\n        var _a, _b, _c;\n        assert(features.directfile !== null, \"Initializing `MediaElementTracksStore` without Directfile feature\");\n        assert(this.videoElement !== null, \"Initializing `MediaElementTracksStore` on a disposed RxPlayer\");\n        const mediaElementTracksStore = new features.directfile.mediaElementTracksStore(this.videoElement);\n        this._priv_triggerEventIfNotStopped(\"availableAudioTracksChange\", mediaElementTracksStore.getAvailableAudioTracks(), cancelSignal);\n        this._priv_triggerEventIfNotStopped(\"availableVideoTracksChange\", mediaElementTracksStore.getAvailableVideoTracks(), cancelSignal);\n        this._priv_triggerEventIfNotStopped(\"availableTextTracksChange\", mediaElementTracksStore.getAvailableTextTracks(), cancelSignal);\n        this._priv_triggerEventIfNotStopped(\"audioTrackChange\", (_a = mediaElementTracksStore.getChosenAudioTrack()) !== null && _a !== void 0 ? _a : null, cancelSignal);\n        this._priv_triggerEventIfNotStopped(\"textTrackChange\", (_b = mediaElementTracksStore.getChosenTextTrack()) !== null && _b !== void 0 ? _b : null, cancelSignal);\n        this._priv_triggerEventIfNotStopped(\"videoTrackChange\", (_c = mediaElementTracksStore.getChosenVideoTrack()) !== null && _c !== void 0 ? _c : null, cancelSignal);\n        mediaElementTracksStore.addEventListener(\"availableVideoTracksChange\", (val) => this.trigger(\"availableVideoTracksChange\", val));\n        mediaElementTracksStore.addEventListener(\"availableAudioTracksChange\", (val) => this.trigger(\"availableAudioTracksChange\", val));\n        mediaElementTracksStore.addEventListener(\"availableTextTracksChange\", (val) => this.trigger(\"availableTextTracksChange\", val));\n        mediaElementTracksStore.addEventListener(\"audioTrackChange\", (val) => this.trigger(\"audioTrackChange\", val));\n        mediaElementTracksStore.addEventListener(\"videoTrackChange\", (val) => this.trigger(\"videoTrackChange\", val));\n        mediaElementTracksStore.addEventListener(\"textTrackChange\", (val) => this.trigger(\"textTrackChange\", val));\n        return mediaElementTracksStore;\n    }\n    _priv_callTracksStoreGetterSetter(periodId, defaultValue, cb) {\n        var _a, _b;\n        if (this._priv_contentInfos === null ||\n            this._priv_contentInfos.tracksStore === null) {\n            log.warn(\"API: Trying to call track API too soon\");\n            return defaultValue;\n        }\n        const { tracksStore } = this._priv_contentInfos;\n        const currentPeriod = (_b = (_a = this._priv_contentInfos) === null || _a === void 0 ? void 0 : _a.currentPeriod) !== null && _b !== void 0 ? _b : undefined;\n        const wantedPeriodId = periodId !== null && periodId !== void 0 ? periodId : currentPeriod === null || currentPeriod === void 0 ? void 0 : currentPeriod.id;\n        if (wantedPeriodId === undefined) {\n            return defaultValue;\n        }\n        const periodRef = wantedPeriodId === (currentPeriod === null || currentPeriod === void 0 ? void 0 : currentPeriod.id)\n            ? tracksStore.getPeriodObjectFromPeriod(currentPeriod)\n            : tracksStore.getPeriodObjectFromId(wantedPeriodId);\n        if (periodRef === undefined) {\n            return defaultValue;\n        }\n        return cb(tracksStore, periodRef);\n    }\n    /**\n     * Method to call when some event lead to a high for possibility that the\n     * available tracks for the given type have changed.\n     * Send the corresponding `available*Tracks` change event with the last\n     * available tracks.\n     *\n     * @param {string} trackType\n     * @param {Object|undefined} [oPeriodRef] - optional period object used by the\n     * `tracksStore` API, allows to optimize the method by bypassing this step.\n     */\n    _priv_onAvailableTracksMayHaveChanged(trackType, oPeriodRef) {\n        const contentInfos = this._priv_contentInfos;\n        if (contentInfos === null) {\n            return;\n        }\n        const { currentPeriod, tracksStore, currentContentCanceller } = contentInfos;\n        const cancelSignal = currentContentCanceller.signal;\n        if (isNullOrUndefined(currentPeriod) || tracksStore === null) {\n            return;\n        }\n        const periodRef = oPeriodRef !== null && oPeriodRef !== void 0 ? oPeriodRef : tracksStore.getPeriodObjectFromPeriod(currentPeriod);\n        if (periodRef === undefined) {\n            return;\n        }\n        switch (trackType) {\n            case \"video\": {\n                const videoTracks = tracksStore.getAvailableVideoTracks(periodRef, true);\n                this._priv_triggerEventIfNotStopped(\"availableVideoTracksChange\", videoTracks !== null && videoTracks !== void 0 ? videoTracks : [], cancelSignal);\n                break;\n            }\n            case \"audio\": {\n                const audioTracks = tracksStore.getAvailableAudioTracks(periodRef, true);\n                this._priv_triggerEventIfNotStopped(\"availableAudioTracksChange\", audioTracks !== null && audioTracks !== void 0 ? audioTracks : [], cancelSignal);\n                break;\n            }\n            case \"text\": {\n                const textTracks = tracksStore.getAvailableTextTracks(periodRef);\n                this._priv_triggerEventIfNotStopped(\"availableTextTracksChange\", textTracks !== null && textTracks !== void 0 ? textTracks : [], cancelSignal);\n                break;\n            }\n            default:\n                assertUnreachable(trackType);\n        }\n    }\n    /**\n     * Method to call when a fatal error lead to the stopping of the current\n     * content.\n     *\n     * @param {*} err - The error encountered.\n     * @param {Object} contentInfos - The `IPublicApiContentInfos` object linked\n     * to the content for which the error was received.\n     */\n    _priv_onFatalError(err, contentInfos) {\n        const formattedError = formatError(err, {\n            defaultCode: \"NONE\",\n            defaultReason: \"An unknown error stopped content playback.\",\n        });\n        formattedError.fatal = true;\n        contentInfos.currentContentCanceller.cancel();\n        this._priv_cleanUpCurrentContentState();\n        this._priv_currentError = formattedError;\n        log.error(\"API: The player stopped because of an error\", formattedError);\n        this._priv_setPlayerState(\"STOPPED\" /* PLAYER_STATES.STOPPED */);\n        // TODO This condition is here because the eventual callback called when the\n        // player state is updated can launch a new content, thus the error will not\n        // be here anymore, in which case triggering the \"error\" event is unwanted.\n        // This is very ugly though, and we should probable have a better solution\n        if (this._priv_currentError === formattedError) {\n            this.trigger(\"error\", formattedError);\n        }\n    }\n}\n/**\n * Store all video elements currently in use by an RxPlayer instance.\n * This is used to check that a video element is not shared between multiple instances.\n * Use of a WeakSet ensure the object is garbage collected if it's not used anymore.\n */\nPlayer._priv_currentlyUsedVideoElements = new WeakSet();\nPlayer.version = /* PLAYER_VERSION */ \"4.3.0\";\nexport default Player;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport config from \"../../config\";\nimport arrayIncludes from \"../../utils/array_includes\";\nimport isNullOrUndefined from \"../../utils/is_null_or_undefined\";\nimport SharedReference from \"../../utils/reference\";\n/**\n * @param {Object} playbackObserver - Observes playback conditions on\n * `mediaElement`.\n * @param {function} onSeeking - Callback called when a seeking operation starts\n * on `mediaElement`.\n * @param {function} onSeeked - Callback called when a seeking operation ends\n * on `mediaElement`.\n * @param {Object} cancelSignal - When triggered, stop calling callbacks and\n * remove all listeners this function has registered.\n */\nexport function emitSeekEvents(playbackObserver, onSeeking, onSeeked, cancelSignal) {\n    if (cancelSignal.isCancelled()) {\n        return;\n    }\n    let wasSeeking = playbackObserver.getReference().getValue().seeking === 2 /* SeekingState.External */;\n    if (wasSeeking) {\n        onSeeking();\n        if (cancelSignal.isCancelled()) {\n            return;\n        }\n    }\n    playbackObserver.listen((obs) => {\n        if (obs.event === \"seeking\") {\n            wasSeeking = true;\n            onSeeking();\n        }\n        else if (wasSeeking && obs.event === \"seeked\") {\n            wasSeeking = false;\n            onSeeked();\n        }\n    }, { includeLastObservation: true, clearSignal: cancelSignal });\n}\n/**\n * @param {HTMLMediaElement} mediaElement\n * @param {function} onPlay - Callback called when a play operation has started\n * on `mediaElement`.\n * @param {function} onPause - Callback called when a pause operation has\n * started on `mediaElement`.\n * @param {Object} cancelSignal - When triggered, stop calling callbacks and\n * remove all listeners this function has registered.\n */\nexport function emitPlayPauseEvents(mediaElement, onPlay, onPause, cancelSignal) {\n    if (cancelSignal.isCancelled() || mediaElement === null) {\n        return;\n    }\n    mediaElement.addEventListener(\"play\", onPlay);\n    mediaElement.addEventListener(\"pause\", onPause);\n    cancelSignal.register(() => {\n        mediaElement.removeEventListener(\"play\", onPlay);\n        mediaElement.removeEventListener(\"pause\", onPause);\n    });\n}\nexport function constructPlayerStateReference(initializer, mediaElement, playbackObserver, cancelSignal) {\n    const playerStateRef = new SharedReference(\"LOADING\" /* PLAYER_STATES.LOADING */, cancelSignal);\n    initializer.addEventListener(\"loaded\", () => {\n        if (playerStateRef.getValue() === \"LOADING\" /* PLAYER_STATES.LOADING */) {\n            playerStateRef.setValue(\"LOADED\" /* PLAYER_STATES.LOADED */);\n            if (!cancelSignal.isCancelled()) {\n                const newState = getLoadedContentState(mediaElement, null);\n                if (newState !== \"PAUSED\" /* PLAYER_STATES.PAUSED */) {\n                    playerStateRef.setValue(newState);\n                }\n            }\n        }\n        else if (playerStateRef.getValue() === \"RELOADING\" /* PLAYER_STATES.RELOADING */) {\n            playerStateRef.setValue(getLoadedContentState(mediaElement, null));\n        }\n        else {\n            updateStateIfLoaded(null);\n        }\n    }, cancelSignal);\n    initializer.addEventListener(\"reloadingMediaSource\", () => {\n        if (isLoadedState(playerStateRef.getValue())) {\n            playerStateRef.setValueIfChanged(\"RELOADING\" /* PLAYER_STATES.RELOADING */);\n        }\n    }, cancelSignal);\n    /**\n     * Keep track of the last known stalling situation.\n     * `null` if playback is not stalled.\n     */\n    let prevStallReason = null;\n    initializer.addEventListener(\"stalled\", (s) => {\n        if (s !== prevStallReason) {\n            updateStateIfLoaded(s);\n            prevStallReason = s;\n        }\n    }, cancelSignal);\n    initializer.addEventListener(\"unstalled\", () => {\n        if (prevStallReason !== null) {\n            updateStateIfLoaded(null);\n            prevStallReason = null;\n        }\n    }, cancelSignal);\n    playbackObserver.listen((observation) => {\n        if (arrayIncludes([\"seeking\", \"ended\", \"play\", \"pause\"], observation.event)) {\n            updateStateIfLoaded(prevStallReason);\n        }\n    }, { clearSignal: cancelSignal });\n    return playerStateRef;\n    function updateStateIfLoaded(stallRes) {\n        if (!isLoadedState(playerStateRef.getValue())) {\n            return;\n        }\n        const newState = getLoadedContentState(mediaElement, stallRes);\n        const prevState = playerStateRef.getValue();\n        // Some safety checks to avoid having nonsense state switches\n        if (prevState === \"LOADED\" /* PLAYER_STATES.LOADED */ && newState === \"PAUSED\" /* PLAYER_STATES.PAUSED */) {\n            return;\n        }\n        playerStateRef.setValueIfChanged(newState);\n    }\n}\n/**\n * Get state string for a _loaded_ content.\n * @param {HTMLMediaElement} mediaElement\n * @param {Object} stalledStatus - Current stalled state:\n *   - null when not stalled\n *   - a description of the situation if stalled.\n * @returns {string}\n */\nexport function getLoadedContentState(mediaElement, stalledStatus) {\n    const { FORCED_ENDED_THRESHOLD } = config.getCurrent();\n    if (mediaElement.ended) {\n        return \"ENDED\" /* PLAYER_STATES.ENDED */;\n    }\n    if (stalledStatus !== null) {\n        // On some old browsers (e.g. Chrome 54), the browser does not\n        // emit an 'ended' event in some conditions. Detect if we\n        // reached the end by comparing the current position and the\n        // duration instead.\n        const gapBetweenDurationAndCurrentTime = Math.abs(mediaElement.duration - mediaElement.currentTime);\n        if (!isNullOrUndefined(FORCED_ENDED_THRESHOLD) &&\n            gapBetweenDurationAndCurrentTime < FORCED_ENDED_THRESHOLD) {\n            return \"ENDED\" /* PLAYER_STATES.ENDED */;\n        }\n        if (stalledStatus === \"seeking\") {\n            return \"SEEKING\" /* PLAYER_STATES.SEEKING */;\n        }\n        if (stalledStatus === \"freezing\") {\n            return \"FREEZING\" /* PLAYER_STATES.FREEZING */;\n        }\n        return \"BUFFERING\" /* PLAYER_STATES.BUFFERING */;\n    }\n    return mediaElement.paused ? \"PAUSED\" /* PLAYER_STATES.PAUSED */ : \"PLAYING\" /* PLAYER_STATES.PLAYING */;\n}\nexport function isLoadedState(state) {\n    return (state !== \"LOADING\" /* PLAYER_STATES.LOADING */ &&\n        state !== \"RELOADING\" /* PLAYER_STATES.RELOADING */ &&\n        state !== \"STOPPED\" /* PLAYER_STATES.STOPPED */);\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport shouldUnsetMediaKeys from \"../../compat/should_unset_media_keys\";\nimport log from \"../../log\";\nimport disposeDecryptionResources from \"./dispose_decryption_resources\";\nimport MediaKeysAttacher from \"./utils/media_keys_attacher\";\n/**\n * Clear DRM-related resources that should be cleared when the current content\n * stops its playback.\n * @param {HTMLMediaElement} mediaElement\n * @returns {Promise}\n */\nexport default async function clearOnStop(mediaElement) {\n    log.info(\"DRM: Clearing-up DRM session.\");\n    if (shouldUnsetMediaKeys()) {\n        log.info(\"DRM: disposing current MediaKeys.\");\n        return disposeDecryptionResources(mediaElement);\n    }\n    const currentState = await MediaKeysAttacher.getAttachedMediaKeysState(mediaElement);\n    if (currentState !== null &&\n        currentState.keySystemOptions.closeSessionsOnStop === true) {\n        log.info(\"DRM: closing all current sessions.\");\n        return currentState.loadedSessionsStore.closeAllSessions();\n    }\n    log.info(\"DRM: Nothing to clear. Returning right away. No state =\", currentState === null);\n    return Promise.resolve();\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport eme, { getInitData } from \"../../compat/eme\";\nimport config from \"../../config\";\nimport { EncryptedMediaError, OtherError } from \"../../errors\";\nimport log from \"../../log\";\nimport areArraysOfNumbersEqual from \"../../utils/are_arrays_of_numbers_equal\";\nimport arrayFind from \"../../utils/array_find\";\nimport arrayIncludes from \"../../utils/array_includes\";\nimport EventEmitter from \"../../utils/event_emitter\";\nimport isNullOrUndefined from \"../../utils/is_null_or_undefined\";\nimport { objectValues } from \"../../utils/object_values\";\nimport { bytesToHex } from \"../../utils/string_parsing\";\nimport TaskCanceller from \"../../utils/task_canceller\";\nimport createOrLoadSession from \"./create_or_load_session\";\nimport initMediaKeys from \"./init_media_keys\";\nimport SessionEventsListener, { BlacklistedSessionError, } from \"./session_events_listener\";\nimport setServerCertificate from \"./set_server_certificate\";\nimport { ContentDecryptorState } from \"./types\";\nimport { DecommissionedSessionError } from \"./utils/check_key_statuses\";\nimport cleanOldStoredPersistentInfo from \"./utils/clean_old_stored_persistent_info\";\nimport getDrmSystemId from \"./utils/get_drm_system_id\";\nimport InitDataValuesContainer from \"./utils/init_data_values_container\";\nimport isCompatibleCodecSupported from \"./utils/is_compatible_codec_supported\";\nimport { areAllKeyIdsContainedIn, areSomeKeyIdsContainedIn, } from \"./utils/key_id_comparison\";\nimport MediaKeysAttacher from \"./utils/media_keys_attacher\";\n/**\n * Module communicating with the Content Decryption Module (or CDM) to be able\n * to decrypt contents.\n *\n * The `ContentDecryptor` starts communicating with the CDM, to initialize the\n * key system, as soon as it is created.\n *\n * You can be notified of various events, such as fatal errors, by registering\n * to one of its multiple events (@see IContentDecryptorEvent).\n *\n * @class ContentDecryptor\n */\nexport default class ContentDecryptor extends EventEmitter {\n    /**\n     * `true` if the EME API are available on the current platform according to\n     * the default EME implementation used.\n     * `false` otherwise.\n     * @returns {boolean}\n     */\n    static hasEmeApis() {\n        return !isNullOrUndefined(eme.requestMediaKeySystemAccess);\n    }\n    /**\n     * Create a new `ContentDecryptor`, and initialize its decryption capabilities\n     * right away.\n     * Goes into the `WaitingForAttachment` state once that initialization is\n     * done, after which you should call the `attach` method when you're ready for\n     * those decryption capabilities to be attached to the HTMLMediaElement.\n     *\n     * @param {HTMLMediaElement} mediaElement - The MediaElement which will be\n     * associated to a MediaKeys object\n     * @param {Array.<Object>} ksOptions - key system configuration.\n     * The `ContentDecryptor` can be given one or multiple key system\n     * configurations. It will choose the appropriate one depending on user\n     * settings and browser support.\n     */\n    constructor(mediaElement, ksOptions) {\n        super();\n        log.debug(\"DRM: Starting ContentDecryptor logic.\");\n        const canceller = new TaskCanceller();\n        this._currentSessions = [];\n        this._canceller = canceller;\n        this._initDataQueue = [];\n        this._stateData = {\n            state: ContentDecryptorState.Initializing,\n            isMediaKeysAttached: 0 /* MediaKeyAttachmentStatus.NotAttached */,\n            isInitDataQueueLocked: true,\n            data: null,\n        };\n        this._supportedCodecWhenEncrypted = [];\n        this.error = null;\n        eme.onEncrypted(mediaElement, (evt) => {\n            log.debug(\"DRM: Encrypted event received from media element.\");\n            const initData = getInitData(evt);\n            if (initData !== null) {\n                this.onInitializationData(initData);\n            }\n        }, canceller.signal);\n        initMediaKeys(mediaElement, ksOptions, canceller.signal)\n            .then((mediaKeysInfo) => {\n            const { options, mediaKeySystemAccess } = mediaKeysInfo;\n            this._supportedCodecWhenEncrypted = mediaKeysInfo.codecSupport;\n            /**\n             * String identifying the key system, allowing the rest of the code to\n             * only advertise the required initialization data for license requests.\n             *\n             * Note that we only set this value if retro-compatibility to older\n             * persistent logic in the RxPlayer is not important, as the\n             * optimizations this property unlocks can break the loading of\n             * MediaKeySessions persisted in older RxPlayer's versions.\n             */\n            let systemId;\n            if (isNullOrUndefined(options.persistentLicenseConfig) ||\n                options.persistentLicenseConfig.disableRetroCompatibility === true) {\n                systemId = getDrmSystemId(mediaKeySystemAccess.keySystem);\n            }\n            this.systemId = systemId;\n            if (this._stateData.state === ContentDecryptorState.Initializing) {\n                log.debug(\"DRM: Waiting for attachment.\");\n                this._stateData = {\n                    state: ContentDecryptorState.WaitingForAttachment,\n                    isInitDataQueueLocked: true,\n                    isMediaKeysAttached: 0 /* MediaKeyAttachmentStatus.NotAttached */,\n                    data: { mediaKeysInfo, mediaElement },\n                };\n                this.trigger(\"stateChange\", this._stateData.state);\n            }\n        })\n            .catch((err) => {\n            this._onFatalError(err);\n        });\n    }\n    /**\n     * Returns the current state of the ContentDecryptor.\n     * @see ContentDecryptorState\n     * @returns {Object}\n     */\n    getState() {\n        return this._stateData.state;\n    }\n    /**\n     * Attach the current decryption capabilities to the HTMLMediaElement.\n     * This method should only be called once the `ContentDecryptor` is in the\n     * `WaitingForAttachment` state.\n     *\n     * You might want to first set the HTMLMediaElement's `src` attribute before\n     * calling this method, and only push data to it once the `ReadyForContent`\n     * state is reached, for compatibility reasons.\n     */\n    attach() {\n        if (this._stateData.state !== ContentDecryptorState.WaitingForAttachment) {\n            throw new Error(\"`attach` should only be called when \" + \"in the WaitingForAttachment state\");\n        }\n        else if (this._stateData.isMediaKeysAttached !== 0 /* MediaKeyAttachmentStatus.NotAttached */) {\n            log.warn(\"DRM: ContentDecryptor's `attach` method called more than once.\");\n            return;\n        }\n        const { mediaElement, mediaKeysInfo } = this._stateData.data;\n        const { options, mediaKeys, mediaKeySystemAccess, stores, askedConfiguration } = mediaKeysInfo;\n        const shouldDisableLock = options.disableMediaKeysAttachmentLock === true;\n        if (shouldDisableLock) {\n            log.debug(\"DRM: disabling MediaKeys attachment lock. Ready for content\");\n            this._stateData = {\n                state: ContentDecryptorState.ReadyForContent,\n                isInitDataQueueLocked: true,\n                isMediaKeysAttached: 1 /* MediaKeyAttachmentStatus.Pending */,\n                data: { mediaKeysInfo, mediaElement },\n            };\n            this.trigger(\"stateChange\", this._stateData.state);\n            // previous trigger might have lead to disposal\n            if (this._isStopped()) {\n                return;\n            }\n        }\n        this._stateData.isMediaKeysAttached = 1 /* MediaKeyAttachmentStatus.Pending */;\n        const stateToAttach = {\n            emeImplementation: eme,\n            loadedSessionsStore: stores.loadedSessionsStore,\n            mediaKeySystemAccess,\n            mediaKeys,\n            askedConfiguration,\n            keySystemOptions: options,\n        };\n        log.debug(\"DRM: Attaching current MediaKeys\");\n        MediaKeysAttacher.attach(mediaElement, stateToAttach)\n            .then(async () => {\n            if (this._isStopped()) {\n                // We might be stopped since then\n                return;\n            }\n            this._stateData.isMediaKeysAttached = 2 /* MediaKeyAttachmentStatus.Attached */;\n            const { serverCertificate } = options;\n            if (!isNullOrUndefined(serverCertificate)) {\n                const resSsc = await setServerCertificate(mediaKeys, serverCertificate);\n                if (resSsc.type === \"error\") {\n                    this.trigger(\"warning\", resSsc.value);\n                }\n            }\n            if (this._isStopped()) {\n                // We might be stopped since then\n                return;\n            }\n            const prevState = this._stateData.state;\n            this._stateData = {\n                state: ContentDecryptorState.ReadyForContent,\n                isMediaKeysAttached: 2 /* MediaKeyAttachmentStatus.Attached */,\n                isInitDataQueueLocked: false,\n                data: { mediaKeysData: mediaKeysInfo },\n            };\n            if (prevState !== ContentDecryptorState.ReadyForContent) {\n                this.trigger(\"stateChange\", ContentDecryptorState.ReadyForContent);\n            }\n            if (!this._isStopped()) {\n                this._processCurrentInitDataQueue();\n            }\n        })\n            .catch((err) => {\n            this._onFatalError(err);\n        });\n    }\n    /**\n     * Stop this `ContentDecryptor` instance:\n     *   - stop listening and reacting to the various event listeners\n     *   - abort all operations.\n     *\n     * Once disposed, a `ContentDecryptor` cannot be used anymore.\n     */\n    dispose() {\n        this.removeEventListener();\n        this._stateData = {\n            state: ContentDecryptorState.Disposed,\n            isMediaKeysAttached: undefined,\n            isInitDataQueueLocked: undefined,\n            data: null,\n        };\n        this._canceller.cancel();\n        this.trigger(\"stateChange\", this._stateData.state);\n    }\n    /**\n     * Returns `true` if the given mimeType and codec couple should be supported\n     * by the current key system.\n     * Returns `false` if it isn't.\n     *\n     * Returns `undefined` if we cannot determine if it is supported.\n     *\n     * @param {string} mimeType\n     * @param {string} codec\n     * @returns {boolean}\n     */\n    isCodecSupported(mimeType, codec) {\n        if (this._stateData.state === ContentDecryptorState.Initializing) {\n            log.error(\"DRM: Asking for codec support while the ContentDecryptor is still initializing\");\n            return undefined;\n        }\n        if (this._stateData.state === ContentDecryptorState.Error ||\n            this._stateData.state === ContentDecryptorState.Disposed) {\n            log.error(\"DRM: Asking for codec support while the ContentDecryptor is disposed\");\n        }\n        return isCompatibleCodecSupported(mimeType, codec, this._supportedCodecWhenEncrypted);\n    }\n    /**\n     * Method to call when new protection initialization data is encounted on the\n     * content.\n     *\n     * When called, the `ContentDecryptor` will try to obtain the decryption key\n     * if not already obtained.\n     *\n     * @param {Object} initializationData\n     */\n    onInitializationData(initializationData) {\n        if (this._stateData.isInitDataQueueLocked !== false) {\n            if (this._isStopped()) {\n                throw new Error(\"ContentDecryptor either disposed or stopped.\");\n            }\n            this._initDataQueue.push(initializationData);\n            return;\n        }\n        const { mediaKeysData } = this._stateData.data;\n        const processedInitializationData = Object.assign(Object.assign({}, initializationData), { values: new InitDataValuesContainer(initializationData.values) });\n        this._processInitializationData(processedInitializationData, mediaKeysData).catch((err) => {\n            this._onFatalError(err);\n        });\n    }\n    /**\n     * Async logic run each time new initialization data has to be processed.\n     * The promise return may reject, in which case a fatal error should be linked\n     * the current `ContentDecryptor`.\n     *\n     * The Promise's resolution however provides no semantic value.\n     * @param {Object} initializationData\n     * @returns {Promise.<void>}\n     */\n    async _processInitializationData(initializationData, mediaKeysData) {\n        var _a, _b, _c;\n        if (log.hasLevel(\"DEBUG\")) {\n            log.debug(\"DRM: processing init data\", (_a = initializationData.content) === null || _a === void 0 ? void 0 : _a.adaptation.type, (_b = initializationData.content) === null || _b === void 0 ? void 0 : _b.representation.bitrate, ((_c = initializationData.keyIds) !== null && _c !== void 0 ? _c : []).map((k) => bytesToHex(k)).join(\", \"));\n        }\n        const { mediaKeySystemAccess, stores, options } = mediaKeysData;\n        if (this._tryToUseAlreadyCreatedSession(initializationData, mediaKeysData) ||\n            this._isStopped()) {\n            // _isStopped is voluntarly checked after here\n            return;\n        }\n        if (options.singleLicensePer === \"content\") {\n            const firstCreatedSession = arrayFind(this._currentSessions, (x) => x.source === \"created-session\" /* MediaKeySessionLoadingType.Created */);\n            if (firstCreatedSession !== undefined) {\n                // We already fetched a `singleLicensePer: \"content\"` license, yet we\n                // could not use the already-created MediaKeySession with it.\n                // It means that we'll never handle it and we should thus blacklist it.\n                const keyIds = initializationData.keyIds;\n                if (keyIds === undefined) {\n                    if (initializationData.content === undefined) {\n                        log.warn(\"DRM: Unable to fallback from a non-decipherable quality.\");\n                    }\n                    else {\n                        log.debug(\"DRM: Blacklisting new init data (due to singleLicensePer content policy)\");\n                        this.trigger(\"blackListProtectionData\", initializationData);\n                    }\n                    return;\n                }\n                firstCreatedSession.record.associateKeyIds(keyIds);\n                if (initializationData.content === undefined) {\n                    log.warn(\"DRM: Unable to fallback from a non-decipherable quality.\");\n                }\n                else {\n                    if (log.hasLevel(\"DEBUG\")) {\n                        const hexKids = keyIds.reduce((acc, kid) => `${acc}, ${bytesToHex(kid)}`, \"\");\n                        log.debug(\"DRM: Blacklisting new key ids\", hexKids);\n                    }\n                    this.trigger(\"keyIdsCompatibilityUpdate\", {\n                        whitelistedKeyIds: [],\n                        blacklistedKeyIds: keyIds,\n                        delistedKeyIds: [],\n                    });\n                }\n                return;\n            }\n        }\n        else if (options.singleLicensePer === \"periods\" &&\n            initializationData.content !== undefined) {\n            const { period } = initializationData.content;\n            const createdSessions = this._currentSessions.filter((x) => x.source === \"created-session\" /* MediaKeySessionLoadingType.Created */);\n            const periodKeys = new Set();\n            addKeyIdsFromPeriod(periodKeys, period);\n            for (const createdSess of createdSessions) {\n                const periodKeysArr = Array.from(periodKeys);\n                for (const kid of periodKeysArr) {\n                    if (createdSess.record.isAssociatedWithKeyId(kid)) {\n                        createdSess.record.associateKeyIds(periodKeys.values());\n                        // Re-loop through the Period's key ids to blacklist ones that are missing\n                        // from `createdSess`'s `keyStatuses` and to update the content's\n                        // decipherability.\n                        for (const innerKid of periodKeysArr) {\n                            if (!createdSess.keyStatuses.whitelisted.some((k) => areArraysOfNumbersEqual(k, innerKid)) &&\n                                !createdSess.keyStatuses.blacklisted.some((k) => areArraysOfNumbersEqual(k, innerKid))) {\n                                createdSess.keyStatuses.blacklisted.push(innerKid);\n                            }\n                        }\n                        if (log.hasLevel(\"DEBUG\")) {\n                            log.debug(\"DRM: Session already created for\", bytesToHex(kid), 'under singleLicensePer \"periods\" policy');\n                        }\n                        this.trigger(\"keyIdsCompatibilityUpdate\", {\n                            whitelistedKeyIds: createdSess.keyStatuses.whitelisted,\n                            blacklistedKeyIds: createdSess.keyStatuses.blacklisted,\n                            delistedKeyIds: [],\n                        });\n                        return;\n                    }\n                }\n            }\n        }\n        // /!\\ Do not forget to unlock when done\n        // TODO this is error-prone and can lead to performance issue when loading\n        // persistent sessions.\n        // Can we find a better strategy?\n        this._lockInitDataQueue();\n        let wantedSessionType;\n        if (canCreatePersistentSession(mediaKeySystemAccess) &&\n            (!isNullOrUndefined(options.persistentLicenseConfig) ||\n                !canCreateTemporarySession(mediaKeySystemAccess))) {\n            wantedSessionType = \"persistent-license\";\n        }\n        else {\n            wantedSessionType = \"temporary\";\n        }\n        const { EME_DEFAULT_MAX_SIMULTANEOUS_MEDIA_KEY_SESSIONS, EME_MAX_STORED_PERSISTENT_SESSION_INFORMATION, } = config.getCurrent();\n        const maxSessionCacheSize = typeof options.maxSessionCacheSize === \"number\"\n            ? options.maxSessionCacheSize\n            : EME_DEFAULT_MAX_SIMULTANEOUS_MEDIA_KEY_SESSIONS;\n        const sessionRes = await createOrLoadSession(initializationData, stores, wantedSessionType, maxSessionCacheSize, this._canceller.signal);\n        if (this._isStopped()) {\n            return;\n        }\n        const sessionInfo = {\n            record: sessionRes.value.keySessionRecord,\n            source: sessionRes.type,\n            keyStatuses: { whitelisted: [], blacklisted: [] },\n            blacklistedSessionError: null,\n        };\n        this._currentSessions.push(sessionInfo);\n        const { mediaKeySession, sessionType } = sessionRes.value;\n        /**\n         * We only store persistent sessions once its keys are known.\n         * This boolean allows to know if this session has already been\n         * persisted or not.\n         */\n        let isSessionPersisted = false;\n        SessionEventsListener(mediaKeySession, options, mediaKeySystemAccess.keySystem, {\n            onKeyUpdate: (value) => {\n                const linkedKeys = getKeyIdsLinkedToSession(initializationData, sessionInfo.record, options.singleLicensePer, sessionInfo.source === \"created-session\" /* MediaKeySessionLoadingType.Created */, value.whitelistedKeyIds, value.blacklistedKeyIds);\n                sessionInfo.record.associateKeyIds(linkedKeys.whitelisted);\n                sessionInfo.record.associateKeyIds(linkedKeys.blacklisted);\n                sessionInfo.keyStatuses = {\n                    whitelisted: linkedKeys.whitelisted,\n                    blacklisted: linkedKeys.blacklisted,\n                };\n                if (sessionInfo.record.getAssociatedKeyIds().length !== 0 &&\n                    sessionType === \"persistent-license\" &&\n                    stores.persistentSessionsStore !== null &&\n                    !isSessionPersisted) {\n                    const { persistentSessionsStore } = stores;\n                    cleanOldStoredPersistentInfo(persistentSessionsStore, EME_MAX_STORED_PERSISTENT_SESSION_INFORMATION - 1);\n                    persistentSessionsStore.add(initializationData, sessionInfo.record.getAssociatedKeyIds(), mediaKeySession);\n                    isSessionPersisted = true;\n                }\n                if (initializationData.content !== undefined) {\n                    this.trigger(\"keyIdsCompatibilityUpdate\", {\n                        whitelistedKeyIds: linkedKeys.whitelisted,\n                        blacklistedKeyIds: linkedKeys.blacklisted,\n                        delistedKeyIds: [],\n                    });\n                }\n                this._unlockInitDataQueue();\n            },\n            onWarning: (value) => {\n                this.trigger(\"warning\", value);\n            },\n            onError: (err) => {\n                var _a;\n                if (err instanceof DecommissionedSessionError) {\n                    log.warn(\"DRM: A session's closing condition has been triggered\");\n                    this._lockInitDataQueue();\n                    const indexOf = this._currentSessions.indexOf(sessionInfo);\n                    if (indexOf >= 0) {\n                        this._currentSessions.splice(indexOf);\n                    }\n                    if (initializationData.content !== undefined) {\n                        this.trigger(\"keyIdsCompatibilityUpdate\", {\n                            whitelistedKeyIds: [],\n                            blacklistedKeyIds: [],\n                            delistedKeyIds: sessionInfo.record.getAssociatedKeyIds(),\n                        });\n                    }\n                    (_a = stores.persistentSessionsStore) === null || _a === void 0 ? void 0 : _a.delete(mediaKeySession.sessionId);\n                    stores.loadedSessionsStore\n                        .closeSession(mediaKeySession)\n                        .catch((e) => {\n                        const closeError = e instanceof Error ? e : \"unknown error\";\n                        log.warn(\"DRM: failed to close expired session\", closeError);\n                    })\n                        .then(() => this._unlockInitDataQueue())\n                        .catch((retryError) => this._onFatalError(retryError));\n                    if (!this._isStopped()) {\n                        this.trigger(\"warning\", err.reason);\n                    }\n                    return;\n                }\n                if (!(err instanceof BlacklistedSessionError)) {\n                    this._onFatalError(err);\n                    return;\n                }\n                sessionInfo.blacklistedSessionError = err;\n                if (initializationData.content !== undefined) {\n                    log.info(\"DRM: blacklisting Representations based on \" + \"protection data.\");\n                    this.trigger(\"blackListProtectionData\", initializationData);\n                }\n                this._unlockInitDataQueue();\n                // TODO warning for blacklisted session?\n            },\n        }, this._canceller.signal);\n        if (options.singleLicensePer === undefined ||\n            options.singleLicensePer === \"init-data\") {\n            this._unlockInitDataQueue();\n        }\n        if (sessionRes.type === \"created-session\" /* MediaKeySessionLoadingType.Created */) {\n            const requestData = initializationData.values.constructRequestData();\n            try {\n                await stores.loadedSessionsStore.generateLicenseRequest(mediaKeySession, initializationData.type, requestData);\n            }\n            catch (error) {\n                // First check that the error was not due to the MediaKeySession closing\n                // or being closed\n                const entry = stores.loadedSessionsStore.getEntryForSession(mediaKeySession);\n                if (entry === null || entry.closingStatus.type !== \"none\") {\n                    // MediaKeySession closing/closed: Just remove from handled list and abort.\n                    const indexInCurrent = this._currentSessions.indexOf(sessionInfo);\n                    if (indexInCurrent >= 0) {\n                        this._currentSessions.splice(indexInCurrent, 1);\n                    }\n                    return Promise.resolve();\n                }\n                throw new EncryptedMediaError(\"KEY_GENERATE_REQUEST_ERROR\", error instanceof Error ? error.toString() : \"Unknown error\");\n            }\n        }\n        return Promise.resolve();\n    }\n    _tryToUseAlreadyCreatedSession(initializationData, mediaKeysData) {\n        const { stores, options } = mediaKeysData;\n        /**\n         * If set, a currently-used key session is already compatible to this\n         * initialization data.\n         */\n        const compatibleSessionInfo = arrayFind(this._currentSessions, (x) => x.record.isCompatibleWith(initializationData));\n        if (compatibleSessionInfo === undefined) {\n            return false;\n        }\n        /**\n         * On Safari using Directfile, the old EME implementation triggers\n         * the \"webkitneedkey\" event instead of \"encrypted\". There's an issue in Safari\n         * where \"webkitneedkey\" fires too early before all tracks are added from an HLS playlist.\n         * Safari incorrectly assumes some keys are missing for these tracks,\n         * leading to repeated \"webkitneedkey\" events. Because RxPlayer recognizes\n         * it already has a session for these keys and ignores the events,\n         * the content remains frozen. To resolve this, the session is re-created.\n         */\n        const forceSessionRecreation = initializationData.forceSessionRecreation;\n        if (forceSessionRecreation === true) {\n            this.removeSessionForInitData(initializationData, mediaKeysData);\n            return false;\n        }\n        // Check if the compatible session is blacklisted\n        const blacklistedSessionError = compatibleSessionInfo.blacklistedSessionError;\n        if (!isNullOrUndefined(blacklistedSessionError)) {\n            if (initializationData.type === undefined ||\n                initializationData.content === undefined) {\n                log.error(\"DRM: This initialization data has already been blacklisted \" +\n                    \"but the current content is not known.\");\n                return true;\n            }\n            else {\n                log.info(\"DRM: This initialization data has already been blacklisted. \" +\n                    \"Blacklisting the related content.\");\n                this.trigger(\"blackListProtectionData\", initializationData);\n                return true;\n            }\n        }\n        // Check if the current key id(s) has been blacklisted by this session\n        if (initializationData.keyIds !== undefined) {\n            /**\n             * If set to `true`, the Representation(s) linked to this\n             * initialization data's key id should be marked as \"not decipherable\".\n             */\n            let isUndecipherable;\n            if (options.singleLicensePer === undefined ||\n                options.singleLicensePer === \"init-data\") {\n                // Note: In the default \"init-data\" mode, we only avoid a\n                // Representation if the key id was originally explicitely\n                // blacklisted (and not e.g. if its key was just not present in\n                // the license).\n                //\n                // This is to enforce v3.x.x retro-compatibility: we cannot\n                // fallback from a Representation unless some RxPlayer option\n                // documentating this behavior has been set.\n                const { blacklisted } = compatibleSessionInfo.keyStatuses;\n                isUndecipherable = areSomeKeyIdsContainedIn(initializationData.keyIds, blacklisted);\n            }\n            else {\n                // In any other mode, as soon as not all of this initialization\n                // data's linked key ids are explicitely whitelisted, we can mark\n                // the corresponding Representation as \"not decipherable\".\n                // This is because we've no such retro-compatibility guarantee to\n                // make there.\n                const { whitelisted } = compatibleSessionInfo.keyStatuses;\n                isUndecipherable = !areAllKeyIdsContainedIn(initializationData.keyIds, whitelisted);\n            }\n            if (isUndecipherable) {\n                if (initializationData.content === undefined) {\n                    log.error(\"DRM: Cannot forbid key id, the content is unknown.\");\n                    return true;\n                }\n                log.info(\"DRM: Current initialization data is linked to blacklisted keys. \" +\n                    \"Marking Representations as not decipherable\");\n                this.trigger(\"keyIdsCompatibilityUpdate\", {\n                    whitelistedKeyIds: [],\n                    blacklistedKeyIds: initializationData.keyIds,\n                    delistedKeyIds: [],\n                });\n                return true;\n            }\n        }\n        // If we reached here, it means that this initialization data is not\n        // blacklisted in any way.\n        // Search loaded session and put it on top of the cache if it exists.\n        const entry = stores.loadedSessionsStore.reuse(initializationData);\n        if (entry !== null) {\n            // TODO update decipherability to `true` if not?\n            log.debug(\"DRM: Init data already processed. Skipping it.\");\n            return true;\n        }\n        // Session not found in `loadedSessionsStore`, it might have been closed\n        // since.\n        // Remove from `this._currentSessions` and start again.\n        const indexOf = this._currentSessions.indexOf(compatibleSessionInfo);\n        if (indexOf === -1) {\n            log.error(\"DRM: Unable to remove processed init data: not found.\");\n        }\n        else {\n            log.debug(\"DRM: A session from a processed init data is not available \" +\n                \"anymore. Re-processing it.\");\n            this._currentSessions.splice(indexOf, 1);\n        }\n        return false;\n    }\n    /**\n     * Remove the session corresponding to the initData provided, and close it.\n     * It does nothing if no session was found for this initData.\n     * @param {Object} initData : The initialization data corresponding to the session\n     * that need to be removed\n     * @param {Object} mediaKeysData : The media keys data\n     */\n    removeSessionForInitData(initData, mediaKeysData) {\n        const { stores } = mediaKeysData;\n        /** Remove the session and close it from the loadedSessionStore */\n        const entry = stores.loadedSessionsStore.reuse(initData);\n        if (entry !== null) {\n            stores.loadedSessionsStore\n                .closeSession(entry.mediaKeySession)\n                .catch(() => log.error(\"DRM: Cannot close the session from the loaded session store\"));\n        }\n        /**\n         * If set, a currently-used key session is already compatible to this\n         * initialization data.\n         */\n        const compatibleSessionInfo = arrayFind(this._currentSessions, (x) => x.record.isCompatibleWith(initData));\n        if (compatibleSessionInfo === undefined) {\n            return;\n        }\n        /** Remove the session from the currentSessions */\n        const indexOf = this._currentSessions.indexOf(compatibleSessionInfo);\n        if (indexOf !== -1) {\n            log.debug(\"DRM: A session from a processed init is removed due to forceSessionRecreation policy.\");\n            this._currentSessions.splice(indexOf, 1);\n        }\n    }\n    /**\n     * Callback that should be called if an error that made the current\n     * `ContentDecryptor` instance unusable arised.\n     * This callbacks takes care of resetting state and sending the right events.\n     *\n     * Once called, no further actions should be taken.\n     *\n     * @param {*} err - The error object which describes the issue. Will be\n     * formatted and sent in an \"error\" event.\n     */\n    _onFatalError(err) {\n        if (this._canceller.isUsed()) {\n            return;\n        }\n        const formattedErr = err instanceof Error ? err : new OtherError(\"NONE\", \"Unknown decryption error\");\n        this.error = formattedErr;\n        this._initDataQueue.length = 0;\n        this._stateData = {\n            state: ContentDecryptorState.Error,\n            isMediaKeysAttached: undefined,\n            isInitDataQueueLocked: undefined,\n            data: null,\n        };\n        this._canceller.cancel();\n        this.trigger(\"error\", formattedErr);\n        // The previous trigger might have lead to a disposal of the `ContentDecryptor`.\n        if (this._stateData.state === ContentDecryptorState.Error) {\n            this.trigger(\"stateChange\", this._stateData.state);\n        }\n    }\n    /**\n     * Return `true` if the `ContentDecryptor` has either been disposed or\n     * encountered a fatal error which made it stop.\n     * @returns {boolean}\n     */\n    _isStopped() {\n        return (this._stateData.state === ContentDecryptorState.Disposed ||\n            this._stateData.state === ContentDecryptorState.Error);\n    }\n    /**\n     * Start processing the next initialization data of the `_initDataQueue` if it\n     * isn't lock.\n     */\n    _processCurrentInitDataQueue() {\n        while (this._stateData.isInitDataQueueLocked === false) {\n            const initData = this._initDataQueue.shift();\n            if (initData === undefined) {\n                return;\n            }\n            this.onInitializationData(initData);\n        }\n    }\n    /**\n     * Lock new initialization data (from the `_initDataQueue`) from being\n     * processed until `_unlockInitDataQueue` is called.\n     *\n     * You may want to call this method when performing operations which may have\n     * an impact on the handling of other initialization data.\n     */\n    _lockInitDataQueue() {\n        if (this._stateData.isInitDataQueueLocked === false) {\n            this._stateData.isInitDataQueueLocked = true;\n        }\n    }\n    /**\n     * Unlock `_initDataQueue` and start processing the first element.\n     *\n     * Should have no effect if the `_initDataQueue` was not locked.\n     */\n    _unlockInitDataQueue() {\n        if (this._stateData.isMediaKeysAttached !== 2 /* MediaKeyAttachmentStatus.Attached */) {\n            log.error(\"DRM: Trying to unlock in the wrong state\");\n            return;\n        }\n        this._stateData.isInitDataQueueLocked = false;\n        this._processCurrentInitDataQueue();\n    }\n}\n/**\n * Returns `true` if the given MediaKeySystemAccess can create\n * \"persistent-license\" MediaKeySessions.\n * @param {MediaKeySystemAccess} mediaKeySystemAccess\n * @returns {Boolean}\n */\nfunction canCreatePersistentSession(mediaKeySystemAccess) {\n    const { sessionTypes } = mediaKeySystemAccess.getConfiguration();\n    return sessionTypes !== undefined && arrayIncludes(sessionTypes, \"persistent-license\");\n}\n/**\n * Returns `true` if the given MediaKeySystemAccess can create\n * \"temporary\" MediaKeySessions.\n * @param {MediaKeySystemAccess} mediaKeySystemAccess\n * @returns {Boolean}\n */\nfunction canCreateTemporarySession(mediaKeySystemAccess) {\n    const { sessionTypes } = mediaKeySystemAccess.getConfiguration();\n    return sessionTypes !== undefined && arrayIncludes(sessionTypes, \"temporary\");\n}\n/**\n * Return the list of key IDs present in the `expectedKeyIds` array\n * but that are not present in `actualKeyIds`.\n * @param {Uint8Array[]} expectedKeyIds - Array of key IDs expected to be found.\n * @param {Uint8Array[]} actualKeyIds - Array of key IDs to test.\n * @returns {Uint8Array[]} An array of key IDs that are missing from `actualKeyIds`.\n */\nexport function getMissingKeyIds(expectedKeyIds, actualKeyIds) {\n    return expectedKeyIds.filter((expected) => {\n        return !actualKeyIds.some((actual) => areArraysOfNumbersEqual(actual, expected));\n    });\n}\n/**\n * Returns an array of all key IDs that are known by the `KeySessionRecord`\n * but are missing in the provided array of key IDs `newKeyIds`.\n * @param {KeySessionRecord} keySessionRecord - The KeySessionRecord containing known key IDs.\n * @param {Uint8Array[]} newKeyIds - Array of key IDs.\n * @returns {Uint8Array[]} An array of key IDs that are known by the `keySessionRecord`\n *                          but are missing in the license.\n */\nexport function getMissingKnownKeyIds(keySessionRecord, newKeyIds) {\n    const allKnownKeyIds = keySessionRecord.getAssociatedKeyIds();\n    const missingKeyIds = getMissingKeyIds(allKnownKeyIds, newKeyIds);\n    if (missingKeyIds.length > 0 && log.hasLevel(\"DEBUG\")) {\n        log.debug(\"DRM: KeySessionRecord's keys missing in the license, blacklisting them\", missingKeyIds.map((m) => bytesToHex(m)).join(\", \"));\n    }\n    return missingKeyIds;\n}\n/**\n * Returns an array of all key IDs that are present in InitData\n * but are missing in the provided array of key IDs `newKeyIds`.\n * @param {IProcessedProtectionData} initializationData - The initialization data containing key IDs.\n * @param {Uint8Array[]} newKeyIds - Array of key IDs.\n * @returns {Uint8Array[]} An array of key IDs that are present in initializationData\n *                          but are missing in the license.\n */\nexport function getMissingInitDataKeyIds(initializationData, newKeyIds) {\n    let missingKeyIds = [];\n    const { keyIds: expectedKeyIds } = initializationData;\n    if (expectedKeyIds !== undefined) {\n        missingKeyIds = getMissingKeyIds(expectedKeyIds, newKeyIds);\n    }\n    if (missingKeyIds.length > 0 && log.hasLevel(\"DEBUG\")) {\n        log.debug(\"DRM: init data keys missing in the license, blacklisting them\", missingKeyIds.map((m) => bytesToHex(m)).join(\", \"));\n    }\n    return missingKeyIds;\n}\n/**\n * Returns set of all usable and unusable keys - explicit or implicit - that are\n * linked to a `MediaKeySession`.\n *\n * In the RxPlayer, there is a concept of \"explicit\" key ids, which are key ids\n * found in a license whose status can be known through the `keyStatuses`\n * property from a `MediaKeySession`, and of \"implicit\" key ids, which are key\n * ids which were expected to be in a fetched license, but apparently weren't.\n *\n * @param {Object} initializationData - Initialization data object used to make\n * the request for the current license.\n * @param {Object} keySessionRecord - The `KeySessionRecord` associated with the\n * session that has been loaded. It might give supplementary information on\n * keys implicitly linked to the license.\n * @param {string|undefined} singleLicensePer - Setting allowing to indicate the\n * scope a given license should have.\n * @param {boolean} isCurrentLicense - If `true` the license has been fetched\n * especially for the current content.\n *\n * Knowing this allows to determine that if decryption keys that should have\n * been referenced in the fetched license (according to the `singleLicensePer`\n * setting) are missing, then the keys surely must have been voluntarly\n * removed from the license.\n *\n * If it is however set to `false`, it means that the license is an older\n * license that might have been linked to another content, thus we cannot make\n * that assumption.\n * @param {Array.<Uint8Array>} usableKeyIds - Key ids that are present in the\n * license and can be used.\n * @param {Array.<Uint8Array>} unusableKeyIds - Key ids that are present in the\n * license yet cannot be used.\n * @returns {Object} - Returns an object with the following properties:\n *   - `whitelisted`: Array of key ids for keys that are known to be usable\n *   - `blacklisted`: Array of key ids for keys that are considered unusable.\n *     The qualities linked to those keys should not be played.\n */\nfunction getKeyIdsLinkedToSession(initializationData, keySessionRecord, singleLicensePer, isCurrentLicense, usableKeyIds, unusableKeyIds) {\n    var _a;\n    /**\n     * Every key id associated with the MediaKeySession, starting with\n     * whitelisted ones.\n     */\n    const keyIdsInLicense = [...usableKeyIds, ...unusableKeyIds];\n    const missingKnownKeyIds = getMissingKnownKeyIds(keySessionRecord, keyIdsInLicense);\n    const associatedKeyIds = keyIdsInLicense.concat(missingKnownKeyIds);\n    if (singleLicensePer !== undefined && singleLicensePer !== \"init-data\") {\n        // We want to add the current key ids in the blacklist if it is\n        // not already there.\n        //\n        // We only do that when `singleLicensePer` is set to something\n        // else than the default `\"init-data\"` because this logic:\n        //   1. might result in a quality fallback, which is a v3.x.x\n        //      breaking change if some APIs (like `singleLicensePer`)\n        //      aren't used.\n        //   2. Rely on the EME spec regarding key statuses being well\n        //      implemented on all supported devices, which we're not\n        //      sure yet. Because in any other `singleLicensePer`, we\n        //      need a good implementation anyway, it doesn't matter\n        //      there.\n        const missingInitDataKeyIds = getMissingInitDataKeyIds(initializationData, associatedKeyIds);\n        associatedKeyIds.push(...missingInitDataKeyIds);\n        const { content } = initializationData;\n        if (isCurrentLicense && content !== undefined) {\n            if (singleLicensePer === \"content\") {\n                // Put it in a Set to automatically filter out duplicates (by ref)\n                const contentKeys = new Set();\n                const { manifest } = content;\n                for (const period of manifest.periods) {\n                    addKeyIdsFromPeriod(contentKeys, period);\n                }\n                mergeKeyIdSetIntoArray(contentKeys, associatedKeyIds);\n            }\n            else if (singleLicensePer === \"periods\") {\n                const { manifest } = content;\n                for (const period of manifest.periods) {\n                    const periodKeys = new Set();\n                    addKeyIdsFromPeriod(periodKeys, period);\n                    if (((_a = initializationData.content) === null || _a === void 0 ? void 0 : _a.period.id) === period.id) {\n                        mergeKeyIdSetIntoArray(periodKeys, associatedKeyIds);\n                    }\n                    else {\n                        const periodKeysArr = Array.from(periodKeys);\n                        for (const kid of periodKeysArr) {\n                            const isFound = associatedKeyIds.some((k) => areArraysOfNumbersEqual(k, kid));\n                            if (isFound) {\n                                mergeKeyIdSetIntoArray(periodKeys, associatedKeyIds);\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return {\n        whitelisted: usableKeyIds,\n        /** associatedKeyIds starts with the whitelisted one. */\n        blacklisted: associatedKeyIds.slice(usableKeyIds.length),\n    };\n}\n/**\n * Push all kei ids in the given `set` and add it to the `arr` Array only if it\n * isn't already present in it.\n * @param {Set.<Uint8Array>} set\n * @param {Array.<Uint8Array>} arr\n */\nfunction mergeKeyIdSetIntoArray(set, arr) {\n    const setArr = Array.from(set.values());\n    for (const kid of setArr) {\n        const isFound = arr.some((k) => areArraysOfNumbersEqual(k, kid));\n        if (!isFound) {\n            arr.push(kid);\n        }\n    }\n}\n/**\n * Add to the given `set` all key ids found in the given `Period`.\n * @param {Set.<Uint8Array>} set\n * @param {Object} period\n */\nfunction addKeyIdsFromPeriod(set, period) {\n    const adaptationsByType = period.adaptations;\n    const adaptations = objectValues(adaptationsByType).reduce(\n    // Note: the second case cannot happen. TS is just being dumb here\n    (acc, adaps) => (!isNullOrUndefined(adaps) ? acc.concat(adaps) : acc), []);\n    for (const adaptation of adaptations) {\n        for (const representation of adaptation.representations) {\n            if (representation.contentProtections !== undefined &&\n                representation.contentProtections.keyIds !== undefined) {\n                for (const kid of representation.contentProtections.keyIds) {\n                    set.add(kid);\n                }\n            }\n        }\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../log\";\nimport createSession from \"./create_session\";\nimport cleanOldLoadedSessions from \"./utils/clean_old_loaded_sessions\";\nimport isSessionUsable from \"./utils/is_session_usable\";\n/**\n * Handle MediaEncryptedEvents sent by a HTMLMediaElement:\n * Either create a MediaKeySession, recuperate a previous MediaKeySession or\n * load a persistent session.\n *\n * Some previously created MediaKeySession can be closed in this process to\n * respect the maximum limit of concurrent MediaKeySession, as defined by the\n * `EME_MAX_SIMULTANEOUS_MEDIA_KEY_SESSIONS` config property.\n *\n * You can refer to the events emitted to know about the current situation.\n * @param {Object} initializationData\n * @param {Object} stores\n * @param {string} wantedSessionType\n * @param {number} maxSessionCacheSize\n * @param {Object} cancelSignal\n * @returns {Promise}\n */\nexport default async function createOrLoadSession(initializationData, stores, wantedSessionType, maxSessionCacheSize, cancelSignal) {\n    /** Store previously-loaded compatible MediaKeySession, if one. */\n    let previousLoadedSession = null;\n    const { loadedSessionsStore, persistentSessionsStore } = stores;\n    const entry = loadedSessionsStore.reuse(initializationData);\n    if (entry !== null) {\n        previousLoadedSession = entry.mediaKeySession;\n        if (isSessionUsable(previousLoadedSession)) {\n            log.info(\"DRM: Reuse loaded session\", previousLoadedSession.sessionId);\n            return {\n                type: \"loaded-open-session\" /* MediaKeySessionLoadingType.LoadedOpenSession */,\n                value: {\n                    mediaKeySession: previousLoadedSession,\n                    sessionType: entry.sessionType,\n                    keySessionRecord: entry.keySessionRecord,\n                },\n            };\n        }\n        else if (persistentSessionsStore !== null) {\n            // If the session is not usable anymore, we can also remove it from the\n            // PersistentSessionsStore.\n            // TODO Are we sure this is always what we want?\n            if (entry.mediaKeySession.sessionId !== \"\") {\n                persistentSessionsStore.delete(entry.mediaKeySession.sessionId);\n            }\n        }\n    }\n    if (previousLoadedSession !== null) {\n        await loadedSessionsStore.closeSession(previousLoadedSession);\n        if (cancelSignal.cancellationError !== null) {\n            throw cancelSignal.cancellationError; // stop here if cancelled since\n        }\n    }\n    await cleanOldLoadedSessions(loadedSessionsStore, \n    // Account for the next session we will be creating\n    // Note that `maxSessionCacheSize < 0 has special semantic (no limit)`\n    maxSessionCacheSize <= 0 ? maxSessionCacheSize : maxSessionCacheSize - 1);\n    if (cancelSignal.cancellationError !== null) {\n        throw cancelSignal.cancellationError; // stop here if cancelled since\n    }\n    const evt = await createSession(stores, initializationData, wantedSessionType, cancelSignal);\n    return {\n        type: evt.type,\n        value: {\n            mediaKeySession: evt.value.mediaKeySession,\n            sessionType: evt.value.sessionType,\n            keySessionRecord: evt.value.keySessionRecord,\n        },\n    };\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../log\";\nimport isSessionUsable from \"./utils/is_session_usable\";\n/**\n * Create a new Session or load a persistent one on the given MediaKeys,\n * according to wanted settings and what is currently stored.\n *\n * If session creating fails, remove the oldest MediaKeySession loaded and\n * retry.\n *\n * /!\\ This only creates new sessions.\n * It will fail if loadedSessionsStore already has a MediaKeySession with\n * the given initialization data.\n * @param {Object} stores\n * @param {Object} initData\n * @param {string} wantedSessionType\n * @param {Object} cancelSignal\n * @returns {Promise}\n */\nexport default function createSession(stores, initData, wantedSessionType, cancelSignal) {\n    const { loadedSessionsStore, persistentSessionsStore } = stores;\n    if (wantedSessionType === \"temporary\") {\n        return createTemporarySession(loadedSessionsStore, initData);\n    }\n    else if (persistentSessionsStore === null) {\n        log.warn(\"DRM: Cannot create persistent MediaKeySession, \" +\n            \"PersistentSessionsStore not created.\");\n        return createTemporarySession(loadedSessionsStore, initData);\n    }\n    return createAndTryToRetrievePersistentSession(loadedSessionsStore, persistentSessionsStore, initData, cancelSignal);\n}\n/**\n * Create a new temporary MediaKeySession linked to the given initData and\n * initDataType.\n * @param {Object} loadedSessionsStore\n * @param {Object} initData\n * @returns {Promise}\n */\nfunction createTemporarySession(loadedSessionsStore, initData) {\n    log.info(\"DRM: Creating a new temporary session\");\n    const entry = loadedSessionsStore.createSession(initData, \"temporary\");\n    return Promise.resolve({\n        type: \"created-session\" /* MediaKeySessionLoadingType.Created */,\n        value: entry,\n    });\n}\n/**\n * Create a persistent MediaKeySession and try to load on it a previous\n * MediaKeySession linked to the same initialization data.\n * @param {Object} loadedSessionsStore\n * @param {Object} persistentSessionsStore\n * @param {Object} initData\n * @param {Object} cancelSignal\n * @returns {Promise}\n */\nasync function createAndTryToRetrievePersistentSession(loadedSessionsStore, persistentSessionsStore, initData, cancelSignal) {\n    if (cancelSignal.cancellationError !== null) {\n        throw cancelSignal.cancellationError;\n    }\n    log.info(\"DRM: Creating persistent MediaKeySession\");\n    const entry = loadedSessionsStore.createSession(initData, \"persistent-license\");\n    const storedEntry = persistentSessionsStore.getAndReuse(initData);\n    if (storedEntry === null) {\n        return { type: \"created-session\" /* MediaKeySessionLoadingType.Created */, value: entry };\n    }\n    try {\n        const hasLoadedSession = await loadedSessionsStore.loadPersistentSession(entry.mediaKeySession, storedEntry.sessionId);\n        if (!hasLoadedSession) {\n            log.warn(\"DRM: No data stored for the loaded session\");\n            persistentSessionsStore.delete(storedEntry.sessionId);\n            // The EME specification is kind of implicit about it but it seems from my\n            // understanding (Paul B.) that a MediaKeySession on wich a `load` attempt\n            // did not succeed due to the loaded session not being found by the\n            // browser/CDM, should neither be used anymore nor closed.\n            // Thus, we're creating another `\"persistent-license\"` `MediaKeySession`\n            // in that specific case.\n            loadedSessionsStore.removeSessionWithoutClosingIt(entry.mediaKeySession);\n            const newEntry = loadedSessionsStore.createSession(initData, \"persistent-license\");\n            return { type: \"created-session\" /* MediaKeySessionLoadingType.Created */, value: newEntry };\n        }\n        if (hasLoadedSession && isSessionUsable(entry.mediaKeySession)) {\n            persistentSessionsStore.add(initData, initData.keyIds, entry.mediaKeySession);\n            log.info(\"DRM: Succeeded to load persistent session.\");\n            return {\n                type: \"loaded-persistent-session\" /* MediaKeySessionLoadingType.LoadedPersistentSession */,\n                value: entry,\n            };\n        }\n        // Unusable persistent session: recreate a new session from scratch.\n        log.warn(\"DRM: Previous persistent session not usable anymore.\");\n        return recreatePersistentSession();\n    }\n    catch (err) {\n        log.warn(\"DRM: Unable to load persistent session: \" +\n            (err instanceof Error ? err.toString() : \"Unknown Error\"));\n        return recreatePersistentSession();\n    }\n    /**\n     * Helper function to close and restart the current persistent session\n     * considered, and re-create it from scratch.\n     * @returns {Promise.<Object>}\n     */\n    async function recreatePersistentSession() {\n        if (cancelSignal.cancellationError !== null) {\n            throw cancelSignal.cancellationError;\n        }\n        log.info(\"DRM: Removing previous persistent session.\");\n        const persistentEntry = persistentSessionsStore.get(initData);\n        if (persistentEntry !== null) {\n            persistentSessionsStore.delete(persistentEntry.sessionId);\n        }\n        try {\n            await loadedSessionsStore.closeSession(entry.mediaKeySession);\n        }\n        catch (err) {\n            // From reading the EME specification in details, it seems that a\n            // `MediaKeySession`'s ability to be closed is tightly linked to its\n            // possession of a \"sanitized session ID\" set as `sessionId`.\n            // This is never clearly stated however and I'm (Paul B.) always afraid of\n            // breaking compatibility when it comes to EME code.\n            // So we still try to close the `MediaKeySession` in any case, only, if it\n            // fails and it didn't had any `sessionId` set, we just ignore the error.\n            // Note that trying to close the `MediaKeySession` might incur some delays\n            // in those rare cases.\n            if (entry.mediaKeySession.sessionId !== \"\") {\n                throw err;\n            }\n            loadedSessionsStore.removeSessionWithoutClosingIt(entry.mediaKeySession);\n        }\n        if (cancelSignal.cancellationError !== null) {\n            throw cancelSignal.cancellationError;\n        }\n        const newEntry = loadedSessionsStore.createSession(initData, \"persistent-license\");\n        return { type: \"created-session\" /* MediaKeySessionLoadingType.Created */, value: newEntry };\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport MediaKeysAttacher from \"./utils/media_keys_attacher\";\n/**\n * Free up all ressources taken by the content decryption logic.\n * @param {HTMLMediaElement} mediaElement\n * @returns {Promise}\n */\nexport default async function disposeDecryptionResources(mediaElement) {\n    return MediaKeysAttacher.clearMediaKeys(mediaElement);\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { canRelyOnRequestMediaKeySystemAccess } from \"../../compat/can_rely_on_request_media_key_system_access\";\nimport eme from \"../../compat/eme\";\nimport { generatePlayReadyInitData, DUMMY_PLAY_READY_HEADER, } from \"../../compat/generate_init_data\";\nimport shouldRenewMediaKeySystemAccess from \"../../compat/should_renew_media_key_system_access\";\nimport config from \"../../config\";\nimport { EncryptedMediaError } from \"../../errors\";\nimport log from \"../../log\";\nimport { parseCodec } from \"../../utils/are_codecs_compatible\";\nimport arrayIncludes from \"../../utils/array_includes\";\nimport flatMap from \"../../utils/flat_map\";\nimport isNullOrUndefined from \"../../utils/is_null_or_undefined\";\nimport MediaKeysAttacher from \"./utils/media_keys_attacher\";\n/**\n * Takes a `newConfiguration` `MediaKeySystemConfiguration`, that is intended\n * for the creation of a `MediaKeySystemAccess`, and a `prevConfiguration`\n * `MediaKeySystemConfiguration`, that was the one used at creation of the\n * current `MediaKeySystemAccess`.\n *\n * This function will then return `true` if it determined that the new\n * configuration is conceptually compatible with the one used before, and\n * `false` otherwise.\n * @param {Object} newConfiguration - New wanted `MediaKeySystemConfiguration`\n * @param {Object} prevConfiguration - The `MediaKeySystemConfiguration` that is\n * relied on util now.\n * @returns {boolean} - `true` if `newConfiguration` is compatible with\n * `prevConfiguration`.\n */\nfunction isNewMediaKeySystemConfigurationCompatibleWithPreviousOne(newConfiguration, prevConfiguration) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n    if (newConfiguration.label !== prevConfiguration.label) {\n        return false;\n    }\n    const prevDistinctiveIdentifier = (_a = prevConfiguration.distinctiveIdentifier) !== null && _a !== void 0 ? _a : \"optional\";\n    const newDistinctiveIdentifier = (_b = newConfiguration.distinctiveIdentifier) !== null && _b !== void 0 ? _b : \"optional\";\n    if (prevDistinctiveIdentifier !== newDistinctiveIdentifier) {\n        return false;\n    }\n    const prevPersistentState = (_c = prevConfiguration.persistentState) !== null && _c !== void 0 ? _c : \"optional\";\n    const newPersistentState = (_d = newConfiguration.persistentState) !== null && _d !== void 0 ? _d : \"optional\";\n    if (prevPersistentState !== newPersistentState) {\n        return false;\n    }\n    const prevInitDataTypes = (_e = prevConfiguration.initDataTypes) !== null && _e !== void 0 ? _e : [];\n    const newInitDataTypes = (_f = newConfiguration.initDataTypes) !== null && _f !== void 0 ? _f : [];\n    if (!isArraySubsetOf(newInitDataTypes, prevInitDataTypes)) {\n        return false;\n    }\n    const prevSessionTypes = (_g = prevConfiguration.sessionTypes) !== null && _g !== void 0 ? _g : [];\n    const newSessionTypes = (_h = newConfiguration.sessionTypes) !== null && _h !== void 0 ? _h : [];\n    if (!isArraySubsetOf(newSessionTypes, prevSessionTypes)) {\n        return false;\n    }\n    for (const prop of [\"audioCapabilities\", \"videoCapabilities\"]) {\n        const newCapabilities = (_j = newConfiguration[prop]) !== null && _j !== void 0 ? _j : [];\n        const prevCapabilities = (_k = prevConfiguration[prop]) !== null && _k !== void 0 ? _k : [];\n        const wasFound = newCapabilities.every((n) => {\n            var _a, _b, _c, _d, _e, _f;\n            for (let i = 0; i < prevCapabilities.length; i++) {\n                const prevCap = prevCapabilities[i];\n                if (((_a = prevCap.robustness) !== null && _a !== void 0 ? _a : \"\") === ((_b = n.robustness) !== null && _b !== void 0 ? _b : \"\") ||\n                    ((_c = prevCap.encryptionScheme) !== null && _c !== void 0 ? _c : null) === ((_d = n.encryptionScheme) !== null && _d !== void 0 ? _d : null) ||\n                    ((_e = prevCap.robustness) !== null && _e !== void 0 ? _e : \"\") === ((_f = n.robustness) !== null && _f !== void 0 ? _f : \"\")) {\n                    return true;\n                }\n            }\n            return false;\n        });\n        if (!wasFound) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Find key system canonical name from key system type.\n * @param {string} ksType - Obtained via inversion\n * @returns {string|undefined} - Either the canonical name, or undefined.\n */\nfunction findKeySystemCanonicalName(ksType) {\n    const { EME_KEY_SYSTEMS } = config.getCurrent();\n    for (const ksName of Object.keys(EME_KEY_SYSTEMS)) {\n        if (arrayIncludes(EME_KEY_SYSTEMS[ksName], ksType)) {\n            return ksName;\n        }\n    }\n    return undefined;\n}\n/**\n * Build configuration for the requestMediaKeySystemAccess EME API, based\n * on the current keySystem object.\n * @param {Object} keySystemTypeInfo\n * @returns {Array.<Object>} - Configuration to give to the\n * requestMediaKeySystemAccess API.\n */\nfunction buildKeySystemConfigurations(keySystemTypeInfo) {\n    const { keyName, keyType, keySystemOptions: keySystem } = keySystemTypeInfo;\n    let sessionTypes;\n    let persistentState = \"optional\";\n    let distinctiveIdentifier = \"optional\";\n    if (Array.isArray(keySystem.wantedSessionTypes)) {\n        sessionTypes = keySystem.wantedSessionTypes;\n        if (arrayIncludes(keySystem.wantedSessionTypes, \"persistent-license\") &&\n            !isNullOrUndefined(keySystem.persistentLicenseConfig)) {\n            persistentState = \"required\";\n        }\n    }\n    else if (!isNullOrUndefined(keySystem.persistentLicenseConfig)) {\n        persistentState = \"required\";\n        sessionTypes = [\"persistent-license\"];\n    }\n    else {\n        sessionTypes = [\"temporary\"];\n    }\n    if (!isNullOrUndefined(keySystem.persistentState)) {\n        persistentState = keySystem.persistentState;\n    }\n    if (!isNullOrUndefined(keySystem.distinctiveIdentifier)) {\n        distinctiveIdentifier = keySystem.distinctiveIdentifier;\n    }\n    const { EME_DEFAULT_AUDIO_CODECS, EME_DEFAULT_VIDEO_CODECS, EME_DEFAULT_WIDEVINE_ROBUSTNESSES, EME_DEFAULT_PLAYREADY_RECOMMENDATION_ROBUSTNESSES, } = config.getCurrent();\n    // From the W3 EME spec, we have to provide videoCapabilities and\n    // audioCapabilities.\n    // These capabilities must specify a codec (even though you can use a\n    // completely different codec afterward).\n    // It is also strongly recommended to specify the required security\n    // robustness. As we do not want to forbide any security level, we specify\n    // every existing security level from highest to lowest so that the best\n    // security level is selected.\n    // More details here:\n    // https://storage.googleapis.com/wvdocs/Chrome_EME_Changes_and_Best_Practices.pdf\n    // https://www.w3.org/TR/encrypted-media/#get-supported-configuration-and-consent\n    let audioCapabilities;\n    let videoCapabilities;\n    const { audioCapabilitiesConfig, videoCapabilitiesConfig } = keySystem;\n    if ((audioCapabilitiesConfig === null || audioCapabilitiesConfig === void 0 ? void 0 : audioCapabilitiesConfig.type) === \"full\") {\n        audioCapabilities = audioCapabilitiesConfig.value;\n    }\n    else {\n        let audioRobustnesses;\n        if ((audioCapabilitiesConfig === null || audioCapabilitiesConfig === void 0 ? void 0 : audioCapabilitiesConfig.type) === \"robustness\") {\n            audioRobustnesses = audioCapabilitiesConfig.value;\n        }\n        else if (keyName === \"widevine\") {\n            audioRobustnesses = EME_DEFAULT_WIDEVINE_ROBUSTNESSES;\n        }\n        else if (keyType === \"com.microsoft.playready.recommendation\") {\n            audioRobustnesses = EME_DEFAULT_PLAYREADY_RECOMMENDATION_ROBUSTNESSES;\n        }\n        else {\n            audioRobustnesses = [];\n        }\n        if (audioRobustnesses.length === 0) {\n            audioRobustnesses.push(undefined);\n        }\n        const audioCodecs = (audioCapabilitiesConfig === null || audioCapabilitiesConfig === void 0 ? void 0 : audioCapabilitiesConfig.type) === \"contentType\"\n            ? audioCapabilitiesConfig.value\n            : EME_DEFAULT_AUDIO_CODECS;\n        audioCapabilities = flatMap(audioRobustnesses, (robustness) => audioCodecs.map((contentType) => {\n            return robustness !== undefined ? { contentType, robustness } : { contentType };\n        }));\n    }\n    if ((videoCapabilitiesConfig === null || videoCapabilitiesConfig === void 0 ? void 0 : videoCapabilitiesConfig.type) === \"full\") {\n        videoCapabilities = videoCapabilitiesConfig.value;\n    }\n    else {\n        let videoRobustnesses;\n        if ((videoCapabilitiesConfig === null || videoCapabilitiesConfig === void 0 ? void 0 : videoCapabilitiesConfig.type) === \"robustness\") {\n            videoRobustnesses = videoCapabilitiesConfig.value;\n        }\n        else if (keyName === \"widevine\") {\n            videoRobustnesses = EME_DEFAULT_WIDEVINE_ROBUSTNESSES;\n        }\n        else if (keyType === \"com.microsoft.playready.recommendation\") {\n            videoRobustnesses = EME_DEFAULT_PLAYREADY_RECOMMENDATION_ROBUSTNESSES;\n        }\n        else {\n            videoRobustnesses = [];\n        }\n        if (videoRobustnesses.length === 0) {\n            videoRobustnesses.push(undefined);\n        }\n        const videoCodecs = (videoCapabilitiesConfig === null || videoCapabilitiesConfig === void 0 ? void 0 : videoCapabilitiesConfig.type) === \"contentType\"\n            ? videoCapabilitiesConfig.value\n            : EME_DEFAULT_VIDEO_CODECS;\n        videoCapabilities = flatMap(videoRobustnesses, (robustness) => videoCodecs.map((contentType) => {\n            return robustness !== undefined ? { contentType, robustness } : { contentType };\n        }));\n    }\n    const wantedMediaKeySystemConfiguration = {\n        initDataTypes: [\"cenc\"],\n        videoCapabilities,\n        audioCapabilities,\n        distinctiveIdentifier,\n        persistentState,\n        sessionTypes,\n    };\n    if (audioCapabilitiesConfig !== undefined) {\n        if (videoCapabilitiesConfig !== undefined) {\n            return [wantedMediaKeySystemConfiguration];\n        }\n        return [\n            wantedMediaKeySystemConfiguration,\n            Object.assign(Object.assign({}, wantedMediaKeySystemConfiguration), { \n                // Re-try without `videoCapabilities` in case the EME implementation is\n                // buggy\n                videoCapabilities: undefined }),\n        ];\n    }\n    else if (videoCapabilitiesConfig !== undefined) {\n        return [\n            wantedMediaKeySystemConfiguration,\n            Object.assign(Object.assign({}, wantedMediaKeySystemConfiguration), { \n                // Re-try without `audioCapabilities` in case the EME implementation is\n                // buggy\n                audioCapabilities: undefined }),\n        ];\n    }\n    return [\n        wantedMediaKeySystemConfiguration,\n        // Some legacy implementations have issues with `audioCapabilities` and\n        // `videoCapabilities`, so we're including a supplementary\n        // `MediaKeySystemConfiguration` without those properties.\n        Object.assign(Object.assign({}, wantedMediaKeySystemConfiguration), { audioCapabilities: undefined, videoCapabilities: undefined }),\n    ];\n}\n/**\n * Extract from the current mediaKeys the supported Codecs.\n * @param {Object} initialConfiguration - The MediaKeySystemConfiguration given\n * to the `navigator.requestMediaKeySystemAccess` API.\n * @param {Object | undefined} mksConfiguration - The result of\n * getConfiguration() of the media keys.\n * @return {Array} The list of supported codec by the CDM.\n */\nexport function extractCodecSupportListFromConfiguration(initialConfiguration, mksConfiguration) {\n    var _a, _b, _c, _d, _e, _f;\n    const testedAudioCodecs = (_b = (_a = initialConfiguration.audioCapabilities) === null || _a === void 0 ? void 0 : _a.map((v) => v.contentType)) !== null && _b !== void 0 ? _b : [];\n    const testedVideoCodecs = (_d = (_c = initialConfiguration.videoCapabilities) === null || _c === void 0 ? void 0 : _c.map((v) => v.contentType)) !== null && _d !== void 0 ? _d : [];\n    const testedCodecs = testedAudioCodecs\n        .concat(testedVideoCodecs)\n        .filter((c) => c !== undefined);\n    const supportedVideoCodecs = (_e = mksConfiguration.videoCapabilities) === null || _e === void 0 ? void 0 : _e.map((entry) => entry.contentType);\n    const supportedAudioCodecs = (_f = mksConfiguration.audioCapabilities) === null || _f === void 0 ? void 0 : _f.map((entry) => entry.contentType);\n    const supportedCodecs = [\n        ...(supportedVideoCodecs !== null && supportedVideoCodecs !== void 0 ? supportedVideoCodecs : []),\n        ...(supportedAudioCodecs !== null && supportedAudioCodecs !== void 0 ? supportedAudioCodecs : []),\n    ].filter((contentType) => contentType !== undefined);\n    if (supportedCodecs.length === 0) {\n        // Some legacy implementations have issues with `audioCapabilities` and\n        // `videoCapabilities` in requestMediaKeySystemAccess so the codecs are not provided.\n        // In this case, we can't tell which codec is supported or not.\n        // Let's instead provide an empty list.\n        // Note: on a correct EME implementation, if a list of codec is provided\n        // with `audioCapabilities` or `videoCapabilities`, but none of them is supported,\n        // requestMediaKeySystemAccess should yield an error \"NotSupported\" and we should\n        // never reach this code.\n        return [];\n    }\n    const codecSupportList = testedCodecs.map((codec) => {\n        const { codecs, mimeType } = parseCodec(codec);\n        const isSupported = arrayIncludes(supportedCodecs, codec);\n        return {\n            codec: codecs,\n            mimeType,\n            result: isSupported,\n        };\n    });\n    return codecSupportList;\n}\n/**\n * Try to find a compatible key system from the keySystems array given.\n *\n * This function will request a MediaKeySystemAccess based on the various\n * keySystems provided.\n *\n * This Promise might either:\n *   - resolves the MediaKeySystemAccess and the keySystems as an object, when\n *     found.\n *   - reject if no compatible key system has been found.\n *\n * @param {HTMLMediaElement} mediaElement\n * @param {Array.<Object>} keySystemsConfigs - The keySystems you want to test.\n * @param {Object} cancelSignal\n * @returns {Promise.<Object>}\n */\nexport default function getMediaKeySystemAccess(mediaElement, keySystemsConfigs, cancelSignal) {\n    log.info(\"DRM: Searching for compatible MediaKeySystemAccess\");\n    /** Array of set keySystems for this content. */\n    const keySystemsType = keySystemsConfigs.reduce((arr, keySystemOptions) => {\n        const { EME_KEY_SYSTEMS } = config.getCurrent();\n        const managedRDNs = EME_KEY_SYSTEMS[keySystemOptions.type];\n        let ksType;\n        if (!isNullOrUndefined(managedRDNs)) {\n            ksType = managedRDNs.map((keyType) => {\n                const keyName = keySystemOptions.type;\n                return { keyName, keyType, keySystemOptions };\n            });\n        }\n        else {\n            const keyName = findKeySystemCanonicalName(keySystemOptions.type);\n            const keyType = keySystemOptions.type;\n            ksType = [{ keyName, keyType, keySystemOptions }];\n        }\n        return arr.concat(ksType);\n    }, []);\n    return recursivelyTestKeySystems(0);\n    /**\n     * Test all key system configuration stored in `keySystemsType` one by one\n     * recursively.\n     * Returns a Promise which will emit the MediaKeySystemAccess if one was\n     * found compatible with one of the configurations or just reject if none\n     * were found to be compatible.\n     * @param {Number} index - The index in `keySystemsType` to start from.\n     * Should be set to `0` when calling directly.\n     * @returns {Promise.<Object>}\n     */\n    async function recursivelyTestKeySystems(index) {\n        // if we iterated over the whole keySystemsType Array, quit on error\n        if (index >= keySystemsType.length) {\n            throw new EncryptedMediaError(\"INCOMPATIBLE_KEYSYSTEMS\", \"No key system compatible with your wanted \" +\n                \"configuration has been found in the current \" +\n                \"browser.\");\n        }\n        if (isNullOrUndefined(eme.requestMediaKeySystemAccess)) {\n            throw new Error(\"requestMediaKeySystemAccess is not implemented in your browser.\");\n        }\n        const chosenType = keySystemsType[index];\n        const { keyType, keySystemOptions } = chosenType;\n        const keySystemConfigurations = buildKeySystemConfigurations(chosenType);\n        log.debug(`DRM: Request keysystem access ${keyType},` +\n            `${index + 1} of ${keySystemsType.length}`);\n        let keySystemAccess;\n        const currentState = await MediaKeysAttacher.getAttachedMediaKeysState(mediaElement);\n        for (let configIdx = 0; configIdx < keySystemConfigurations.length; configIdx++) {\n            const keySystemConfiguration = keySystemConfigurations[configIdx];\n            // Check if the current `MediaKeySystemAccess` created cannot be reused here\n            if (currentState !== null &&\n                !shouldRenewMediaKeySystemAccess() &&\n                // TODO: Do it with MediaKeySystemAccess.prototype.keySystem instead?\n                keyType === currentState.mediaKeySystemAccess.keySystem &&\n                eme.implementation === currentState.emeImplementation.implementation &&\n                isNewMediaKeySystemConfigurationCompatibleWithPreviousOne(keySystemConfiguration, currentState.askedConfiguration)) {\n                log.info(\"DRM: Found cached compatible keySystem\");\n                return Promise.resolve({\n                    type: \"reuse-media-key-system-access\",\n                    value: {\n                        mediaKeySystemAccess: currentState.mediaKeySystemAccess,\n                        askedConfiguration: currentState.askedConfiguration,\n                        options: keySystemOptions,\n                        codecSupport: extractCodecSupportListFromConfiguration(currentState.askedConfiguration, currentState.mediaKeySystemAccess.getConfiguration()),\n                    },\n                });\n            }\n            try {\n                keySystemAccess = await testKeySystem(keyType, [keySystemConfiguration]);\n                log.info(\"DRM: Found compatible keysystem\", keyType, index + 1);\n                return {\n                    type: \"create-media-key-system-access\",\n                    value: {\n                        options: keySystemOptions,\n                        mediaKeySystemAccess: keySystemAccess,\n                        askedConfiguration: keySystemConfiguration,\n                        codecSupport: extractCodecSupportListFromConfiguration(keySystemConfiguration, keySystemAccess.getConfiguration()),\n                    },\n                };\n            }\n            catch (_) {\n                log.debug(\"DRM: Rejected access to keysystem\", keyType, index + 1, configIdx);\n                if (cancelSignal.cancellationError !== null) {\n                    throw cancelSignal.cancellationError;\n                }\n            }\n        }\n        return recursivelyTestKeySystems(index + 1);\n    }\n}\n/**\n * Test a key system configuration, resolves with the MediaKeySystemAccess\n * or reject if the key system is unsupported.\n * @param {string} keyType - The KeySystem string to test (ex: com.microsoft.playready.recommendation)\n * @param {Array.<MediaKeySystemMediaCapability>} keySystemConfigurations - Configurations for this keySystem\n * @returns Promise resolving with the MediaKeySystemAccess. Rejects if unsupported.\n */\nexport async function testKeySystem(keyType, keySystemConfigurations) {\n    const keySystemAccess = await eme.requestMediaKeySystemAccess(keyType, keySystemConfigurations);\n    if (!canRelyOnRequestMediaKeySystemAccess(keyType)) {\n        try {\n            const mediaKeys = await keySystemAccess.createMediaKeys();\n            const session = mediaKeys.createSession();\n            const initData = generatePlayReadyInitData(DUMMY_PLAY_READY_HEADER);\n            await session.generateRequest(\"cenc\", initData);\n            session.close().catch(() => {\n                log.warn(\"DRM: Failed to close the dummy session\");\n            });\n        }\n        catch (err) {\n            log.debug(\"DRM: KeySystemAccess was granted but it is not usable\");\n            throw err;\n        }\n    }\n    return keySystemAccess;\n}\n/**\n * Returns `true` if `arr1`'s values are entirely contained in `arr2`.\n * @param {string} arr1\n * @param {string} arr2\n * @return {boolean}\n */\nfunction isArraySubsetOf(arr1, arr2) {\n    for (let i = 0; i < arr1.length; i++) {\n        if (!arrayIncludes(arr2, arr1[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport MediaKeysAttacher from \"./utils/media_keys_attacher\";\n/**\n * Returns the name of the current key system used as well as its configuration,\n * as reported by the `MediaKeySystemAccess` itself.\n * @param {HTMLMediaElement} mediaElement\n * @returns {Array|null}\n */\nexport default function getKeySystemConfiguration(mediaElement) {\n    const currentState = MediaKeysAttacher.getAwaitedState(mediaElement);\n    if (currentState === null) {\n        return null;\n    }\n    return [\n        currentState.mediaKeySystemAccess.keySystem,\n        currentState.mediaKeySystemAccess.getConfiguration(),\n    ];\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport canReuseMediaKeys from \"../../compat/can_reuse_media_keys\";\nimport { EncryptedMediaError } from \"../../errors\";\nimport log from \"../../log\";\nimport isNullOrUndefined from \"../../utils/is_null_or_undefined\";\nimport getMediaKeySystemAccess from \"./find_key_system\";\nimport LoadedSessionsStore from \"./utils/loaded_sessions_store\";\nimport MediaKeysAttacher from \"./utils/media_keys_attacher\";\nimport PersistentSessionsStore from \"./utils/persistent_sessions_store\";\nimport ServerCertificateStore from \"./utils/server_certificate_store\";\n/**\n * @throws {EncryptedMediaError}\n * @param {Object} keySystemOptions\n * @returns {Object|null}\n */\nfunction createPersistentSessionsStorage(keySystemOptions) {\n    const { persistentLicenseConfig } = keySystemOptions;\n    if (isNullOrUndefined(persistentLicenseConfig)) {\n        return null;\n    }\n    log.debug(\"DRM: Set the given license storage\");\n    return new PersistentSessionsStore(persistentLicenseConfig);\n}\n/**\n * Create a MediaKeys instance and associated structures (or just return the\n * current ones if sufficient) based on a wanted configuration.\n * @param {HTMLMediaElement} mediaElement - The HTMLMediaElement on which you\n * will attach the MediaKeys instance.\n * This Element is here only used to check if the current MediaKeys and\n * MediaKeySystemAccess instances are sufficient\n * @param {Array.<Object>} keySystemsConfigs - The key system configuration.\n * Needed to ask the right MediaKeySystemAccess.\n * @param {Object} cancelSignal - CancellationSignal allowing to cancel the\n * creation of the MediaKeys instance while the task is still pending.\n * @returns {Promise.<Object>}\n */\nexport default async function getMediaKeysInfos(mediaElement, keySystemsConfigs, cancelSignal) {\n    const evt = await getMediaKeySystemAccess(mediaElement, keySystemsConfigs, cancelSignal);\n    if (cancelSignal.cancellationError !== null) {\n        throw cancelSignal.cancellationError;\n    }\n    const { options, mediaKeySystemAccess, askedConfiguration, codecSupport } = evt.value;\n    const currentState = await MediaKeysAttacher.getAttachedMediaKeysState(mediaElement);\n    const persistentSessionsStore = createPersistentSessionsStorage(options);\n    if (evt.value.options.reuseMediaKeys !== false &&\n        canReuseMediaKeys() &&\n        currentState !== null &&\n        evt.type === \"reuse-media-key-system-access\") {\n        log.debug(\"DRM: Reusing already created MediaKeys\");\n        const { mediaKeys, loadedSessionsStore } = currentState;\n        // We might just rely on the currently attached MediaKeys instance.\n        // First check if server certificate parameters are the same than in the\n        // current MediaKeys instance. If not, re-create MediaKeys from scratch.\n        if (ServerCertificateStore.hasOne(mediaKeys) === false ||\n            (!isNullOrUndefined(options.serverCertificate) &&\n                ServerCertificateStore.has(mediaKeys, options.serverCertificate))) {\n            return {\n                mediaKeys,\n                mediaKeySystemAccess,\n                askedConfiguration,\n                stores: { loadedSessionsStore, persistentSessionsStore },\n                options,\n                codecSupport,\n            };\n        }\n    }\n    const mediaKeys = await createMediaKeys(mediaKeySystemAccess);\n    log.info(\"DRM: MediaKeys created with success\");\n    const loadedSessionsStore = new LoadedSessionsStore(mediaKeys);\n    return {\n        mediaKeys,\n        mediaKeySystemAccess,\n        askedConfiguration,\n        stores: { loadedSessionsStore, persistentSessionsStore },\n        options,\n        codecSupport,\n    };\n}\n/**\n * Create `MediaKeys` from the `MediaKeySystemAccess` given.\n * Throws the right formatted error if it fails.\n * @param {MediaKeySystemAccess} mediaKeySystemAccess\n * @returns {Promise.<MediaKeys>}\n */\nasync function createMediaKeys(mediaKeySystemAccess) {\n    log.info(\"DRM: Calling createMediaKeys on the MediaKeySystemAccess\");\n    try {\n        const mediaKeys = await mediaKeySystemAccess.createMediaKeys();\n        return mediaKeys;\n    }\n    catch (error) {\n        const message = error instanceof Error ? error.message : \"Unknown error when creating MediaKeys.\";\n        throw new EncryptedMediaError(\"CREATE_MEDIA_KEYS_ERROR\", message);\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * /!\\ This file is feature-switchable.\n * It always should be imported through the `features` object.\n */\nimport clearOnStop from \"./clear_on_stop\";\nimport ContentDecryptor from \"./content_decryptor\";\nimport disposeDecryptionResources from \"./dispose_decryption_resources\";\nimport getKeySystemConfiguration from \"./get_key_system_configuration\";\nexport * from \"./types\";\nexport default ContentDecryptor;\nexport { clearOnStop, disposeDecryptionResources, getKeySystemConfiguration };\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../log\";\nimport getMediaKeysInfos from \"./get_media_keys\";\nimport MediaKeysAttacher from \"./utils/media_keys_attacher\";\n/**\n * Get media keys infos from key system configs then attach media keys to media element.\n * @param {HTMLMediaElement} mediaElement\n * @param {Array.<Object>} keySystemsConfigs\n * @param {Object} cancelSignal\n * @returns {Promise.<Object>}\n */\nexport default async function initMediaKeys(mediaElement, keySystemsConfigs, cancelSignal) {\n    const mediaKeysInfo = await getMediaKeysInfos(mediaElement, keySystemsConfigs, cancelSignal);\n    const { mediaKeys } = mediaKeysInfo;\n    const shouldDisableOldMediaKeys = mediaElement.mediaKeys !== null &&\n        mediaElement.mediaKeys !== undefined &&\n        mediaKeys !== mediaElement.mediaKeys;\n    if (shouldDisableOldMediaKeys) {\n        log.debug(\"DRM: Disabling old MediaKeys\");\n        await MediaKeysAttacher.clearMediaKeys(mediaElement);\n    }\n    return mediaKeysInfo;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { onKeyError, onKeyMessage, onKeyStatusesChange, } from \"../../compat/event_listeners\";\nimport { EncryptedMediaError } from \"../../errors\";\nimport log from \"../../log\";\nimport isNonEmptyString from \"../../utils/is_non_empty_string\";\nimport isNullOrUndefined from \"../../utils/is_null_or_undefined\";\nimport retryPromiseWithBackoff from \"../../utils/retry_promise_with_backoff\";\nimport TaskCanceller, { CancellationSignal } from \"../../utils/task_canceller\";\nimport checkKeyStatuses from \"./utils/check_key_statuses\";\n/**\n * Listen to various events from a MediaKeySession and react accordingly\n * depending on the configuration given.\n * @param {MediaKeySession} session - The MediaKeySession concerned.\n * @param {Object} keySystemOptions - The key system options.\n * @param {String} keySystem - The configuration keySystem used for deciphering\n * @param {Object} callbacks\n * @param {Object} cancelSignal\n */\nexport default function SessionEventsListener(session, keySystemOptions, keySystem, callbacks, cancelSignal) {\n    log.info(\"DRM: Binding session events\", session.sessionId);\n    const { getLicenseConfig = {} } = keySystemOptions;\n    /** Allows to manually cancel everything the `SessionEventsListener` is doing. */\n    const manualCanceller = new TaskCanceller();\n    manualCanceller.linkToSignal(cancelSignal);\n    if (!isNullOrUndefined(session.closed)) {\n        session.closed\n            .then(() => manualCanceller.cancel())\n            .catch((err) => {\n            // Should never happen\n            if (cancelSignal.isCancelled()) {\n                return;\n            }\n            manualCanceller.cancel();\n            callbacks.onError(err);\n        });\n    }\n    onKeyError(session, (evt) => {\n        manualCanceller.cancel();\n        callbacks.onError(new EncryptedMediaError(\"KEY_ERROR\", evt.type));\n    }, manualCanceller.signal);\n    onKeyStatusesChange(session, () => {\n        log.info(\"DRM: keystatuseschange event received\", session.sessionId);\n        try {\n            checkAndHandleCurrentKeyStatuses();\n        }\n        catch (error) {\n            if (cancelSignal.isCancelled() ||\n                (manualCanceller.isUsed() && error instanceof CancellationSignal)) {\n                return;\n            }\n            manualCanceller.cancel();\n            callbacks.onError(error);\n        }\n    }, manualCanceller.signal);\n    onKeyMessage(session, (evt) => {\n        const messageEvent = evt;\n        const message = new Uint8Array(messageEvent.message);\n        const messageType = isNonEmptyString(messageEvent.messageType)\n            ? messageEvent.messageType\n            : \"license-request\";\n        log.info(`DRM: Received message event, type ${messageType}`, session.sessionId);\n        const backoffOptions = getLicenseBackoffOptions(getLicenseConfig.retry);\n        retryPromiseWithBackoff(() => runGetLicense(message, messageType), backoffOptions, manualCanceller.signal).then(async (licenseObject) => {\n            if (manualCanceller.isUsed()) {\n                return;\n            }\n            if (isNullOrUndefined(licenseObject)) {\n                log.info(\"DRM: No license given, skipping session.update\");\n            }\n            else {\n                try {\n                    await updateSessionWithMessage(session, licenseObject);\n                }\n                catch (err) {\n                    manualCanceller.cancel();\n                    callbacks.onError(err);\n                }\n            }\n        }, (err) => {\n            if (manualCanceller.isUsed()) {\n                return;\n            }\n            manualCanceller.cancel();\n            const formattedError = formatGetLicenseError(err);\n            if (!isNullOrUndefined(err)) {\n                const { fallbackOnLastTry } = err;\n                if (fallbackOnLastTry === true) {\n                    log.warn(\"DRM: Last `getLicense` attempt failed. \" +\n                        \"Blacklisting the current session.\");\n                    callbacks.onError(new BlacklistedSessionError(formattedError));\n                    return;\n                }\n            }\n            callbacks.onError(formattedError);\n        });\n    }, manualCanceller.signal);\n    log.info(\"DRM: transmitting current keystatuses\", session.sessionId);\n    checkAndHandleCurrentKeyStatuses();\n    return;\n    /**\n     * Check current MediaKeyStatus for each key in the given MediaKeySession and:\n     *   - throw if at least one status is a non-recoverable error\n     *   - call warning callback for recoverable errors\n     *   - call onKeyUpdate callback when the MediaKeyStatus of any key is updated\n     */\n    function checkAndHandleCurrentKeyStatuses() {\n        if (manualCanceller.isUsed() || session.keyStatuses.size === 0) {\n            return;\n        }\n        const { warning, blacklistedKeyIds, whitelistedKeyIds } = checkKeyStatuses(session, keySystemOptions, keySystem);\n        if (warning !== undefined) {\n            callbacks.onWarning(warning);\n            if (manualCanceller.isUsed()) {\n                return;\n            }\n        }\n        callbacks.onKeyUpdate({ whitelistedKeyIds, blacklistedKeyIds });\n    }\n    function runGetLicense(message, messageType) {\n        let timeoutId;\n        return new Promise((res, rej) => {\n            try {\n                log.debug(\"DRM: Calling `getLicense`\", messageType);\n                const getLicense = keySystemOptions.getLicense(message, messageType);\n                const getLicenseTimeout = isNullOrUndefined(getLicenseConfig.timeout)\n                    ? 10 * 1000\n                    : getLicenseConfig.timeout;\n                if (getLicenseTimeout >= 0) {\n                    timeoutId = setTimeout(() => {\n                        rej(new GetLicenseTimeoutError(`\"getLicense\" timeout exceeded (${getLicenseTimeout} ms)`));\n                    }, getLicenseTimeout);\n                }\n                Promise.resolve(getLicense).then(clearTimeoutAndResolve, clearTimeoutAndReject);\n            }\n            catch (err) {\n                clearTimeoutAndReject(err);\n            }\n            function clearTimeoutAndResolve(data) {\n                if (timeoutId !== undefined) {\n                    clearTimeout(timeoutId);\n                }\n                res(data);\n            }\n            function clearTimeoutAndReject(err) {\n                if (timeoutId !== undefined) {\n                    clearTimeout(timeoutId);\n                }\n                rej(err);\n            }\n        });\n    }\n    /**\n     * Construct backoff options for the getLicense call.\n     * @param {number|undefined} numberOfRetry - Maximum of amount retried.\n     * Equal to `2` if not defined.\n     * @returns {Object}\n     */\n    function getLicenseBackoffOptions(numberOfRetry) {\n        return {\n            totalRetry: numberOfRetry !== null && numberOfRetry !== void 0 ? numberOfRetry : 2,\n            baseDelay: 200,\n            maxDelay: 3000,\n            shouldRetry: (error) => error instanceof GetLicenseTimeoutError ||\n                isNullOrUndefined(error) ||\n                error.noRetry !== true,\n            onRetry: (error) => callbacks.onWarning(formatGetLicenseError(error)),\n        };\n    }\n}\n/**\n * Format an error returned by a `getLicense` call to a proper form as defined\n * by the RxPlayer's API.\n * @param {*} error\n * @returns {Error}\n */\nfunction formatGetLicenseError(error) {\n    if (error instanceof GetLicenseTimeoutError) {\n        return new EncryptedMediaError(\"KEY_LOAD_TIMEOUT\", \"The license server took too much time to \" + \"respond.\");\n    }\n    const err = new EncryptedMediaError(\"KEY_LOAD_ERROR\", \"An error occured when calling `getLicense`.\");\n    if (!isNullOrUndefined(error) &&\n        isNonEmptyString(error.message)) {\n        err.message = error.message;\n    }\n    return err;\n}\n/**\n * Call MediaKeySession.update with the given `message`, if defined.\n * @param {MediaKeySession} session\n * @param {ArrayBuffer|TypedArray|null} message\n * @returns {Promise}\n */\nasync function updateSessionWithMessage(session, message) {\n    log.info(\"DRM: Updating MediaKeySession with message\");\n    try {\n        await session.update(message);\n    }\n    catch (error) {\n        const reason = error instanceof Error ? error.toString() : \"`session.update` failed\";\n        throw new EncryptedMediaError(\"KEY_UPDATE_ERROR\", reason);\n    }\n    log.info(\"DRM: MediaKeySession update succeeded.\");\n}\n/**\n * Error thrown when the MediaKeySession is blacklisted.\n * Such MediaKeySession should not be re-used but other MediaKeySession for the\n * same content can still be used.\n * @class BlacklistedSessionError\n * @extends Error\n */\nexport class BlacklistedSessionError extends Error {\n    constructor(sessionError) {\n        super(sessionError.message);\n        // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class\n        Object.setPrototypeOf(this, BlacklistedSessionError.prototype);\n        this.sessionError = sessionError;\n    }\n}\n/**\n * Error thrown when a `getLicense` call timeouts.\n * @class GetLicenseTimeoutError\n * @extends Error\n */\nexport class GetLicenseTimeoutError extends Error {\n    constructor(message) {\n        super(message);\n        // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class\n        Object.setPrototypeOf(this, BlacklistedSessionError.prototype);\n        this.message = message;\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { EncryptedMediaError, isKnownError } from \"../../errors\";\nimport log from \"../../log\";\nimport ServerCertificateStore from \"./utils/server_certificate_store\";\n/**\n * Call the setServerCertificate API with the given certificate.\n * Resolves on success, rejects on failure.\n *\n * TODO Handle returned value?\n * From the spec:\n *   - setServerCertificate resolves with true if everything worked\n *   - it resolves with false if the CDM does not support server\n *     certificates.\n *\n * @param {MediaKeys} mediaKeys\n * @param {ArrayBuffer} serverCertificate\n * @returns {Promise}\n */\nasync function setServerCertificate(mediaKeys, serverCertificate) {\n    try {\n        const res = await mediaKeys.setServerCertificate(serverCertificate);\n        // Note: Even if `setServerCertificate` technically should return a\n        // Promise.<boolean>, this is not technically always true.\n        // Thus we prefer to return unknown here.\n        return res;\n    }\n    catch (error) {\n        log.warn(\"DRM: mediaKeys.setServerCertificate returned an error\", error instanceof Error ? error : \"\");\n        const reason = error instanceof Error ? error.toString() : \"`setServerCertificate` error\";\n        throw new EncryptedMediaError(\"LICENSE_SERVER_CERTIFICATE_ERROR\", reason);\n    }\n}\n/**\n * Call the setCertificate API. If it fails just emit the error as warning\n * and complete.\n * @param {MediaKeys} mediaKeys\n * @param {ArrayBuffer} serverCertificate\n * @returns {Promise.<Object>}\n */\nexport default async function trySettingServerCertificate(mediaKeys, serverCertificate) {\n    if (ServerCertificateStore.hasOne(mediaKeys) === true) {\n        log.info(\"DRM: The MediaKeys already has a server certificate, skipping...\");\n        return { type: \"already-has-one\" };\n    }\n    if (typeof mediaKeys.setServerCertificate !== \"function\") {\n        log.warn(\"DRM: Could not set the server certificate.\" +\n            \" mediaKeys.setServerCertificate is not a function\");\n        return { type: \"method-not-implemented\" };\n    }\n    log.info(\"DRM: Setting server certificate on the MediaKeys\");\n    // Because of browser errors, or a user action that can lead to interrupting\n    // server certificate setting, we might be left in a status where we don't\n    // know if we attached the server certificate or not.\n    // Calling `prepare` allow to invalidate temporarily that status.\n    ServerCertificateStore.prepare(mediaKeys);\n    try {\n        const result = await setServerCertificate(mediaKeys, serverCertificate);\n        ServerCertificateStore.set(mediaKeys, serverCertificate);\n        return { type: \"success\", value: result };\n    }\n    catch (error) {\n        const formattedErr = isKnownError(error)\n            ? error\n            : new EncryptedMediaError(\"LICENSE_SERVER_CERTIFICATE_ERROR\", \"Unknown error when setting the server certificate.\");\n        return { type: \"error\", value: formattedErr };\n    }\n}\nexport { trySettingServerCertificate, setServerCertificate };\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Enumeration of the various \"state\" the `ContentDecryptor` can be in. */\nexport var ContentDecryptorState;\n(function (ContentDecryptorState) {\n    /**\n     * The `ContentDecryptor` is not yet ready to create key sessions and request\n     * licenses.\n     * This is is the initial state of the ContentDecryptor.\n     */\n    ContentDecryptorState[ContentDecryptorState[\"Initializing\"] = 0] = \"Initializing\";\n    /**\n     * The `ContentDecryptor` has been initialized.\n     * You should now called the `attach` method when you want to add decryption\n     * capabilities to the HTMLMediaElement. The ContentDecryptor won't go to the\n     * `ReadyForContent` state until `attach` is called.\n     *\n     * For compatibility reasons, this should be done after the HTMLMediaElement's\n     * src attribute is set.\n     *\n     * It is also from when this state is reached that the `ContentDecryptor`'s\n     * `systemId` property may be known.\n     *\n     * This state is always coming after the `Initializing` state.\n     */\n    ContentDecryptorState[ContentDecryptorState[\"WaitingForAttachment\"] = 1] = \"WaitingForAttachment\";\n    /**\n     * Content (encrypted or not) can begin to be pushed on the HTMLMediaElement\n     * (this state was needed because some browser quirks sometimes forces us to\n     * call EME API before this can be done).\n     *\n     * This state is always coming after the `WaitingForAttachment` state.\n     */\n    ContentDecryptorState[ContentDecryptorState[\"ReadyForContent\"] = 2] = \"ReadyForContent\";\n    /**\n     * The `ContentDecryptor` has encountered a fatal error and has been stopped.\n     * It is now unusable.\n     */\n    ContentDecryptorState[ContentDecryptorState[\"Error\"] = 3] = \"Error\";\n    /** The `ContentDecryptor` has been disposed of and is now unusable. */\n    ContentDecryptorState[ContentDecryptorState[\"Disposed\"] = 4] = \"Disposed\";\n})(ContentDecryptorState || (ContentDecryptorState = {}));\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport areArraysOfNumbersEqual from \"../../../utils/are_arrays_of_numbers_equal\";\nimport SerializableBytes from \"./serializable_bytes\";\n/**\n * Returns `true` if both values are compatible initialization data, which\n * means that one is completely contained in the other.\n *\n * Both values given should be sorted by systemId the same way.\n * @param {Array.<Object>} stored\n * @param {Array.<Object>} newElts\n * @returns {boolean}\n */\nexport default function areInitializationValuesCompatible(stored, newElts) {\n    var _a, _b;\n    return (_b = (_a = _isAInB(stored, newElts)) !== null && _a !== void 0 ? _a : _isAInB(newElts, stored)) !== null && _b !== void 0 ? _b : false;\n}\n/**\n * Take two arrays of initialization data values, `a` and `b`, sorted by\n * their `systemId` property in the same order.\n *\n * Returns `true` if `a` is not empty and is completely contained in the `b`\n * array.\n * This is equivalent to: \"`a` is contained in `b`\".\n *\n * Returns `false` either if `a` is empty or if `b` has different initialization\n * data than it for equivalent system ids.\n * This is equivalent to: \"`a` represents different data than `b`\".\n *\n * Returns `null` if `a` is not fully contained in `b` but can still be\n * compatible with it.\n * This is equivalent to: \"`a` is not contained in `b`, but `b` could be\n * contained in `a`\".\n * @param {Array.<Object>} a\n * @param {Array.<Object>} b\n * @returns {boolean}\n */\nfunction _isAInB(a, b) {\n    if (a.length === 0) {\n        return false;\n    }\n    if (b.length < a.length) {\n        return null;\n    }\n    const firstAElt = a[0];\n    let aIdx = 0;\n    let bIdx = 0;\n    for (; bIdx < b.length; bIdx++) {\n        const bElt = b[bIdx];\n        if (bElt.systemId !== firstAElt.systemId) {\n            continue;\n        }\n        if (bElt.hash !== firstAElt.hash) {\n            return false;\n        }\n        let aData;\n        if (firstAElt.data instanceof Uint8Array) {\n            aData = firstAElt.data;\n        }\n        else if (typeof firstAElt.data === \"string\") {\n            aData = SerializableBytes.decode(firstAElt.data);\n        }\n        else {\n            aData = firstAElt.data.initData;\n        }\n        let bData;\n        if (bElt.data instanceof Uint8Array) {\n            bData = bElt.data;\n        }\n        else if (typeof bElt.data === \"string\") {\n            bData = SerializableBytes.decode(bElt.data);\n        }\n        else {\n            bData = bElt.data.initData;\n        }\n        if (!areArraysOfNumbersEqual(aData, bData)) {\n            return false;\n        }\n        if (b.length - bIdx < a.length) {\n            // not enough place to store `a`'s initialization data.\n            return null;\n        }\n        // first `a` value was found. Check if all `a` values are found in `b`\n        for (aIdx = 1; aIdx < a.length; aIdx++) {\n            const aElt = a[aIdx];\n            for (bIdx += 1; bIdx < b.length; bIdx++) {\n                const bNewElt = b[bIdx];\n                if (aElt.systemId !== bNewElt.systemId) {\n                    continue;\n                }\n                if (aElt.hash !== bNewElt.hash) {\n                    return false;\n                }\n                let aNewData;\n                if (aElt.data instanceof Uint8Array) {\n                    aNewData = aElt.data;\n                }\n                else if (typeof aElt.data === \"string\") {\n                    aNewData = SerializableBytes.decode(aElt.data);\n                }\n                else {\n                    aNewData = aElt.data.initData;\n                }\n                let bNewData;\n                if (bNewElt.data instanceof Uint8Array) {\n                    bNewData = bNewElt.data;\n                }\n                else if (typeof bNewElt.data === \"string\") {\n                    bNewData = SerializableBytes.decode(bNewElt.data);\n                }\n                else {\n                    bNewData = bNewElt.data.initData;\n                }\n                if (!areArraysOfNumbersEqual(aNewData, bNewData)) {\n                    return false;\n                }\n                break;\n            }\n            if (aIdx === b.length) {\n                // we didn't find `aElt`'s systemId in b\n                return null;\n            }\n        }\n        // If we're here, then we've found all `a`'s systemId in `b` and they match\n        return true;\n    }\n    return null; // We didn't find the firstAElt`s systemId in `b`.\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport getUUIDKidFromKeyStatusKID from \"../../../compat/eme/get_uuid_kid_from_keystatus_kid\";\nimport { EncryptedMediaError } from \"../../../errors\";\nimport log from \"../../../log\";\nimport { assertUnreachable } from \"../../../utils/assert\";\nimport { bytesToHex } from \"../../../utils/string_parsing\";\n/**\n * Error thrown when the MediaKeySession has to be closed due to a trigger\n * specified by user configuration.\n * Such MediaKeySession should be closed immediately and may be re-created if\n * needed again.\n * @class DecommissionedSessionError\n * @extends Error\n */\nexport class DecommissionedSessionError extends Error {\n    /**\n     * Creates a new `DecommissionedSessionError`.\n     * @param {Error} reason - Error that led to the decision to close the\n     * current MediaKeySession. Should be used for reporting purposes.\n     */\n    constructor(reason) {\n        super(reason.message);\n        // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class\n        Object.setPrototypeOf(this, DecommissionedSessionError.prototype);\n        this.reason = reason;\n    }\n}\nconst KEY_STATUSES = {\n    EXPIRED: \"expired\",\n    INTERNAL_ERROR: \"internal-error\",\n    OUTPUT_RESTRICTED: \"output-restricted\",\n};\n/**\n * Look at the current key statuses in the sessions and construct the\n * appropriate warnings, whitelisted and blacklisted key ids.\n *\n * Throws if one of the keyID is on an error.\n * @param {MediaKeySession} session - The MediaKeySession from which the keys\n * will be checked.\n * @param {Object} options\n * @param {String} keySystem - The configuration keySystem used for deciphering\n * @returns {Object} - Warnings to send, whitelisted and blacklisted key ids.\n */\nexport default function checkKeyStatuses(session, options, keySystem) {\n    const { onKeyInternalError, onKeyOutputRestricted, onKeyExpiration } = options;\n    const blacklistedKeyIds = [];\n    const whitelistedKeyIds = [];\n    const badKeyStatuses = [];\n    session.keyStatuses.forEach((_arg1, _arg2) => {\n        // Hack present because the order of the arguments has changed in spec\n        // and is not the same between some versions of Edge and Chrome.\n        const [keyStatus, keyStatusKeyId] = (() => {\n            return (typeof _arg1 === \"string\" ? [_arg1, _arg2] : [_arg2, _arg1]);\n        })();\n        const keyId = getUUIDKidFromKeyStatusKID(keySystem, new Uint8Array(keyStatusKeyId));\n        const keyStatusObj = { keyId: keyId.buffer, keyStatus };\n        if (log.hasLevel(\"DEBUG\")) {\n            log.debug(`DRM: key status update (${bytesToHex(keyId)}): ${keyStatus}`);\n        }\n        switch (keyStatus) {\n            case KEY_STATUSES.EXPIRED: {\n                const error = new EncryptedMediaError(\"KEY_STATUS_CHANGE_ERROR\", `A decryption key expired (${bytesToHex(keyId)})`, { keyStatuses: [keyStatusObj, ...badKeyStatuses] });\n                if (onKeyExpiration === \"error\" || onKeyExpiration === undefined) {\n                    throw error;\n                }\n                switch (onKeyExpiration) {\n                    case \"close-session\":\n                        throw new DecommissionedSessionError(error);\n                    case \"fallback\":\n                        blacklistedKeyIds.push(keyId);\n                        break;\n                    default:\n                        // I weirdly stopped relying on switch-cases here due to some TypeScript\n                        // issue, not checking properly `case undefined` (bug?)\n                        if (onKeyExpiration === \"continue\" || onKeyExpiration === undefined) {\n                            whitelistedKeyIds.push(keyId);\n                        }\n                        else {\n                            // Compile-time check throwing when not all possible cases are handled\n                            assertUnreachable(onKeyExpiration);\n                        }\n                        break;\n                }\n                badKeyStatuses.push(keyStatusObj);\n                break;\n            }\n            case KEY_STATUSES.INTERNAL_ERROR: {\n                const error = new EncryptedMediaError(\"KEY_STATUS_CHANGE_ERROR\", `A \"${keyStatus}\" status has been encountered (${bytesToHex(keyId)})`, { keyStatuses: [keyStatusObj, ...badKeyStatuses] });\n                switch (onKeyInternalError) {\n                    case undefined:\n                    case \"error\":\n                        throw error;\n                    case \"close-session\":\n                        throw new DecommissionedSessionError(error);\n                    case \"fallback\":\n                        blacklistedKeyIds.push(keyId);\n                        break;\n                    case \"continue\":\n                        whitelistedKeyIds.push(keyId);\n                        break;\n                    default:\n                        // Weirdly enough, TypeScript is not checking properly\n                        // `case undefined` (bug?)\n                        if (onKeyInternalError !== undefined) {\n                            assertUnreachable(onKeyInternalError);\n                        }\n                        else {\n                            throw error;\n                        }\n                }\n                badKeyStatuses.push(keyStatusObj);\n                break;\n            }\n            case KEY_STATUSES.OUTPUT_RESTRICTED: {\n                const error = new EncryptedMediaError(\"KEY_STATUS_CHANGE_ERROR\", `A \"${keyStatus}\" status has been encountered (${bytesToHex(keyId)})`, { keyStatuses: [keyStatusObj, ...badKeyStatuses] });\n                switch (onKeyOutputRestricted) {\n                    case undefined:\n                    case \"error\":\n                        throw error;\n                    case \"fallback\":\n                        blacklistedKeyIds.push(keyId);\n                        break;\n                    case \"continue\":\n                        whitelistedKeyIds.push(keyId);\n                        break;\n                    default:\n                        // Weirdly enough, TypeScript is not checking properly\n                        // `case undefined` (bug?)\n                        if (onKeyOutputRestricted !== undefined) {\n                            assertUnreachable(onKeyOutputRestricted);\n                        }\n                        else {\n                            throw error;\n                        }\n                }\n                badKeyStatuses.push(keyStatusObj);\n                break;\n            }\n            default:\n                whitelistedKeyIds.push(keyId);\n                break;\n        }\n    });\n    let warning;\n    if (badKeyStatuses.length > 0) {\n        warning = new EncryptedMediaError(\"KEY_STATUS_CHANGE_ERROR\", \"One or several problematic key statuses have been encountered\", { keyStatuses: badKeyStatuses });\n    }\n    return { warning, blacklistedKeyIds, whitelistedKeyIds };\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../../log\";\n/**\n * Close sessions from the loadedSessionsStore to allow at maximum `limit`\n * stored MediaKeySessions in it.\n *\n * Emit event when a MediaKeySession begin to be closed and another when the\n * MediaKeySession is closed.\n * @param {Object} loadedSessionsStore\n * @returns {Promise}\n */\nexport default async function cleanOldLoadedSessions(loadedSessionsStore, limit) {\n    if (limit < 0 || limit >= loadedSessionsStore.getLength()) {\n        return;\n    }\n    log.info(\"DRM: LSS cache limit exceeded\", limit, loadedSessionsStore.getLength());\n    const proms = [];\n    const entries = loadedSessionsStore.getAll().slice(); // clone\n    const toDelete = entries.length - limit;\n    for (let i = 0; i < toDelete; i++) {\n        const entry = entries[i];\n        proms.push(loadedSessionsStore.closeSession(entry.mediaKeySession));\n    }\n    await Promise.all(proms);\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../../log\";\n/**\n * Remove old information from a PersistentSessionsStore so that it respects the\n * given `limit` as a maximum size. This can be used to prevent its size from\n * growing indefinitely.\n *\n * This is needed because our persistent session information storage is\n * un-bounded in size, adding more data will just add more data without removing\n * the old one - which can be valid or invalid.\n *\n * This is problematic for at least two reasons:\n *   - This data is loaded into JS memory which is finite (and which maximum\n *     bounds depends on the user environment).\n *   - The final storage used (as chosen by the application using the RxPlayer)\n *     will in most cases have a maximum storage size.\n */\nexport default function cleanOldStoredPersistentInfo(persistentSessionsStore, limit) {\n    if (isNaN(limit) || limit < 0 || limit >= persistentSessionsStore.getLength()) {\n        return;\n    }\n    const numberOfPersistentSessions = persistentSessionsStore.getLength();\n    const toDelete = numberOfPersistentSessions - limit;\n    log.info(\"DRM: Too many stored persistent sessions, removing some.\", numberOfPersistentSessions, toDelete);\n    persistentSessionsStore.deleteOldSessions(toDelete);\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport startsWith from \"../../../utils/starts_with\";\n/**\n * @param {string} keySystem\n * @returns {string|undefined}\n */\nexport default function getDrmSystemId(keySystem) {\n    if (startsWith(keySystem, \"com.microsoft.playready\") ||\n        keySystem === \"com.chromecast.playready\" ||\n        keySystem === \"com.youtube.playready\") {\n        return \"9a04f07998404286ab92e65be0885f95\";\n    }\n    if (keySystem === \"com.widevine.alpha\") {\n        return \"edef8ba979d64acea3c827dcd51d21ed\";\n    }\n    if (startsWith(keySystem, \"com.apple.fps\")) {\n        return \"94ce86fb07ff4f43adb893d2fa968ca2\";\n    }\n    if (startsWith(keySystem, \"com.nagra.\")) {\n        return \"adb41c242dbf4a6d958b4457c0d27b95\";\n    }\n    return undefined;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { concat } from \"../../../utils/byte_parsing\";\nimport hashBuffer from \"../../../utils/hash_buffer\";\nimport areInitializationValuesCompatible from \"./are_init_values_compatible\";\n/**\n * Wrap initialization data values and reformat it so it becomes easier to check\n * compatibility with other `InitDataValuesContainer`.\n * @class InitDataValuesContainer\n */\nexport default class InitDataValuesContainer {\n    /**\n     * Construct a new `InitDataValuesContainer`.\n     * Note that the data is not formatted right away.\n     * It is only really formatted lazily the first time we need it.\n     *\n     * @param {Array.<Object>} initDataValues\n     */\n    constructor(initDataValues) {\n        this._innerValues = initDataValues;\n        this._lazyFormattedValues = null;\n    }\n    /**\n     * Construct data that should be given to the `generateRequest` EME API.\n     * @returns {Uint8Array}\n     */\n    constructRequestData() {\n        // `generateKeyRequest` awaits a single Uint8Array containing all\n        // initialization data.\n        return concat(...this._innerValues.map((i) => i.data));\n    }\n    /**\n     * Returns `true` if the given `InitDataValuesContainer` seems to be\n     * \"compatible\" with the one stored in this instance.\n     * Returns `false` if not.\n     *\n     * By \"compatible\" we mean that it will generate the same key request.\n     * @param {InitDataValuesContainer | Object} initDataValues\n     * @returns {boolean}\n     */\n    isCompatibleWith(initDataValues) {\n        const formatted = initDataValues instanceof InitDataValuesContainer\n            ? initDataValues.getFormattedValues()\n            : initDataValues;\n        return areInitializationValuesCompatible(this.getFormattedValues(), formatted);\n    }\n    /**\n     * Return the stored initialization data values, with added niceties:\n     *   - they are sorted always the same way for similar\n     *     `InitDataValuesContainer`\n     *   - each value is associated to its hash, which is always done with  the\n     *     same hashing function than for all other InitDataValuesContainer).\n     *\n     * The main point being to be able to compare much faster multiple\n     * `InitDataValuesContainer`, though that data can also be used in any\n     * other way.\n     * @returns {Array.<Object>}\n     */\n    getFormattedValues() {\n        if (this._lazyFormattedValues === null) {\n            this._lazyFormattedValues = formatInitDataValues(this._innerValues);\n        }\n        return this._lazyFormattedValues;\n    }\n}\n/**\n * Format given initializationData's values so they are faster to compare:\n *   - sort them by systemId\n *   - add hash for each initialization data encountered.\n * @param {Array.<Object>} initialValues\n * @returns {Array.<Object>}\n */\nfunction formatInitDataValues(initialValues) {\n    return initialValues\n        .slice()\n        .sort((a, b) => {\n        if (a.systemId === b.systemId) {\n            return 0;\n        }\n        if (a.systemId === undefined) {\n            return 1;\n        }\n        if (b.systemId === undefined) {\n            return -1;\n        }\n        if (a.systemId < b.systemId) {\n            return -1;\n        }\n        return 1;\n    })\n        .map(({ systemId, data }) => ({ systemId, data, hash: hashBuffer(data) }));\n}\n","import areCodecsCompatible from \"../../../utils/are_codecs_compatible\";\n/**\n * Find the first codec in the provided codec list that is compatible with the given mimeType and codec.\n * This first codec is called the \"compatible codec\". Return true if the \"compatible codec\"\n * is supported or false if it's not supported. If no \"compatible codec\" has been found, return undefined.\n *\n * @param {string} mimeType - The MIME type to check.\n * @param {string} codec - The codec to check.\n * @param {Array} codecList - The list of codecs to check against.\n * @returns {boolean|undefined} - True if the \"compatible codec\" is supported, false if not,\n * or undefined if no \"compatible codec\" is found.\n */\nexport default function isCompatibleCodecSupported(mimeType, codec, codecList) {\n    const inputCodec = `${mimeType};codecs=\"${codec}\"`;\n    const sameMimeTypeCodec = codecList.filter((c) => c.mimeType === mimeType);\n    if (sameMimeTypeCodec.length === 0) {\n        // No codec with the same MIME type was found.\n        return undefined;\n    }\n    for (const { codec: currentCodec, mimeType: currentMimeType, result, } of sameMimeTypeCodec) {\n        const existingCodec = `${currentMimeType};codecs=\"${currentCodec}\"`;\n        if (areCodecsCompatible(inputCodec, existingCodec)) {\n            return result;\n        }\n    }\n    // No compatible codec was found.\n    return undefined;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../../log\";\nimport arrayIncludes from \"../../../utils/array_includes\";\n/**\n * If all key statuses attached to session are valid (either not\n * \"expired\" or \"internal-error\"), return true.\n * If not, return false.\n * @param {MediaKeySession} loadedSession\n * @returns {MediaKeySession}\n */\nexport default function isSessionUsable(loadedSession) {\n    if (loadedSession.sessionId === \"\") {\n        return false;\n    }\n    const keyStatusesMap = loadedSession.keyStatuses;\n    const keyStatuses = [];\n    keyStatusesMap.forEach((keyStatus) => {\n        keyStatuses.push(keyStatus);\n    });\n    if (keyStatuses.length <= 0) {\n        log.debug(\"DRM: isSessionUsable: MediaKeySession given has an empty keyStatuses\", loadedSession.sessionId);\n        return false;\n    }\n    if (arrayIncludes(keyStatuses, \"expired\")) {\n        log.debug(\"DRM: isSessionUsable: MediaKeySession given has an expired key\", loadedSession.sessionId);\n        return false;\n    }\n    if (arrayIncludes(keyStatuses, \"internal-error\")) {\n        log.debug(\"DRM: isSessionUsable: MediaKeySession given has a key with an \" + \"internal-error\", loadedSession.sessionId);\n        return false;\n    }\n    log.debug(\"DRM: isSessionUsable: MediaKeySession is usable\", loadedSession.sessionId);\n    return true;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport areArraysOfNumbersEqual from \"../../../utils/are_arrays_of_numbers_equal\";\n/**\n * Returns `true` if all key ids in `wantedKeyIds` are present in the\n * `keyIdsArr` array.\n * @param {Array.<Uint8Array>} wantedKeyIds\n * @param {Array.<Uint8Array>} keyIdsArr\n * @returns {boolean}\n */\nexport function areAllKeyIdsContainedIn(wantedKeyIds, keyIdsArr) {\n    for (const keyId of wantedKeyIds) {\n        const found = keyIdsArr.some((k) => areArraysOfNumbersEqual(k, keyId));\n        if (!found) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Returns `true` if at least one key id in `wantedKeyIds` is present in the\n * `keyIdsArr` array.\n * @param {Array.<Uint8Array>} wantedKeyIds\n * @param {Array.<Uint8Array>} keyIdsArr\n * @returns {boolean}\n */\nexport function areSomeKeyIdsContainedIn(wantedKeyIds, keyIdsArr) {\n    for (const keyId of wantedKeyIds) {\n        const found = keyIdsArr.some((k) => areArraysOfNumbersEqual(k, keyId));\n        if (found) {\n            return true;\n        }\n    }\n    return false;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport areArraysOfNumbersEqual from \"../../../utils/are_arrays_of_numbers_equal\";\nimport { areAllKeyIdsContainedIn } from \"./key_id_comparison\";\n/**\n * Class storing key-related information linked to a created `MediaKeySession`.\n *\n * This class allows to regroup one or multiple key ids and can be linked to a\n * single MediaKeySession so you can know which key that MediaKeySession\n * handles.\n *\n * The main use case behind the complexities of this `KeySessionRecord` is to\n * better handle the `singleLicensePer` RxPlayer option, which allows the\n * recuperation of a license containing multiple keys, even if only one of\n * those keys was asked for (which in turn allows to reduce the number of\n * requests and to improve performance).\n * Here, the `KeySessionRecord` will regroup all those key's id and can be\n * linked to the corresponding MediaKeySession.\n * That way, you can later check if another encrypted content is compatible with\n * that session through the `KeySessionRecord`'s `isCompatibleWith` method.\n *\n * @example\n * ```js\n * const record = new KeySessionRecord(initData);\n *\n * // Create a MediaKeySession linked to that initialization data and fetch the\n * // license\n * // ...\n *\n * // Once the license has been loaded to the MediaKeySession linked to that\n - // initialization data, associate the license's key Ids with the latter.\n * record.associateKeyIds(someKeyIds);\n *\n * // Function called when new initialization data is encountered\n * function onNewInitializationData(newInitializationData) {\n *   if (record.isCompatibleWith(newInitializationData)) {\n *     console.log(\"This initialization data should already be handled, ignored.\");\n *   } else {\n *     console.log(\"This initialization data is not handled yet.\";\n *   }\n * }\n * ```\n * @class KeySessionRecord\n */\nexport default class KeySessionRecord {\n    /**\n     * Create a new `KeySessionRecord`, linked to its corresponding initialization\n     * data,\n     * @param {Object} initializationData\n     */\n    constructor(initializationData) {\n        this._initializationData = initializationData;\n        this._keyIds = null;\n    }\n    /**\n     * Associate supplementary key ids to this `KeySessionRecord` so it becomes\n     * \"compatible\" to them.\n     *\n     * After this call, new initialization data linked to subsets of those key\n     * ids will be considered compatible  to this `KeySessionRecord` (calls to\n     * `isCompatibleWith` with the corresponding initialization data will return\n     * `true`).\n     * @param {Array.<Uint8Array>} keyIds\n     */\n    associateKeyIds(keyIds) {\n        if (this._keyIds === null) {\n            this._keyIds = [];\n        }\n        const keyIdsArr = Array.from(keyIds);\n        for (const keyId of keyIdsArr) {\n            if (!this.isAssociatedWithKeyId(keyId)) {\n                this._keyIds.push(keyId);\n            }\n        }\n    }\n    /**\n     * @param {Uint8Array} keyId\n     * @returns {boolean}\n     */\n    isAssociatedWithKeyId(keyId) {\n        if (this._keyIds === null) {\n            return false;\n        }\n        for (const storedKeyId of this._keyIds) {\n            if (areArraysOfNumbersEqual(storedKeyId, keyId)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * @returns {Array.<Uint8Array>}\n     */\n    getAssociatedKeyIds() {\n        if (this._keyIds === null) {\n            return [];\n        }\n        return this._keyIds;\n    }\n    /**\n     * Check if that `KeySessionRecord` is compatible to the initialization data\n     * given.\n     *\n     * If it returns `true`, it means that this `KeySessionRecord` is already\n     * linked to that initialization data's key. As such, if that\n     * `KeySessionRecord` is already associated to an active MediaKeySession for\n     * example, the content linked to that initialization data should already be\n     * handled.\n     *\n     * If it returns `false`, it means that this `KeySessionRecord` has no\n     * relation with the given initialization data.\n     *\n     * @param {Object} initializationData\n     * @returns {boolean}\n     */\n    isCompatibleWith(initializationData) {\n        const { keyIds } = initializationData;\n        if (keyIds !== undefined && keyIds.length > 0) {\n            if (this._keyIds !== null && areAllKeyIdsContainedIn(keyIds, this._keyIds)) {\n                return true;\n            }\n            if (this._initializationData.keyIds !== undefined) {\n                return areAllKeyIdsContainedIn(keyIds, this._initializationData.keyIds);\n            }\n        }\n        return this._checkInitializationDataCompatibility(initializationData);\n    }\n    _checkInitializationDataCompatibility(initializationData) {\n        if (initializationData.keyIds !== undefined &&\n            initializationData.keyIds.length > 0 &&\n            this._initializationData.keyIds !== undefined) {\n            return areAllKeyIdsContainedIn(initializationData.keyIds, this._initializationData.keyIds);\n        }\n        if (this._initializationData.type !== initializationData.type) {\n            return false;\n        }\n        return this._initializationData.values.isCompatibleWith(initializationData.values);\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { closeSession, generateKeyRequest, loadSession } from \"../../../compat/eme\";\nimport log from \"../../../log\";\nimport assert from \"../../../utils/assert\";\nimport isNullOrUndefined from \"../../../utils/is_null_or_undefined\";\nimport KeySessionRecord from \"./key_session_record\";\n/**\n * Create and store MediaKeySessions linked to a single MediaKeys\n * instance.\n *\n * Keep track of sessionTypes and of the initialization data each\n * MediaKeySession is created for.\n * @class LoadedSessionsStore\n */\nexport default class LoadedSessionsStore {\n    /**\n     * Create a new LoadedSessionsStore, which will store information about\n     * loaded MediaKeySessions on the given MediaKeys instance.\n     * @param {MediaKeys} mediaKeys\n     */\n    constructor(mediaKeys) {\n        this._mediaKeys = mediaKeys;\n        this._storage = [];\n    }\n    /**\n     * Create a new MediaKeySession and store it in this store.\n     * @param {Object} initData\n     * @param {string} sessionType\n     * @returns {Object}\n     */\n    createSession(initData, sessionType) {\n        const keySessionRecord = new KeySessionRecord(initData);\n        log.debug(\"DRM-LSS: calling `createSession`\", sessionType);\n        const mediaKeySession = this._mediaKeys.createSession(sessionType);\n        const entry = {\n            mediaKeySession,\n            sessionType,\n            keySessionRecord,\n            isGeneratingRequest: false,\n            isLoadingPersistentSession: false,\n            closingStatus: { type: \"none\" },\n        };\n        if (!isNullOrUndefined(mediaKeySession.closed)) {\n            mediaKeySession.closed\n                .then(() => {\n                log.info(\"DRM-LSS: session was closed, removing it.\", mediaKeySession.sessionId);\n                const index = this.getIndex(keySessionRecord);\n                if (index >= 0 && this._storage[index].mediaKeySession === mediaKeySession) {\n                    this._storage.splice(index, 1);\n                }\n            })\n                .catch((e) => {\n                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                log.warn(`DRM-LSS: MediaKeySession.closed rejected: ${e}`);\n            });\n        }\n        this._storage.push(Object.assign({}, entry));\n        log.debug(\"DRM-LSS: MediaKeySession added\", entry.sessionType, this._storage.length);\n        return entry;\n    }\n    /**\n     * Find a stored entry compatible with the initialization data given and moves\n     * this entry at the end of the `LoadedSessionsStore`''s storage, returned by\n     * its `getAll` method.\n     *\n     * This can be used for example to tell when a previously-stored\n     * entry is re-used to then be able to implement a caching replacement\n     * algorithm based on the least-recently-used values by just evicting the first\n     * values returned by `getAll`.\n     * @param {Object} initializationData\n     * @returns {Object|null}\n     */\n    reuse(initializationData) {\n        for (let i = this._storage.length - 1; i >= 0; i--) {\n            const stored = this._storage[i];\n            if (stored.keySessionRecord.isCompatibleWith(initializationData)) {\n                this._storage.splice(i, 1);\n                this._storage.push(stored);\n                log.debug(\"DRM-LSS: Reusing session:\", stored.mediaKeySession.sessionId, stored.sessionType);\n                return Object.assign({}, stored);\n            }\n        }\n        return null;\n    }\n    /**\n     * Get `LoadedSessionsStore`'s entry for a given MediaKeySession.\n     * Returns `null` if the given MediaKeySession is not stored in the\n     * `LoadedSessionsStore`.\n     * @param {MediaKeySession} mediaKeySession\n     * @returns {Object|null}\n     */\n    getEntryForSession(mediaKeySession) {\n        for (let i = this._storage.length - 1; i >= 0; i--) {\n            const stored = this._storage[i];\n            if (stored.mediaKeySession === mediaKeySession) {\n                return Object.assign({}, stored);\n            }\n        }\n        return null;\n    }\n    /**\n     * Generate a license request on the given MediaKeySession, while indicating\n     * to the LoadedSessionsStore that a license-request is pending so\n     * session-closing orders are properly scheduled after it is done.\n     * @param {Object} mediaKeySession\n     * @param {string|undefined} initializationDataType - Initialization data type\n     * given e.g. by the \"encrypted\" event for the corresponding request.\n     * @param {Uint8Array} initializationData - Initialization data given e.g. by\n     * the \"encrypted\" event for the corresponding request.\n     * @returns {Promise}\n     */\n    async generateLicenseRequest(mediaKeySession, initializationDataType, initializationData) {\n        let entry;\n        for (const stored of this._storage) {\n            if (stored.mediaKeySession === mediaKeySession) {\n                entry = stored;\n                break;\n            }\n        }\n        if (entry === undefined) {\n            log.error(\"DRM-LSS: generateRequest error. No MediaKeySession found with \" +\n                \"the given initData and initDataType\");\n            return generateKeyRequest(mediaKeySession, initializationDataType, initializationData);\n        }\n        entry.isGeneratingRequest = true;\n        // Note the `as string` is needed due to TypeScript not understanding that\n        // the `closingStatus` might change in the next checks\n        if (entry.closingStatus.type !== \"none\") {\n            throw new Error(\"The `MediaKeySession` is being closed.\");\n        }\n        try {\n            await generateKeyRequest(mediaKeySession, initializationDataType, initializationData);\n        }\n        catch (err) {\n            if (entry === undefined) {\n                throw err;\n            }\n            entry.isGeneratingRequest = false;\n            if (entry.closingStatus.type === \"awaiting\") {\n                entry.closingStatus.start();\n            }\n            throw err;\n        }\n        if (entry === undefined) {\n            return undefined;\n        }\n        entry.isGeneratingRequest = false;\n        if (entry.closingStatus.type === \"awaiting\") {\n            entry.closingStatus.start();\n        }\n    }\n    /**\n     * @param {Object} mediaKeySession\n     * @param {string} sessionId\n     * @returns {Promise}\n     */\n    async loadPersistentSession(mediaKeySession, sessionId) {\n        let entry;\n        for (const stored of this._storage) {\n            if (stored.mediaKeySession === mediaKeySession) {\n                entry = stored;\n                break;\n            }\n        }\n        if (entry === undefined) {\n            log.error(\"DRM-LSS: loadPersistentSession error. No MediaKeySession found with \" +\n                \"the given initData and initDataType\");\n            return loadSession(mediaKeySession, sessionId);\n        }\n        entry.isLoadingPersistentSession = true;\n        // Note the `as string` is needed due to TypeScript not understanding that\n        // the `closingStatus` might change in the next checks\n        if (entry.closingStatus.type !== \"none\") {\n            throw new Error(\"The `MediaKeySession` is being closed.\");\n        }\n        let ret;\n        try {\n            ret = await loadSession(mediaKeySession, sessionId);\n        }\n        catch (err) {\n            if (entry === undefined) {\n                throw err;\n            }\n            entry.isLoadingPersistentSession = false;\n            if (entry.closingStatus.type === \"awaiting\") {\n                entry.closingStatus.start();\n            }\n            throw err;\n        }\n        if (entry === undefined) {\n            return ret;\n        }\n        entry.isLoadingPersistentSession = false;\n        if (entry.closingStatus.type === \"awaiting\") {\n            entry.closingStatus.start();\n        }\n        return ret;\n    }\n    /**\n     * Close a MediaKeySession and remove its related stored information from the\n     * `LoadedSessionsStore`.\n     * Emit when done.\n     * @param {Object} mediaKeySession\n     * @returns {Promise}\n     */\n    async closeSession(mediaKeySession) {\n        let entry;\n        for (const stored of this._storage) {\n            if (stored.mediaKeySession === mediaKeySession) {\n                entry = stored;\n                break;\n            }\n        }\n        if (entry === undefined) {\n            log.warn(\"DRM-LSS: No MediaKeySession found with \" + \"the given initData and initDataType\");\n            return Promise.resolve(false);\n        }\n        return this._closeEntry(entry);\n    }\n    /**\n     * Returns the number of stored MediaKeySessions in this LoadedSessionsStore.\n     * @returns {number}\n     */\n    getLength() {\n        return this._storage.length;\n    }\n    /**\n     * Returns information about all stored MediaKeySession, in the order in which\n     * the MediaKeySession have been created.\n     * @returns {Array.<Object>}\n     */\n    getAll() {\n        return this._storage;\n    }\n    /**\n     * Close all sessions in this store.\n     * Emit `null` when done.\n     * @returns {Promise}\n     */\n    async closeAllSessions() {\n        const allEntries = this._storage;\n        log.debug(\"DRM-LSS: Closing all current MediaKeySessions\", allEntries.length);\n        // re-initialize the storage, so that new interactions with the\n        // `LoadedSessionsStore` do not rely on MediaKeySessions we're in the\n        // process of removing\n        this._storage = [];\n        const closingProms = allEntries.map((entry) => this._closeEntry(entry));\n        await Promise.all(closingProms);\n    }\n    /**\n     * Find the given `MediaKeySession` in the `LoadedSessionsStore` and removes\n     * any reference to it without actually closing it.\n     *\n     * Returns `true` if the given `mediaKeySession` has been found and removed,\n     * `false` otherwise.\n     *\n     * Note that this may create a `MediaKeySession` leakage in the wrong\n     * conditions, cases where this method should be called should be very\n     * carefully evaluated.\n     * @param {MediaKeySession} mediaKeySession\n     * @returns {boolean}\n     */\n    removeSessionWithoutClosingIt(mediaKeySession) {\n        assert(mediaKeySession.sessionId === \"\", \"Initialized `MediaKeySession`s should always be properly closed\");\n        for (let i = this._storage.length - 1; i >= 0; i--) {\n            const stored = this._storage[i];\n            if (stored.mediaKeySession === mediaKeySession) {\n                log.debug(\"DRM-LSS: Removing session without closing it\", mediaKeySession.sessionId);\n                this._storage.splice(i, 1);\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Get the index of a stored MediaKeySession entry based on its\n     * `KeySessionRecord`.\n     * Returns -1 if not found.\n     * @param {Object} record\n     * @returns {number}\n     */\n    getIndex(record) {\n        for (let i = 0; i < this._storage.length; i++) {\n            const stored = this._storage[i];\n            if (stored.keySessionRecord === record) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    /**\n     * Prepare the closure of a `MediaKeySession` stored as an entry of the\n     * `LoadedSessionsStore`.\n     * Allows to postpone the closure action if another MediaKeySession action\n     * is already pending.\n     * @param {Object} entry\n     * @returns {Promise.<boolean>}\n     */\n    async _closeEntry(entry) {\n        const { mediaKeySession } = entry;\n        return new Promise((resolve, reject) => {\n            if (entry !== undefined &&\n                (entry.isLoadingPersistentSession || entry.isGeneratingRequest)) {\n                entry.closingStatus = {\n                    type: \"awaiting\",\n                    start: tryClosingEntryAndResolve,\n                };\n            }\n            else {\n                tryClosingEntryAndResolve();\n            }\n            function tryClosingEntryAndResolve() {\n                if (entry !== undefined) {\n                    entry.closingStatus = { type: \"pending\" };\n                }\n                safelyCloseMediaKeySession(mediaKeySession)\n                    .then(() => {\n                    if (entry !== undefined) {\n                        entry.closingStatus = { type: \"done\" };\n                    }\n                    resolve(true);\n                })\n                    .catch((err) => {\n                    if (entry !== undefined) {\n                        entry.closingStatus = { type: \"failed\" };\n                    }\n                    reject(err);\n                });\n            }\n        });\n    }\n}\n/**\n * Close a MediaKeySession and just log an error if it fails (while resolving).\n * Emits then complete when done.\n * @param {MediaKeySession} mediaKeySession\n * @returns {Promise}\n */\nasync function safelyCloseMediaKeySession(mediaKeySession) {\n    log.debug(\"DRM: Trying to close a MediaKeySession\", mediaKeySession.sessionId);\n    try {\n        await closeSession(mediaKeySession);\n        log.debug(\"DRM: Succeeded to close MediaKeySession\");\n        return;\n    }\n    catch (err) {\n        log.error(\"DRM: Could not close MediaKeySession: \" +\n            (err instanceof Error ? err.toString() : \"Unknown error\"));\n        return;\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { setMediaKeys } from \"../../../compat/eme/set_media_keys\";\nimport { EncryptedMediaError } from \"../../../errors\";\nimport log from \"../../../log\";\nimport isNullOrUndefined from \"../../../utils/is_null_or_undefined\";\n// Store the MediaKeys infos attached to a media element.\nconst currentMediaState = new WeakMap();\nexport default {\n    /**\n     * Attach new MediaKeys infos set on a HMTLMediaElement.\n     * @param {HTMLMediaElement} mediaElement\n     * @param {Object} mediaKeysInfo\n     * @returns {Promise}\n     */\n    async attach(mediaElement, mediaKeysInfo) {\n        const previousState = currentMediaState.get(mediaElement);\n        const pendingTask = attachMediaKeys(mediaElement, previousState, mediaKeysInfo).then(() => {\n            currentMediaState.set(mediaElement, {\n                pendingTask: null,\n                mediaKeysState: mediaKeysInfo,\n            });\n        }, () => {\n            currentMediaState.set(mediaElement, {\n                pendingTask: null,\n                mediaKeysState: null,\n            });\n        });\n        currentMediaState.set(mediaElement, {\n            pendingTask,\n            mediaKeysState: mediaKeysInfo,\n        });\n        return pendingTask;\n    },\n    /**\n     * Get MediaKeys information expected to be linked to the given\n     * `HTMLMediaElement`.\n     *\n     * Unlike `getAttachedMediaKeysState`, this method is synchronous and will\n     * also return the expected state when `MediaKeys` attachment is still\n     * pending and thus when that state is not truly applied (and where it\n     * might fail before being applied).\n     *\n     * As such, only call this method if you want the currently expected state,\n     * not the actual one.\n     * @param {HTMLMediaElement} mediaElement\n     * @returns {Array}\n     */\n    getAwaitedState(mediaElement) {\n        var _a;\n        const currentState = currentMediaState.get(mediaElement);\n        return (_a = currentState === null || currentState === void 0 ? void 0 : currentState.mediaKeysState) !== null && _a !== void 0 ? _a : null;\n    },\n    /**\n     * Get MediaKeys information set on a HMTLMediaElement.\n     *\n     * This method is asynchronous because that state may still be in a process\n     * of being attached to the `HTMLMediaElement` (and the state we're\n     * currently setting may not work out).\n     * @param {HTMLMediaElement} mediaElement\n     * @returns {Object|null}\n     */\n    async getAttachedMediaKeysState(mediaElement) {\n        const currentState = currentMediaState.get(mediaElement);\n        if (currentState === undefined) {\n            return null;\n        }\n        if (currentState.pendingTask !== null) {\n            await currentState.pendingTask;\n            return this.getAttachedMediaKeysState(mediaElement);\n        }\n        return currentState.mediaKeysState;\n    },\n    /**\n     * Remove MediaKeys currently set on a HMTLMediaElement and update state\n     * accordingly.\n     * @param {HTMLMediaElement} mediaElement\n     * @returns {Promise}\n     */\n    clearMediaKeys(mediaElement) {\n        const previousState = currentMediaState.get(mediaElement);\n        const pendingTask = clearMediaKeys(mediaElement, previousState).then(() => {\n            currentMediaState.set(mediaElement, {\n                pendingTask: null,\n                mediaKeysState: null,\n            });\n        }, () => {\n            currentMediaState.set(mediaElement, {\n                pendingTask: null,\n                mediaKeysState: null,\n            });\n        });\n        currentMediaState.set(mediaElement, {\n            pendingTask,\n            mediaKeysState: null,\n        });\n        return pendingTask;\n    },\n};\n/**\n * Ensure that the last `MediaKeys` set on the given HTMLMediaElement is\n * attached.\n *\n * The returned Promise never rejects, it will just log an error if the\n * previous attachment failed.\n *\n * @param {Object} previousState\n * @returns {Promise.<undefined>}\n */\nasync function awaitMediaKeysAttachment(previousState) {\n    const promise = previousState.pendingTask;\n    if (isNullOrUndefined(promise)) {\n        return;\n    }\n    log.info(\"DRM: Awaiting previous MediaKeys attachment operation\");\n    try {\n        await previousState.pendingTask;\n    }\n    catch (err) {\n        log.info(\"DRM: previous MediaKeys attachment operation failed\", err instanceof Error ? err : \"Unknown error\");\n    }\n}\nasync function attachMediaKeys(mediaElement, previousState, mediaKeysInfo) {\n    if (previousState !== undefined) {\n        if (previousState.pendingTask !== null) {\n            // Ensure the `MediaKeys` has been fully attached to the HTMLMediaElement before\n            // resetting things, to avoid browser errors due to an invalid state.\n            await awaitMediaKeysAttachment(previousState);\n        }\n        const closeAllSessions = !isNullOrUndefined(previousState.mediaKeysState) &&\n            previousState.mediaKeysState.loadedSessionsStore !==\n                mediaKeysInfo.loadedSessionsStore\n            ? previousState.mediaKeysState.loadedSessionsStore.closeAllSessions()\n            : Promise.resolve();\n        await closeAllSessions;\n        if (mediaElement.mediaKeys === mediaKeysInfo.mediaKeys) {\n            log.debug(\"DRM: Right MediaKeys already set\");\n            return;\n        }\n    }\n    log.info(\"DRM: Attaching MediaKeys to the media element\");\n    try {\n        await setMediaKeys(mediaKeysInfo.emeImplementation, mediaElement, mediaKeysInfo.mediaKeys);\n        log.info(\"DRM: MediaKeys attached with success\");\n    }\n    catch (err) {\n        const errMessage = err instanceof Error ? err.toString() : \"Unknown Error\";\n        throw new EncryptedMediaError(\"MEDIA_KEYS_ATTACHMENT_ERROR\", \"Could not attach the MediaKeys to the media element: \" + errMessage);\n    }\n}\nasync function clearMediaKeys(mediaElement, previousState) {\n    if (previousState === undefined) {\n        return;\n    }\n    if (previousState.pendingTask !== null) {\n        // Ensure the `MediaKeys` has been fully attached to the HTMLMediaElement before\n        // resetting things, to avoid browser errors due to an invalid state.\n        await awaitMediaKeysAttachment(previousState);\n    }\n    if (previousState.mediaKeysState === null) {\n        return;\n    }\n    log.info(\"DRM: Disposing of the current MediaKeys\");\n    const { loadedSessionsStore } = previousState.mediaKeysState;\n    await loadedSessionsStore.closeAllSessions();\n    return setMediaKeys(previousState.mediaKeysState.emeImplementation, mediaElement, null);\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../../log\";\nimport areArraysOfNumbersEqual from \"../../../utils/are_arrays_of_numbers_equal\";\nimport { assertInterface } from \"../../../utils/assert\";\nimport { bytesToBase64 } from \"../../../utils/base64\";\nimport hashBuffer from \"../../../utils/hash_buffer\";\nimport isNonEmptyString from \"../../../utils/is_non_empty_string\";\nimport isNullOrUndefined from \"../../../utils/is_null_or_undefined\";\nimport areInitializationValuesCompatible from \"./are_init_values_compatible\";\nimport SerializableBytes from \"./serializable_bytes\";\n/**\n * Throw if the given storage does not respect the right interface.\n * @param {Object} storage\n */\nfunction checkStorage(storage) {\n    assertInterface(storage, { save: \"function\", load: \"function\" }, \"persistentLicenseConfig\");\n}\n/**\n * Set representing persisted licenses. Depends on a simple\n * implementation with a `save`/`load` synchronous interface\n * to persist information on persisted sessions.\n *\n * This set is used only for a cdm/keysystem with license persistency\n * supported.\n * @class PersistentSessionsStore\n */\nexport default class PersistentSessionsStore {\n    /**\n     * Create a new PersistentSessionsStore.\n     * @param {Object} storage\n     */\n    constructor(storage) {\n        checkStorage(storage);\n        this._entries = [];\n        this._storage = storage;\n        try {\n            let entries = this._storage.load();\n            if (!Array.isArray(entries)) {\n                entries = [];\n            }\n            this._entries = entries;\n        }\n        catch (e) {\n            log.warn(\"DRM-PSS: Could not get entries from license storage\", e instanceof Error ? e : \"\");\n            this.dispose();\n        }\n    }\n    /**\n     * Returns the number of stored values.\n     * @returns {number}\n     */\n    getLength() {\n        return this._entries.length;\n    }\n    /**\n     * Returns information about all stored MediaKeySession, in the order in which\n     * the MediaKeySession have been created.\n     * @returns {Array.<Object>}\n     */\n    getAll() {\n        return this._entries;\n    }\n    /**\n     * Retrieve an entry based on its initialization data.\n     * @param {Object}  initData\n     * @returns {Object|null}\n     */\n    get(initData) {\n        const index = this._getIndex(initData);\n        return index === -1 ? null : this._entries[index];\n    }\n    /**\n     * Like `get`, but also move the corresponding value at the end of the store\n     * (as returned by `getAll`) if found.\n     * This can be used for example to tell when a previously-stored value is\n     * re-used to then be able to implement a caching replacement algorithm based\n     * on the least-recently-used values by just evicting the first values\n     * returned by `getAll`.\n     * @param {Object} initData\n     * @returns {*}\n     */\n    getAndReuse(initData) {\n        const index = this._getIndex(initData);\n        if (index === -1) {\n            return null;\n        }\n        const item = this._entries.splice(index, 1)[0];\n        this._entries.push(item);\n        return item;\n    }\n    /**\n     * Add a new entry in the PersistentSessionsStore.\n     * @param {Object}  initData\n     * @param {Array.<Uint8Array>|undefined} keyIds\n     * @param {MediaKeySession} session\n     */\n    add(initData, keyIds, session) {\n        var _a;\n        if (isNullOrUndefined(session) || !isNonEmptyString(session.sessionId)) {\n            log.warn(\"DRM-PSS: Invalid Persisten Session given.\");\n            return;\n        }\n        const { sessionId } = session;\n        const currentIndex = this._getIndex(initData);\n        if (currentIndex >= 0) {\n            const currVersion = keyIds === undefined ? 3 : 4;\n            const currentEntry = this._entries[currentIndex];\n            const entryVersion = (_a = currentEntry.version) !== null && _a !== void 0 ? _a : -1;\n            if (entryVersion >= currVersion && sessionId === currentEntry.sessionId) {\n                return;\n            }\n            log.info(\"DRM-PSS: Updating session info.\", sessionId);\n            this._entries.splice(currentIndex, 1);\n        }\n        else {\n            log.info(\"DRM-PSS: Add new session\", sessionId);\n        }\n        const storedValues = prepareValuesForStore(initData.values.getFormattedValues());\n        if (keyIds === undefined) {\n            this._entries.push({\n                version: 3,\n                sessionId,\n                values: storedValues,\n                initDataType: initData.type,\n            });\n        }\n        else {\n            this._entries.push({\n                version: 4,\n                sessionId,\n                keyIds: keyIds.map((k) => new SerializableBytes(k)),\n                values: storedValues,\n                initDataType: initData.type,\n            });\n        }\n        this._save();\n    }\n    /**\n     * Delete stored MediaKeySession information based on its session id.\n     * @param {string} sessionId\n     */\n    delete(sessionId) {\n        let index = -1;\n        for (let i = 0; i < this._entries.length; i++) {\n            const entry = this._entries[i];\n            if (entry.sessionId === sessionId) {\n                index = i;\n                break;\n            }\n        }\n        if (index === -1) {\n            log.warn(\"DRM-PSS: initData to delete not found.\");\n            return;\n        }\n        const entry = this._entries[index];\n        log.warn(\"DRM-PSS: Delete session from store\", entry.sessionId);\n        this._entries.splice(index, 1);\n        this._save();\n    }\n    deleteOldSessions(sessionsToDelete) {\n        log.info(`DRM-PSS: Deleting last ${sessionsToDelete} sessions.`);\n        if (sessionsToDelete <= 0) {\n            return;\n        }\n        if (sessionsToDelete <= this._entries.length) {\n            this._entries.splice(0, sessionsToDelete);\n        }\n        else {\n            log.warn(\"DRM-PSS: Asked to remove more information that it contains\", sessionsToDelete, this._entries.length);\n            this._entries = [];\n        }\n        this._save();\n    }\n    /**\n     * Delete all saved entries.\n     */\n    dispose() {\n        this._entries = [];\n        this._save();\n    }\n    /**\n     * Retrieve index of an entry.\n     * Returns `-1` if not found.\n     * @param {Object} initData\n     * @returns {number}\n     */\n    _getIndex(initData) {\n        // Older versions of the format include a concatenation of all\n        // initialization data and its hash.\n        // This is only computed lazily, the first time it is needed.\n        let lazyConcatenatedData = null;\n        function getConcatenatedInitDataInfo() {\n            if (lazyConcatenatedData === null) {\n                const concatInitData = initData.values.constructRequestData();\n                lazyConcatenatedData = {\n                    initData: concatInitData,\n                    initDataHash: hashBuffer(concatInitData),\n                };\n            }\n            return lazyConcatenatedData;\n        }\n        for (let i = 0; i < this._entries.length; i++) {\n            const entry = this._entries[i];\n            if (entry.initDataType === initData.type) {\n                switch (entry.version) {\n                    case 4:\n                        if (initData.keyIds !== undefined) {\n                            const foundCompatible = initData.keyIds.every((keyId) => {\n                                const keyIdB64 = bytesToBase64(keyId);\n                                for (const entryKid of entry.keyIds) {\n                                    if (typeof entryKid === \"string\") {\n                                        if (keyIdB64 === entryKid) {\n                                            return true;\n                                        }\n                                    }\n                                    else if (areArraysOfNumbersEqual(entryKid.initData, keyId)) {\n                                        return true;\n                                    }\n                                }\n                                return false;\n                            });\n                            if (foundCompatible) {\n                                return i;\n                            }\n                        }\n                        else {\n                            const formatted = initData.values.getFormattedValues();\n                            if (areInitializationValuesCompatible(formatted, entry.values)) {\n                                return i;\n                            }\n                        }\n                        break;\n                    case 3: {\n                        const formatted = initData.values.getFormattedValues();\n                        if (areInitializationValuesCompatible(formatted, entry.values)) {\n                            return i;\n                        }\n                        break;\n                    }\n                    case 2: {\n                        const { initData: concatInitData, initDataHash: concatHash } = getConcatenatedInitDataInfo();\n                        if (entry.initDataHash === concatHash) {\n                            try {\n                                const decodedInitData = typeof entry.initData === \"string\"\n                                    ? SerializableBytes.decode(entry.initData)\n                                    : entry.initData.initData;\n                                if (areArraysOfNumbersEqual(decodedInitData, concatInitData)) {\n                                    return i;\n                                }\n                            }\n                            catch (e) {\n                                log.warn(\"DRM-PSS: Could not decode initialization data.\", e instanceof Error ? e : \"\");\n                            }\n                        }\n                        break;\n                    }\n                    case 1: {\n                        const { initData: concatInitData, initDataHash: concatHash } = getConcatenatedInitDataInfo();\n                        if (entry.initDataHash === concatHash) {\n                            if (typeof entry.initData.length === \"undefined\") {\n                                // If length is undefined, it has been linearized. We could still\n                                // convert it back to an Uint8Array but this would necessitate some\n                                // ugly unreadable logic for a very very minor possibility.\n                                // Just consider that it is a match based on the hash.\n                                return i;\n                            }\n                            else if (areArraysOfNumbersEqual(entry.initData, concatInitData)) {\n                                return i;\n                            }\n                        }\n                        break;\n                    }\n                    default: {\n                        const { initDataHash: concatHash } = getConcatenatedInitDataInfo();\n                        if (entry.initData === concatHash) {\n                            return i;\n                        }\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n    /**\n     * Use the given storage to store the current entries.\n     */\n    _save() {\n        try {\n            this._storage.save(this._entries);\n        }\n        catch (e) {\n            const err = e instanceof Error ? e : undefined;\n            log.warn(\"DRM-PSS: Could not save MediaKeySession information\", err);\n        }\n    }\n}\n/**\n * Format given initializationData's values so they are ready to be stored:\n *   - sort them by systemId, so they are faster to compare\n *   - add hash for each initialization data encountered.\n * @param {Array.<Object>} initialValues\n * @returns {Array.<Object>}\n */\nfunction prepareValuesForStore(initialValues) {\n    return initialValues.map(({ systemId, data, hash }) => ({\n        systemId,\n        hash,\n        data: new SerializableBytes(data),\n    }));\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { base64ToBytes, bytesToBase64 } from \"../../../utils/base64\";\n/** Wrap byte-based data and allow serialization of it into base64. */\nexport default class SerializableBytes {\n    /**\n     * Create a new `SerializableBytes`, wrapping the initialization data\n     * given and allowing serialization into base64.\n     * @param {Uint8Array} initData\n     */\n    constructor(initData) {\n        this.initData = initData;\n    }\n    /**\n     * Convert it to base64.\n     * `toJSON` is specially interpreted by JavaScript engines to be able to rely\n     * on it when calling `JSON.stringify` on it or any of its parent objects:\n     * https://tc39.es/ecma262/#sec-serializejsonproperty\n     * @returns {string}\n     */\n    toJSON() {\n        return bytesToBase64(this.initData);\n    }\n    /**\n     * Decode a base64 sequence representing an initialization data back to an\n     * Uint8Array.\n     * @param {string}\n     * @returns {Uint8Array}\n     */\n    static decode(base64) {\n        return base64ToBytes(base64);\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport hashBuffer from \"../../../utils/hash_buffer\";\n/**\n * Keep track of server certificate which have been set for a MediaKeys.\n * As it is impossible for a MediaKeys to have his server certificate reset\n * or updated, we consider that once it has been set, it will remain set until\n * the MediaKeys instance is killed.\n *\n * So, a WeakMap helps keeping a trace of which server certificate (identified\n * with a unique hash) is set on a MediaKeys.\n * `null` indicate that we don't know (and not `undefined`, because this is the\n * default value for when a WeakMap has no value for a key) which server\n * certificate is attached to a MediaKeys instance (most likely because related\n * EME APIs failed or had an unexpected behavior).\n */\nconst serverCertificateHashesMap = new WeakMap();\n/** ServerCertificateStore */\nexport default {\n    /**\n     * Tells the ServerCertificateStore that you begin to call the APIs to set a\n     * ServerCertificate on `mediaKeys`.\n     *\n     * Calling this function is necessary due to how server certificate work\n     * currently in EME APIs:\n     * Because right now, it is impossible to tell if a MediaKeys instance has an\n     * attached ServerCertificate or not when the corresponding API fails or if it\n     * never answers, we prefer to announce through this function that the current\n     * server certificate attached to this MediaKeys is for now invalid.\n     * @param {MediaKeys | Object} mediaKeys\n     */\n    prepare(mediaKeys) {\n        serverCertificateHashesMap.set(mediaKeys, null);\n    },\n    /**\n     * Attach a new server certificate to a MediaKeys in the\n     * ServerCertificateStore.\n     *\n     * Only one server certificate should ever be attached to a MediaKeys\n     * instance and the `prepare` function should have been called before any\n     * action to update the server certificate took place (this function does not\n     * enforce either of those behaviors).\n     * @param {MediaKeys | Object} mediaKeys\n     * @param {ArrayBufferView | BufferSource} serverCertificate\n     */\n    set(mediaKeys, serverCertificate) {\n        const formattedServerCertificate = serverCertificate instanceof Uint8Array\n            ? serverCertificate\n            : new Uint8Array(serverCertificate instanceof ArrayBuffer\n                ? serverCertificate\n                : serverCertificate.buffer);\n        const hash = hashBuffer(formattedServerCertificate);\n        serverCertificateHashesMap.set(mediaKeys, {\n            hash,\n            serverCertificate: formattedServerCertificate,\n        });\n    },\n    /**\n     * Returns `true` if the MediaKeys instance has an attached ServerCertificate.\n     * Returns `false` if it doesn't.\n     *\n     * Returns `undefined` if we cannot know, most likely because related EME APIs\n     * failed or had an unexpected behavior.\n     * @param {MediaKeys} mediaKeys\n     * @returns {Boolean|undefined}\n     */\n    hasOne(mediaKeys) {\n        const currentServerCertificate = serverCertificateHashesMap.get(mediaKeys);\n        if (currentServerCertificate === undefined) {\n            return false;\n        }\n        if (currentServerCertificate === null) {\n            return undefined;\n        }\n        return true;\n    },\n    /**\n     * Returns `true` if the given `mediaKeys` has `serverCertificate` attached to\n     * it.\n     * Returns `false` either if it doesn't of if we doesn't know if it does.\n     * @param {MediaKeys | Object} mediaKeys\n     * @param {ArrayBufferView | BufferSource} serverCertificate\n     * @returns {boolean}\n     */\n    has(mediaKeys, serverCertificate) {\n        const serverCertificateHash = serverCertificateHashesMap.get(mediaKeys);\n        if (serverCertificateHash === undefined || serverCertificateHash === null) {\n            return false;\n        }\n        const { hash: oldHash, serverCertificate: oldServerCertificate } = serverCertificateHash;\n        const newServerCertificate = serverCertificate instanceof Uint8Array\n            ? serverCertificate\n            : new Uint8Array(serverCertificate instanceof ArrayBuffer\n                ? serverCertificate\n                : serverCertificate.buffer);\n        const newHash = hashBuffer(newServerCertificate);\n        if (newHash !== oldHash ||\n            oldServerCertificate.length !== newServerCertificate.length) {\n            return false;\n        }\n        for (let i = 0; i < oldServerCertificate.length; i++) {\n            if (oldServerCertificate[i] !== newServerCertificate[i]) {\n                return false;\n            }\n        }\n        return true;\n    },\n};\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport clearElementSrc from \"../../compat/clear_element_src\";\nimport log from \"../../log\";\nimport assert from \"../../utils/assert\";\nimport isNullOrUndefined from \"../../utils/is_null_or_undefined\";\nimport noop from \"../../utils/noop\";\nimport TaskCanceller from \"../../utils/task_canceller\";\nimport { ContentInitializer } from \"./types\";\nimport getLoadedReference from \"./utils/get_loaded_reference\";\nimport performInitialSeekAndPlay from \"./utils/initial_seek_and_play\";\nimport initializeContentDecryption from \"./utils/initialize_content_decryption\";\nimport RebufferingController from \"./utils/rebuffering_controller\";\nimport listenToMediaError from \"./utils/throw_on_media_error\";\n/**\n * `ContentIntializer` which will load contents by putting their URL in the\n * `src` attribute of the given HTMLMediaElement.\n *\n * Because such contents are mainly loaded by the browser, those (called\n * \"directfile\" contents in the RxPlayer) needs a simpler logic in-JS when\n * compared to a content that relies on the MSE API.\n *\n * @class DirectFileContentInitializer\n */\nexport default class DirectFileContentInitializer extends ContentInitializer {\n    /**\n     * Creates a new `DirectFileContentInitializer` linked to the given settings.\n     * @param {Object} settings\n     */\n    constructor(settings) {\n        super();\n        this._settings = settings;\n        this._initCanceller = new TaskCanceller();\n    }\n    /**\n     * \"Prepare\" content so it can later be played by calling `start`.\n     */\n    prepare() {\n        return; // Directfile contents do not have any preparation\n    }\n    /**\n     * Start playback of the content linked to this `DirectFileContentInitializer`\n     * on the given `HTMLMediaElement` and its associated `PlaybackObserver`.\n     * @param {HTMLMediaElement} mediaElement - HTMLMediaElement on which the\n     * content will be played.\n     * @param {Object} playbackObserver - Object regularly emitting playback\n     * information.\n     */\n    start(mediaElement, playbackObserver) {\n        const cancelSignal = this._initCanceller.signal;\n        const { keySystems, speed, url } = this._settings;\n        clearElementSrc(mediaElement);\n        const { statusRef: drmInitRef } = initializeContentDecryption(mediaElement, keySystems, {\n            onError: (err) => this._onFatalError(err),\n            onWarning: (err) => this.trigger(\"warning\", err),\n            onBlackListProtectionData: noop,\n            onKeyIdsCompatibilityUpdate: noop,\n        }, cancelSignal);\n        /** Translate errors coming from the media element into RxPlayer errors. */\n        listenToMediaError(mediaElement, (error) => this._onFatalError(error), cancelSignal);\n        /**\n         * Class trying to avoid various stalling situations, emitting \"stalled\"\n         * events when it cannot, as well as \"unstalled\" events when it get out of one.\n         */\n        const rebufferingController = new RebufferingController(playbackObserver, null, speed);\n        rebufferingController.addEventListener(\"stalled\", (evt) => this.trigger(\"stalled\", evt));\n        rebufferingController.addEventListener(\"unstalled\", () => this.trigger(\"unstalled\", null));\n        rebufferingController.addEventListener(\"warning\", (err) => this.trigger(\"warning\", err));\n        cancelSignal.register(() => {\n            rebufferingController.destroy();\n        });\n        rebufferingController.start();\n        drmInitRef.onUpdate((evt, stopListeningToDrmUpdates) => {\n            if (evt.initializationState.type === \"uninitialized\") {\n                return; // nothing done yet\n            }\n            stopListeningToDrmUpdates();\n            // Start everything! (Just put the URL in the element's src).\n            log.info(\"Setting URL to HTMLMediaElement\", url);\n            mediaElement.src = url;\n            cancelSignal.register(() => {\n                log.info(\"Init: Removing directfile src from media element\", mediaElement.src);\n                clearElementSrc(mediaElement);\n            });\n            if (evt.initializationState.type === \"awaiting-media-link\") {\n                evt.initializationState.value.isMediaLinked.setValue(true);\n                drmInitRef.onUpdate((newDrmStatus, stopListeningToDrmUpdatesAgain) => {\n                    if (newDrmStatus.initializationState.type === \"initialized\") {\n                        stopListeningToDrmUpdatesAgain();\n                        this._seekAndPlay(mediaElement, playbackObserver);\n                    }\n                }, { emitCurrentValue: true, clearSignal: cancelSignal });\n            }\n            else {\n                assert(evt.initializationState.type === \"initialized\");\n                this._seekAndPlay(mediaElement, playbackObserver);\n            }\n        }, { emitCurrentValue: true, clearSignal: cancelSignal });\n    }\n    /**\n     * Update URL this `ContentIntializer` depends on.\n     * @param {Array.<string>|undefined} _urls\n     * @param {boolean} _refreshNow\n     */\n    updateContentUrls(_urls, _refreshNow) {\n        throw new Error(\"Cannot update content URL of directfile contents\");\n    }\n    /**\n     * Stop content and free all resources linked to this `ContentIntializer`.\n     */\n    dispose() {\n        this._initCanceller.cancel();\n    }\n    /**\n     * Logic performed when a fatal error was triggered.\n     * @param {*} err - The fatal error in question.\n     */\n    _onFatalError(err) {\n        this._initCanceller.cancel();\n        this.trigger(\"error\", err);\n    }\n    /**\n     * Perform the initial seek (to begin playback at an initially-calculated\n     * position based on settings) and auto-play if needed when loaded.\n     * @param {HTMLMediaElement} mediaElement\n     * @param {Object} playbackObserver\n     */\n    _seekAndPlay(mediaElement, playbackObserver) {\n        const cancelSignal = this._initCanceller.signal;\n        const { autoPlay, startAt } = this._settings;\n        const initialTime = () => {\n            log.debug(\"Init: Calculating initial time\");\n            const initTime = getDirectFileInitialTime(mediaElement, startAt);\n            log.debug(\"Init: Initial time calculated:\", initTime);\n            return initTime;\n        };\n        performInitialSeekAndPlay({\n            mediaElement,\n            playbackObserver,\n            startTime: initialTime,\n            mustAutoPlay: autoPlay,\n            onWarning: (err) => this.trigger(\"warning\", err),\n            isDirectfile: true,\n        }, cancelSignal)\n            .autoPlayResult.then(() => getLoadedReference(playbackObserver, true, cancelSignal).onUpdate((isLoaded, stopListening) => {\n            if (isLoaded) {\n                stopListening();\n                this.trigger(\"loaded\", {\n                    getSegmentSinkMetrics: null,\n                    getThumbnailData: () => Promise.reject(new Error(\"Thumbnail data not available with directfile contents\")),\n                });\n            }\n        }, { emitCurrentValue: true, clearSignal: cancelSignal }))\n            .catch((err) => {\n            if (!cancelSignal.isCancelled()) {\n                this._onFatalError(err);\n            }\n        });\n    }\n}\n/**\n * calculate initial time as a position in seconds.\n * @param {HTMLMediaElement} mediaElement\n * @param {Object|undefined} [startAt]\n * @returns {number}\n */\nfunction getDirectFileInitialTime(mediaElement, startAt) {\n    if (isNullOrUndefined(startAt)) {\n        return 0;\n    }\n    if (!isNullOrUndefined(startAt.position)) {\n        return startAt.position;\n    }\n    else if (!isNullOrUndefined(startAt.wallClockTime)) {\n        return startAt.wallClockTime;\n    }\n    else if (!isNullOrUndefined(startAt.fromFirstPosition)) {\n        return startAt.fromFirstPosition;\n    }\n    const duration = mediaElement.duration;\n    if (typeof startAt.fromLastPosition === \"number\") {\n        if (!isNullOrUndefined(duration) && isFinite(duration)) {\n            return Math.max(0, duration + startAt.fromLastPosition);\n        }\n        if (mediaElement.seekable.length > 0) {\n            const lastSegmentEnd = mediaElement.seekable.end(mediaElement.seekable.length - 1);\n            if (isFinite(lastSegmentEnd)) {\n                return Math.max(0, lastSegmentEnd + startAt.fromLastPosition);\n            }\n        }\n        log.warn(\"Init: startAt.fromLastPosition set but no known duration, \" +\n            \"it may be too soon to seek\");\n        return undefined;\n    }\n    else if (typeof startAt.fromLivePosition === \"number\") {\n        const livePosition = mediaElement.seekable.length > 0 ? mediaElement.seekable.end(0) : duration;\n        if (isNullOrUndefined(livePosition)) {\n            log.warn(\"Init: startAt.fromLivePosition set but no known live position, \" +\n                \"beginning at 0.\");\n            return 0;\n        }\n        return Math.max(0, livePosition + startAt.fromLivePosition);\n    }\n    else if (!isNullOrUndefined(startAt.percentage)) {\n        if (isNullOrUndefined(duration) || !isFinite(duration)) {\n            log.warn(\"Init: startAt.percentage set but no known duration, \" + \"beginning at 0.\");\n            return 0;\n        }\n        const { percentage } = startAt;\n        if (percentage >= 100) {\n            return duration;\n        }\n        else if (percentage <= 0) {\n            return 0;\n        }\n        const ratio = +percentage / 100;\n        return duration * ratio;\n    }\n    return 0;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport isCodecSupported from \"../../compat/is_codec_supported\";\nimport mayMediaElementFailOnUndecipherableData from \"../../compat/may_media_element_fail_on_undecipherable_data\";\nimport shouldReloadMediaSourceOnDecipherabilityUpdate from \"../../compat/should_reload_media_source_on_decipherability_update\";\nimport config from \"../../config\";\nimport AdaptiveRepresentationSelector from \"../../core/adaptive\";\nimport CmcdDataBuilder from \"../../core/cmcd\";\nimport { CdnPrioritizer, createThumbnailFetcher, ManifestFetcher, SegmentQueueCreator, } from \"../../core/fetchers\";\nimport createContentTimeBoundariesObserver from \"../../core/main/common/create_content_time_boundaries_observer\";\nimport FreezeResolver from \"../../core/main/common/FreezeResolver\";\nimport getThumbnailData from \"../../core/main/common/get_thumbnail_data\";\nimport synchronizeSegmentSinksOnObservation from \"../../core/main/common/synchronize_sinks_on_observation\";\nimport SegmentSinksStore from \"../../core/segment_sinks\";\nimport StreamOrchestrator from \"../../core/stream\";\nimport { MediaError } from \"../../errors\";\nimport features from \"../../features\";\nimport log from \"../../log\";\nimport areArraysOfNumbersEqual from \"../../utils/are_arrays_of_numbers_equal\";\nimport assert, { assertUnreachable } from \"../../utils/assert\";\nimport createCancellablePromise from \"../../utils/create_cancellable_promise\";\nimport isNullOrUndefined from \"../../utils/is_null_or_undefined\";\nimport noop from \"../../utils/noop\";\nimport objectAssign from \"../../utils/object_assign\";\nimport SyncOrAsync from \"../../utils/sync_or_async\";\nimport TaskCanceller from \"../../utils/task_canceller\";\nimport { ContentDecryptorState, getKeySystemConfiguration } from \"../decrypt\";\nimport { ContentInitializer } from \"./types\";\nimport createCorePlaybackObserver from \"./utils/create_core_playback_observer\";\nimport createMediaSource from \"./utils/create_media_source\";\nimport getInitialTime from \"./utils/get_initial_time\";\nimport getLoadedReference from \"./utils/get_loaded_reference\";\nimport performInitialSeekAndPlay from \"./utils/initial_seek_and_play\";\nimport initializeContentDecryption from \"./utils/initialize_content_decryption\";\nimport MainThreadTextDisplayerInterface from \"./utils/main_thread_text_displayer_interface\";\nimport RebufferingController from \"./utils/rebuffering_controller\";\nimport StreamEventsEmitter from \"./utils/stream_events_emitter\";\nimport listenToMediaError from \"./utils/throw_on_media_error\";\n/**\n * Allows to load a new content thanks to the MediaSource Extensions (a.k.a. MSE)\n * Web APIs.\n *\n * Through this `ContentInitializer`, a Manifest will be fetched (and depending\n * on the situation, refreshed), a `MediaSource` instance will be linked to the\n * wanted `HTMLMediaElement` and chunks of media data, called segments, will be\n * pushed on buffers associated to this `MediaSource` instance.\n *\n * @class MediaSourceContentInitializer\n */\nexport default class MediaSourceContentInitializer extends ContentInitializer {\n    /**\n     * Create a new `MediaSourceContentInitializer`, associated to the given\n     * settings.\n     * @param {Object} settings\n     */\n    constructor(settings) {\n        super();\n        this._initSettings = settings;\n        this._initCanceller = new TaskCanceller();\n        this._manifest = null;\n        this._decryptionCapabilities = { status: \"uninitialized\", value: null };\n        const urls = settings.url === undefined ? undefined : [settings.url];\n        this._cmcdDataBuilder =\n            settings.cmcd === undefined ? null : new CmcdDataBuilder(settings.cmcd);\n        this._manifestFetcher = new ManifestFetcher(urls, settings.transport, Object.assign(Object.assign({}, settings.manifestRequestSettings), { lowLatencyMode: settings.lowLatencyMode, cmcdDataBuilder: this._cmcdDataBuilder }));\n    }\n    /**\n     * Perform non-destructive preparation steps, to prepare a future content.\n     * For now, this mainly mean loading the Manifest document.\n     */\n    prepare() {\n        if (this._manifest !== null) {\n            return;\n        }\n        this._manifest = SyncOrAsync.createAsync(createCancellablePromise(this._initCanceller.signal, (res, rej) => {\n            this._manifestFetcher.addEventListener(\"warning\", (err) => this.trigger(\"warning\", err));\n            this._manifestFetcher.addEventListener(\"error\", (err) => {\n                this.trigger(\"error\", err);\n                rej(err);\n            });\n            this._manifestFetcher.addEventListener(\"manifestReady\", (manifest) => {\n                res(manifest);\n            });\n        }));\n        this._manifestFetcher.start();\n        this._initCanceller.signal.register(() => {\n            this._manifestFetcher.dispose();\n        });\n    }\n    /**\n     * @param {HTMLMediaElement} mediaElement\n     * @param {Object} playbackObserver\n     */\n    start(mediaElement, playbackObserver) {\n        this.prepare(); // Load Manifest if not already done\n        /** Translate errors coming from the media element into RxPlayer errors. */\n        listenToMediaError(mediaElement, (error) => this._onFatalError(error), this._initCanceller.signal);\n        this._setupInitialMediaSourceAndDecryption(mediaElement)\n            .then((initResult) => this._onInitialMediaSourceReady(mediaElement, initResult.mediaSource, playbackObserver, initResult.drmSystemId, initResult.unlinkMediaSource))\n            .catch((err) => {\n            this._onFatalError(err);\n        });\n    }\n    /**\n     * Update URL of the Manifest.\n     * @param {Array.<string>|undefined} urls - URLs to reach that Manifest from\n     * the most prioritized URL to the least prioritized URL.\n     * @param {boolean} refreshNow - If `true` the resource in question (e.g.\n     * DASH's MPD) will be refreshed immediately.\n     */\n    updateContentUrls(urls, refreshNow) {\n        this._manifestFetcher.updateContentUrls(urls, refreshNow);\n    }\n    /**\n     * Stop content and free all resources linked to this\n     * `MediaSourceContentInitializer`.\n     */\n    dispose() {\n        this._initCanceller.cancel();\n    }\n    /**\n     * Callback called when an error interrupting playback arised.\n     * @param {*} err\n     */\n    _onFatalError(err) {\n        if (this._initCanceller.isUsed()) {\n            return;\n        }\n        this._initCanceller.cancel();\n        this.trigger(\"error\", err);\n    }\n    /**\n     * Initialize decryption mechanisms if needed and begin creating and relying\n     * on the initial `MediaSourceInterface` for this content.\n     * @param {HTMLMediaElement|null} mediaElement\n     * @returns {Promise.<Object>}\n     */\n    _setupInitialMediaSourceAndDecryption(mediaElement) {\n        const initCanceller = this._initCanceller;\n        return createCancellablePromise(initCanceller.signal, (resolve) => {\n            const { keySystems } = this._initSettings;\n            /** Initialize decryption capabilities. */\n            const { statusRef: drmInitRef, contentDecryptor } = initializeContentDecryption(mediaElement, keySystems, {\n                onWarning: (err) => this.trigger(\"warning\", err),\n                onError: (err) => this._onFatalError(err),\n                onBlackListProtectionData: (val) => {\n                    // Ugly IIFE workaround to allow async event listener\n                    (async () => {\n                        var _a;\n                        if (this._manifest === null) {\n                            return;\n                        }\n                        const manifest = (_a = this._manifest.syncValue) !== null && _a !== void 0 ? _a : (await this._manifest.getValueAsAsync());\n                        blackListProtectionDataOnManifest(manifest, val);\n                    })().catch(noop);\n                },\n                onKeyIdsCompatibilityUpdate: (updates) => {\n                    // Ugly IIFE workaround to allow async event listener\n                    (async () => {\n                        var _a;\n                        if (this._manifest === null) {\n                            return;\n                        }\n                        const manifest = (_a = this._manifest.syncValue) !== null && _a !== void 0 ? _a : (await this._manifest.getValueAsAsync());\n                        updateKeyIdsDecipherabilityOnManifest(manifest, updates.whitelistedKeyIds, updates.blacklistedKeyIds, updates.delistedKeyIds);\n                    })().catch(noop);\n                },\n                onCodecSupportUpdate: () => {\n                    var _a, _b;\n                    const syncManifest = (_a = this._manifest) === null || _a === void 0 ? void 0 : _a.syncValue;\n                    if (isNullOrUndefined(syncManifest)) {\n                        // The Manifest is not yet fetched, but we will be able to check\n                        // the codecs once it is the case\n                        (_b = this._manifest) === null || _b === void 0 ? void 0 : _b.getValueAsAsync().then((loadedManifest) => {\n                            if (this._initCanceller.isUsed()) {\n                                return;\n                            }\n                            this._refreshManifestCodecSupport(loadedManifest);\n                        }, noop);\n                    }\n                    else {\n                        this._refreshManifestCodecSupport(syncManifest);\n                    }\n                },\n            }, initCanceller.signal);\n            if (contentDecryptor.enabled) {\n                this._decryptionCapabilities = {\n                    status: \"enabled\",\n                    value: contentDecryptor.value,\n                };\n            }\n            else {\n                this._decryptionCapabilities = {\n                    status: \"disabled\",\n                    value: contentDecryptor.value,\n                };\n            }\n            drmInitRef.onUpdate((drmStatus, stopListeningToDrmUpdates) => {\n                if (drmStatus.initializationState.type === \"uninitialized\") {\n                    return;\n                }\n                stopListeningToDrmUpdates();\n                const mediaSourceCanceller = new TaskCanceller();\n                mediaSourceCanceller.linkToSignal(initCanceller.signal);\n                createMediaSource(mediaElement, mediaSourceCanceller.signal)\n                    .then((mediaSource) => {\n                    const lastDrmStatus = drmInitRef.getValue();\n                    if (lastDrmStatus.initializationState.type === \"awaiting-media-link\") {\n                        lastDrmStatus.initializationState.value.isMediaLinked.setValue(true);\n                        drmInitRef.onUpdate((newDrmStatus, stopListeningToDrmUpdatesAgain) => {\n                            if (newDrmStatus.initializationState.type === \"initialized\") {\n                                stopListeningToDrmUpdatesAgain();\n                                resolve({\n                                    mediaSource,\n                                    drmSystemId: newDrmStatus.drmSystemId,\n                                    unlinkMediaSource: mediaSourceCanceller,\n                                });\n                                return;\n                            }\n                        }, { emitCurrentValue: true, clearSignal: initCanceller.signal });\n                    }\n                    else if (drmStatus.initializationState.type === \"initialized\") {\n                        resolve({\n                            mediaSource,\n                            drmSystemId: drmStatus.drmSystemId,\n                            unlinkMediaSource: mediaSourceCanceller,\n                        });\n                        return;\n                    }\n                })\n                    .catch((err) => {\n                    if (mediaSourceCanceller.isUsed()) {\n                        return;\n                    }\n                    this._onFatalError(err);\n                });\n            }, { emitCurrentValue: true, clearSignal: initCanceller.signal });\n        });\n    }\n    async _onInitialMediaSourceReady(mediaElement, initialMediaSource, playbackObserver, drmSystemId, initialMediaSourceCanceller) {\n        var _a;\n        const { adaptiveOptions, autoPlay, bufferOptions, lowLatencyMode, segmentRequestOptions, speed, startAt, textTrackOptions, transport, } = this._initSettings;\n        const initCanceller = this._initCanceller;\n        assert(this._manifest !== null);\n        let manifest;\n        try {\n            manifest = (_a = this._manifest.syncValue) !== null && _a !== void 0 ? _a : (await this._manifest.getValueAsAsync());\n        }\n        catch (_e) {\n            return; // The error should already have been processed through an event listener\n        }\n        manifest.addEventListener(\"manifestUpdate\", (updates) => {\n            this.trigger(\"manifestUpdate\", updates);\n            this._refreshManifestCodecSupport(manifest);\n        }, initCanceller.signal);\n        manifest.addEventListener(\"decipherabilityUpdate\", (elts) => {\n            this.trigger(\"decipherabilityUpdate\", elts);\n        }, initCanceller.signal);\n        manifest.addEventListener(\"supportUpdate\", () => {\n            this.trigger(\"codecSupportUpdate\", null);\n        }, initCanceller.signal);\n        log.debug(\"Init: Calculating initial time\");\n        const initialTime = getInitialTime(manifest, lowLatencyMode, startAt);\n        log.debug(\"Init: Initial time calculated:\", initialTime);\n        /** Choose the right \"Representation\" for a given \"Adaptation\". */\n        const representationEstimator = AdaptiveRepresentationSelector(adaptiveOptions);\n        const subBufferOptions = objectAssign({ textTrackOptions, drmSystemId }, bufferOptions);\n        const cdnPrioritizer = new CdnPrioritizer(initCanceller.signal);\n        const segmentQueueCreator = new SegmentQueueCreator(transport, cdnPrioritizer, this._cmcdDataBuilder, segmentRequestOptions);\n        this._refreshManifestCodecSupport(manifest);\n        this.trigger(\"manifestReady\", manifest);\n        if (initCanceller.isUsed()) {\n            return;\n        }\n        // handle initial load and reloads\n        this._setupContentWithNewMediaSource({\n            mediaElement,\n            playbackObserver,\n            mediaSource: initialMediaSource,\n            initialTime,\n            autoPlay,\n            manifest,\n            representationEstimator,\n            cdnPrioritizer,\n            segmentQueueCreator,\n            speed,\n            bufferOptions: subBufferOptions,\n        }, initialMediaSourceCanceller);\n    }\n    /**\n     * Load the content defined by the Manifest in the mediaSource given at the\n     * given position and playing status.\n     * This function recursively re-call itself when a MediaSource reload is\n     * wanted.\n     * @param {Object} args\n     * @param {Object} currentCanceller\n     */\n    _setupContentWithNewMediaSource(args, currentCanceller) {\n        this._startLoadingContentOnMediaSource(args, this._createReloadMediaSourceCallback(args, currentCanceller), currentCanceller.signal);\n    }\n    /**\n     * Create `IReloadMediaSourceCallback` allowing to handle reload orders.\n     * @param {Object} args\n     * @param {Object} currentCanceller\n     */\n    _createReloadMediaSourceCallback(args, currentCanceller) {\n        const initCanceller = this._initCanceller;\n        return (reloadOrder) => {\n            currentCanceller.cancel();\n            if (initCanceller.isUsed()) {\n                return;\n            }\n            this.trigger(\"reloadingMediaSource\", reloadOrder);\n            if (initCanceller.isUsed()) {\n                return;\n            }\n            const newCanceller = new TaskCanceller();\n            newCanceller.linkToSignal(initCanceller.signal);\n            createMediaSource(args.mediaElement, newCanceller.signal)\n                .then((newMediaSource) => {\n                this._setupContentWithNewMediaSource(Object.assign(Object.assign({}, args), { mediaSource: newMediaSource, initialTime: reloadOrder.position, autoPlay: reloadOrder.autoPlay }), newCanceller);\n            })\n                .catch((err) => {\n                if (newCanceller.isUsed()) {\n                    return;\n                }\n                this._onFatalError(err);\n            });\n        };\n    }\n    /**\n     * Buffer the content on the given MediaSource.\n     * @param {Object} args\n     * @param {function} onReloadOrder\n     * @param {Object} cancelSignal\n     */\n    _startLoadingContentOnMediaSource(args, onReloadOrder, cancelSignal) {\n        var _a, _b;\n        const { autoPlay, bufferOptions, initialTime, manifest, mediaElement, mediaSource, playbackObserver, representationEstimator, cdnPrioritizer, segmentQueueCreator, speed, } = args;\n        const { transport } = this._initSettings;\n        const initialPeriod = (_a = manifest.getPeriodForTime(initialTime)) !== null && _a !== void 0 ? _a : manifest.getNextPeriod(initialTime);\n        if (initialPeriod === undefined) {\n            const error = new MediaError(\"MEDIA_STARTING_TIME_NOT_FOUND\", \"Wanted starting time not found in the Manifest.\");\n            return this._onFatalError(error);\n        }\n        let textDisplayerInterface = null;\n        const textDisplayer = createTextDisplayer(mediaElement, this._initSettings.textTrackOptions);\n        if (textDisplayer !== null) {\n            const sender = new MainThreadTextDisplayerInterface(textDisplayer);\n            textDisplayerInterface = sender;\n            cancelSignal.register(() => {\n                sender.stop();\n                textDisplayer === null || textDisplayer === void 0 ? void 0 : textDisplayer.stop();\n            });\n        }\n        /** Interface to create media buffers. */\n        const segmentSinksStore = new SegmentSinksStore(mediaSource, mediaElement.nodeName === \"VIDEO\", textDisplayerInterface);\n        cancelSignal.register(() => {\n            segmentSinksStore.disposeAll();\n        });\n        const { autoPlayResult, initialPlayPerformed } = performInitialSeekAndPlay({\n            mediaElement,\n            playbackObserver,\n            startTime: initialTime,\n            mustAutoPlay: autoPlay,\n            onWarning: (err) => {\n                this.trigger(\"warning\", err);\n            },\n            isDirectfile: false,\n        }, cancelSignal);\n        if (cancelSignal.isCancelled()) {\n            return;\n        }\n        initialPlayPerformed.onUpdate((isPerformed, stopListening) => {\n            if (isPerformed) {\n                stopListening();\n                const streamEventsEmitter = new StreamEventsEmitter(manifest, playbackObserver);\n                manifest.addEventListener(\"manifestUpdate\", () => {\n                    streamEventsEmitter.onManifestUpdate(manifest);\n                }, cancelSignal);\n                streamEventsEmitter.addEventListener(\"event\", (payload) => {\n                    this.trigger(\"streamEvent\", payload);\n                }, cancelSignal);\n                streamEventsEmitter.addEventListener(\"eventSkip\", (payload) => {\n                    this.trigger(\"streamEventSkip\", payload);\n                }, cancelSignal);\n                streamEventsEmitter.start();\n                cancelSignal.register(() => {\n                    streamEventsEmitter.stop();\n                });\n            }\n        }, { clearSignal: cancelSignal, emitCurrentValue: true });\n        const coreObserver = createCorePlaybackObserver(playbackObserver, {\n            autoPlay,\n            manifest,\n            mediaSource,\n            textDisplayer,\n            initialPlayPerformed,\n            speed,\n        }, cancelSignal);\n        (_b = this._cmcdDataBuilder) === null || _b === void 0 ? void 0 : _b.startMonitoringPlayback(coreObserver);\n        cancelSignal.register(() => {\n            var _a;\n            (_a = this._cmcdDataBuilder) === null || _a === void 0 ? void 0 : _a.stopMonitoringPlayback();\n        });\n        const rebufferingController = this._createRebufferingController(playbackObserver, manifest, speed, cancelSignal);\n        const freezeResolver = new FreezeResolver(segmentSinksStore);\n        if (mayMediaElementFailOnUndecipherableData) {\n            // On some devices, just reload immediately when data become undecipherable\n            manifest.addEventListener(\"decipherabilityUpdate\", (elts) => {\n                if (elts.some((e) => e.representation.decipherable !== true)) {\n                    reloadMediaSource(0, undefined, undefined);\n                }\n            }, cancelSignal);\n        }\n        coreObserver.listen((observation) => {\n            synchronizeSegmentSinksOnObservation(observation, segmentSinksStore);\n            const freezeResolution = freezeResolver.onNewObservation(observation);\n            if (freezeResolution === null) {\n                return;\n            }\n            // TODO: The following method looks generic, we may be able to factorize\n            // it with other reload handlers after some work.\n            const triggerReload = () => {\n                var _a;\n                const lastObservation = playbackObserver.getReference().getValue();\n                const position = lastObservation.position.isAwaitingFuturePosition()\n                    ? lastObservation.position.getWanted()\n                    : ((_a = coreObserver.getCurrentTime()) !== null && _a !== void 0 ? _a : lastObservation.position.getPolled());\n                const autoplay = initialPlayPerformed.getValue()\n                    ? !playbackObserver.getIsPaused()\n                    : autoPlay;\n                onReloadOrder({ position, autoPlay: autoplay });\n            };\n            handleFreezeResolution(freezeResolution, {\n                enableRepresentationAvoidance: this._initSettings.enableRepresentationAvoidance,\n                manifest,\n                triggerReload,\n                playbackObserver,\n            });\n        }, { clearSignal: cancelSignal });\n        const contentTimeBoundariesObserver = createContentTimeBoundariesObserver(manifest, mediaSource, coreObserver, segmentSinksStore, {\n            onWarning: (err) => this.trigger(\"warning\", err),\n            onPeriodChanged: (period) => this.trigger(\"activePeriodChanged\", { period }),\n        }, cancelSignal);\n        /**\n         * Emit a \"loaded\" events once the initial play has been performed and the\n         * media can begin playback.\n         * Also emits warning events if issues arise when doing so.\n         */\n        autoPlayResult\n            .then(() => {\n            getLoadedReference(playbackObserver, false, cancelSignal).onUpdate((isLoaded, stopListening) => {\n                if (isLoaded) {\n                    stopListening();\n                    this.trigger(\"loaded\", {\n                        getSegmentSinkMetrics: async () => {\n                            return new Promise((resolve) => resolve(segmentSinksStore.getSegmentSinksMetrics()));\n                        },\n                        getThumbnailData: async (periodId, thumbnailTrackId, time) => {\n                            const fetchThumbnails = createThumbnailFetcher(transport.thumbnails, cdnPrioritizer);\n                            return getThumbnailData(fetchThumbnails, manifest, periodId, thumbnailTrackId, time);\n                        },\n                    });\n                }\n            }, { emitCurrentValue: true, clearSignal: cancelSignal });\n        })\n            .catch((err) => {\n            if (cancelSignal.isCancelled()) {\n                return; // Current loading cancelled, no need to trigger the error\n            }\n            this._onFatalError(err);\n        });\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const self = this;\n        StreamOrchestrator({ manifest, initialPeriod }, coreObserver, representationEstimator, segmentSinksStore, segmentQueueCreator, bufferOptions, handleStreamOrchestratorCallbacks(), cancelSignal);\n        /**\n         * Returns Object handling the callbacks from a `StreamOrchestrator`, which\n         * are basically how it communicates about events.\n         * @returns {Object}\n         */\n        function handleStreamOrchestratorCallbacks() {\n            return {\n                needsBufferFlush: (payload) => {\n                    var _a;\n                    let wantedSeekingTime;\n                    const lastObservation = playbackObserver.getReference().getValue();\n                    const currentTime = lastObservation.position.isAwaitingFuturePosition()\n                        ? lastObservation.position.getWanted()\n                        : mediaElement.currentTime;\n                    const relativeResumingPosition = (_a = payload === null || payload === void 0 ? void 0 : payload.relativeResumingPosition) !== null && _a !== void 0 ? _a : 0;\n                    const canBeApproximateSeek = Boolean(payload === null || payload === void 0 ? void 0 : payload.relativePosHasBeenDefaulted);\n                    if (relativeResumingPosition === 0 && canBeApproximateSeek) {\n                        // in case relativeResumingPosition is 0, we still perform\n                        // a tiny seek to be sure that the browser will correclty reload the video.\n                        wantedSeekingTime = currentTime + 0.001;\n                    }\n                    else {\n                        wantedSeekingTime = currentTime + relativeResumingPosition;\n                    }\n                    playbackObserver.setCurrentTime(wantedSeekingTime);\n                    // Seek again once data begins to be buffered.\n                    // This is sadly necessary on some browsers to avoid decoding\n                    // issues after a flush.\n                    //\n                    // NOTE: there's in theory a potential race condition in the following\n                    // logic as the callback could be called when media data is still\n                    // being removed by the browser - which is an asynchronous process.\n                    // The following condition checking for buffered data could thus lead\n                    // to a false positive where we're actually checking previous data.\n                    // For now, such scenario is avoided by setting the\n                    // `includeLastObservation` option to `false` and calling\n                    // `needsBufferFlush` once MSE media removal operations have been\n                    // explicitely validated by the browser, but that's a complex and easy\n                    // to break system.\n                    playbackObserver.listen((obs, stopListening) => {\n                        if (\n                        // Data is buffered around the current position\n                        obs.currentRange !== null ||\n                            // Or, for whatever reason, we have no buffer but we're already advancing\n                            obs.position.getPolled() > wantedSeekingTime + 0.1) {\n                            stopListening();\n                            playbackObserver.setCurrentTime(obs.position.getWanted() + 0.001);\n                        }\n                    }, { includeLastObservation: false, clearSignal: cancelSignal });\n                },\n                streamStatusUpdate(value) {\n                    // Announce discontinuities if found\n                    const { period, bufferType, imminentDiscontinuity, position } = value;\n                    rebufferingController.updateDiscontinuityInfo({\n                        period,\n                        bufferType,\n                        discontinuity: imminentDiscontinuity,\n                        position,\n                    });\n                    if (cancelSignal.isCancelled()) {\n                        return; // Previous call has stopped streams due to a side-effect\n                    }\n                    // If the status for the last Period indicates that segments are all loaded\n                    // or on the contrary that the loading resumed, announce it to the\n                    // ContentTimeBoundariesObserver.\n                    if (manifest.isLastPeriodKnown &&\n                        value.period.id === manifest.periods[manifest.periods.length - 1].id) {\n                        const hasFinishedLoadingLastPeriod = value.hasFinishedLoading || value.isEmptyStream;\n                        if (hasFinishedLoadingLastPeriod) {\n                            contentTimeBoundariesObserver.onLastSegmentFinishedLoading(value.bufferType);\n                        }\n                        else {\n                            contentTimeBoundariesObserver.onLastSegmentLoadingResume(value.bufferType);\n                        }\n                    }\n                },\n                needsManifestRefresh: () => self._manifestFetcher.scheduleManualRefresh({\n                    enablePartialRefresh: true,\n                    canUseUnsafeMode: true,\n                }),\n                manifestMightBeOufOfSync: () => {\n                    const { OUT_OF_SYNC_MANIFEST_REFRESH_DELAY } = config.getCurrent();\n                    self._manifestFetcher.scheduleManualRefresh({\n                        enablePartialRefresh: false,\n                        canUseUnsafeMode: false,\n                        delay: OUT_OF_SYNC_MANIFEST_REFRESH_DELAY,\n                    });\n                },\n                lockedStream: (value) => rebufferingController.onLockedStream(value.bufferType, value.period),\n                adaptationChange: (value) => {\n                    self.trigger(\"adaptationChange\", value);\n                    if (cancelSignal.isCancelled()) {\n                        return; // Previous call has stopped streams due to a side-effect\n                    }\n                    contentTimeBoundariesObserver.onAdaptationChange(value.type, value.period, value.adaptation);\n                },\n                representationChange: (value) => {\n                    self.trigger(\"representationChange\", value);\n                    if (cancelSignal.isCancelled()) {\n                        return; // Previous call has stopped streams due to a side-effect\n                    }\n                    contentTimeBoundariesObserver.onRepresentationChange(value.type, value.period);\n                },\n                inbandEvent: (value) => self.trigger(\"inbandEvents\", value),\n                warning: (value) => self.trigger(\"warning\", value),\n                periodStreamReady: (value) => self.trigger(\"periodStreamReady\", value),\n                periodStreamCleared: (value) => {\n                    contentTimeBoundariesObserver.onPeriodCleared(value.type, value.period);\n                    if (cancelSignal.isCancelled()) {\n                        return; // Previous call has stopped streams due to a side-effect\n                    }\n                    self.trigger(\"periodStreamCleared\", {\n                        type: value.type,\n                        periodId: value.period.id,\n                    });\n                },\n                bitrateEstimateChange: (value) => {\n                    var _a;\n                    (_a = self._cmcdDataBuilder) === null || _a === void 0 ? void 0 : _a.updateThroughput(value.type, value.bitrate);\n                    self.trigger(\"bitrateEstimateChange\", value);\n                },\n                needsMediaSourceReload: (payload) => {\n                    reloadMediaSource(payload.timeOffset, payload.minimumPosition, payload.maximumPosition);\n                },\n                needsDecipherabilityFlush() {\n                    var _a, _b, _c, _d;\n                    const keySystem = getKeySystemConfiguration(mediaElement);\n                    if (shouldReloadMediaSourceOnDecipherabilityUpdate(keySystem === null || keySystem === void 0 ? void 0 : keySystem[0])) {\n                        const lastObservation = coreObserver.getReference().getValue();\n                        const position = lastObservation.position.isAwaitingFuturePosition()\n                            ? lastObservation.position.getWanted()\n                            : ((_a = coreObserver.getCurrentTime()) !== null && _a !== void 0 ? _a : lastObservation.position.getPolled());\n                        const isPaused = (_c = (_b = lastObservation.paused.pending) !== null && _b !== void 0 ? _b : coreObserver.getIsPaused()) !== null && _c !== void 0 ? _c : lastObservation.paused.last;\n                        onReloadOrder({ position, autoPlay: !isPaused });\n                    }\n                    else {\n                        const lastObservation = coreObserver.getReference().getValue();\n                        const position = lastObservation.position.isAwaitingFuturePosition()\n                            ? lastObservation.position.getWanted()\n                            : ((_d = coreObserver.getCurrentTime()) !== null && _d !== void 0 ? _d : lastObservation.position.getPolled());\n                        // simple seek close to the current position\n                        // to flush the buffers\n                        if (position + 0.001 < lastObservation.duration) {\n                            playbackObserver.setCurrentTime(mediaElement.currentTime + 0.001);\n                        }\n                        else {\n                            playbackObserver.setCurrentTime(position);\n                        }\n                    }\n                },\n                encryptionDataEncountered: (value) => {\n                    if (self._decryptionCapabilities.status === \"disabled\") {\n                        self._onFatalError(self._decryptionCapabilities.value);\n                        return;\n                    }\n                    else if (self._decryptionCapabilities.status === \"uninitialized\") {\n                        // Should never happen\n                        log.error(\"Init: received encryption data without known decryption capabilities\");\n                        return;\n                    }\n                    for (const protectionData of value) {\n                        self._decryptionCapabilities.value.onInitializationData(protectionData);\n                        if (cancelSignal.isCancelled()) {\n                            return; // Previous call has stopped streams due to a side-effect\n                        }\n                    }\n                },\n                error: (err) => self._onFatalError(err),\n            };\n        }\n        /**\n         * Callback allowing to reload the current content.\n         * @param {number} deltaPosition - Position you want to seek to after\n         * reloading, as a delta in seconds from the last polled playing position.\n         * @param {number|undefined} minimumPosition - If set, minimum time bound\n         * in seconds after `deltaPosition` has been applied.\n         * @param {number|undefined} maximumPosition - If set, minimum time bound\n         * in seconds after `deltaPosition` has been applied.\n         */\n        function reloadMediaSource(deltaPosition, minimumPosition, maximumPosition) {\n            var _a, _b, _c;\n            const lastObservation = coreObserver.getReference().getValue();\n            const currentPosition = lastObservation.position.isAwaitingFuturePosition()\n                ? lastObservation.position.getWanted()\n                : ((_a = coreObserver.getCurrentTime()) !== null && _a !== void 0 ? _a : lastObservation.position.getPolled());\n            const isPaused = (_c = (_b = lastObservation.paused.pending) !== null && _b !== void 0 ? _b : coreObserver.getIsPaused()) !== null && _c !== void 0 ? _c : lastObservation.paused.last;\n            let position = currentPosition + deltaPosition;\n            if (minimumPosition !== undefined) {\n                position = Math.max(minimumPosition, position);\n            }\n            if (maximumPosition !== undefined) {\n                position = Math.min(maximumPosition, position);\n            }\n            onReloadOrder({ position, autoPlay: !isPaused });\n        }\n    }\n    /**\n     * Creates a `RebufferingController`, a class trying to avoid various stalling\n     * situations (such as rebuffering periods), and returns it.\n     *\n     * Various methods from that class need then to be called at various events\n     * (see `RebufferingController` definition).\n     *\n     * This function also handles the `RebufferingController`'s events:\n     *   - emit \"stalled\" events when stalling situations cannot be prevented,\n     *   - emit \"unstalled\" events when we could get out of one,\n     *   - emit \"warning\" on various rebuffering-related minor issues\n     *     like discontinuity skipping.\n     * @param {Object} playbackObserver\n     * @param {Object} manifest\n     * @param {Object} speed\n     * @param {Object} cancelSignal\n     * @returns {Object}\n     */\n    _createRebufferingController(playbackObserver, manifest, speed, cancelSignal) {\n        const rebufferingController = new RebufferingController(playbackObserver, manifest, speed);\n        // Bubble-up events\n        rebufferingController.addEventListener(\"stalled\", (evt) => this.trigger(\"stalled\", evt));\n        rebufferingController.addEventListener(\"unstalled\", () => this.trigger(\"unstalled\", null));\n        rebufferingController.addEventListener(\"warning\", (err) => this.trigger(\"warning\", err));\n        cancelSignal.register(() => rebufferingController.destroy());\n        rebufferingController.start();\n        return rebufferingController;\n    }\n    /**\n     * Evaluates a list of codecs to determine their support status.\n     *\n     * @param {Array} codecsToCheck - The list of codecs to check.\n     * @returns {Array} - The list of evaluated codecs with their support status updated.\n     */\n    getCodecsSupportInfo(codecsToCheck) {\n        const codecsSupportInfo = codecsToCheck.map((codecToCheck) => {\n            var _a;\n            const inputCodec = `${codecToCheck.mimeType};codecs=\"${codecToCheck.codec}\"`;\n            const isSupported = isCodecSupported(inputCodec);\n            if (!isSupported) {\n                return {\n                    mimeType: codecToCheck.mimeType,\n                    codec: codecToCheck.codec,\n                    supported: false,\n                    supportedIfEncrypted: false,\n                };\n            }\n            /**\n             * `true` if the codec is supported when encrypted, `false` if it is not\n             * supported, or `undefined` if we cannot obtain that information.\n             */\n            let supportedIfEncrypted;\n            if (this._decryptionCapabilities.status === \"uninitialized\") {\n                supportedIfEncrypted = undefined;\n            }\n            else if (this._decryptionCapabilities.status === \"disabled\") {\n                // It's ambiguous here, but let's say that no ContentDecryptor means that\n                // the codec is supported by it.\n                supportedIfEncrypted = true;\n            }\n            else {\n                const contentDecryptor = this._decryptionCapabilities.value;\n                if (contentDecryptor.getState() !== ContentDecryptorState.Initializing) {\n                    // No information is available regarding the support status.\n                    // Defaulting to assume the codec is supported.\n                    supportedIfEncrypted =\n                        (_a = contentDecryptor.isCodecSupported(codecToCheck.mimeType, codecToCheck.codec)) !== null && _a !== void 0 ? _a : true;\n                }\n            }\n            return {\n                mimeType: codecToCheck.mimeType,\n                codec: codecToCheck.codec,\n                supported: isSupported,\n                supportedIfEncrypted,\n            };\n        });\n        return codecsSupportInfo;\n    }\n    /**\n     * Update the support status of all Representations in the Manifest.\n     *\n     * To call anytime either the Manifest is linked to new codecs or new means\n     * to test for codec support are available.\n     * @param {Object} manifest\n     */\n    _refreshManifestCodecSupport(manifest) {\n        const codecsToTest = manifest.getCodecsWithUnknownSupport();\n        const codecsSupportInfo = this.getCodecsSupportInfo(codecsToTest);\n        if (codecsSupportInfo.length > 0) {\n            try {\n                manifest.updateCodecSupport(codecsSupportInfo);\n            }\n            catch (err) {\n                this._onFatalError(err);\n            }\n        }\n    }\n}\nfunction createTextDisplayer(mediaElement, textTrackOptions) {\n    if (textTrackOptions.textTrackMode === \"html\" && features.htmlTextDisplayer !== null) {\n        return new features.htmlTextDisplayer(mediaElement, textTrackOptions.textTrackElement);\n    }\n    else if (features.nativeTextDisplayer !== null) {\n        return new features.nativeTextDisplayer(mediaElement);\n    }\n    return null;\n}\n/**\n * Change the decipherability of Representations which have their key id in one\n * of the given Arrays:\n *\n *   - Those who have a key id listed in `whitelistedKeyIds` will have their\n *     decipherability updated to `true`\n *\n *   - Those who have a key id listed in `blacklistedKeyIds` will have their\n *     decipherability updated to `false`\n *\n *   - Those who have a key id listed in `delistedKeyIds` will have their\n *     decipherability updated to `undefined`.\n *\n * @param {Object} manifest\n * @param {Array.<Uint8Array>} whitelistedKeyIds\n * @param {Array.<Uint8Array>} blacklistedKeyIds\n * @param {Array.<Uint8Array>} delistedKeyIds\n */\nfunction updateKeyIdsDecipherabilityOnManifest(manifest, whitelistedKeyIds, blacklistedKeyIds, delistedKeyIds) {\n    manifest.updateRepresentationsDeciperability((ctx) => {\n        const { representation } = ctx;\n        if (representation.contentProtections === undefined) {\n            return representation.decipherable;\n        }\n        const contentKIDs = representation.contentProtections.keyIds;\n        if (contentKIDs !== undefined) {\n            for (const elt of contentKIDs) {\n                for (const blacklistedKeyId of blacklistedKeyIds) {\n                    if (areArraysOfNumbersEqual(blacklistedKeyId, elt)) {\n                        return false;\n                    }\n                }\n                for (const whitelistedKeyId of whitelistedKeyIds) {\n                    if (areArraysOfNumbersEqual(whitelistedKeyId, elt)) {\n                        return true;\n                    }\n                }\n                for (const delistedKeyId of delistedKeyIds) {\n                    if (areArraysOfNumbersEqual(delistedKeyId, elt)) {\n                        return undefined;\n                    }\n                }\n            }\n        }\n        return representation.decipherable;\n    });\n}\n/**\n * Update decipherability to `false` to any Representation which is linked to\n * the given initialization data.\n * @param {Object} manifest\n * @param {Object} initData\n */\nfunction blackListProtectionDataOnManifest(manifest, initData) {\n    manifest.updateRepresentationsDeciperability((ctx) => {\n        var _a, _b;\n        const rep = ctx.representation;\n        if (rep.decipherable === false) {\n            return false;\n        }\n        const segmentProtections = (_b = (_a = rep.contentProtections) === null || _a === void 0 ? void 0 : _a.initData) !== null && _b !== void 0 ? _b : [];\n        for (const protection of segmentProtections) {\n            if (initData.type === undefined || protection.type === initData.type) {\n                const containedInitData = initData.values\n                    .getFormattedValues()\n                    .every((undecipherableVal) => {\n                    return protection.values.some((currVal) => {\n                        return ((undecipherableVal.systemId === undefined ||\n                            currVal.systemId === undecipherableVal.systemId) &&\n                            areArraysOfNumbersEqual(currVal.data, undecipherableVal.data));\n                    });\n                });\n                if (containedInitData) {\n                    return false;\n                }\n            }\n        }\n        return rep.decipherable;\n    });\n}\n/**\n * Handle accordingly an `IFreezeResolution` object.\n * @param {Object|null} freezeResolution - The `IFreezeResolution` suggested.\n * @param {Object} param - Parameters that might be needed to implement the\n * resolution.\n * @param {Object} param.manifest - The current content's Manifest object.\n * @param {Object} param.playbackObserver - Object regularly emitting playback\n * conditions.\n * @param {Function} param.triggerReload - Function to call if we need to ask\n * for a \"MediaSource reload\".\n * @param {Boolean} param.enableRepresentationAvoidance - If `true`, this\n * function is authorized to mark `Representation` as \"to avoid\" if the\n * `IFreezeResolution` object suggest it.\n */\nfunction handleFreezeResolution(freezeResolution, { playbackObserver, enableRepresentationAvoidance, manifest, triggerReload, }) {\n    switch (freezeResolution.type) {\n        case \"reload\": {\n            log.info(\"Init: Planning reload due to freeze\");\n            triggerReload();\n            break;\n        }\n        case \"flush\": {\n            log.info(\"Init: Flushing buffer due to freeze\");\n            const observation = playbackObserver.getReference().getValue();\n            const currentTime = observation.position.isAwaitingFuturePosition()\n                ? observation.position.getWanted()\n                : playbackObserver.getCurrentTime();\n            const relativeResumingPosition = freezeResolution.value.relativeSeek;\n            const wantedSeekingTime = currentTime + relativeResumingPosition;\n            playbackObserver.setCurrentTime(wantedSeekingTime);\n            break;\n        }\n        case \"avoid-representations\": {\n            const contents = freezeResolution.value;\n            if (enableRepresentationAvoidance) {\n                manifest.addRepresentationsToAvoid(contents);\n            }\n            triggerReload();\n            break;\n        }\n        default:\n            assertUnreachable(freezeResolution);\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport EventEmitter from \"../../utils/event_emitter\";\n/**\n * Class allowing to start playing a content on an `HTMLMediaElement`.\n *\n * The actual constructor arguments depend on the `ContentInitializer` defined,\n * but should reflect all potential configuration wanted relative to this\n * content's playback.\n *\n * Various events may be emitted by a `ContentInitializer`. However, no event\n * should be emitted before `prepare` or `start` is called and no event should\n * be emitted after `dispose` is called.\n */\nexport class ContentInitializer extends EventEmitter {\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport getBufferedDataPerMediaBuffer from \"../../../core/main/common/get_buffered_data_per_media_buffer\";\nimport { getMaximumSafePosition } from \"../../../manifest\";\nimport SharedReference from \"../../../utils/reference\";\nimport TaskCanceller from \"../../../utils/task_canceller\";\n/**\n * Create PlaybackObserver for the core part of the code.\n * @param {Object} srcPlaybackObserver - Base `PlaybackObserver` from which we\n * will derive information.\n * @param {Object} context - Various information linked to the current content\n * being played.\n * @param {Object} fnCancelSignal - Abort the created PlaybackObserver.\n * @returns {Object}\n */\nexport default function createCorePlaybackObserver(srcPlaybackObserver, { autoPlay, initialPlayPerformed, manifest, mediaSource, speed, textDisplayer, }, fnCancelSignal) {\n    return srcPlaybackObserver.deriveReadOnlyObserver(function transform(observationRef, parentObserverCancelSignal) {\n        const canceller = new TaskCanceller();\n        canceller.linkToSignal(parentObserverCancelSignal);\n        canceller.linkToSignal(fnCancelSignal);\n        const newRef = new SharedReference(constructCorePlaybackObservation(), canceller.signal);\n        // TODO there might be subtle unexpected behavior here as updating the\n        // speed will send observation which may be outdated at the time it is sent\n        speed.onUpdate(emitCorePlaybackObservation, {\n            clearSignal: canceller.signal,\n            emitCurrentValue: false,\n        });\n        observationRef.onUpdate(emitCorePlaybackObservation, {\n            clearSignal: canceller.signal,\n            emitCurrentValue: false,\n        });\n        // TODO there might be subtle unexpected behavior here as listening to mediaSource\n        // event will send observation which may be outdated at the time it is sent\n        mediaSource === null || mediaSource === void 0 ? void 0 : mediaSource.addEventListener(\"streamingChanged\", () => {\n            emitCorePlaybackObservation();\n        }, canceller.signal);\n        return newRef;\n        function constructCorePlaybackObservation() {\n            var _a;\n            const observation = observationRef.getValue();\n            const lastSpeed = speed.getValue();\n            updateWantedPositionIfAfterManifest(observation, manifest);\n            return {\n                // TODO more exact according to the current Adaptation chosen?\n                maximumPosition: getMaximumSafePosition(manifest),\n                bufferGap: observation.bufferGap,\n                position: observation.position,\n                buffered: getBufferedDataPerMediaBuffer(mediaSource, textDisplayer),\n                duration: observation.duration,\n                rebuffering: observation.rebuffering,\n                freezing: observation.freezing,\n                paused: {\n                    last: observation.paused,\n                    pending: getPendingPaused(initialPlayPerformed, autoPlay),\n                },\n                readyState: observation.readyState,\n                speed: lastSpeed,\n                canStream: (_a = mediaSource === null || mediaSource === void 0 ? void 0 : mediaSource.streaming) !== null && _a !== void 0 ? _a : true,\n                fullyLoaded: observation.fullyLoaded,\n            };\n        }\n        function emitCorePlaybackObservation() {\n            newRef.setValue(constructCorePlaybackObservation());\n        }\n    });\n}\nexport function updateWantedPositionIfAfterManifest(observation, manifest) {\n    if (!manifest.isDynamic || manifest.isLastPeriodKnown) {\n        // HACK: When the position is actually further than the maximum\n        // position for a finished content, we actually want to be loading\n        // the last segment before ending.\n        // For now, this behavior is implicitely forced by making as if we\n        // want to seek one second before the period's end (despite never\n        // doing it).\n        const lastPeriod = manifest.periods[manifest.periods.length - 1];\n        if (lastPeriod !== undefined && lastPeriod.end !== undefined) {\n            const wantedPosition = observation.position.getWanted();\n            if (wantedPosition >= lastPeriod.start && wantedPosition >= lastPeriod.end - 1) {\n                // We're after the end of the last Period, check if `buffered`\n                // indicates that the last segment is probably not loaded, in which\n                // case act as if we want to load one second before the end.\n                const buffered = observation.buffered;\n                if (buffered.length === 0 ||\n                    buffered.end(buffered.length - 1) < observation.duration - 1) {\n                    observation.position.forceWantedPosition(lastPeriod.end - 1);\n                }\n            }\n        }\n    }\n}\nexport function getPendingPaused(initialPlayPerformed, autoPlay) {\n    return initialPlayPerformed.getValue() ? undefined : !autoPlay;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { isManagedMediaSource, } from \"../../../compat/browser_compatibility_types\";\nimport clearElementSrc from \"../../../compat/clear_element_src\";\nimport log from \"../../../log\";\nimport MainMediaSourceInterface from \"../../../mse/main_media_source_interface\";\nimport createCancellablePromise from \"../../../utils/create_cancellable_promise\";\nimport idGenerator from \"../../../utils/id_generator\";\nimport isNonEmptyString from \"../../../utils/is_non_empty_string\";\nconst generateMediaSourceId = idGenerator();\n/**\n * Dispose of ressources taken by the MediaSource:\n *   - Clear the MediaSource' SourceBuffers\n *   - Clear the mediaElement's src (stop the mediaElement)\n *   - Revoke MediaSource' URL\n * @param {HTMLMediaElement} mediaElement\n * @param {string|null} mediaSourceURL\n */\nexport function resetMediaElement(mediaElement, mediaSourceURL) {\n    if (mediaSourceURL !== null && mediaElement.src === mediaSourceURL) {\n        log.info(\"Init: Clearing HTMLMediaElement's src\");\n        clearElementSrc(mediaElement);\n    }\n    if (mediaSourceURL !== null) {\n        try {\n            log.debug(\"Init: Revoking previous URL\");\n            URL.revokeObjectURL(mediaSourceURL);\n        }\n        catch (e) {\n            log.warn(\"Init: Error while revoking the media source URL\", e instanceof Error ? e : \"\");\n        }\n    }\n}\n/**\n * Temporarily disables remote playback on a media element by setting the\n * `disableRemotePlayback` attribute to `true` when using a `ManagedMediaSource`.\n * The original value of the `disableRemotePlayback` attribute is restored when\n * the cancellation signal is triggered.\n *\n * This is useful when the `ManagedMediaSource` is being used and\n * the media element needs to ensure that remote playback (e.g., Airplay) is disabled\n * during the playback session.\n * @param {HTMLElement} mediaElement - The media element whose `disableRemotePlayback`\n * attribute will be modified.\n * @param {CancellationSignal} cancellationSignal - The signal that, when triggered,\n * restores the `disableRemotePlayback` attribute to its original value.\n */\nexport function disableRemotePlaybackOnManagedMediaSource(mediaElement, cancellationSignal) {\n    if (isManagedMediaSource && \"disableRemotePlayback\" in mediaElement) {\n        const disableRemotePlaybackPreviousValue = mediaElement.disableRemotePlayback;\n        cancellationSignal.register(() => {\n            /**\n             * Restore the `disableRemotePlayback` attribute to its previous value.\n             * This ensures that the media element's state is the same as it was before\n             * calling `RxPlayer.loadVideo` in the application.\n             */\n            mediaElement.disableRemotePlayback = disableRemotePlaybackPreviousValue;\n        });\n        /**\n         * Using ManagedMediaSource needs to disableRemotePlayback or to provide\n         * an Airplay source alternative, such as HLS.\n         * https://github.com/w3c/media-source/issues/320\n         */\n        mediaElement.disableRemotePlayback = true;\n    }\n}\n/**\n * Create a MediaSource instance and attach it to the given mediaElement element's\n * src attribute.\n *\n * Returns a Promise which resolves with the MediaSource when created and attached\n * to the `mediaElement` element.\n *\n * When the given `unlinkSignal` emits, mediaElement.src is cleaned, MediaSource\n * SourceBuffers are aborted and some minor cleaning is done.\n * @param {HTMLMediaElement} mediaElement\n * @param {Object} unlinkSignal\n * @returns {MediaSource}\n */\nfunction createMediaSource(mediaElement, unlinkSignal) {\n    // make sure the media has been correctly reset\n    const oldSrc = isNonEmptyString(mediaElement.src) ? mediaElement.src : null;\n    resetMediaElement(mediaElement, oldSrc);\n    const mediaSource = new MainMediaSourceInterface(generateMediaSourceId());\n    disableRemotePlaybackOnManagedMediaSource(mediaElement, unlinkSignal);\n    unlinkSignal.register(() => {\n        mediaSource.dispose();\n    });\n    return mediaSource;\n}\n/**\n * Create and open a new MediaSource object on the given media element.\n * Resolves with the MediaSource when done.\n *\n * When the given `unlinkSignal` emits, mediaElement.src is cleaned, MediaSource\n * SourceBuffers are aborted and some minor cleaning is done.\n * @param {HTMLMediaElement} mediaElement\n * @param {Object} unlinkSignal\n * @returns {Promise}\n */\nexport default function openMediaSource(mediaElement, unlinkSignal) {\n    return createCancellablePromise(unlinkSignal, (resolve) => {\n        const mediaSource = createMediaSource(mediaElement, unlinkSignal);\n        mediaSource.addEventListener(\"mediaSourceOpen\", () => {\n            log.info(\"Init: MediaSource opened\");\n            resolve(mediaSource);\n        }, unlinkSignal);\n        log.info(\"MTCI: Attaching MediaSource URL to the media element\");\n        if (mediaSource.handle.type === \"handle\") {\n            mediaElement.srcObject = mediaSource.handle.value;\n            unlinkSignal.register(() => {\n                resetMediaElement(mediaElement, null);\n            });\n        }\n        else {\n            const url = URL.createObjectURL(mediaSource.handle.value);\n            mediaElement.src = url;\n            unlinkSignal.register(() => {\n                resetMediaElement(mediaElement, url);\n            });\n        }\n    });\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport config from \"../../../config\";\nimport log from \"../../../log\";\nimport { getLivePosition, getMaximumSafePosition, getMinimumSafePosition, } from \"../../../manifest\";\nimport isNullOrUndefined from \"../../../utils/is_null_or_undefined\";\nimport getMonotonicTimeStamp from \"../../../utils/monotonic_timestamp\";\n/**\n * Returns the calculated initial time for the content described by the given\n * Manifest:\n *   1. if a start time is defined by user, calculate starting time from the\n *      manifest information\n *   2. else if the media is live, use the live edge and suggested delays from\n *      it\n *   3. else returns the minimum time announced in the manifest\n * @param {Manifest} manifest\n * @param {boolean} lowLatencyMode\n * @param {Object} startAt\n * @returns {Number}\n */\nexport default function getInitialTime(manifest, lowLatencyMode, startAt) {\n    var _a;\n    if (!isNullOrUndefined(startAt)) {\n        const min = getMinimumSafePosition(manifest);\n        const max = getMaximumSafePosition(manifest);\n        if (!isNullOrUndefined(startAt.position)) {\n            log.debug(\"Init: using startAt.minimumPosition\");\n            return Math.max(Math.min(startAt.position, max), min);\n        }\n        else if (!isNullOrUndefined(startAt.wallClockTime)) {\n            log.debug(\"Init: using startAt.wallClockTime\");\n            const ast = manifest.availabilityStartTime === undefined ? 0 : manifest.availabilityStartTime;\n            const position = startAt.wallClockTime - ast;\n            return Math.max(Math.min(position, max), min);\n        }\n        else if (!isNullOrUndefined(startAt.fromFirstPosition)) {\n            log.debug(\"Init: using startAt.fromFirstPosition\");\n            const { fromFirstPosition } = startAt;\n            return fromFirstPosition <= 0 ? min : Math.min(max, min + fromFirstPosition);\n        }\n        else if (!isNullOrUndefined(startAt.fromLastPosition)) {\n            log.debug(\"Init: using startAt.fromLastPosition\");\n            const { fromLastPosition } = startAt;\n            return fromLastPosition >= 0 ? max : Math.max(min, max + fromLastPosition);\n        }\n        else if (!isNullOrUndefined(startAt.fromLivePosition)) {\n            log.debug(\"Init: using startAt.fromLivePosition\");\n            const livePosition = (_a = getLivePosition(manifest)) !== null && _a !== void 0 ? _a : max;\n            const { fromLivePosition } = startAt;\n            return fromLivePosition >= 0\n                ? livePosition\n                : Math.max(min, livePosition + fromLivePosition);\n        }\n        else if (!isNullOrUndefined(startAt.percentage)) {\n            log.debug(\"Init: using startAt.percentage\");\n            const { percentage } = startAt;\n            if (percentage > 100) {\n                return max;\n            }\n            else if (percentage < 0) {\n                return min;\n            }\n            const ratio = +percentage / 100;\n            const extent = max - min;\n            return min + extent * ratio;\n        }\n    }\n    const minimumPosition = getMinimumSafePosition(manifest);\n    if (manifest.isLive) {\n        const { suggestedPresentationDelay, clockOffset } = manifest;\n        const maximumPosition = getMaximumSafePosition(manifest);\n        let liveTime;\n        const { DEFAULT_LIVE_GAP } = config.getCurrent();\n        if (clockOffset === undefined) {\n            log.info(\"Init: no clock offset found for a live content, \" +\n                \"starting close to maximum available position\");\n            liveTime = maximumPosition;\n        }\n        else {\n            log.info(\"Init: clock offset found for a live content, \" +\n                \"checking if we can start close to it\");\n            const ast = manifest.availabilityStartTime === undefined ? 0 : manifest.availabilityStartTime;\n            const clockRelativeLiveTime = (getMonotonicTimeStamp() + clockOffset) / 1000 - ast;\n            liveTime = Math.min(maximumPosition, clockRelativeLiveTime);\n        }\n        const diffFromLiveTime = suggestedPresentationDelay !== null && suggestedPresentationDelay !== void 0 ? suggestedPresentationDelay : (lowLatencyMode ? DEFAULT_LIVE_GAP.LOW_LATENCY : DEFAULT_LIVE_GAP.DEFAULT);\n        log.debug(`Init: ${liveTime} defined as the live time, applying a live gap` +\n            ` of ${diffFromLiveTime}`);\n        return Math.max(liveTime - diffFromLiveTime, minimumPosition);\n    }\n    log.info(\"Init: starting at the minimum available position:\", minimumPosition);\n    return minimumPosition;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport shouldValidateMetadata from \"../../../compat/should_validate_metadata\";\nimport shouldWaitForDataBeforeLoaded from \"../../../compat/should_wait_for_data_before_loaded\";\nimport shouldWaitForHaveEnoughData from \"../../../compat/should_wait_for_have_enough_data\";\nimport SharedReference from \"../../../utils/reference\";\nimport TaskCanceller from \"../../../utils/task_canceller\";\n/**\n * Returns an `IReadOnlySharedReference` that switches to `true` once the\n * content is considered loaded (i.e. once it can begin to be played).\n * @param {Object} playbackObserver\n * @param {boolean} isDirectfile - `true` if this is a directfile content\n * @param {Object} cancelSignal\n * @returns {Object}\n */\nexport default function getLoadedReference(playbackObserver, isDirectfile, cancelSignal) {\n    const listenCanceller = new TaskCanceller();\n    listenCanceller.linkToSignal(cancelSignal);\n    const isLoaded = new SharedReference(false, listenCanceller.signal);\n    playbackObserver.listen((observation) => {\n        if (observation.rebuffering !== null ||\n            observation.freezing !== null ||\n            observation.readyState === 0) {\n            return;\n        }\n        if (!shouldWaitForDataBeforeLoaded(isDirectfile)) {\n            // The duration is NaN if no media data is available,\n            // which means media is not loaded yet.\n            if (isNaN(observation.duration)) {\n                return;\n            }\n            if (observation.duration > 0) {\n                isLoaded.setValue(true);\n                listenCanceller.cancel();\n                return;\n            }\n        }\n        const minReadyState = shouldWaitForHaveEnoughData() ? 4 : 3;\n        if (observation.readyState >= minReadyState) {\n            if (observation.currentRange !== null || observation.ended) {\n                if (!shouldValidateMetadata() || observation.duration > 0) {\n                    isLoaded.setValue(true);\n                    listenCanceller.cancel();\n                    return;\n                }\n            }\n        }\n    }, { includeLastObservation: true, clearSignal: listenCanceller.signal });\n    return isLoaded;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport canSeekDirectlyAfterLoadedMetadata from \"../../../compat/can_seek_directly_after_loaded_metadata\";\nimport shouldValidateMetadata from \"../../../compat/should_validate_metadata\";\nimport { MediaError } from \"../../../errors\";\nimport log from \"../../../log\";\nimport SharedReference from \"../../../utils/reference\";\n/**\n * Seek as soon as possible at the initially wanted position and play if\n * autoPlay is wanted.\n * @param {Object} args\n * @param {Object} cancelSignal\n * @returns {Object}\n */\nexport default function performInitialSeekAndPlay({ mediaElement, playbackObserver, startTime, mustAutoPlay, isDirectfile, onWarning, }, cancelSignal) {\n    const initialPlayPerformed = new SharedReference(false, cancelSignal);\n    const autoPlayResult = new Promise((resolveAutoPlay, rejectAutoPlay) => {\n        const deregisterCancellation = cancelSignal.register((err) => {\n            rejectAutoPlay(err);\n        });\n        if (cancelSignal.isCancelled()) {\n            return;\n        }\n        /** `true` if we asked the `PlaybackObserver` to perform an initial seek. */\n        let hasAskedForInitialSeek = false;\n        const performInitialSeek = (initialSeekTime) => {\n            playbackObserver.setCurrentTime(initialSeekTime);\n            hasAskedForInitialSeek = true;\n        };\n        // `startTime` defined as a function might depend on metadata to make its\n        // choice, such as the content duration, minimum and/or maximum position.\n        //\n        // The RxPlayer might already know those through the Manifest file for\n        // non-Directfile contents, yet only through the `HTMLMediaElement` once a\n        // a sufficient `readyState` has been reached for directfile contents.\n        // So let's divide the two possibilities here.\n        if (!isDirectfile || typeof startTime === \"number\") {\n            const initiallySeekedTime = typeof startTime === \"number\" ? startTime : startTime();\n            if (initiallySeekedTime !== 0 && initiallySeekedTime !== undefined) {\n                performInitialSeek(initiallySeekedTime);\n            }\n            waitForSeekable();\n        }\n        else {\n            playbackObserver.listen((obs, stopListening) => {\n                const initiallySeekedTime = typeof startTime === \"number\" ? startTime : startTime();\n                if (initiallySeekedTime === undefined &&\n                    obs.readyState < HTMLMediaElement.HAVE_CURRENT_DATA) {\n                    /**\n                     * The starting position may not be known yet.\n                     * Postpone the seek to a moment where the starting position should be known,\n                     * assumely it's when readyState is greater or equal to HAVE_CURRENT_DATA (2).\n                     * If the initiallySeekedTime is still `undefined` when the readyState is >= 2,\n                     * let assume that the initiallySeekedTime will never be known and continue\n                     * the logic without seeking.\n                     */\n                    return;\n                }\n                if (obs.readyState >= 1) {\n                    stopListening();\n                    if (initiallySeekedTime !== 0 && initiallySeekedTime !== undefined) {\n                        if (canSeekDirectlyAfterLoadedMetadata) {\n                            performInitialSeek(initiallySeekedTime);\n                        }\n                        else {\n                            setTimeout(() => {\n                                performInitialSeek(initiallySeekedTime);\n                            }, 0);\n                        }\n                    }\n                    waitForSeekable();\n                }\n            }, { includeLastObservation: true, clearSignal: cancelSignal });\n        }\n        /**\n         * Logic that should be run once the initial seek has been asked to the\n         * PlaybackObserver.\n         *\n         * Actually wait until the seek has been performed, wait for the right moment\n         * to perform autoplay, resolve the promise once everything has been done and\n         * potentially send warning if a minor issue is detected.\n         */\n        function waitForSeekable() {\n            /**\n             * We only want to continue to `play` when a `seek` has actually been\n             * performed (if it has been asked). This boolean keep track of if the\n             * seek arised.\n             */\n            let hasStartedSeeking = false;\n            playbackObserver.listen((obs, stopListening) => {\n                if (!hasStartedSeeking &&\n                    (obs.seeking !== 0 /* SeekingState.None */ ||\n                        obs.event === \"seeking\" ||\n                        obs.event === \"internal-seeking\")) {\n                    hasStartedSeeking = true;\n                }\n                if ((hasAskedForInitialSeek && !hasStartedSeeking) || obs.readyState === 0) {\n                    return;\n                }\n                stopListening();\n                if (shouldValidateMetadata() && mediaElement.duration === 0) {\n                    const error = new MediaError(\"MEDIA_ERR_NOT_LOADED_METADATA\", \"Cannot load automatically: your browser \" +\n                        \"falsely announced having loaded the content.\");\n                    onWarning(error);\n                }\n                if (cancelSignal.isCancelled()) {\n                    return;\n                }\n                waitForPlayable();\n            }, { includeLastObservation: true, clearSignal: cancelSignal });\n        }\n        /**\n         * Logic that should be run once the initial seek has been properly performed.\n         *\n         * Wait for the media being playable before performing the autoplay operation\n         * if asked. Potentially send warning if a minor issue has been detected while\n         * doing so.\n         */\n        function waitForPlayable() {\n            playbackObserver.listen((observation, stopListening) => {\n                if (observation.seeking === 0 /* SeekingState.None */ &&\n                    observation.rebuffering === null &&\n                    observation.readyState >= 1) {\n                    stopListening();\n                    onPlayable();\n                }\n            }, { includeLastObservation: true, clearSignal: cancelSignal });\n        }\n        /**\n         * Callback called once the content is considered \"playable\".\n         *\n         * Perform the autoplay if needed, handling potential issues and resolve the\n         * Promise when done.\n         * Might also send warnings if minor issues arise.\n         */\n        function onPlayable() {\n            var _a;\n            log.info(\"Init: Can begin to play content\");\n            if (!mustAutoPlay) {\n                if (mediaElement.autoplay) {\n                    log.warn(\"Init: autoplay is enabled on HTML media element. \" +\n                        \"Media will play as soon as possible.\");\n                }\n                initialPlayPerformed.setValue(true);\n                initialPlayPerformed.finish();\n                deregisterCancellation();\n                return resolveAutoPlay({ type: \"skipped\" });\n            }\n            else if (mediaElement.ended) {\n                // the video has ended state to true, executing VideoElement.play() will\n                // restart the video from the start, which is not wanted in most cases.\n                // returning \"skipped\" prevents the call to play() and fix the issue\n                log.warn(\"Init: autoplay is enabled but the video is ended. \" +\n                    \"Skipping autoplay to prevent video to start again\");\n                initialPlayPerformed.setValue(true);\n                initialPlayPerformed.finish();\n                deregisterCancellation();\n                return resolveAutoPlay({ type: \"skipped\" });\n            }\n            let playResult;\n            try {\n                playResult = (_a = mediaElement.play()) !== null && _a !== void 0 ? _a : Promise.resolve();\n            }\n            catch (playError) {\n                deregisterCancellation();\n                return rejectAutoPlay(playError);\n            }\n            playResult\n                .then(() => {\n                if (cancelSignal.isCancelled()) {\n                    return;\n                }\n                initialPlayPerformed.setValue(true);\n                initialPlayPerformed.finish();\n                deregisterCancellation();\n                return resolveAutoPlay({ type: \"autoplay\" });\n            })\n                .catch((playError) => {\n                deregisterCancellation();\n                if (cancelSignal.isCancelled()) {\n                    return;\n                }\n                if (playError instanceof Error && playError.name === \"NotAllowedError\") {\n                    // auto-play was probably prevented.\n                    log.warn(\"Init: Media element can't play.\" +\n                        \" It may be due to browser auto-play policies.\");\n                    const error = new MediaError(\"MEDIA_ERR_BLOCKED_AUTOPLAY\", \"Cannot trigger auto-play automatically: \" +\n                        \"your browser does not allow it.\");\n                    onWarning(error);\n                    if (cancelSignal.isCancelled()) {\n                        return;\n                    }\n                    return resolveAutoPlay({ type: \"autoplay-blocked\" });\n                }\n                else {\n                    rejectAutoPlay(playError);\n                }\n            });\n        }\n    });\n    return { autoPlayResult, initialPlayPerformed };\n}\n","import { EncryptedMediaError } from \"../../../errors\";\nimport features from \"../../../features\";\nimport log from \"../../../log\";\nimport SharedReference from \"../../../utils/reference\";\nimport TaskCanceller from \"../../../utils/task_canceller\";\nimport { ContentDecryptorState } from \"../../decrypt\";\n/**\n * Initialize content decryption capabilities on the given `HTMLMediaElement`.\n *\n * You can call this function even if you don't want decrytpion capabilities, in\n * which case you can just set the `keySystems` option as an empty array.\n * In this situation, the returned object will directly correspond to an\n * \"`initialized`\" state and the `onError` callback will be triggered as soon\n * as protection information is received.\n *\n * @param {HTMLMediaElement} mediaElement - `HTMLMediaElement` on which content\n * decryption may be wanted.\n * @param {Array.<Object>} keySystems - Key system configuration(s) wanted\n * Empty array if no content decryption capability is wanted.\n * protection initialization data will be sent through.\n * @param {Object} callbacks - Callbacks called at various decryption-related\n * events.\n * @param {Object} cancelSignal - When that signal emits, this function will\n * stop listening to various events.\n * @returns {Object} - Reference emitting the current status regarding DRM\n * initialization.\n */\nexport default function initializeContentDecryption(mediaElement, keySystems, callbacks, cancelSignal) {\n    if (keySystems.length === 0) {\n        return createEmeDisabledReference(\"No `keySystems` option given.\");\n    }\n    else if (features.decrypt === null) {\n        return createEmeDisabledReference(\"EME feature not activated.\");\n    }\n    const decryptorCanceller = new TaskCanceller();\n    decryptorCanceller.linkToSignal(cancelSignal);\n    const drmStatusRef = new SharedReference({\n        initializationState: { type: \"uninitialized\", value: null },\n        drmSystemId: undefined,\n    }, cancelSignal);\n    const ContentDecryptor = features.decrypt;\n    if (!ContentDecryptor.hasEmeApis()) {\n        return createEmeDisabledReference(\"EME API not available on the current page.\");\n    }\n    log.debug(\"Init: Creating ContentDecryptor\");\n    const contentDecryptor = new ContentDecryptor(mediaElement, keySystems);\n    const onStateChange = (state) => {\n        var _a;\n        if (state > ContentDecryptorState.Initializing) {\n            (_a = callbacks.onCodecSupportUpdate) === null || _a === void 0 ? void 0 : _a.call(callbacks);\n            contentDecryptor.removeEventListener(\"stateChange\", onStateChange);\n        }\n    };\n    contentDecryptor.addEventListener(\"stateChange\", onStateChange);\n    contentDecryptor.addEventListener(\"stateChange\", (state) => {\n        if (state === ContentDecryptorState.WaitingForAttachment) {\n            const isMediaLinked = new SharedReference(false);\n            isMediaLinked.onUpdate((isAttached, stopListening) => {\n                if (isAttached) {\n                    stopListening();\n                    if (state === ContentDecryptorState.WaitingForAttachment) {\n                        contentDecryptor.attach();\n                    }\n                }\n            }, { clearSignal: decryptorCanceller.signal });\n            drmStatusRef.setValue({\n                initializationState: {\n                    type: \"awaiting-media-link\",\n                    value: { isMediaLinked },\n                },\n                drmSystemId: contentDecryptor.systemId,\n            });\n        }\n        else if (state === ContentDecryptorState.ReadyForContent) {\n            drmStatusRef.setValue({\n                initializationState: { type: \"initialized\", value: null },\n                drmSystemId: contentDecryptor.systemId,\n            });\n            contentDecryptor.removeEventListener(\"stateChange\");\n        }\n    });\n    contentDecryptor.addEventListener(\"error\", (error) => {\n        decryptorCanceller.cancel();\n        callbacks.onError(error);\n    });\n    contentDecryptor.addEventListener(\"warning\", (error) => {\n        callbacks.onWarning(error);\n    });\n    contentDecryptor.addEventListener(\"blackListProtectionData\", (x) => {\n        callbacks.onBlackListProtectionData(x);\n    });\n    contentDecryptor.addEventListener(\"keyIdsCompatibilityUpdate\", (x) => {\n        callbacks.onKeyIdsCompatibilityUpdate(x);\n    });\n    decryptorCanceller.signal.register(() => {\n        contentDecryptor.dispose();\n    });\n    return {\n        statusRef: drmStatusRef,\n        contentDecryptor: { enabled: true, value: contentDecryptor },\n    };\n    function createEmeDisabledReference(errMsg) {\n        const err = new EncryptedMediaError(\"MEDIA_IS_ENCRYPTED_ERROR\", errMsg);\n        const ref = new SharedReference({\n            initializationState: { type: \"initialized\", value: null },\n            drmSystemId: undefined,\n        });\n        ref.finish(); // We know that no new value will be triggered\n        return { statusRef: ref, contentDecryptor: { enabled: false, value: err } };\n    }\n}\n","/**\n * Implementation of an `ITextDisplayerInterface` running in the main\n * thread (so, in the same thread that the `ITextDisplayer`).\n *\n * This is mainly glue code to expose the right types.\n *\n * @class MainThreadTextDisplayerInterface\n */\nexport default class MainThreadTextDisplayerInterface {\n    /**\n     * @param {Object} displayer\n     */\n    constructor(displayer) {\n        this._displayer = displayer;\n    }\n    /**\n     * @see ITextDisplayerInterface\n     */\n    pushTextData(infos) {\n        try {\n            return Promise.resolve(this._displayer.pushTextData(infos));\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    /**\n     * @see ITextDisplayerInterface\n     */\n    remove(start, end) {\n        try {\n            return Promise.resolve(this._displayer.removeBuffer(start, end));\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    /**\n     * @see ITextDisplayerInterface\n     */\n    reset() {\n        this._displayer.reset();\n    }\n    /**\n     * @see ITextDisplayerInterface\n     */\n    stop() {\n        this._displayer.stop();\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport isSeekingApproximate from \"../../../compat/is_seeking_approximate\";\nimport config from \"../../../config\";\nimport { MediaError } from \"../../../errors\";\nimport log from \"../../../log\";\nimport { getPeriodAfter } from \"../../../manifest\";\nimport EventEmitter from \"../../../utils/event_emitter\";\nimport getMonotonicTimeStamp from \"../../../utils/monotonic_timestamp\";\nimport { getNextBufferedTimeRangeGap } from \"../../../utils/ranges\";\nimport TaskCanceller from \"../../../utils/task_canceller\";\n/**\n * Work-around rounding errors with floating points by setting an acceptable,\n * very short, deviation when checking equalities.\n */\nconst EPSILON = 1 / 60;\n/**\n * Monitor playback, trying to avoid stalling situation.\n * If stopping the player to build buffer is needed, temporarily set the\n * playback rate (i.e. speed) at `0` until enough buffer is available again.\n *\n * Emit \"stalled\" then \"unstalled\" respectively when an unavoidable stall is\n * encountered and exited.\n */\nexport default class RebufferingController extends EventEmitter {\n    /**\n     * @param {object} playbackObserver - emit the current playback conditions.\n     * @param {Object} manifest - The Manifest of the currently-played content.\n     * @param {Object} speed - The last speed set by the user\n     */\n    constructor(playbackObserver, manifest, speed) {\n        super();\n        this._playbackObserver = playbackObserver;\n        this._manifest = manifest;\n        this._speed = speed;\n        this._discontinuitiesStore = [];\n        this._isStarted = false;\n        this._canceller = new TaskCanceller();\n    }\n    start() {\n        if (this._isStarted) {\n            return;\n        }\n        this._isStarted = true;\n        const playbackRateUpdater = new PlaybackRateUpdater(this._playbackObserver, this._speed);\n        this._canceller.signal.register(() => {\n            playbackRateUpdater.dispose();\n        });\n        this._playbackObserver.listen((observation) => {\n            const discontinuitiesStore = this._discontinuitiesStore;\n            const { buffered, position, readyState, rebuffering, freezing } = observation;\n            const { BUFFER_DISCONTINUITY_THRESHOLD, FREEZING_STALLED_DELAY } = config.getCurrent();\n            if (freezing !== null) {\n                const now = getMonotonicTimeStamp();\n                if (now - freezing.timestamp > FREEZING_STALLED_DELAY) {\n                    if (rebuffering === null) {\n                        playbackRateUpdater.stopRebuffering();\n                    }\n                    else {\n                        playbackRateUpdater.startRebuffering();\n                    }\n                    this.trigger(\"stalled\", \"freezing\");\n                    return;\n                }\n            }\n            if (rebuffering === null) {\n                playbackRateUpdater.stopRebuffering();\n                if (readyState === 1) {\n                    // With a readyState set to 1, we should still not be able to play:\n                    // Return that we're stalled\n                    let reason;\n                    if (observation.seeking !== 0 /* SeekingState.None */) {\n                        reason =\n                            observation.seeking === 1 /* SeekingState.Internal */\n                                ? \"internal-seek\"\n                                : \"seeking\";\n                    }\n                    else {\n                        reason = \"not-ready\";\n                    }\n                    this.trigger(\"stalled\", reason);\n                    return;\n                }\n                this.trigger(\"unstalled\", null);\n                return;\n            }\n            // We want to separate a stall situation when a seek is due to a seek done\n            // internally by the player to when its due to a regular user seek.\n            const stalledReason = rebuffering.reason === \"seeking\" &&\n                observation.seeking === 1 /* SeekingState.Internal */\n                ? \"internal-seek\"\n                : rebuffering.reason;\n            if (position.isAwaitingFuturePosition()) {\n                playbackRateUpdater.stopRebuffering();\n                log.debug(\"Init: let rebuffering happen as we're awaiting a future position\");\n            }\n            else {\n                playbackRateUpdater.startRebuffering();\n            }\n            if (this._manifest === null ||\n                (isSeekingApproximate &&\n                    // Don't handle discontinuities on devices with broken seeks before\n                    // enough time have passed because seeking brings more risks to\n                    // lead to a lengthy rebuffering-exiting process\n                    getMonotonicTimeStamp() - rebuffering.timestamp <= 1000)) {\n                this.trigger(\"stalled\", stalledReason);\n                return;\n            }\n            /** Position at which data is awaited. */\n            const { position: stalledPosition } = rebuffering;\n            /**\n             * We may still be in the process of waiting for a position to be seeked\n             * to. When calculating a potential position to e.g. skip over\n             * discontinuities, we should compare it to that \"target\" position if\n             * one, not the one we're currently playing.\n             */\n            const targetTime = observation.position.isAwaitingFuturePosition()\n                ? observation.position.getWanted()\n                : this._playbackObserver.getCurrentTime();\n            if (stalledPosition !== null &&\n                stalledPosition !== undefined &&\n                this._speed.getValue() > 0) {\n                const skippableDiscontinuity = findSeekableDiscontinuity(discontinuitiesStore, this._manifest, stalledPosition);\n                if (skippableDiscontinuity !== null) {\n                    const realSeekTime = skippableDiscontinuity + 0.001;\n                    if (realSeekTime <= targetTime) {\n                        log.info(\"Init: position to seek already reached, no seeking\", targetTime, realSeekTime);\n                    }\n                    else {\n                        log.warn(\"SA: skippable discontinuity found in the stream\", position.getPolled(), realSeekTime);\n                        this._playbackObserver.setCurrentTime(realSeekTime);\n                        this.trigger(\"warning\", generateDiscontinuityError(stalledPosition, realSeekTime));\n                        return;\n                    }\n                }\n            }\n            const positionBlockedAt = stalledPosition !== null && stalledPosition !== void 0 ? stalledPosition : position.getPolled();\n            // Is it a very short discontinuity in buffer ? -> Seek at the beginning of the\n            //                                                 next range\n            //\n            // Discontinuity check in case we are close a buffered range but still\n            // calculate a stalled state. This is useful for some\n            // implementation that might drop an injected segment, or in\n            // case of small discontinuity in the content.\n            const nextBufferRangeGap = getNextBufferedTimeRangeGap(buffered, positionBlockedAt);\n            if ((!isSeekingApproximate ||\n                getMonotonicTimeStamp() - rebuffering.timestamp > 1000) &&\n                this._speed.getValue() > 0 &&\n                nextBufferRangeGap < BUFFER_DISCONTINUITY_THRESHOLD) {\n                const seekTo = positionBlockedAt + nextBufferRangeGap + EPSILON;\n                if (targetTime < seekTo) {\n                    log.warn(\"Init: discontinuity encountered inferior to the threshold\", positionBlockedAt, seekTo, BUFFER_DISCONTINUITY_THRESHOLD);\n                    this._playbackObserver.setCurrentTime(seekTo);\n                    this.trigger(\"warning\", generateDiscontinuityError(positionBlockedAt, seekTo));\n                    return;\n                }\n            }\n            // Are we in a discontinuity between periods ? -> Seek at the beginning of the\n            //                                                next period\n            for (let i = this._manifest.periods.length - 2; i >= 0; i--) {\n                const period = this._manifest.periods[i];\n                if (period.end !== undefined && period.end <= positionBlockedAt) {\n                    if (this._manifest.periods[i + 1].start > positionBlockedAt &&\n                        this._manifest.periods[i + 1].start > targetTime) {\n                        const nextPeriod = this._manifest.periods[i + 1];\n                        this._playbackObserver.setCurrentTime(nextPeriod.start);\n                        this.trigger(\"warning\", generateDiscontinuityError(positionBlockedAt, nextPeriod.start));\n                        return;\n                    }\n                    break;\n                }\n            }\n            this.trigger(\"stalled\", stalledReason);\n        }, { includeLastObservation: true, clearSignal: this._canceller.signal });\n    }\n    /**\n     * Update information on an upcoming discontinuity for a given buffer type and\n     * Period.\n     * Each new update for the same Period and type overwrites the previous one.\n     * @param {Object} evt\n     */\n    updateDiscontinuityInfo(evt) {\n        if (!this._isStarted) {\n            this.start();\n        }\n        const lastObservation = this._playbackObserver.getReference().getValue();\n        updateDiscontinuitiesStore(this._discontinuitiesStore, evt, lastObservation);\n    }\n    /**\n     * Function to call when a Stream is currently locked, i.e. we cannot load\n     * segments for the corresponding Period and buffer type until it is seeked\n     * to.\n     * @param {string} bufferType - Buffer type for which no segment will\n     * currently load.\n     * @param {Object} period - Period for which no segment will currently load.\n     */\n    onLockedStream(bufferType, period) {\n        var _a;\n        if (!this._isStarted) {\n            this.start();\n        }\n        const observation = this._playbackObserver.getReference().getValue();\n        if (observation.rebuffering === null ||\n            observation.paused ||\n            this._speed.getValue() <= 0 ||\n            (bufferType !== \"audio\" && bufferType !== \"video\")) {\n            return;\n        }\n        const loadedPos = observation.position.getWanted();\n        const rebufferingPos = (_a = observation.rebuffering.position) !== null && _a !== void 0 ? _a : loadedPos;\n        const lockedPeriodStart = period.start;\n        if (loadedPos < lockedPeriodStart &&\n            Math.abs(rebufferingPos - lockedPeriodStart) < 1) {\n            log.warn(\"Init: rebuffering because of a future locked stream.\\n\" +\n                \"Trying to unlock by seeking to the next Period\");\n            this._playbackObserver.setCurrentTime(lockedPeriodStart + 0.001);\n        }\n    }\n    /**\n     * Stops the `RebufferingController` from montoring stalling situations,\n     * forever.\n     */\n    destroy() {\n        this._canceller.cancel();\n    }\n}\n/**\n * @param {Array.<Object>} discontinuitiesStore\n * @param {Object} manifest\n * @param {number} stalledPosition\n * @returns {number|null}\n */\nfunction findSeekableDiscontinuity(discontinuitiesStore, manifest, stalledPosition) {\n    if (discontinuitiesStore.length === 0) {\n        return null;\n    }\n    let maxDiscontinuityEnd = null;\n    for (const discontinuityInfo of discontinuitiesStore) {\n        const { period } = discontinuityInfo;\n        if (period.start > stalledPosition) {\n            return maxDiscontinuityEnd;\n        }\n        let discontinuityEnd;\n        if (period.end === undefined || period.end > stalledPosition) {\n            const { discontinuity, position } = discontinuityInfo;\n            const { start, end } = discontinuity;\n            const discontinuityLowerLimit = start !== null && start !== void 0 ? start : position;\n            if (stalledPosition >= discontinuityLowerLimit - EPSILON) {\n                if (end === null) {\n                    const nextPeriod = getPeriodAfter(manifest, period);\n                    if (nextPeriod !== null) {\n                        discontinuityEnd = nextPeriod.start + EPSILON;\n                    }\n                    else {\n                        log.warn(\"Init: discontinuity at Period's end but no next Period\");\n                    }\n                }\n                else if (stalledPosition < end + EPSILON) {\n                    discontinuityEnd = end + EPSILON;\n                }\n            }\n            if (discontinuityEnd !== undefined) {\n                log.info(\"Init: discontinuity found\", stalledPosition, discontinuityEnd);\n                maxDiscontinuityEnd =\n                    maxDiscontinuityEnd !== null && maxDiscontinuityEnd > discontinuityEnd\n                        ? maxDiscontinuityEnd\n                        : discontinuityEnd;\n            }\n        }\n    }\n    return maxDiscontinuityEnd;\n}\n/**\n * Return `true` if the given event indicates that a discontinuity is present.\n * @param {Object} evt\n * @returns {Array.<Object>}\n */\nfunction eventContainsDiscontinuity(evt) {\n    return evt.discontinuity !== null;\n}\n/**\n * Update the `discontinuitiesStore` Object with the given event information:\n *\n *   - If that event indicates than no discontinuity is found for a Period\n *     and buffer type, remove a possible existing discontinuity for that\n *     combination.\n *\n *   - If that event indicates that a discontinuity can be found for a Period\n *     and buffer type, replace previous occurences for that combination and\n *     store it in Period's chronological order in the Array.\n * @param {Array.<Object>} discontinuitiesStore\n * @param {Object} evt\n * @param {Object} observation\n * @returns {Array.<Object>}\n */\nfunction updateDiscontinuitiesStore(discontinuitiesStore, evt, observation) {\n    const gcTime = Math.min(observation.position.getPolled(), observation.position.getWanted());\n    // First, perform clean-up of old discontinuities\n    while (discontinuitiesStore.length > 0 &&\n        discontinuitiesStore[0].period.end !== undefined &&\n        discontinuitiesStore[0].period.end + 10 < gcTime) {\n        discontinuitiesStore.shift();\n    }\n    const { period, bufferType } = evt;\n    if (bufferType !== \"audio\" && bufferType !== \"video\") {\n        return;\n    }\n    for (let i = 0; i < discontinuitiesStore.length; i++) {\n        if (discontinuitiesStore[i].period.id === period.id) {\n            if (discontinuitiesStore[i].bufferType === bufferType) {\n                if (!eventContainsDiscontinuity(evt)) {\n                    discontinuitiesStore.splice(i, 1);\n                }\n                else {\n                    discontinuitiesStore[i] = evt;\n                }\n                return;\n            }\n        }\n        else if (discontinuitiesStore[i].period.start > period.start) {\n            if (eventContainsDiscontinuity(evt)) {\n                discontinuitiesStore.splice(i, 0, evt);\n            }\n            return;\n        }\n    }\n    if (eventContainsDiscontinuity(evt)) {\n        discontinuitiesStore.push(evt);\n    }\n    return;\n}\n/**\n * Generate error emitted when a discontinuity has been encountered.\n * @param {number} stalledPosition\n * @param {number} seekTo\n * @returns {Error}\n */\nfunction generateDiscontinuityError(stalledPosition, seekTo) {\n    return new MediaError(\"DISCONTINUITY_ENCOUNTERED\", \"A discontinuity has been encountered at position \" +\n        String(stalledPosition) +\n        \", seeking at position \" +\n        String(seekTo));\n}\n/**\n * Manage playback speed, allowing to force a playback rate of `0` when\n * rebuffering is wanted.\n *\n * Only one `PlaybackRateUpdater` should be created per HTMLMediaElement.\n * Note that the `PlaybackRateUpdater` reacts to playback event and wanted\n * speed change. You should call its `dispose` method once you don't need it\n * anymore.\n * @class PlaybackRateUpdater\n */\nclass PlaybackRateUpdater {\n    /**\n     * Create a new `PlaybackRateUpdater`.\n     * @param {Object} playbackObserver\n     * @param {Object} speed\n     */\n    constructor(playbackObserver, speed) {\n        this._speedUpdateCanceller = new TaskCanceller();\n        this._isRebuffering = false;\n        this._playbackObserver = playbackObserver;\n        this._isDisposed = false;\n        this._speed = speed;\n        this._updateSpeed();\n    }\n    /**\n     * Force the playback rate to `0`, to start a rebuffering phase.\n     *\n     * You can call `stopRebuffering` when you want the rebuffering phase to end.\n     */\n    startRebuffering() {\n        if (this._isRebuffering || this._isDisposed) {\n            return;\n        }\n        this._isRebuffering = true;\n        this._speedUpdateCanceller.cancel();\n        log.info(\"Init: Pause playback to build buffer\");\n        this._playbackObserver.setPlaybackRate(0);\n    }\n    /**\n     * If in a rebuffering phase (during which the playback rate is forced to\n     * `0`), exit that phase to apply the wanted playback rate instead.\n     *\n     * Do nothing if not in a rebuffering phase.\n     */\n    stopRebuffering() {\n        if (!this._isRebuffering || this._isDisposed) {\n            return;\n        }\n        this._isRebuffering = false;\n        this._speedUpdateCanceller = new TaskCanceller();\n        this._updateSpeed();\n    }\n    /**\n     * The `PlaybackRateUpdater` allocate resources to for example listen to\n     * wanted speed changes and react to it.\n     *\n     * Consequently, you should call the `dispose` method, when you don't want the\n     * `PlaybackRateUpdater` to have an effect anymore.\n     */\n    dispose() {\n        this._speedUpdateCanceller.cancel();\n        this._isDisposed = true;\n    }\n    _updateSpeed() {\n        this._speed.onUpdate((lastSpeed) => {\n            log.info(\"Init: Resume playback speed\", lastSpeed);\n            this._playbackObserver.setPlaybackRate(lastSpeed);\n        }, {\n            clearSignal: this._speedUpdateCanceller.signal,\n            emitCurrentValue: true,\n        });\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Compare 2 events.\n * As the payload of two events may be the same, but the JS objects may not\n * have the same references, it may be difficult to compare them.\n * If two events start and end at the same moment, and possess the same id,\n * we consider the two to be the same.\n * /!\\ However, the DASH-if spec does not say that the event payload\n * may be the same if these conditions are met. Thus, there are high chances\n * that it may be the case.\n * TODO See if we can compare payloads\n * @param {Object} evt1\n * @param {Object} evt2\n * @returns {Boolean}\n */\nfunction areSameStreamEvents(evt1, evt2) {\n    return evt1.id === evt2.id && evt1.start === evt2.start && evt1.end === evt2.end;\n}\nexport default areSameStreamEvents;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport streamEventsEmitter from \"./stream_events_emitter\";\nexport default streamEventsEmitter;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport areSameStreamEvents from \"./are_same_stream_events\";\n/**\n * Refresh local scheduled events list\n * @param {Array.<Object>} oldScheduledEvents\n * @param {Object} manifest\n * @returns {Array.<Object>}\n */\nfunction refreshScheduledEventsList(oldScheduledEvents, manifest) {\n    const scheduledEvents = [];\n    const { periods } = manifest;\n    for (const period of periods) {\n        const { streamEvents } = period;\n        streamEvents.forEach(({ start, end, id, data }) => {\n            for (const currentScheduledEvent of oldScheduledEvents) {\n                if (areSameStreamEvents(currentScheduledEvent, { id, start, end })) {\n                    scheduledEvents.push(currentScheduledEvent);\n                    return;\n                }\n            }\n            let element;\n            if (data.value.element !== undefined) {\n                element = data.value.element;\n            }\n            else if (data.value.xmlData !== undefined) {\n                // First, we will create a parent Element defining all namespaces that\n                // should have been encountered until know.\n                // This is needed because the DOMParser API might throw when\n                // encountering unknown namespaced attributes or elements in the given\n                // `<Event>` xml subset.\n                let parentNode = data.value.xmlData.namespaces.reduce((acc, ns) => {\n                    return acc + \"xmlns:\" + ns.key + '=\"' + ns.value + '\" ';\n                }, \"<toremove \");\n                parentNode += \">\";\n                const parsedDom = new DOMParser().parseFromString(parentNode + data.value.xmlData.data + \"</toremove>\", \"application/xml\").documentElement;\n                element =\n                    parsedDom.children.length > 0\n                        ? parsedDom.children[0]\n                        : parsedDom.childNodes[0];\n            }\n            else {\n                return;\n            }\n            const actualData = { type: data.type, value: Object.assign(Object.assign({}, data.value), { element }) };\n            if (end === undefined) {\n                const newScheduledEvent = {\n                    start,\n                    id,\n                    data: actualData,\n                    publicEvent: { start, data: actualData },\n                };\n                scheduledEvents.push(newScheduledEvent);\n            }\n            else {\n                const newScheduledEvent = {\n                    start,\n                    end,\n                    id,\n                    data: actualData,\n                    publicEvent: { start, end, data: actualData },\n                };\n                scheduledEvents.push(newScheduledEvent);\n            }\n        });\n    }\n    return scheduledEvents;\n}\nexport default refreshScheduledEventsList;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport config from \"../../../../config\";\nimport EventEmitter from \"../../../../utils/event_emitter\";\nimport SharedReference from \"../../../../utils/reference\";\nimport TaskCanceller from \"../../../../utils/task_canceller\";\nimport refreshScheduledEventsList from \"./refresh_scheduled_events_list\";\n/**\n * Get events from manifest and emit each time an event has to be emitted\n */\nexport default class StreamEventsEmitter extends EventEmitter {\n    /**\n     * @param {Object} manifest\n     * @param {Object} playbackObserver\n     */\n    constructor(manifest, playbackObserver) {\n        super();\n        this._manifest = manifest;\n        this._playbackObserver = playbackObserver;\n        this._canceller = null;\n        this._scheduledEventsRef = new SharedReference([]);\n        this._eventsBeingPlayed = new WeakMap();\n    }\n    start() {\n        if (this._canceller !== null) {\n            return;\n        }\n        this._canceller = new TaskCanceller();\n        const cancelSignal = this._canceller.signal;\n        const playbackObserver = this._playbackObserver;\n        let isPollingEvents = false;\n        let cancelCurrentPolling = new TaskCanceller();\n        cancelCurrentPolling.linkToSignal(cancelSignal);\n        this._scheduledEventsRef.setValue(refreshScheduledEventsList([], this._manifest));\n        this._scheduledEventsRef.onUpdate(({ length: scheduledEventsLength }) => {\n            if (scheduledEventsLength === 0) {\n                if (isPollingEvents) {\n                    cancelCurrentPolling.cancel();\n                    cancelCurrentPolling = new TaskCanceller();\n                    cancelCurrentPolling.linkToSignal(cancelSignal);\n                    isPollingEvents = false;\n                }\n                return;\n            }\n            else if (isPollingEvents) {\n                return;\n            }\n            isPollingEvents = true;\n            let oldObservation = constructObservation();\n            const checkStreamEvents = () => {\n                const newObservation = constructObservation();\n                this._emitStreamEvents(this._scheduledEventsRef.getValue(), oldObservation, newObservation, cancelCurrentPolling.signal);\n                oldObservation = newObservation;\n            };\n            const { STREAM_EVENT_EMITTER_POLL_INTERVAL } = config.getCurrent();\n            const intervalId = setInterval(checkStreamEvents, STREAM_EVENT_EMITTER_POLL_INTERVAL);\n            playbackObserver.listen(checkStreamEvents, {\n                includeLastObservation: false,\n                clearSignal: cancelCurrentPolling.signal,\n            });\n            cancelCurrentPolling.signal.register(() => {\n                clearInterval(intervalId);\n            });\n            function constructObservation() {\n                var _a;\n                const lastObservation = playbackObserver.getReference().getValue();\n                const currentTime = (_a = playbackObserver.getCurrentTime()) !== null && _a !== void 0 ? _a : playbackObserver.getReference().getValue().position.getPolled();\n                const isSeeking = lastObservation.seeking !== 0 /* SeekingState.None */;\n                return { currentTime, isSeeking };\n            }\n        }, { emitCurrentValue: true, clearSignal: cancelSignal });\n    }\n    onManifestUpdate(man) {\n        const prev = this._scheduledEventsRef.getValue();\n        this._scheduledEventsRef.setValue(refreshScheduledEventsList(prev, man));\n    }\n    stop() {\n        if (this._canceller !== null) {\n            this._canceller.cancel();\n            this._canceller = null;\n        }\n    }\n    /**\n     * Examine playback situation from playback observations to emit stream events and\n     * prepare set onExit callbacks if needed.\n     * @param {Array.<Object>} scheduledEvents\n     * @param {Object} oldObservation\n     * @param {Object} newObservation\n     * @param {Object} stopSignal\n     */\n    _emitStreamEvents(scheduledEvents, oldObservation, newObservation, stopSignal) {\n        const { currentTime: previousTime } = oldObservation;\n        const { isSeeking, currentTime } = newObservation;\n        const eventsToSend = [];\n        const eventsToExit = [];\n        for (let i = 0; i < scheduledEvents.length; i++) {\n            const event = scheduledEvents[i];\n            const start = event.start;\n            const end = isFiniteStreamEvent(event) ? event.end : undefined;\n            const isBeingPlayed = this._eventsBeingPlayed.has(event);\n            if (isBeingPlayed) {\n                if (start > currentTime || (end !== undefined && currentTime >= end)) {\n                    if (isFiniteStreamEvent(event)) {\n                        eventsToExit.push(event.publicEvent);\n                    }\n                    this._eventsBeingPlayed.delete(event);\n                }\n            }\n            else if (start <= currentTime && end !== undefined && currentTime < end) {\n                eventsToSend.push({ type: \"stream-event\", value: event.publicEvent });\n                this._eventsBeingPlayed.set(event, true);\n            }\n            else if (previousTime < start && currentTime >= (end !== null && end !== void 0 ? end : start)) {\n                if (isSeeking) {\n                    eventsToSend.push({\n                        type: \"stream-event-skip\",\n                        value: event.publicEvent,\n                    });\n                }\n                else {\n                    eventsToSend.push({ type: \"stream-event\", value: event.publicEvent });\n                    if (isFiniteStreamEvent(event)) {\n                        eventsToExit.push(event.publicEvent);\n                    }\n                }\n            }\n        }\n        if (eventsToSend.length > 0) {\n            for (const event of eventsToSend) {\n                if (event.type === \"stream-event\") {\n                    this.trigger(\"event\", event.value);\n                }\n                else {\n                    this.trigger(\"eventSkip\", event.value);\n                }\n                if (stopSignal.isCancelled()) {\n                    return;\n                }\n            }\n        }\n        if (eventsToExit.length > 0) {\n            for (const event of eventsToExit) {\n                if (typeof event.onExit === \"function\") {\n                    event.onExit();\n                }\n                if (stopSignal.isCancelled()) {\n                    return;\n                }\n            }\n        }\n    }\n}\n/**\n * Tells if a stream event has a duration\n * @param {Object} evt\n * @returns {Boolean}\n */\nfunction isFiniteStreamEvent(evt) {\n    return evt.end !== undefined;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { MediaError } from \"../../../errors\";\nimport isNullOrUndefined from \"../../../utils/is_null_or_undefined\";\n/**\n * @param {HTMLMediaElement} mediaElement\n * @param {Function} onError\n * @param {Object} cancelSignal\n */\nexport default function listenToMediaError(mediaElement, onError, cancelSignal) {\n    if (cancelSignal.isCancelled()) {\n        return;\n    }\n    mediaElement.addEventListener(\"error\", onMediaError);\n    cancelSignal.register(() => {\n        mediaElement.removeEventListener(\"error\", onMediaError);\n    });\n    function onMediaError() {\n        const mediaError = mediaElement.error;\n        let errorCode;\n        let errorMessage;\n        if (!isNullOrUndefined(mediaError)) {\n            errorCode = mediaError.code;\n            errorMessage = mediaError.message;\n        }\n        switch (errorCode) {\n            case 1:\n                errorMessage =\n                    errorMessage !== null && errorMessage !== void 0 ? errorMessage : \"The fetching of the associated resource was aborted by the user's request.\";\n                return onError(new MediaError(\"MEDIA_ERR_ABORTED\", errorMessage));\n            case 2:\n                errorMessage =\n                    errorMessage !== null && errorMessage !== void 0 ? errorMessage : \"A network error occurred which prevented the media from being \" +\n                        \"successfully fetched\";\n                return onError(new MediaError(\"MEDIA_ERR_NETWORK\", errorMessage));\n            case 3:\n                errorMessage =\n                    errorMessage !== null && errorMessage !== void 0 ? errorMessage : \"An error occurred while trying to decode the media resource\";\n                return onError(new MediaError(\"MEDIA_ERR_DECODE\", errorMessage));\n            case 4:\n                errorMessage =\n                    errorMessage !== null && errorMessage !== void 0 ? errorMessage : \"The media resource has been found to be unsuitable.\";\n                return onError(new MediaError(\"MEDIA_ERR_SRC_NOT_SUPPORTED\", errorMessage));\n            default:\n                errorMessage =\n                    errorMessage !== null && errorMessage !== void 0 ? errorMessage : \"The HTMLMediaElement errored due to an unknown reason.\";\n                return onError(new MediaError(\"MEDIA_ERR_UNKNOWN\", errorMessage));\n        }\n    }\n}\n","import isCodecSupported from \"../../../compat/is_codec_supported\";\nimport { MediaError } from \"../../../errors\";\nimport isNullOrUndefined from \"../../../utils/is_null_or_undefined\";\nimport { ContentDecryptorState } from \"../../decrypt\";\nexport function getCodecsWithUnknownSupport(manifest) {\n    var _a, _b, _c, _d, _e;\n    const codecsWithUnknownSupport = [];\n    for (const period of manifest.periods) {\n        const checkedAdaptations = [\n            ...((_a = period.adaptations.video) !== null && _a !== void 0 ? _a : []),\n            ...((_b = period.adaptations.audio) !== null && _b !== void 0 ? _b : []),\n        ];\n        for (const adaptation of checkedAdaptations) {\n            if (!adaptation.supportStatus.hasCodecWithUndefinedSupport) {\n                continue;\n            }\n            for (const representation of adaptation.representations) {\n                if (representation.isSupported === undefined) {\n                    codecsWithUnknownSupport.push({\n                        mimeType: (_c = representation.mimeType) !== null && _c !== void 0 ? _c : \"\",\n                        codec: (_e = (_d = representation.codecs) === null || _d === void 0 ? void 0 : _d[0]) !== null && _e !== void 0 ? _e : \"\",\n                    });\n                }\n            }\n        }\n    }\n    return codecsWithUnknownSupport;\n}\n/**\n * Ensure that all `Representation` and `Adaptation` have a known status\n * for their codec support and probe it for cases where that's not the\n * case.\n *\n * Because probing for codec support is always synchronous in the main thread,\n * calling this function ensures that support is now known.\n *\n * @param {Object} manifest - The manifest to update\n * @param {Object|null} contentDecryptor - The current content decryptor\n * @param {boolean} isPlayingWithMSEinWorker - True if WebWorker is used with MSE in worker\n * @returns {Array.<Object>}\n */\nexport function updateManifestCodecSupport(manifest, contentDecryptor, isPlayingWithMSEinWorker) {\n    const codecSupportMap = new Map();\n    const updatedCodecs = [];\n    const efficientlyGetCodecSupport = (mimeType, codec) => {\n        var _a;\n        const inputCodec = `${mimeType !== null && mimeType !== void 0 ? mimeType : \"\"};codecs=\"${codec !== null && codec !== void 0 ? codec : \"\"}\"`;\n        const baseData = codecSupportMap.get(inputCodec);\n        if (baseData !== undefined) {\n            return baseData;\n        }\n        let newData;\n        const isSupported = isCodecSupported(inputCodec);\n        if (!isSupported) {\n            newData = {\n                isSupportedClear: false,\n                isSupportedEncrypted: false,\n            };\n        }\n        else if (isNullOrUndefined(contentDecryptor)) {\n            newData = {\n                isSupportedClear: true,\n                // This is ambiguous. Less assume that with no ContentDecryptor, an\n                // encrypted codec is supported\n                isSupportedEncrypted: true,\n            };\n        }\n        else if (contentDecryptor.getState() === ContentDecryptorState.Initializing) {\n            newData = {\n                isSupportedClear: true,\n                isSupportedEncrypted: undefined,\n            };\n        }\n        else {\n            newData = {\n                isSupportedClear: true,\n                isSupportedEncrypted: (_a = contentDecryptor.isCodecSupported(mimeType !== null && mimeType !== void 0 ? mimeType : \"\", codec !== null && codec !== void 0 ? codec : \"\")) !== null && _a !== void 0 ? _a : true,\n            };\n        }\n        codecSupportMap.set(inputCodec, newData);\n        updatedCodecs.push({\n            codec: codec !== null && codec !== void 0 ? codec : \"\",\n            mimeType: mimeType !== null && mimeType !== void 0 ? mimeType : \"\",\n            supported: newData.isSupportedClear,\n            supportedIfEncrypted: newData.isSupportedEncrypted,\n        });\n        return newData;\n    };\n    manifest.periods.forEach((p) => {\n        var _a, _b, _c;\n        [\n            ...((_a = p.adaptations.audio) !== null && _a !== void 0 ? _a : []),\n            ...((_b = p.adaptations.video) !== null && _b !== void 0 ? _b : []),\n            ...((_c = p.adaptations.text) !== null && _c !== void 0 ? _c : []),\n        ].forEach((adaptation) => {\n            let hasSupportedCodec = false;\n            let hasCodecWithUndefinedSupport = false;\n            adaptation.representations.forEach((representation) => {\n                var _a, _b;\n                if (representation.isCodecSupportedInWebWorker === false &&\n                    isPlayingWithMSEinWorker) {\n                    representation.isSupported = false;\n                    return;\n                }\n                if (representation.isSupported !== undefined) {\n                    if (representation.isSupported) {\n                        hasSupportedCodec = true;\n                    }\n                    // We already knew the support for that one, continue to next one\n                    return;\n                }\n                const isEncrypted = representation.contentProtections !== undefined;\n                const mimeType = (_a = representation.mimeType) !== null && _a !== void 0 ? _a : \"\";\n                let codecs = (_b = representation.codecs) !== null && _b !== void 0 ? _b : [];\n                if (codecs.length === 0) {\n                    codecs = [\"\"];\n                }\n                for (const codec of codecs) {\n                    const codecSupportInfo = efficientlyGetCodecSupport(mimeType, codec);\n                    if (!isEncrypted) {\n                        representation.isSupported = codecSupportInfo.isSupportedClear;\n                    }\n                    else if (representation.isSupported !== codecSupportInfo.isSupportedEncrypted) {\n                        representation.isSupported = codecSupportInfo.isSupportedEncrypted;\n                    }\n                    if (representation.isSupported === undefined) {\n                        hasCodecWithUndefinedSupport = true;\n                    }\n                    else if (representation.isSupported) {\n                        hasSupportedCodec = true;\n                        representation.codecs = [codec];\n                        // Don't test subsequent codecs for that Representation\n                        break;\n                    }\n                }\n            });\n            adaptation.supportStatus.hasCodecWithUndefinedSupport =\n                hasCodecWithUndefinedSupport;\n            if (hasCodecWithUndefinedSupport && !hasSupportedCodec) {\n                adaptation.supportStatus.hasSupportedCodec = undefined;\n            }\n            else {\n                adaptation.supportStatus.hasSupportedCodec = hasSupportedCodec;\n            }\n        });\n        [\"audio\", \"video\"].forEach((ttype) => {\n            const forType = p.adaptations[ttype];\n            if (forType !== undefined &&\n                forType.every((a) => a.supportStatus.hasSupportedCodec === false)) {\n                throw new MediaError(\"MANIFEST_INCOMPATIBLE_CODECS_ERROR\", \"No supported \" + ttype + \" adaptations\", { tracks: undefined });\n            }\n        });\n    });\n    return updatedCodecs;\n}\n","import { formatError } from \"../errors\";\nimport errorMessage from \"../errors/error_message\";\nimport { getPeriodForTime } from \"../manifest\";\nimport arrayFind from \"../utils/array_find\";\nimport arrayFindIndex from \"../utils/array_find_index\";\nimport TaskCanceller from \"../utils/task_canceller\";\n/**\n * Render thumbnail available at `time` in the given `container` (in place of\n * a potential previously-rendered thumbnail in that container).\n *\n * If there is no thumbnail at this time, or if there is but it fails to\n * load/render, also removes the previously displayed thumbnail, unless\n * `options.keepPreviousThumbnailOnError` is set to `true`.\n *\n * Returns a Promise which resolves when the thumbnail is rendered successfully,\n * rejects if anything prevented a thumbnail to be rendered.\n *\n * A newer `renderThumbnail` call performed while a previous `renderThumbnail`\n * call on the same container did not yet finish will abort that previous call,\n * rejecting the old call's returned promise.\n *\n * You may know if the promise returned by `renderThumbnail` rejected due to it\n * being aborted, by checking the `code` property on the rejected error: Error\n * due to aborting have their `code` property set to `ABORTED`.\n *\n * @param {Object} contentInfos\n * @param {Object} options\n * @returns {Object}\n */\nexport default async function renderThumbnail(contentInfos, options) {\n    const { time, container } = options;\n    if (contentInfos === null ||\n        contentInfos.fetchThumbnailDataCallback === null ||\n        contentInfos.manifest === null) {\n        return Promise.reject(new ThumbnailRenderingError(\"NO_CONTENT\", \"Cannot get thumbnail: no content loaded\"));\n    }\n    const { thumbnailRequestsInfo, currentContentCanceller } = contentInfos;\n    const canceller = new TaskCanceller();\n    canceller.linkToSignal(currentContentCanceller.signal);\n    let imageUrl;\n    const olderTaskSameContainer = thumbnailRequestsInfo.pendingRequests.get(container);\n    olderTaskSameContainer === null || olderTaskSameContainer === void 0 ? void 0 : olderTaskSameContainer.cancel();\n    thumbnailRequestsInfo.pendingRequests.set(container, canceller);\n    const onFinished = () => {\n        canceller.cancel();\n        thumbnailRequestsInfo.pendingRequests.delete(container);\n        // Let's revoke the URL after a round-trip to the event loop just in case\n        // to prevent revoking before the browser use it.\n        // This is normally not necessary, but better safe than sorry.\n        setTimeout(() => {\n            if (imageUrl !== undefined) {\n                URL.revokeObjectURL(imageUrl);\n            }\n        }, 0);\n    };\n    try {\n        const period = getPeriodForTime(contentInfos.manifest, time);\n        if (period === undefined) {\n            throw new ThumbnailRenderingError(\"NO_THUMBNAIL\", \"Wanted Period not found.\");\n        }\n        const thumbnailTracks = period.thumbnailTracks;\n        const thumbnailTrack = options.thumbnailTrackId !== undefined\n            ? arrayFind(thumbnailTracks, (t) => t.id === options.thumbnailTrackId)\n            : thumbnailTracks[0];\n        if (thumbnailTrack === undefined) {\n            if (options.thumbnailTrackId !== undefined) {\n                throw new ThumbnailRenderingError(\"NO_THUMBNAIL\", \"Given `thumbnailTrackId` not found\");\n            }\n            else {\n                throw new ThumbnailRenderingError(\"NO_THUMBNAIL\", \"Wanted Period has no thumbnail track.\");\n            }\n        }\n        const { lastResponse } = thumbnailRequestsInfo;\n        let res;\n        if (lastResponse !== null &&\n            lastResponse.thumbnailTrackId === thumbnailTrack.id &&\n            lastResponse.periodId === period.id) {\n            const previousThumbs = lastResponse.response.thumbnails;\n            if (previousThumbs.length > 0 &&\n                time >= previousThumbs[0].start &&\n                time < previousThumbs[previousThumbs.length - 1].end) {\n                res = lastResponse.response;\n            }\n        }\n        if (res === undefined) {\n            res = await contentInfos.fetchThumbnailDataCallback(period.id, thumbnailTrack.id, time);\n            thumbnailRequestsInfo.lastResponse = {\n                response: res,\n                periodId: period.id,\n                thumbnailTrackId: thumbnailTrack.id,\n            };\n        }\n        if (canceller.signal.cancellationError !== null) {\n            throw canceller.signal.cancellationError;\n        }\n        const canvas = document.createElement(\"canvas\");\n        const context = canvas.getContext(\"2d\");\n        if (context === null) {\n            throw new ThumbnailRenderingError(\"RENDERING\", \"Cannot display thumbnail: cannot create canvas context\");\n        }\n        const foundIdx = arrayFindIndex(res.thumbnails, (t) => {\n            return t.start <= time && t.end > time;\n        });\n        if (foundIdx < 0) {\n            throw new Error(\"Cannot display thumbnail: time not found in fetched data\");\n        }\n        const image = new Image();\n        const blob = new Blob([res.data], { type: res.mimeType });\n        imageUrl = URL.createObjectURL(blob);\n        image.src = imageUrl;\n        canvas.height = res.thumbnails[foundIdx].height;\n        canvas.width = res.thumbnails[foundIdx].width;\n        return new Promise((resolve, reject) => {\n            image.onload = () => {\n                try {\n                    context.drawImage(image, res.thumbnails[foundIdx].offsetX, res.thumbnails[foundIdx].offsetY, res.thumbnails[foundIdx].width, res.thumbnails[foundIdx].height, 0, 0, res.thumbnails[foundIdx].width, res.thumbnails[foundIdx].height);\n                    canvas.style.width = \"100%\";\n                    canvas.style.height = \"100%\";\n                    canvas.className = \"__rx-thumbnail__\";\n                    clearPreviousThumbnails();\n                    container.appendChild(canvas);\n                    resolve();\n                }\n                catch (srcError) {\n                    reject(new ThumbnailRenderingError(\"RENDERING\", \"Could not draw the image in a canvas:\" +\n                        (srcError instanceof Error ? srcError.toString() : \"Unknown Error\")));\n                }\n                onFinished();\n            };\n            image.onerror = () => {\n                if (options.keepPreviousThumbnailOnError !== true) {\n                    clearPreviousThumbnails();\n                }\n                reject(new ThumbnailRenderingError(\"RENDERING\", \"Could not load the corresponding image in the DOM\"));\n                onFinished();\n            };\n        });\n    }\n    catch (srcError) {\n        if (options.keepPreviousThumbnailOnError !== true) {\n            clearPreviousThumbnails();\n        }\n        if (srcError !== null && srcError === canceller.signal.cancellationError) {\n            const error = new ThumbnailRenderingError(\"ABORTED\", \"Thumbnail rendering has been aborted\");\n            throw error;\n        }\n        const formattedErr = formatError(srcError, {\n            defaultCode: \"NONE\",\n            defaultReason: \"Unknown error\",\n        });\n        let returnedError;\n        if (formattedErr.type === \"NETWORK_ERROR\") {\n            returnedError = new ThumbnailRenderingError(\"LOADING\", formattedErr.message);\n        }\n        else {\n            returnedError = new ThumbnailRenderingError(\"NOT_FOUND\", formattedErr.message);\n        }\n        onFinished();\n        throw returnedError;\n    }\n    function clearPreviousThumbnails() {\n        for (let i = container.children.length - 1; i >= 0; i--) {\n            const child = container.children[i];\n            if (child.className === \"__rx-thumbnail__\") {\n                container.removeChild(child);\n            }\n        }\n    }\n}\n/**\n * Error specifcically defined for the thumbnail rendering API.\n * A caller is then supposed to programatically classify the type of error\n * by checking the `code` property from such an error.\n * @class ThumbnailRenderingError\n */\nclass ThumbnailRenderingError extends Error {\n    /**\n     * @param {string} code\n     * @param {string} message\n     */\n    constructor(code, message) {\n        super(errorMessage(code, message));\n        Object.setPrototypeOf(this, ThumbnailRenderingError.prototype);\n        this.name = \"ThumbnailRenderingError\";\n        this.code = code;\n    }\n}\n","import features from \"../../../features\";\nimport log from \"../../../log\";\n/**\n * Convert text track data into timed HTML Cues.\n * @param {string} type - Text track format wanted\n * @param {string} data - Text track data\n * @param {Number} timestampOffset - offset to apply to every timed text\n * @param {string} [language] - language of the text tracks\n * @returns {Array.<Object>}\n * @throws Error - Throw if no parser is found for the given type\n */\nexport default function parseTextTrackToElements(type, data, timestampOffset, language) {\n    log.debug(\"HTSB: Finding parser for html text tracks:\", type);\n    const parser = features.htmlTextTracksParsers[type];\n    if (typeof parser !== \"function\") {\n        throw new Error(\"no parser found for the given text track\");\n    }\n    log.debug(\"HTSB: Parser found, parsing...\");\n    const parsed = parser(data, timestampOffset, language);\n    log.debug(\"HTTB: Parsed successfully!\", parsed.length);\n    return parsed;\n}\n","import { onEnded, onSeeked, onSeeking } from \"../../../compat/event_listeners\";\nimport onHeightWidthChange from \"../../../compat/on_height_width_change\";\nimport config from \"../../../config\";\nimport log from \"../../../log\";\nimport { convertToRanges } from \"../../../utils/ranges\";\nimport TaskCanceller from \"../../../utils/task_canceller\";\nimport ManualTimeRanges from \"../manual_time_ranges\";\nimport parseTextTrackToElements from \"./html_parsers\";\nimport TextTrackCuesStore from \"./text_track_cues_store\";\nimport updateProportionalElements from \"./update_proportional_elements\";\n/**\n * @param {Element} element\n * @param {Element} child\n */\nfunction safelyRemoveChild(element, child) {\n    try {\n        element.removeChild(child);\n    }\n    catch (_error) {\n        log.warn(\"HTD: Can't remove text track: not in the element.\");\n    }\n}\n/**\n * @param {HTMLElement} element\n * @returns {Object|null}\n */\nfunction getElementResolution(element) {\n    const strRows = element.getAttribute(\"data-resolution-rows\");\n    const strColumns = element.getAttribute(\"data-resolution-columns\");\n    if (strRows === null || strColumns === null) {\n        return null;\n    }\n    const rows = parseInt(strRows, 10);\n    const columns = parseInt(strColumns, 10);\n    if (rows === null || columns === null) {\n        return null;\n    }\n    return { rows, columns };\n}\n/**\n * TextDisplayer implementation which display buffered TextTracks in the given\n * HTML element.\n * @class HTMLTextDisplayer\n */\nexport default class HTMLTextDisplayer {\n    /**\n     * @param {HTMLMediaElement} videoElement\n     * @param {HTMLElement} textTrackElement\n     */\n    constructor(videoElement, textTrackElement) {\n        log.debug(\"HTD: Creating HTMLTextDisplayer\");\n        this._buffered = new ManualTimeRanges();\n        this._videoElement = videoElement;\n        this._textTrackElement = textTrackElement;\n        this._sizeUpdateCanceller = new TaskCanceller();\n        this._subtitlesIntervalCanceller = new TaskCanceller();\n        this._buffer = new TextTrackCuesStore();\n        this._currentCues = [];\n        this._isAutoRefreshing = false;\n    }\n    /**\n     * Push text segment to the HTMLTextDisplayer.\n     * @param {Object} infos\n     * @returns {Object}\n     */\n    pushTextData(infos) {\n        var _a, _b;\n        log.debug(\"HTD: Appending new html text tracks\");\n        const { timestampOffset, appendWindow, chunk } = infos;\n        if (chunk === null) {\n            return convertToRanges(this._buffered);\n        }\n        const { start: startTime, end: endTime, data: dataString, type, language } = chunk;\n        const appendWindowStart = (_a = appendWindow[0]) !== null && _a !== void 0 ? _a : 0;\n        const appendWindowEnd = (_b = appendWindow[1]) !== null && _b !== void 0 ? _b : Infinity;\n        const cues = parseTextTrackToElements(type, dataString, timestampOffset, language);\n        if (appendWindowStart !== 0 && appendWindowEnd !== Infinity) {\n            // Removing before window start\n            let i = 0;\n            while (i < cues.length && cues[i].end <= appendWindowStart) {\n                i++;\n            }\n            cues.splice(0, i);\n            i = 0;\n            while (i < cues.length && cues[i].start < appendWindowStart) {\n                cues[i].start = appendWindowStart;\n                i++;\n            }\n            // Removing after window end\n            i = cues.length - 1;\n            while (i >= 0 && cues[i].start >= appendWindowEnd) {\n                i--;\n            }\n            cues.splice(i, cues.length);\n            i = cues.length - 1;\n            while (i >= 0 && cues[i].end > appendWindowEnd) {\n                cues[i].end = appendWindowEnd;\n                i--;\n            }\n        }\n        let start;\n        if (startTime !== undefined) {\n            start = Math.max(appendWindowStart, startTime);\n        }\n        else {\n            if (cues.length <= 0) {\n                log.warn(\"HTD: Current text tracks have no cues nor start time. Aborting\");\n                return convertToRanges(this._buffered);\n            }\n            log.warn(\"HTD: No start time given. Guessing from cues.\");\n            start = cues[0].start;\n        }\n        let end;\n        if (endTime !== undefined) {\n            end = Math.min(appendWindowEnd, endTime);\n        }\n        else {\n            if (cues.length <= 0) {\n                log.warn(\"HTD: Current text tracks have no cues nor end time. Aborting\");\n                return convertToRanges(this._buffered);\n            }\n            log.warn(\"HTD: No end time given. Guessing from cues.\");\n            end = cues[cues.length - 1].end;\n        }\n        if (end <= start) {\n            log.warn(\"HTD: Invalid text track appended: \", \"the start time is inferior or equal to the end time.\");\n            return convertToRanges(this._buffered);\n        }\n        this._buffer.insert(cues, start, end);\n        this._buffered.insert(start, end);\n        if (!this._isAutoRefreshing && !this._buffer.isEmpty()) {\n            this.autoRefreshSubtitles(this._subtitlesIntervalCanceller.signal);\n        }\n        return convertToRanges(this._buffered);\n    }\n    /**\n     * Remove buffered data.\n     * @param {number} start - start position, in seconds\n     * @param {number} end - end position, in seconds\n     * @returns {Object}\n     */\n    removeBuffer(start, end) {\n        log.debug(\"HTD: Removing html text track data\", start, end);\n        this._buffer.remove(start, end);\n        this._buffered.remove(start, end);\n        if (this._isAutoRefreshing && this._buffer.isEmpty()) {\n            this.refreshSubtitles();\n            this._isAutoRefreshing = false;\n            this._subtitlesIntervalCanceller.cancel();\n            this._subtitlesIntervalCanceller = new TaskCanceller();\n        }\n        return convertToRanges(this._buffered);\n    }\n    /**\n     * Returns the currently buffered data, in a TimeRanges object.\n     * @returns {TimeRanges}\n     */\n    getBufferedRanges() {\n        return convertToRanges(this._buffered);\n    }\n    reset() {\n        log.debug(\"HTD: Resetting HTMLTextDisplayer\");\n        this.stop();\n        this._subtitlesIntervalCanceller = new TaskCanceller();\n    }\n    stop() {\n        if (this._subtitlesIntervalCanceller.isUsed()) {\n            return;\n        }\n        log.debug(\"HTD: Stopping HTMLTextDisplayer\");\n        this._disableCurrentCues();\n        this._buffer.remove(0, Infinity);\n        this._buffered.remove(0, Infinity);\n        this._isAutoRefreshing = false;\n        this._subtitlesIntervalCanceller.cancel();\n    }\n    /**\n     * Remove the current cue from being displayed.\n     */\n    _disableCurrentCues() {\n        this._sizeUpdateCanceller.cancel();\n        if (this._currentCues.length > 0) {\n            for (const cue of this._currentCues) {\n                safelyRemoveChild(this._textTrackElement, cue.element);\n            }\n            this._currentCues = [];\n        }\n    }\n    /**\n     * Display a new Cue. If one was already present, it will be replaced.\n     * @param {HTMLElement} elements\n     */\n    _displayCues(elements) {\n        const nothingChanged = this._currentCues.length === elements.length &&\n            this._currentCues.every((current, index) => current.element === elements[index]);\n        if (nothingChanged) {\n            return;\n        }\n        // Remove and re-display everything\n        // TODO More intelligent handling\n        this._sizeUpdateCanceller.cancel();\n        for (const cue of this._currentCues) {\n            safelyRemoveChild(this._textTrackElement, cue.element);\n        }\n        this._currentCues = [];\n        for (const element of elements) {\n            const resolution = getElementResolution(element);\n            this._currentCues.push({ element, resolution });\n            this._textTrackElement.appendChild(element);\n        }\n        const proportionalCues = this._currentCues.filter((cue) => cue.resolution !== null);\n        if (proportionalCues.length > 0) {\n            this._sizeUpdateCanceller = new TaskCanceller();\n            this._sizeUpdateCanceller.linkToSignal(this._subtitlesIntervalCanceller.signal);\n            const { TEXT_TRACK_SIZE_CHECKS_INTERVAL } = config.getCurrent();\n            // update propertionally-sized elements periodically\n            const heightWidthRef = onHeightWidthChange(this._textTrackElement, TEXT_TRACK_SIZE_CHECKS_INTERVAL, this._sizeUpdateCanceller.signal);\n            heightWidthRef.onUpdate(({ height, width }) => {\n                for (const cue of proportionalCues) {\n                    const { resolution, element } = cue;\n                    updateProportionalElements(height, width, resolution, element);\n                }\n            }, {\n                clearSignal: this._sizeUpdateCanceller.signal,\n                emitCurrentValue: true,\n            });\n        }\n    }\n    /**\n     * Auto-refresh the display of subtitles according to the media element's\n     * position and events.\n     * @param {Object} cancellationSignal\n     */\n    autoRefreshSubtitles(cancellationSignal) {\n        if (this._isAutoRefreshing || cancellationSignal.isCancelled()) {\n            return;\n        }\n        let autoRefreshCanceller = null;\n        const { MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL } = config.getCurrent();\n        const stopAutoRefresh = () => {\n            this._isAutoRefreshing = false;\n            if (autoRefreshCanceller !== null) {\n                autoRefreshCanceller.cancel();\n                autoRefreshCanceller = null;\n            }\n        };\n        const startAutoRefresh = () => {\n            stopAutoRefresh();\n            this._isAutoRefreshing = true;\n            autoRefreshCanceller = new TaskCanceller();\n            autoRefreshCanceller.linkToSignal(cancellationSignal);\n            const intervalId = setInterval(() => this.refreshSubtitles(), MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL);\n            autoRefreshCanceller.signal.register(() => {\n                clearInterval(intervalId);\n            });\n            this.refreshSubtitles();\n        };\n        onSeeking(this._videoElement, () => {\n            stopAutoRefresh();\n            this._disableCurrentCues();\n        }, cancellationSignal);\n        onSeeked(this._videoElement, startAutoRefresh, cancellationSignal);\n        onEnded(this._videoElement, startAutoRefresh, cancellationSignal);\n        startAutoRefresh();\n    }\n    /**\n     * Refresh current subtitles according to the current media element's\n     * position.\n     */\n    refreshSubtitles() {\n        const { MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL } = config.getCurrent();\n        let time;\n        if (this._videoElement.paused || this._videoElement.playbackRate <= 0) {\n            time = this._videoElement.currentTime;\n        }\n        else {\n            // to spread the time error, we divide the regular chosen interval.\n            time = Math.max(this._videoElement.currentTime +\n                MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL / 1000 / 2, 0);\n        }\n        const cues = this._buffer.get(time);\n        if (cues.length === 0) {\n            this._disableCurrentCues();\n        }\n        else {\n            this._displayCues(cues);\n        }\n    }\n}\n/*\n * The following ugly code is here to provide a compile-time check that an\n * `IHTMLTextTracksBufferSegmentData` (type of data pushed to a\n * `HTMLTextDisplayer`) can be derived from a `ITextTrackSegmentData`\n * (text track data parsed from a segment).\n *\n * It doesn't correspond at all to real code that will be called. This is just\n * a hack to tell TypeScript to perform that check.\n */\nif (0 /* __ENVIRONMENT__.CURRENT_ENV */ === 1 /* __ENVIRONMENT__.DEV */) {\n    // @ts-expect-error: uncalled function just for type-checking\n    function _checkType(input) {\n        function checkEqual(_arg) {\n            /* nothing */\n        }\n        checkEqual(input);\n    }\n}\n","import HTMLTextDisplayer from \"./html_text_displayer\";\nexport default HTMLTextDisplayer;\n","import assert from \"../../../utils/assert\";\nimport { areNearlyEqual, getCuesAfter, getCuesBefore, removeCuesInfosBetween, areCuesStartNearlyEqual, } from \"./utils\";\n/**\n * first or last IHTMLCue in a group can have a slighlty different start\n * or end time than the start or end time of the ICuesGroup due to parsing\n * approximation.\n * DELTA_CUES_GROUP defines the tolerance level when comparing the start/end\n * of a IHTMLCue to the start/end of a ICuesGroup.\n * Having this value too high may lead to have unwanted subtitle displayed\n * Having this value too low may lead to have subtitles not displayed\n */\nconst DELTA_CUES_GROUP = 1e-3;\n/**\n * segment_duration / RELATIVE_DELTA_RATIO = relative_delta\n *\n * relative_delta is the tolerance to determine if two segements are the same\n */\nconst RELATIVE_DELTA_RATIO = 5;\n/**\n * Manage a buffer of text track cues.\n * Allows to add, remove and recuperate cues at given times.\n * @class TextTrackCuesStore\n */\nexport default class TextTrackCuesStore {\n    constructor() {\n        this._cuesBuffer = [];\n    }\n    isEmpty() {\n        return this._cuesBuffer.length === 0;\n    }\n    /**\n     * Get corresponding cue(s) for the given time.\n     * A cue is an object with three properties:\n     *   - start {Number}: start time for which the cue should be displayed.\n     *   - end {Number}: end time for which the cue should be displayed.\n     *   - element {HTMLElement}: The cue to diplay\n     *\n     * We do not mutate individual cue here.\n     * That is, if the ``get`` method returns the same cue's reference than a\n     * previous ``get`` call, its properties are guaranteed to have the exact same\n     * values than before, if you did not mutate it on your side.\n     * The inverse is true, if the values are the same than before, the reference\n     * will stay the same (this is useful to easily check if the DOM should be\n     * updated, for example).\n     *\n     * @param {Number} time\n     * @returns {Array.<HTMLElement>} - The cues that need to be displayed at that\n     * time.\n     */\n    get(time) {\n        const cuesBuffer = this._cuesBuffer;\n        const ret = [];\n        // begins at the end as most of the time the player will ask for the last\n        // CuesGroup\n        for (let cueIdx = cuesBuffer.length - 1; cueIdx >= 0; cueIdx--) {\n            const segment = cuesBuffer[cueIdx];\n            if (time < segment.end && time >= segment.start) {\n                const cues = segment.cues;\n                for (const cue of cues) {\n                    if (time >= cue.start && time < cue.end) {\n                        ret.push(cue.element);\n                    }\n                }\n                // first or last IHTMLCue in a group can have a slighlty different start\n                // or end time than the start or end time of the ICuesGroup due to parsing\n                // approximation.\n                // Add a tolerance of 1ms to fix this issue\n                if (ret.length === 0 && cues.length > 0) {\n                    for (const cue of cues) {\n                        if (areNearlyEqual(time, cue.start, DELTA_CUES_GROUP) ||\n                            areNearlyEqual(time, cue.end, DELTA_CUES_GROUP)) {\n                            ret.push(cue.element);\n                        }\n                    }\n                }\n                return ret;\n            }\n        }\n        return [];\n    }\n    /**\n     * Remove cue from a certain range of time.\n     * @param {Number} from\n     * @param {Number} _to\n     */\n    remove(from, _to) {\n        if (0 /* __ENVIRONMENT__.CURRENT_ENV */ === 1 /* __ENVIRONMENT__.DEV */) {\n            assert(from >= 0);\n            assert(_to >= 0);\n            assert(_to > from);\n        }\n        const to = Math.max(from, _to);\n        const cuesBuffer = this._cuesBuffer;\n        for (let cueIdx = 0; cueIdx < cuesBuffer.length; cueIdx++) {\n            if (cuesBuffer[cueIdx].end > from) {\n                // this cuesInfos is concerned by the remove\n                const startCuesInfos = cuesBuffer[cueIdx];\n                if (startCuesInfos.start >= to) {\n                    // our cuesInfos is strictly after this interval, we have nothing to do\n                    return;\n                }\n                if (startCuesInfos.end >= to) {\n                    // our cuesInfos ends after `to`, we have to keep the end of it\n                    if (from <= startCuesInfos.start) {\n                        // from -> to only remove the start of startCuesInfos\n                        startCuesInfos.cues = getCuesAfter(startCuesInfos.cues, to);\n                        startCuesInfos.start = to;\n                    }\n                    else {\n                        // from -> to is in the middle part of startCuesInfos\n                        const [cuesInfos1, cuesInfos2] = removeCuesInfosBetween(startCuesInfos, from, to);\n                        this._cuesBuffer[cueIdx] = cuesInfos1;\n                        cuesBuffer.splice(cueIdx + 1, 0, cuesInfos2);\n                    }\n                    // No cuesInfos can be concerned after this one, we can quit\n                    return;\n                }\n                // Else remove all part after `from`\n                if (startCuesInfos.start >= from) {\n                    // all the segment is concerned\n                    cuesBuffer.splice(cueIdx, 1);\n                    cueIdx--; // one less element, we have to decrement the loop\n                }\n                else {\n                    // only the end is concerned\n                    startCuesInfos.cues = getCuesBefore(startCuesInfos.cues, from);\n                    startCuesInfos.end = Math.max(from, startCuesInfos.start);\n                }\n            }\n        }\n    }\n    /**\n     * Insert new cues in our text buffer.\n     * cues is an array of objects with three properties:\n     *   - start {Number}: start time for which the cue should be displayed.\n     *   - end {Number}: end time for which the cue should be displayed.\n     *   - element {HTMLElement}: The cue to diplay\n     *\n     * @param {Array.<Object>} cues - CuesGroups, array of objects with the\n     * following properties:\n     *   - start {Number}: the time at which the cue will start to be displayed\n     *   - end {Number}: the time at which the cue will end to be displayed\n     *   - cue {HTMLElement}: The cue\n     * @param {Number} start - Start time at which the CuesGroup applies.\n     * This is different than the start of the first cue to display in it, this\n     * has more to do with the time at which the _text segment_ starts.\n     * @param {Number} end - End time at which the CuesGroup applies.\n     * This is different than the end of the last cue to display in it, this\n     * has more to do with the time at which the _text segment_ ends.\n     *\n     * TODO add securities to ensure that:\n     *   - the start of a CuesGroup is inferior or equal to the start of the first\n     *     cue in it\n     *   - the end of a CuesGroup is superior or equal to the end of the last\n     *     cue in it\n     * If those requirements are not met, we could delete some cues when adding\n     * a CuesGroup before/after. Find a solution.\n     */\n    insert(cues, start, end) {\n        const cuesBuffer = this._cuesBuffer;\n        const cuesInfosToInsert = { start, end, cues };\n        // it's preferable to have a delta depending on the duration of the segment\n        // if the delta is one fifth of the length of the segment:\n        // a segment of [0, 2] is the \"same\" segment as [0, 2.1]\n        // but [0, 0.04] is not the \"same\" segement as [0,04, 0.08]\n        const relativeDelta = Math.abs(start - end) / RELATIVE_DELTA_RATIO;\n        /**\n         * Called when we found the index of the next cue relative to the cue we\n         * want to insert (that is a cue starting after its start or at the same\n         * time but ending strictly after its end).\n         * Will insert the cue at the right place and update the next cue\n         * accordingly.\n         * @param {number} indexOfNextCue\n         */\n        function onIndexOfNextCueFound(indexOfNextCue) {\n            const nextCue = cuesBuffer[indexOfNextCue];\n            if (nextCue === undefined || // no cue\n                areNearlyEqual(cuesInfosToInsert.end, nextCue.end, relativeDelta)) {\n                // samey end\n                //   ours:            |AAAAA|\n                //   the current one: |BBBBB|\n                //   Result:          |AAAAA|\n                cuesBuffer[indexOfNextCue] = cuesInfosToInsert;\n            }\n            else if (nextCue.start >= cuesInfosToInsert.end) {\n                // Either\n                //   ours:            |AAAAA|\n                //   the current one:         |BBBBBB|\n                //   Result:          |AAAAA| |BBBBBB|\n                // Or:\n                //   ours:            |AAAAA|\n                //   the current one:       |BBBBBB|\n                //   Result:          |AAAAA|BBBBBB|\n                // Add ours before\n                cuesBuffer.splice(indexOfNextCue, 0, cuesInfosToInsert);\n            }\n            else {\n                // Either\n                //   ours:            |AAAAA|\n                //   the current one: |BBBBBBBB|\n                //   Result:          |AAAAABBB|\n                // Or:\n                //   ours:            |AAAAA|\n                //   the current one:    |BBBBB|\n                //   Result:          |AAAAABBB|\n                nextCue.cues = getCuesAfter(nextCue.cues, cuesInfosToInsert.end);\n                nextCue.start = cuesInfosToInsert.end;\n                cuesBuffer.splice(indexOfNextCue, 0, cuesInfosToInsert);\n            }\n        }\n        for (let cueIdx = 0; cueIdx < cuesBuffer.length; cueIdx++) {\n            let cuesInfos = cuesBuffer[cueIdx];\n            if (start < cuesInfos.end) {\n                if (areCuesStartNearlyEqual(cuesInfosToInsert, cuesInfos)) {\n                    if (areNearlyEqual(end, cuesInfos.end, relativeDelta)) {\n                        // exact same segment\n                        //   ours:            |AAAAA|\n                        //   the current one: |BBBBB|\n                        //   Result:          |AAAAA|\n                        // Which means:\n                        //   1. replace the current cue with ours\n                        cuesBuffer[cueIdx] = cuesInfosToInsert;\n                        return;\n                    }\n                    else if (end < cuesInfos.end) {\n                        // our cue overlaps with the current one:\n                        //   ours:            |AAAAA|\n                        //   the current one: |BBBBBBBB|\n                        //   Result:          |AAAAABBB|\n                        // Which means:\n                        //   1. remove some cues at the start of the current one\n                        //   2. update start of current one\n                        //   3. add ours before the current one\n                        cuesInfos.cues = getCuesAfter(cuesInfos.cues, end);\n                        cuesInfos.start = end;\n                        cuesBuffer.splice(cueIdx, 0, cuesInfosToInsert);\n                        return;\n                    }\n                    // our cue goes beyond the current one:\n                    //   ours:            |AAAAAAA|\n                    //   the current one: |BBBB|...\n                    //   Result:          |AAAAAAA|\n                    // Here we have to delete any cuesInfos which end before ours end,\n                    // and see about the following one.\n                    do {\n                        cuesBuffer.splice(cueIdx, 1);\n                        cuesInfos = cuesBuffer[cueIdx];\n                    } while (cuesInfos !== undefined && end > cuesInfos.end);\n                    onIndexOfNextCueFound(cueIdx);\n                    return;\n                }\n                else if (start < cuesInfos.start) {\n                    if (end < cuesInfos.start) {\n                        // our cue goes strictly before the current one:\n                        //   ours:            |AAAAAAA|\n                        //   the current one:           |BBBB|\n                        //   Result:          |AAAAAAA| |BBBB|\n                        // Which means:\n                        //   - add ours before the current one\n                        cuesBuffer.splice(cueIdx, 0, cuesInfosToInsert);\n                        return;\n                    }\n                    else if (areNearlyEqual(end, cuesInfos.start, relativeDelta)) {\n                        // our cue goes just before the current one:\n                        //   ours:            |AAAAAAA|\n                        //   the current one:         |BBBB|\n                        //   Result:          |AAAAAAA|BBBB|\n                        // Which means:\n                        //   - update start time of the current one to be sure\n                        //   - add ours before the current one\n                        cuesInfos.start = end;\n                        cuesBuffer.splice(cueIdx, 0, cuesInfosToInsert);\n                        return;\n                    }\n                    else if (areNearlyEqual(end, cuesInfos.end, relativeDelta)) {\n                        //   ours:            |AAAAAAA|\n                        //   the current one:    |BBBB|\n                        //   Result:          |AAAAAAA|\n                        // Replace\n                        cuesBuffer.splice(cueIdx, 1, cuesInfosToInsert);\n                        return;\n                    }\n                    else if (end < cuesInfos.end) {\n                        //   ours:            |AAAAAAA|\n                        //   the current one:     |BBBBB|\n                        //   Result:          |AAAAAAABB|\n                        cuesInfos.cues = getCuesAfter(cuesInfos.cues, end);\n                        cuesInfos.start = end;\n                        cuesBuffer.splice(cueIdx, 0, cuesInfosToInsert);\n                        return;\n                    }\n                    //   ours:            |AAAAAAA|\n                    //   the current one:   |BBB|...\n                    //   Result:          |AAAAAAA|...\n                    do {\n                        cuesBuffer.splice(cueIdx, 1);\n                        cuesInfos = cuesBuffer[cueIdx];\n                    } while (cuesInfos !== undefined && end > cuesInfos.end);\n                    onIndexOfNextCueFound(cueIdx);\n                    return;\n                }\n                // else -> start > cuesInfos.start\n                if (areNearlyEqual(cuesInfos.end, end, relativeDelta)) {\n                    //   ours:              |AAAAAA|\n                    //   the current one: |BBBBBBBB|\n                    //   Result:          |BBAAAAAA|\n                    cuesInfos.cues = getCuesBefore(cuesInfos.cues, start);\n                    cuesInfos.end = start;\n                    cuesBuffer.splice(cueIdx + 1, 0, cuesInfosToInsert);\n                    return;\n                }\n                else if (cuesInfos.end > end) {\n                    //   ours:              |AAAAAA|\n                    //   the current one: |BBBBBBBBBBB|\n                    //   Result:          |BBAAAAAABBB|\n                    const [cuesInfos1, cuesInfos2] = removeCuesInfosBetween(cuesInfos, start, end);\n                    this._cuesBuffer[cueIdx] = cuesInfos1;\n                    cuesBuffer.splice(cueIdx + 1, 0, cuesInfosToInsert);\n                    cuesBuffer.splice(cueIdx + 2, 0, cuesInfos2);\n                    return;\n                }\n                else {\n                    //   ours:              |AAAAAA|\n                    //   the current one: |BBBBB|...\n                    //   Result:          |BBAAAAAA|...\n                    cuesInfos.cues = getCuesBefore(cuesInfos.cues, start);\n                    cuesInfos.end = start;\n                    const nextCueIdx = cueIdx + 1;\n                    cuesInfos = cuesBuffer[nextCueIdx];\n                    while (cuesInfos !== undefined && end > cuesInfos.end) {\n                        cuesBuffer.splice(nextCueIdx, 1);\n                        cuesInfos = cuesBuffer[nextCueIdx];\n                    }\n                    onIndexOfNextCueFound(nextCueIdx);\n                    return;\n                }\n            }\n        }\n        if (cuesBuffer.length > 0) {\n            const lastCue = cuesBuffer[cuesBuffer.length - 1];\n            if (areNearlyEqual(lastCue.end, start, relativeDelta)) {\n                // Match the end of the previous cue to the start of the following one\n                // if they are close enough. If there is a small gap between two segments\n                // it can lead to having no subtitles for a short time, this is noticeable when\n                // two successive segments displays the same text, making it diseappear\n                // and reappear quickly, which gives the impression of blinking\n                //\n                //   ours:                   |AAAAA|\n                //   the current one: |BBBBB|...\n                //   Result:          |BBBBBBBAAAAA|\n                lastCue.end = start;\n            }\n        }\n        // no cues group has the end after our current start.\n        // These cues should be the last one\n        cuesBuffer.push(cuesInfosToInsert);\n    }\n}\n","/**\n * Update size of element which are proportional to the current text track\n * element.\n * Returns `true` if at least a single styling information is proportional,\n * `false` otherwise.\n * @param {number} currentHeight\n * @param {number} currentWidth\n * @param {Object} resolution\n * @param {HTMLElement} textTrackElement\n * @returns {boolean}\n */\nexport default function updateProportionalElements(currentHeight, currentWidth, resolution, textTrackElement) {\n    const cellUnit = [currentWidth / resolution.columns, currentHeight / resolution.rows];\n    const proportElts = textTrackElement.getElementsByClassName(\"proportional-style\");\n    for (let eltIdx = 0; eltIdx < proportElts.length; eltIdx++) {\n        const elt = proportElts[eltIdx];\n        if (elt instanceof HTMLElement) {\n            const fontSizeVal = elt.getAttribute(\"data-proportional-font-size\");\n            if (fontSizeVal !== null && !isNaN(+fontSizeVal)) {\n                elt.style.fontSize = String(+fontSizeVal * cellUnit[1]) + \"px\";\n            }\n            const widthVal = elt.getAttribute(\"data-proportional-width\");\n            if (widthVal !== null && !isNaN(+widthVal)) {\n                elt.style.width = String(+widthVal * cellUnit[0]) + \"px\";\n            }\n            const heightVal = elt.getAttribute(\"data-proportional-height\");\n            if (heightVal !== null && !isNaN(+heightVal)) {\n                elt.style.height = String(+heightVal * cellUnit[1]) + \"px\";\n            }\n            const lineHeightVal = elt.getAttribute(\"data-proportional-line-height\");\n            if (lineHeightVal !== null && !isNaN(+lineHeightVal)) {\n                elt.style.lineHeight = String(+lineHeightVal * cellUnit[1]) + \"px\";\n            }\n            const leftVal = elt.getAttribute(\"data-proportional-left\");\n            if (leftVal !== null && !isNaN(+leftVal)) {\n                elt.style.left = String(+leftVal * cellUnit[0]) + \"px\";\n            }\n            const topVal = elt.getAttribute(\"data-proportional-top\");\n            if (topVal !== null && !isNaN(+topVal)) {\n                elt.style.top = String(+topVal * cellUnit[1]) + \"px\";\n            }\n            const paddingTopVal = elt.getAttribute(\"data-proportional-padding-top\");\n            if (paddingTopVal !== null && !isNaN(+paddingTopVal)) {\n                elt.style.paddingTop = String(+paddingTopVal * cellUnit[1]) + \"px\";\n            }\n            const paddingBottomVal = elt.getAttribute(\"data-proportional-padding-bottom\");\n            if (paddingBottomVal !== null && !isNaN(+paddingBottomVal)) {\n                elt.style.paddingBottom = String(+paddingBottomVal * cellUnit[1]) + \"px\";\n            }\n            const paddingLeftVal = elt.getAttribute(\"data-proportional-padding-left\");\n            if (paddingLeftVal !== null && !isNaN(+paddingLeftVal)) {\n                elt.style.paddingLeft = String(+paddingLeftVal * cellUnit[0]) + \"px\";\n            }\n            const paddingRightVal = elt.getAttribute(\"data-proportional-padding-right\");\n            if (paddingRightVal !== null && !isNaN(+paddingRightVal)) {\n                elt.style.paddingRight = String(+paddingRightVal * cellUnit[0]) + \"px\";\n            }\n        }\n    }\n    return proportElts.length > 0;\n}\n","/**\n * Maximum time difference, in seconds, between two text segment's start times\n * and/or end times for them to be considered the same.\n *\n * For example for two segments s1 and s2 which have a start time respectively\n * of st1 and st2 and end time of et1 and et2:\n *   - if both the absolute difference between st1 and st2 AND the one between\n *     et1 and et2 is inferior or equal to the MAX_DELTA_BUFFER_TIME, s1 and s2\n *     are considered to target the exact same time. As a consequence, if s2 is\n *     added after s1 in the buffer, s1 will be completely replaced by it and\n *     vice-versa.\n *   - if only one of the two (absolute difference between st1 and st2 OR et1\n *     and et2) is inferior to the MAX_DELTA_BUFFER_TIME then the last added\n *     is not completely considered the same. It WILL still replace - either\n *     partially or completely (depending on the sign of the other difference) -\n *     the previously added segment.\n *   - if both differences are strictly superior to the MAX_DELTA_BUFFER_TIME,\n *     then they are not considered to have the same start nor the same end.\n *     They can still overlap however, and MIGHT thus still replace partially\n *     or completely each other.\n *\n * Setting a value too low might lead to two segments targeting the same time,\n * both being present in the buffer. In worst case scenarios, this could lead\n * to indicate that an unwanted text track is still here (theorically though,\n * this is a case that should never happen for reasons that might be too long\n * to explain here).\n *\n * Setting a value too high might lead to two segments targeting different times\n * to be wrongly believed to target the same time. In worst case scenarios, this\n * could lead to wanted text tracks being removed.\n *\n * When comparing 2 segments s1 and s2, you may want to take into account the duration\n * of the segments:\n *   - if s1 is [0, 2] and s2 is [0, 2.1] s1 and s2 can be considered as nearly equal as\n *     there is a relative difference of: (2.1-2) / 2 = 5%;\n *     Formula: (end_s1 - end_s2) / duration_s2 = relative_difference\n *   - if s1 is [0, 0.04] and s2 is [0.04, 0.08] s1 and s2 may not considered as nearly\n *     equal as there is a relative difference of: (0.04-0.08) / 0.04 = 100%\n *\n * To compare relatively to the duration of a segment you can provide and additional\n * parameter \"delta\" that remplace MAX_DELTA_BUFFER_TIME.\n * If parameter \"delta\" is higher than MAX_DELTA_BUFFER_TIME, MAX_DELTA_BUFFER_TIME\n * is used instead of delta. This ensure that segments are nearly equal when comparing\n * relatively AND absolutely.\n *\n * @type Number\n */\nconst MAX_DELTA_BUFFER_TIME = 0.2;\n/**\n * @see MAX_DELTA_BUFFER_TIME\n * @param {Number} a\n * @param {Number} b\n * @param {Number} delta\n * @returns {Boolean}\n */\nexport function areNearlyEqual(a, b, delta = MAX_DELTA_BUFFER_TIME) {\n    return Math.abs(a - b) <= Math.min(delta, MAX_DELTA_BUFFER_TIME);\n}\nconst EPSILON = 5e-2; // 5%\n/**\n * Check if two cues start are almost the same.\n * It should depend on there relative length:\n *\n * [0, 2] and [2, 4] start are NOT equals\n * [0, 2] and [0, 4]  start are equals\n * [0, 0.1] and [0.101, 2] start are NOT equals\n * [0, 2] and [0.01, 4]  start are equals\n * [0, 100] and [1, 200]  start are NOT equals\n * @see MAX_DELTA_BUFFER_TIME\n * @param {Number} firstCue the existing cue\n * @param {Number} secondCue the cue that we test if it follow firstCue\n * @returns {Boolean}\n */\nexport function areCuesStartNearlyEqual(firstCue, secondCue) {\n    const firstCueDuration = firstCue.end - firstCue.start;\n    const secondCueDuration = secondCue.end - secondCue.start;\n    const diffBetweenStart = Math.abs(firstCue.start - secondCue.start);\n    const minDuration = Math.min(firstCueDuration, secondCueDuration, MAX_DELTA_BUFFER_TIME);\n    return diffBetweenStart / minDuration <= EPSILON; // ratio diff/ minduration is bellow 5%\n}\n/**\n * Get all cues which have data before the given time.\n * @param {Object} cues\n * @param {Number} time\n * @returns {Array.<Object>}\n */\nexport function getCuesBefore(cues, time) {\n    for (let i = cues.length - 1; i >= 0; i--) {\n        const cue = cues[i];\n        if (cue.start < time) {\n            return cues.slice(0, i + 1);\n        }\n    }\n    return [];\n}\n/**\n * Get all cues which have data after the given time.\n * @param {Object} cues\n * @param {Number} time\n * @returns {Array.<Object>}\n */\nexport function getCuesAfter(cues, time) {\n    for (let i = 0; i < cues.length; i++) {\n        const cue = cues[i];\n        if (cue.end > time) {\n            return cues.slice(i, cues.length);\n        }\n    }\n    return [];\n}\n/**\n * @param {Object} cuesInfos\n * @param {Number} start\n * @param {Number} end\n * @returns {Array.<Object>}\n */\nexport function removeCuesInfosBetween(cuesInfos, start, end) {\n    const endCuesInfos1 = Math.max(cuesInfos.start, start);\n    const cues1 = getCuesBefore(cuesInfos.cues, start);\n    const cuesInfos1 = {\n        start: cuesInfos.start,\n        end: endCuesInfos1,\n        cues: cues1,\n    };\n    const startCuesInfos2 = Math.min(end, cuesInfos.end);\n    const cues2 = getCuesAfter(cuesInfos.cues, end);\n    const cuesInfos2 = {\n        start: startCuesInfos2,\n        end: cuesInfos.end,\n        cues: cues2,\n    };\n    return [cuesInfos1, cuesInfos2];\n}\n","import assert from \"../../utils/assert\";\nimport { insertInto, keepRangeIntersection } from \"../../utils/ranges\";\n/**\n * Simulate TimeRanges as returned by SourceBuffer.prototype.buffered.\n * Add an \"insert\" and \"remove\" methods to manually update it.\n * @class ManualTimeRanges\n */\nexport default class ManualTimeRanges {\n    constructor() {\n        this._ranges = [];\n        this.length = 0;\n    }\n    insert(start, end) {\n        if (0 /* __ENVIRONMENT__.CURRENT_ENV */ === 1 /* __ENVIRONMENT__.DEV */) {\n            assert(start >= 0, \"invalid start time\");\n            assert(end - start > 0, \"invalid end time\");\n        }\n        insertInto(this._ranges, { start, end });\n        this.length = this._ranges.length;\n    }\n    remove(start, end) {\n        if (0 /* __ENVIRONMENT__.CURRENT_ENV */ === 1 /* __ENVIRONMENT__.DEV */) {\n            assert(start >= 0, \"invalid start time\");\n            assert(end - start > 0, \"invalid end time\");\n        }\n        const rangesToIntersect = [];\n        if (start > 0) {\n            rangesToIntersect.push({ start: 0, end: start });\n        }\n        if (end < Infinity) {\n            rangesToIntersect.push({ start: end, end: Infinity });\n        }\n        this._ranges = keepRangeIntersection(this._ranges, rangesToIntersect);\n        this.length = this._ranges.length;\n    }\n    start(index) {\n        if (index >= this._ranges.length) {\n            throw new Error(\"INDEX_SIZE_ERROR\");\n        }\n        return this._ranges[index].start;\n    }\n    end(index) {\n        if (index >= this._ranges.length) {\n            throw new Error(\"INDEX_SIZE_ERROR\");\n        }\n        return this._ranges[index].end;\n    }\n}\n","import NativeTextDisplayer from \"./native_text_displayer\";\nexport default NativeTextDisplayer;\n","import features from \"../../../features\";\nimport log from \"../../../log\";\n/**\n * Convert text track data into timed VTT Cues.\n * @param {string} type - Text track format wanted\n * @param {string} data - Text track data\n * @param {Number} timestampOffset - offset to apply to every timed text\n * @param {string} [language] - language of the text tracks\n * @returns {Array.<VTTCue>}\n * @throws Error - Throw if no parser is found for the given type\n */\nexport default function parseTextTrackToCues(type, data, timestampOffset, language) {\n    log.debug(\"NTSB: Finding parser for native text tracks:\", type);\n    const parser = features.nativeTextTracksParsers[type];\n    if (typeof parser !== \"function\") {\n        throw new Error(\"no parser found for the given text track\");\n    }\n    log.debug(\"NTSB: Parser found, parsing...\");\n    const parsed = parser(data, timestampOffset, language);\n    log.debug(\"NTSB: Parsed successfully!\", parsed.length);\n    return parsed;\n}\n","import addTextTrack from \"../../../compat/add_text_track\";\nimport removeCue from \"../../../compat/remove_cue\";\nimport log from \"../../../log\";\nimport { convertToRanges } from \"../../../utils/ranges\";\nimport ManualTimeRanges from \"../manual_time_ranges\";\nimport parseTextTrackToCues from \"./native_parsers\";\n/**\n * Implementation of an `ITextDisplayer` for \"native\" text tracks.\n * \"Native\" text tracks rely on a `<track>` HTMLElement and its associated\n * expected behavior to display subtitles synchronized to the video.\n * @class NativeTextDisplayer\n */\nexport default class NativeTextDisplayer {\n    /**\n     * @param {HTMLMediaElement} videoElement\n     */\n    constructor(videoElement) {\n        log.debug(\"NTD: Creating NativeTextDisplayer\");\n        const { track, trackElement } = addTextTrack(videoElement);\n        this._buffered = new ManualTimeRanges();\n        this._videoElement = videoElement;\n        this._track = track;\n        this._trackElement = trackElement;\n    }\n    /**\n     * Push text segment to the NativeTextDisplayer.\n     * @param {Object} infos\n     * @returns {Object}\n     */\n    pushTextData(infos) {\n        var _a, _b;\n        log.debug(\"NTD: Appending new native text tracks\");\n        if (infos.chunk === null) {\n            return convertToRanges(this._buffered);\n        }\n        const { timestampOffset, appendWindow, chunk } = infos;\n        const { start: startTime, end: endTime, data: dataString, type, language } = chunk;\n        const appendWindowStart = (_a = appendWindow[0]) !== null && _a !== void 0 ? _a : 0;\n        const appendWindowEnd = (_b = appendWindow[1]) !== null && _b !== void 0 ? _b : Infinity;\n        const cues = parseTextTrackToCues(type, dataString, timestampOffset, language);\n        if (appendWindowStart !== 0 && appendWindowEnd !== Infinity) {\n            // Removing before window start\n            let i = 0;\n            while (i < cues.length && cues[i].endTime <= appendWindowStart) {\n                i++;\n            }\n            cues.splice(0, i);\n            i = 0;\n            while (i < cues.length && cues[i].startTime < appendWindowStart) {\n                cues[i].startTime = appendWindowStart;\n                i++;\n            }\n            // Removing after window end\n            i = cues.length - 1;\n            while (i >= 0 && cues[i].startTime >= appendWindowEnd) {\n                i--;\n            }\n            cues.splice(i, cues.length);\n            i = cues.length - 1;\n            while (i >= 0 && cues[i].endTime > appendWindowEnd) {\n                cues[i].endTime = appendWindowEnd;\n                i--;\n            }\n        }\n        let start;\n        if (startTime !== undefined) {\n            start = Math.max(appendWindowStart, startTime);\n        }\n        else {\n            if (cues.length <= 0) {\n                log.warn(\"NTD: Current text tracks have no cues nor start time. Aborting\");\n                return convertToRanges(this._buffered);\n            }\n            log.warn(\"NTD: No start time given. Guessing from cues.\");\n            start = cues[0].startTime;\n        }\n        let end;\n        if (endTime !== undefined) {\n            end = Math.min(appendWindowEnd, endTime);\n        }\n        else {\n            if (cues.length <= 0) {\n                log.warn(\"NTD: Current text tracks have no cues nor end time. Aborting\");\n                return convertToRanges(this._buffered);\n            }\n            log.warn(\"NTD: No end time given. Guessing from cues.\");\n            end = cues[cues.length - 1].endTime;\n        }\n        if (end <= start) {\n            log.warn(\"NTD: Invalid text track appended: \", \"the start time is inferior or equal to the end time.\");\n            return convertToRanges(this._buffered);\n        }\n        if (cues.length > 0) {\n            const firstCue = cues[0];\n            // NOTE(compat): cleanup all current cues if the newly added\n            // ones are in the past. this is supposed to fix an issue on\n            // IE/Edge.\n            // TODO Move to compat\n            const currentCues = this._track.cues;\n            if (currentCues !== null && currentCues.length > 0) {\n                if (firstCue.startTime < currentCues[currentCues.length - 1].startTime) {\n                    this._removeData(firstCue.startTime, +Infinity);\n                }\n            }\n            for (const cue of cues) {\n                this._track.addCue(cue);\n            }\n        }\n        this._buffered.insert(start, end);\n        return convertToRanges(this._buffered);\n    }\n    /**\n     * Remove buffered data.\n     * @param {number} start - start position, in seconds\n     * @param {number} end - end position, in seconds\n     * @returns {Object}\n     */\n    removeBuffer(start, end) {\n        this._removeData(start, end);\n        return convertToRanges(this._buffered);\n    }\n    /**\n     * Returns the currently buffered data, in a TimeRanges object.\n     * @returns {Array.<Object>}\n     */\n    getBufferedRanges() {\n        return convertToRanges(this._buffered);\n    }\n    reset() {\n        log.debug(\"NTD: Aborting NativeTextDisplayer\");\n        this._removeData(0, Infinity);\n        this._clearTrackElement();\n    }\n    stop() {\n        log.debug(\"NTD: Aborting NativeTextDisplayer\");\n        this._removeData(0, Infinity);\n        const { _trackElement, _videoElement } = this;\n        if (_trackElement !== undefined && _videoElement.hasChildNodes()) {\n            try {\n                _videoElement.removeChild(_trackElement);\n            }\n            catch (_e) {\n                log.warn(\"NTD: Can't remove track element from the video\");\n            }\n        }\n        this._track.mode = \"disabled\";\n        if (this._trackElement !== undefined) {\n            this._trackElement.innerHTML = \"\";\n        }\n    }\n    _removeData(start, end) {\n        log.debug(\"NTD: Removing native text track data\", start, end);\n        const track = this._track;\n        const cues = track.cues;\n        if (cues !== null) {\n            for (let i = cues.length - 1; i >= 0; i--) {\n                const cue = cues[i];\n                const { startTime, endTime } = cue;\n                if (startTime >= start && startTime <= end && endTime <= end) {\n                    removeCue(track, cue);\n                }\n            }\n        }\n        this._buffered.remove(start, end);\n    }\n    _clearTrackElement() {\n        const { _trackElement, _videoElement } = this;\n        if (_trackElement !== undefined && _videoElement.hasChildNodes()) {\n            try {\n                _videoElement.removeChild(_trackElement);\n            }\n            catch (_e) {\n                log.warn(\"NTD: Can't remove track element from the video\");\n            }\n        }\n        // Ugly trick to work-around browser bugs by refreshing its mode\n        const oldMode = this._track.mode;\n        this._track.mode = \"disabled\";\n        this._track.mode = oldMode;\n        if (this._trackElement !== undefined) {\n            this._trackElement.innerHTML = \"\";\n        }\n    }\n}\n/*\n * The following ugly code is here to provide a compile-time check that an\n * `INativeTextTracksBufferSegmentData` (type of data pushed to a\n * `NativeTextDisplayer`) can be derived from a `ITextTrackSegmentData`\n * (text track data parsed from a segment).\n *\n * It doesn't correspond at all to real code that will be called. This is just\n * a hack to tell TypeScript to perform that check.\n */\nif (0 /* __ENVIRONMENT__.CURRENT_ENV */ === 1 /* __ENVIRONMENT__.DEV */) {\n    // @ts-expect-error: uncalled function just for type checking\n    function _checkType(input) {\n        function checkEqual(_arg) {\n            /* nothing */\n        }\n        checkEqual(input);\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport TracksStore from \"./tracks_store\";\nexport default TracksStore;\nexport * from \"./tracks_store\";\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport enableAudioTrack from \"../../compat/enable_audio_track\";\nimport EventEmitter from \"../../utils/event_emitter\";\nimport isNullOrUndefined from \"../../utils/is_null_or_undefined\";\nimport normalizeLanguage from \"../../utils/languages\";\n/**\n * Check if track array is different from an other one\n * @param {Array.<Object>} oldTrackArray\n * @param {Array.<Object>} newTrackArray\n * @returns {boolean}\n */\nfunction areTrackArraysDifferent(oldTrackArray, newTrackArray) {\n    var _a;\n    if (newTrackArray.length !== oldTrackArray.length) {\n        return true;\n    }\n    for (let i = 0; i < newTrackArray.length; i++) {\n        if (newTrackArray[i].nativeTrack !== ((_a = oldTrackArray[i]) === null || _a === void 0 ? void 0 : _a.nativeTrack)) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Create audio tracks from native audio tracks.\n * @param {AudioTrackList} audioTracks\n * @returns {Array.<Object>}\n */\nfunction createAudioTracks(audioTracks) {\n    var _a;\n    const newAudioTracks = [];\n    const languagesOccurences = {};\n    for (let i = 0; i < audioTracks.length; i++) {\n        const audioTrack = audioTracks[i];\n        const language = audioTrack.language === \"\" ? \"nolang\" : audioTrack.language;\n        const occurences = (_a = languagesOccurences[language]) !== null && _a !== void 0 ? _a : 1;\n        const id = \"gen_audio_\" + language + \"_\" + occurences.toString();\n        languagesOccurences[language] = occurences + 1;\n        const track = {\n            language: audioTrack.language,\n            id,\n            normalized: normalizeLanguage(audioTrack.language),\n            audioDescription: audioTrack.kind === \"descriptions\" ||\n                // Safari seem to prefer the non-standard singular\n                // version, funnily enough\n                audioTrack.kind === \"description\",\n            representations: [],\n        };\n        newAudioTracks.push({ track, nativeTrack: audioTrack });\n    }\n    return newAudioTracks;\n}\n/**\n * Create text tracks from native text tracks.\n * @param {TextTrackList} textTracks\n * @returns {Array.<Object>}\n */\nfunction createTextTracks(textTracks) {\n    var _a;\n    const newTextTracks = [];\n    const languagesOccurences = {};\n    for (let i = 0; i < textTracks.length; i++) {\n        const textTrack = textTracks[i];\n        const language = textTrack.language === \"\" ? \"nolang\" : textTrack.language;\n        const occurences = (_a = languagesOccurences[language]) !== null && _a !== void 0 ? _a : 1;\n        const id = \"gen_text_\" + language + \"_\" + occurences.toString();\n        languagesOccurences[language] = occurences + 1;\n        // Safari seems to be indicating that the subtitles track is a forced\n        // subtitles track by setting the `kind` attribute to `\"forced\"`.\n        // As of now (2023-04-04), this is not standard.\n        // @see https://github.com/whatwg/html/issues/4472\n        const forced = textTrack.kind === \"forced\" ? true : undefined;\n        const track = {\n            language: textTrack.language,\n            forced,\n            label: textTrack.label,\n            id,\n            normalized: normalizeLanguage(textTrack.language),\n            closedCaption: textTrack.kind === \"captions\",\n        };\n        newTextTracks.push({ track, nativeTrack: textTrack });\n    }\n    return newTextTracks;\n}\n/**\n * Create video tracks from native video tracks.\n * @param {VideoTrackList} videoTracks\n * @returns {Array.<Object>}\n */\nfunction createVideoTracks(videoTracks) {\n    var _a;\n    const newVideoTracks = [];\n    const languagesOccurences = {};\n    for (let i = 0; i < videoTracks.length; i++) {\n        const videoTrack = videoTracks[i];\n        const language = videoTrack.language === \"\" ? \"nolang\" : videoTrack.language;\n        const occurences = (_a = languagesOccurences[language]) !== null && _a !== void 0 ? _a : 1;\n        const id = \"gen_video_\" + language + \"_\" + occurences.toString();\n        languagesOccurences[language] = occurences + 1;\n        newVideoTracks.push({\n            track: { id, representations: [] },\n            nativeTrack: videoTrack,\n        });\n    }\n    return newVideoTracks;\n}\n/**\n * Manage video, audio and text tracks for current direct file content.\n * @class MediaElementTracksStore\n */\nexport default class MediaElementTracksStore extends EventEmitter {\n    constructor(mediaElement) {\n        var _a, _b, _c;\n        super();\n        // TODO In practice, the audio/video/text tracks API are not always implemented on\n        // the media element, although Typescript HTMLMediaElement types tend to mean\n        // that can't be undefined.\n        this._nativeAudioTracks = mediaElement.audioTracks;\n        this._nativeVideoTracks = mediaElement.videoTracks;\n        this._nativeTextTracks = mediaElement.textTracks;\n        this._audioTracks =\n            this._nativeAudioTracks !== undefined\n                ? createAudioTracks(this._nativeAudioTracks)\n                : [];\n        this._videoTracks =\n            this._nativeVideoTracks !== undefined\n                ? createVideoTracks(this._nativeVideoTracks)\n                : [];\n        this._textTracks =\n            this._nativeTextTracks !== undefined\n                ? createTextTracks(this._nativeTextTracks)\n                : [];\n        this._lastEmittedNativeAudioTrack = (_a = this._getCurrentAudioTrack()) === null || _a === void 0 ? void 0 : _a.nativeTrack;\n        this._lastEmittedNativeVideoTrack = (_b = this._getCurrentVideoTrack()) === null || _b === void 0 ? void 0 : _b.nativeTrack;\n        this._lastEmittedNativeTextTrack = (_c = this._getCurrentTextTrack()) === null || _c === void 0 ? void 0 : _c.nativeTrack;\n        this._handleNativeTracksCallbacks();\n    }\n    /**\n     * Update the currently active audio track by setting the wanted audio track's\n     * ID property.\n     * Throws if the wanted audio track is not found.\n     * @param {string|number|undefined} id\n     */\n    setAudioTrackById(id) {\n        for (let i = 0; i < this._audioTracks.length; i++) {\n            const { track, nativeTrack } = this._audioTracks[i];\n            if (track.id === id) {\n                this._enableAudioTrackFromIndex(i);\n                this._audioTrackLockedOn = nativeTrack;\n                return;\n            }\n        }\n        throw new Error(\"Audio track not found.\");\n    }\n    /**\n     * Disable the currently-active text track, if one.\n     */\n    disableTextTrack() {\n        disableTextTracks(this._textTracks);\n        this._textTrackLockedOn = null;\n    }\n    /**\n     * Update the currently active text track by setting the wanted text track's\n     * ID property.\n     * Throws if the wanted text track is not found.\n     * @param {string|number|undefined} id\n     */\n    setTextTrackById(id) {\n        let hasSetTrack = false;\n        for (let i = 0; i < this._textTracks.length; i++) {\n            const { track, nativeTrack } = this._textTracks[i];\n            if (track.id === id) {\n                nativeTrack.mode = \"showing\";\n                hasSetTrack = true;\n                this._textTrackLockedOn = nativeTrack;\n            }\n            else if (nativeTrack.mode === \"showing\" || nativeTrack.mode === \"hidden\") {\n                nativeTrack.mode = \"disabled\";\n            }\n        }\n        if (!hasSetTrack) {\n            throw new Error(\"Text track not found.\");\n        }\n    }\n    /**\n     * Disable the currently-active video track, if one.\n     */\n    disableVideoTrack() {\n        disableVideoTracks(this._videoTracks);\n        this._videoTrackLockedOn = null;\n    }\n    /**\n     * Update the currently active video track by setting the wanted video track's\n     * ID property.\n     * Throws if the wanted video track is not found.\n     * @param {string|number|undefined} id\n     */\n    setVideoTrackById(id) {\n        for (let i = 0; i < this._videoTracks.length; i++) {\n            const { track, nativeTrack } = this._videoTracks[i];\n            if (track.id === id) {\n                nativeTrack.selected = true;\n                this._videoTrackLockedOn = nativeTrack;\n                return;\n            }\n        }\n        throw new Error(\"Video track not found.\");\n    }\n    /**\n     * Returns the currently active audio track.\n     * Returns `null` if no audio track is active.\n     * Returns `undefined` if we cannot know which audio track is active.\n     * @returns {Object|null|undefined}\n     */\n    getChosenAudioTrack() {\n        const currentAudioTrack = this._getCurrentAudioTrack();\n        return isNullOrUndefined(currentAudioTrack)\n            ? currentAudioTrack\n            : currentAudioTrack.track;\n    }\n    /**\n     * Returns the currently active text track.\n     * Returns `null` if no text track is active.\n     * Returns `undefined` if we cannot know which text track is active.\n     * @returns {Object|null|undefined}\n     */\n    getChosenTextTrack() {\n        const currentTextTrack = this._getCurrentTextTrack();\n        return isNullOrUndefined(currentTextTrack)\n            ? currentTextTrack\n            : currentTextTrack.track;\n    }\n    /**\n     * Returns the currently active video track.\n     * Returns `null` if no video track is active.\n     * Returns `undefined` if we cannot know which video track is active.\n     * @returns {Object|null|undefined}\n     */\n    getChosenVideoTrack() {\n        const currentVideoTrack = this._getCurrentVideoTrack();\n        return isNullOrUndefined(currentVideoTrack)\n            ? currentVideoTrack\n            : currentVideoTrack.track;\n    }\n    /**\n     * Returns a description of every available audio tracks.\n     * @returns {Array.<Object>}\n     */\n    getAvailableAudioTracks() {\n        return this._audioTracks.map(({ track, nativeTrack }) => {\n            return {\n                id: track.id,\n                language: track.language,\n                normalized: track.normalized,\n                audioDescription: track.audioDescription,\n                active: nativeTrack.enabled,\n                representations: track.representations,\n            };\n        });\n    }\n    /**\n     * Returns a description of every available text tracks.\n     * @returns {Array.<Object>}\n     */\n    getAvailableTextTracks() {\n        return this._textTracks.map(({ track, nativeTrack }) => {\n            return {\n                id: track.id,\n                label: track.label,\n                forced: track.forced,\n                language: track.language,\n                normalized: track.normalized,\n                closedCaption: track.closedCaption,\n                active: nativeTrack.mode === \"showing\",\n            };\n        });\n    }\n    /**\n     * Returns a description of every available video tracks.\n     * @returns {Array.<Object>}\n     */\n    getAvailableVideoTracks() {\n        return this._videoTracks.map(({ track, nativeTrack }) => {\n            return {\n                id: track.id,\n                representations: track.representations,\n                active: nativeTrack.selected,\n            };\n        });\n    }\n    /**\n     * Free the resources used by the MediaElementTracksStore.\n     */\n    dispose() {\n        if (this._nativeVideoTracks !== undefined) {\n            this._nativeVideoTracks.onchange = null;\n            this._nativeVideoTracks.onaddtrack = null;\n            this._nativeVideoTracks.onremovetrack = null;\n        }\n        if (this._nativeAudioTracks !== undefined) {\n            this._nativeAudioTracks.onchange = null;\n            this._nativeAudioTracks.onaddtrack = null;\n            this._nativeAudioTracks.onremovetrack = null;\n        }\n        if (this._nativeTextTracks !== undefined) {\n            this._nativeTextTracks.onchange = null;\n            this._nativeTextTracks.onaddtrack = null;\n            this._nativeTextTracks.onremovetrack = null;\n        }\n        this.removeEventListener();\n    }\n    /**\n     * Get information about the currently chosen audio track.\n     * `undefined` if we cannot know it.\n     * `null` if no audio track is chosen.\n     * @returns {Object|undefined|null}\n     */\n    _getCurrentAudioTrack() {\n        if (this._nativeAudioTracks === undefined) {\n            return undefined;\n        }\n        for (let i = 0; i < this._audioTracks.length; i++) {\n            const audioTrack = this._audioTracks[i];\n            if (audioTrack.nativeTrack.enabled) {\n                return audioTrack;\n            }\n        }\n        return null;\n    }\n    /**\n     * Get information about the currently chosen video track.\n     * `undefined` if we cannot know it.\n     * `null` if no video track is chosen.\n     * @returns {Object|undefined|null}\n     */\n    _getCurrentVideoTrack() {\n        if (this._nativeVideoTracks === undefined) {\n            return undefined;\n        }\n        for (let i = 0; i < this._videoTracks.length; i++) {\n            const videoTrack = this._videoTracks[i];\n            if (videoTrack.nativeTrack.selected) {\n                return videoTrack;\n            }\n        }\n        return null;\n    }\n    /**\n     * Get information about the currently chosen text track.\n     * `undefined` if we cannot know it.\n     * `null` if no text track is chosen.\n     * @returns {Object|undefined|null}\n     */\n    _getCurrentTextTrack() {\n        if (this._nativeTextTracks === undefined) {\n            return undefined;\n        }\n        for (let i = 0; i < this._textTracks.length; i++) {\n            const textTrack = this._textTracks[i];\n            if (textTrack.nativeTrack.mode === \"showing\") {\n                return textTrack;\n            }\n        }\n        return null;\n    }\n    /**\n     * Iterate over every available audio tracks on the media element and either:\n     *   - if the last manually set audio track is found, set that one.\n     *   - if we still do not find an optimal track, let the one chosen by default\n     */\n    _setPreviouslyLockedAudioTrack() {\n        if (this._audioTrackLockedOn === undefined) {\n            return;\n        }\n        else if (this._audioTrackLockedOn === null) {\n            for (let i = 0; i < this._audioTracks.length; i++) {\n                const { nativeTrack } = this._audioTracks[i];\n                nativeTrack.enabled = false;\n            }\n        }\n        else {\n            for (let i = 0; i < this._audioTracks.length; i++) {\n                const { nativeTrack } = this._audioTracks[i];\n                if (nativeTrack === this._audioTrackLockedOn) {\n                    this._enableAudioTrackFromIndex(i);\n                    return;\n                }\n            }\n        }\n    }\n    /**\n     * Iterate over every available text tracks on the media element and either:\n     *   - if the last manually set text track is found, set that one.\n     *   - if we still do not find an optimal track, just disable it.\n     */\n    _setPreviouslyLockedTextTrack() {\n        if (this._textTrackLockedOn === undefined) {\n            return;\n        }\n        else if (this._textTrackLockedOn === null) {\n            disableTextTracks(this._textTracks);\n            return;\n        }\n        else {\n            for (let i = 0; i < this._textTracks.length; i++) {\n                const { nativeTrack } = this._textTracks[i];\n                if (nativeTrack === this._textTrackLockedOn) {\n                    // disable the rest\n                    disableAllTextTracksBut(this._textTracks, nativeTrack);\n                    if (nativeTrack.mode !== \"showing\") {\n                        nativeTrack.mode = \"showing\";\n                    }\n                    return;\n                }\n            }\n        }\n    }\n    /**\n     * Iterate over every available video tracks on the media element and either:\n     *   - if the last manually set video track is found, set that one.\n     *   - if we still do not find an optimal track, let the one chosen by default\n     */\n    _setPreviouslyLockedVideoTrack() {\n        if (this._videoTrackLockedOn === undefined) {\n            return;\n        }\n        else if (this._videoTrackLockedOn === null) {\n            disableVideoTracks(this._videoTracks);\n            return;\n        }\n        else {\n            for (let i = 0; i < this._videoTracks.length; i++) {\n                const { nativeTrack } = this._videoTracks[i];\n                if (nativeTrack === this._videoTrackLockedOn) {\n                    nativeTrack.selected = true;\n                    return;\n                }\n            }\n        }\n    }\n    /**\n     * Monitor native tracks add, remove and change callback and trigger the\n     * change events.\n     */\n    _handleNativeTracksCallbacks() {\n        if (this._nativeAudioTracks !== undefined) {\n            this._nativeAudioTracks.onaddtrack = () => {\n                var _a, _b;\n                if (this._nativeAudioTracks !== undefined) {\n                    const newAudioTracks = createAudioTracks(this._nativeAudioTracks);\n                    if (areTrackArraysDifferent(this._audioTracks, newAudioTracks)) {\n                        this._audioTracks = newAudioTracks;\n                        this._setPreviouslyLockedAudioTrack();\n                        this.trigger(\"availableAudioTracksChange\", this.getAvailableAudioTracks());\n                        const chosenAudioTrack = this._getCurrentAudioTrack();\n                        if ((chosenAudioTrack === null || chosenAudioTrack === void 0 ? void 0 : chosenAudioTrack.nativeTrack) !== this._lastEmittedNativeAudioTrack) {\n                            this.trigger(\"audioTrackChange\", (_a = chosenAudioTrack === null || chosenAudioTrack === void 0 ? void 0 : chosenAudioTrack.track) !== null && _a !== void 0 ? _a : null);\n                            this._lastEmittedNativeAudioTrack = (_b = chosenAudioTrack === null || chosenAudioTrack === void 0 ? void 0 : chosenAudioTrack.nativeTrack) !== null && _b !== void 0 ? _b : null;\n                        }\n                    }\n                }\n            };\n            this._nativeAudioTracks.onremovetrack = () => {\n                var _a, _b;\n                if (this._nativeAudioTracks !== undefined) {\n                    const newAudioTracks = createAudioTracks(this._nativeAudioTracks);\n                    if (areTrackArraysDifferent(this._audioTracks, newAudioTracks)) {\n                        this._audioTracks = newAudioTracks;\n                        this.trigger(\"availableAudioTracksChange\", this.getAvailableAudioTracks());\n                        const chosenAudioTrack = this._getCurrentAudioTrack();\n                        if ((chosenAudioTrack === null || chosenAudioTrack === void 0 ? void 0 : chosenAudioTrack.nativeTrack) !== this._lastEmittedNativeAudioTrack) {\n                            this.trigger(\"audioTrackChange\", (_a = chosenAudioTrack === null || chosenAudioTrack === void 0 ? void 0 : chosenAudioTrack.track) !== null && _a !== void 0 ? _a : null);\n                            this._lastEmittedNativeAudioTrack = (_b = chosenAudioTrack === null || chosenAudioTrack === void 0 ? void 0 : chosenAudioTrack.nativeTrack) !== null && _b !== void 0 ? _b : null;\n                        }\n                    }\n                }\n            };\n            this._nativeAudioTracks.onchange = () => {\n                if (this._audioTracks !== undefined) {\n                    for (let i = 0; i < this._audioTracks.length; i++) {\n                        const { track, nativeTrack } = this._audioTracks[i];\n                        if (nativeTrack.enabled) {\n                            if (nativeTrack !== this._lastEmittedNativeAudioTrack) {\n                                this.trigger(\"audioTrackChange\", track);\n                                this._lastEmittedNativeAudioTrack = nativeTrack;\n                            }\n                            return;\n                        }\n                    }\n                }\n                if (this._lastEmittedNativeAudioTrack !== null) {\n                    this.trigger(\"audioTrackChange\", null);\n                    this._lastEmittedNativeAudioTrack = null;\n                }\n                return;\n            };\n        }\n        if (this._nativeTextTracks !== undefined) {\n            this._nativeTextTracks.onaddtrack = () => {\n                var _a, _b;\n                if (this._nativeTextTracks !== undefined) {\n                    const newTextTracks = createTextTracks(this._nativeTextTracks);\n                    if (areTrackArraysDifferent(this._textTracks, newTextTracks)) {\n                        this._textTracks = newTextTracks;\n                        this._setPreviouslyLockedTextTrack();\n                        this.trigger(\"availableTextTracksChange\", this.getAvailableTextTracks());\n                        const chosenTextTrack = this._getCurrentTextTrack();\n                        if ((chosenTextTrack === null || chosenTextTrack === void 0 ? void 0 : chosenTextTrack.nativeTrack) !== this._lastEmittedNativeTextTrack) {\n                            this.trigger(\"textTrackChange\", (_a = chosenTextTrack === null || chosenTextTrack === void 0 ? void 0 : chosenTextTrack.track) !== null && _a !== void 0 ? _a : null);\n                            this._lastEmittedNativeTextTrack = (_b = chosenTextTrack === null || chosenTextTrack === void 0 ? void 0 : chosenTextTrack.nativeTrack) !== null && _b !== void 0 ? _b : null;\n                        }\n                    }\n                }\n            };\n            this._nativeTextTracks.onremovetrack = () => {\n                var _a, _b;\n                if (this._nativeTextTracks !== undefined) {\n                    const newTextTracks = createTextTracks(this._nativeTextTracks);\n                    if (areTrackArraysDifferent(this._textTracks, newTextTracks)) {\n                        this._textTracks = newTextTracks;\n                        this._setPreviouslyLockedTextTrack();\n                        this.trigger(\"availableTextTracksChange\", this.getAvailableTextTracks());\n                        const chosenTextTrack = this._getCurrentTextTrack();\n                        if ((chosenTextTrack === null || chosenTextTrack === void 0 ? void 0 : chosenTextTrack.nativeTrack) !== this._lastEmittedNativeTextTrack) {\n                            this.trigger(\"textTrackChange\", (_a = chosenTextTrack === null || chosenTextTrack === void 0 ? void 0 : chosenTextTrack.track) !== null && _a !== void 0 ? _a : null);\n                            this._lastEmittedNativeTextTrack = (_b = chosenTextTrack === null || chosenTextTrack === void 0 ? void 0 : chosenTextTrack.nativeTrack) !== null && _b !== void 0 ? _b : null;\n                        }\n                    }\n                }\n            };\n            this._nativeTextTracks.onchange = () => {\n                if (this._textTracks !== undefined) {\n                    for (let i = 0; i < this._textTracks.length; i++) {\n                        const { track, nativeTrack } = this._textTracks[i];\n                        if (nativeTrack.mode === \"showing\") {\n                            if (nativeTrack !== this._lastEmittedNativeTextTrack) {\n                                this.trigger(\"textTrackChange\", track);\n                                this._lastEmittedNativeTextTrack = nativeTrack;\n                            }\n                            return;\n                        }\n                    }\n                }\n                if (this._lastEmittedNativeTextTrack !== null) {\n                    this.trigger(\"textTrackChange\", null);\n                    this._lastEmittedNativeTextTrack = null;\n                }\n                return;\n            };\n        }\n        if (this._nativeVideoTracks !== undefined) {\n            this._nativeVideoTracks.onaddtrack = () => {\n                var _a, _b;\n                if (this._nativeVideoTracks !== undefined) {\n                    const newVideoTracks = createVideoTracks(this._nativeVideoTracks);\n                    if (areTrackArraysDifferent(this._videoTracks, newVideoTracks)) {\n                        this._videoTracks = newVideoTracks;\n                        this._setPreviouslyLockedVideoTrack();\n                        this.trigger(\"availableVideoTracksChange\", this.getAvailableVideoTracks());\n                        const chosenVideoTrack = this._getCurrentVideoTrack();\n                        if ((chosenVideoTrack === null || chosenVideoTrack === void 0 ? void 0 : chosenVideoTrack.nativeTrack) !== this._lastEmittedNativeVideoTrack) {\n                            this.trigger(\"videoTrackChange\", (_a = chosenVideoTrack === null || chosenVideoTrack === void 0 ? void 0 : chosenVideoTrack.track) !== null && _a !== void 0 ? _a : null);\n                            this._lastEmittedNativeVideoTrack = (_b = chosenVideoTrack === null || chosenVideoTrack === void 0 ? void 0 : chosenVideoTrack.nativeTrack) !== null && _b !== void 0 ? _b : null;\n                        }\n                    }\n                }\n            };\n            this._nativeVideoTracks.onremovetrack = () => {\n                var _a, _b;\n                if (this._nativeVideoTracks !== undefined) {\n                    const newVideoTracks = createVideoTracks(this._nativeVideoTracks);\n                    if (areTrackArraysDifferent(this._videoTracks, newVideoTracks)) {\n                        this._videoTracks = newVideoTracks;\n                        this._setPreviouslyLockedVideoTrack();\n                        this.trigger(\"availableVideoTracksChange\", this.getAvailableVideoTracks());\n                        const chosenVideoTrack = this._getCurrentVideoTrack();\n                        if ((chosenVideoTrack === null || chosenVideoTrack === void 0 ? void 0 : chosenVideoTrack.nativeTrack) !== this._lastEmittedNativeVideoTrack) {\n                            this.trigger(\"videoTrackChange\", (_a = chosenVideoTrack === null || chosenVideoTrack === void 0 ? void 0 : chosenVideoTrack.track) !== null && _a !== void 0 ? _a : null);\n                            this._lastEmittedNativeVideoTrack = (_b = chosenVideoTrack === null || chosenVideoTrack === void 0 ? void 0 : chosenVideoTrack.nativeTrack) !== null && _b !== void 0 ? _b : null;\n                        }\n                    }\n                }\n            };\n            this._nativeVideoTracks.onchange = () => {\n                if (this._videoTracks !== undefined) {\n                    for (let i = 0; i < this._videoTracks.length; i++) {\n                        const { track, nativeTrack } = this._videoTracks[i];\n                        if (nativeTrack.selected) {\n                            if (nativeTrack !== this._lastEmittedNativeVideoTrack) {\n                                this.trigger(\"videoTrackChange\", track);\n                                this._lastEmittedNativeVideoTrack = nativeTrack;\n                            }\n                            return;\n                        }\n                    }\n                }\n                if (this._lastEmittedNativeVideoTrack !== null) {\n                    this.trigger(\"videoTrackChange\", null);\n                    this._lastEmittedNativeVideoTrack = null;\n                }\n                return;\n            };\n        }\n    }\n    /**\n     * Enable an audio track (and disable all others), based on its index in the\n     * `this._audioTracks` array.\n     * @param {number} index}\n     */\n    _enableAudioTrackFromIndex(index) {\n        enableAudioTrack(this._audioTracks.map(({ nativeTrack }) => nativeTrack), index);\n    }\n}\n/**\n * Disable all text track elements in the given array from showing.\n * @param {Array.<Object>} textTracks\n */\nfunction disableTextTracks(textTracks) {\n    for (let i = 0; i < textTracks.length; i++) {\n        const { nativeTrack } = textTracks[i];\n        nativeTrack.mode = \"disabled\";\n    }\n}\n/**\n * Disable all text track elements in the given array from showing but one which\n * should stay in the same state it was before.\n * @param {Array.<Object>} textTracks\n * @param {TextTrack} track\n */\nfunction disableAllTextTracksBut(textTracks, track) {\n    for (let i = 0; i < textTracks.length; i++) {\n        const { nativeTrack } = textTracks[i];\n        if (nativeTrack !== track &&\n            (nativeTrack.mode === \"showing\" || nativeTrack.mode === \"hidden\")) {\n            nativeTrack.mode = \"disabled\";\n        }\n    }\n}\n/**\n * Disable all video track elements in the given array from showing.\n * Note that browser need to support that use case, which they often do not.\n * @param {Array.<Object>} videoTracks\n */\nfunction disableVideoTracks(videoTracks) {\n    for (let i = 0; i < videoTracks.length; i++) {\n        const { nativeTrack } = videoTracks[i];\n        nativeTrack.selected = false;\n    }\n}\n","import { isRepresentationPlayable } from \"../../manifest\";\nimport arrayIncludes from \"../../utils/array_includes\";\nimport EventEmitter from \"../../utils/event_emitter\";\nimport noop from \"../../utils/noop\";\nimport SharedReference from \"../../utils/reference\";\nimport TaskCanceller from \"../../utils/task_canceller\";\n/**\n * Class handling track changes and quality locking for a single Period and\n * Adaptation type.\n * @class TrackDispatcher\n */\nexport default class TrackDispatcher extends EventEmitter {\n    /**\n     * Create a new `TrackDispatcher` by giving its Reference and an initial track\n     * setting.\n     * This constructor will update the Reference with the right preferences\n     * synchronously.\n     * @param {Object} adaptationRef\n     */\n    constructor(adaptationRef) {\n        super();\n        this._canceller = new TaskCanceller();\n        this._adaptationRef = adaptationRef;\n        this._updateToken = false;\n        this._lastEmitted = undefined;\n        this.refresh = noop;\n    }\n    /**\n     * Returns `true` if the initial track choice has been sent by this\n     * `TrackDispatcher`.\n     * Returns `false` if that's not the case yet.\n     * @returns {boolean}\n     */\n    hasSetTrack() {\n        return this._adaptationRef.getValue() !== undefined;\n    }\n    /**\n     * Update the wanted track on the Reference linked to this `TrackDispatcher`.\n     * @param {Object|null} newTrackInfo\n     */\n    updateTrack(newTrackInfo) {\n        this._updateToken = true;\n        if (newTrackInfo === null) {\n            if (this._lastEmitted === null) {\n                return;\n            }\n            this._updateToken = false;\n            this._canceller.cancel();\n            // has no point but let's still create one for simplicity sake\n            this._canceller = new TaskCanceller();\n            this._lastEmitted = null;\n            this._adaptationRef.setValue(null);\n            return;\n        }\n        const { adaptation, switchingMode, relativeResumingPosition } = newTrackInfo;\n        this._canceller.cancel();\n        this._canceller = new TaskCanceller();\n        const reference = this._constructLockedRepresentationsReference(newTrackInfo);\n        if (!this._updateToken) {\n            return;\n        }\n        this._lastEmitted = {\n            adaptation,\n            switchingMode,\n            lockedRepresentations: null,\n        };\n        this._updateToken = false;\n        this._adaptationRef.setValue({\n            adaptationId: adaptation.id,\n            switchingMode,\n            representations: reference,\n            relativeResumingPosition,\n        });\n    }\n    /**\n     * Create a shared reference which will emit the wanted locked Representations\n     * based on the current capabilities and the last user settings.\n     *\n     * @param {Object} trackInfo\n     * @returns {Object}\n     */\n    _constructLockedRepresentationsReference(trackInfo) {\n        /* Initialize it. Will be at its true value at the end of the function. */\n        const reference = new SharedReference({\n            representationIds: [],\n            switchingMode: \"lazy\",\n        });\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const self = this;\n        this.refresh = updateReferenceIfNeeded;\n        this._canceller.signal.register(removeListeners);\n        trackInfo.lockedRepresentations.onUpdate(updateReferenceIfNeeded, {\n            clearSignal: this._canceller.signal,\n            emitCurrentValue: false,\n        });\n        updateReferenceIfNeeded();\n        return reference;\n        function updateReferenceIfNeeded() {\n            const repSettings = trackInfo.lockedRepresentations.getValue();\n            let switchingMode;\n            /** Representations for which a `RepresentationStream` can be created. */\n            let playableRepresentations;\n            if (repSettings === null) {\n                // unlocking\n                playableRepresentations = trackInfo.adaptation.representations.filter((representation) => isRepresentationPlayable(representation) === true);\n                // No need to remove the previous content when unlocking\n                switchingMode = \"lazy\";\n            }\n            else {\n                const { representationIds } = repSettings;\n                switchingMode = repSettings.switchingMode;\n                const representations = trackInfo.adaptation.representations.filter((r) => arrayIncludes(representationIds, r.id));\n                playableRepresentations = representations.filter((representation) => isRepresentationPlayable(representation) === true);\n                if (playableRepresentations.length === 0) {\n                    self.trigger(\"noPlayableLockedRepresentation\", null);\n                    return;\n                }\n            }\n            if (playableRepresentations.length <= 0) {\n                self.trigger(\"noPlayableRepresentation\", null);\n                return;\n            }\n            // Check if Locked Representations have changed\n            const oldRef = reference.getValue();\n            const sortedReps = playableRepresentations\n                .map((r) => r.id)\n                .slice()\n                .sort();\n            if (sortedReps.length !== oldRef.representationIds.length) {\n                reference.setValue({ representationIds: sortedReps, switchingMode });\n                return;\n            }\n            for (let i = 0; i < sortedReps.length; i++) {\n                if (oldRef.representationIds[i] !== sortedReps[i]) {\n                    reference.setValue({ representationIds: sortedReps, switchingMode });\n                    return;\n                }\n            }\n        }\n        function removeListeners() {\n            self.refresh = noop;\n        }\n    }\n    /**\n     * Free the resources (e.g. `Manifest` event listeners) linked to this\n     * `TrackDispatcher`.\n     */\n    dispose() {\n        this.removeEventListener();\n        this._canceller.cancel();\n        this._adaptationRef.finish();\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * This file is used to abstract the notion of text, audio and video tracks\n * switching for an easier API management.\n */\nimport config from \"../../config\";\nimport { MediaError } from \"../../errors\";\nimport log from \"../../log\";\nimport { getSupportedAdaptations, isRepresentationPlayable, toAudioTrack, toTextTrack, toVideoTrack, } from \"../../manifest\";\nimport arrayFind from \"../../utils/array_find\";\nimport assert from \"../../utils/assert\";\nimport EventEmitter from \"../../utils/event_emitter\";\nimport isNullOrUndefined from \"../../utils/is_null_or_undefined\";\nimport objectAssign from \"../../utils/object_assign\";\nimport SharedReference from \"../../utils/reference\";\nimport TrackDispatcher from \"./track_dispatcher\";\n/**\n * Class helping with the management of the audio, video and text tracks and\n * qualities.\n *\n * The `TracksStore` allows to choose a track and qualities for different types\n * of media through a simpler API.\n *\n * @class TracksStore\n */\nexport default class TracksStore extends EventEmitter {\n    constructor(args) {\n        var _a;\n        super();\n        this._storedPeriodInfo = [];\n        this._isDisposed = false;\n        this._cachedPeriodInfo = new WeakMap();\n        this._isTrickModeTrackEnabled = args.preferTrickModeTracks;\n        this._defaultAudioTrackSwitchingMode =\n            (_a = args.defaultAudioTrackSwitchingMode) !== null && _a !== void 0 ? _a : config.getCurrent().DEFAULT_AUDIO_TRACK_SWITCHING_MODE;\n    }\n    /**\n     * Return Array of Period information, to allow an outside application to\n     * modify the track of any Period.\n     * @returns {Array.<Object>}\n     */\n    getAvailablePeriods() {\n        return this._storedPeriodInfo.reduce((acc, p) => {\n            if (p.isPeriodAdvertised) {\n                acc.push(toExposedPeriod(p.period));\n            }\n            return acc;\n        }, []);\n    }\n    /**\n     * Callack that needs to be called as codec support is either first known or\n     * updated on the Manifest.\n     */\n    onManifestCodecSupportUpdate() {\n        this._selectInitialTrackIfNeeded();\n    }\n    /**\n     * Update the list of Periods handled by the TracksStore and make a\n     * track choice decision for each of them.\n     * @param {Object} manifest - The new Manifest object\n     */\n    onManifestUpdate(manifest) {\n        var _a, _b, _c, _d, _e, _f;\n        const { DEFAULT_VIDEO_TRACK_SWITCHING_MODE } = config.getCurrent();\n        const { periods } = manifest;\n        // We assume that they are always sorted chronologically\n        // In dev mode, perform a runtime check that this is the case\n        if (0 /* __ENVIRONMENT__.CURRENT_ENV */ === 1 /* __ENVIRONMENT__.DEV */) {\n            for (let i = 1; i < periods.length; i++) {\n                assert(periods[i - 1].start <= periods[i].start);\n            }\n        }\n        /** Periods which have just been added. */\n        const addedPeriods = [];\n        let newPListIdx = 0;\n        for (let i = 0; i < this._storedPeriodInfo.length; i++) {\n            const oldPeriod = this._storedPeriodInfo[i].period;\n            const newPeriod = periods[newPListIdx];\n            if (newPeriod === undefined) {\n                // We reached the end of the new Periods, remove remaining old Periods\n                for (let j = this._storedPeriodInfo.length - 1; j >= i; j--) {\n                    this._storedPeriodInfo[j].inManifest = false;\n                    if (isPeriodItemRemovable(this._storedPeriodInfo[j])) {\n                        this._removePeriodObject(j);\n                    }\n                }\n            }\n            else if (oldPeriod === newPeriod) {\n                newPListIdx++;\n                const curWantedTextTrack = this._storedPeriodInfo[i].text.storedSettings;\n                if (!isNullOrUndefined(curWantedTextTrack)) {\n                    const textAdaptations = getSupportedAdaptations(newPeriod, \"text\");\n                    const stillHere = textAdaptations.some((a) => a.id === curWantedTextTrack.adaptation.id);\n                    if (!stillHere) {\n                        log.warn(\"TS: Chosen text Adaptation not available anymore\");\n                        const periodInfo = this._storedPeriodInfo[i];\n                        periodInfo.text.storedSettings = null;\n                        this.trigger(\"trackUpdate\", {\n                            period: toExposedPeriod(newPeriod),\n                            trackType: \"text\",\n                            reason: \"missing\",\n                        });\n                        // The previous event trigger could have had side-effects, so we\n                        // re-check if we're still mostly in the same state\n                        if (this._isDisposed) {\n                            return; // The current TracksStore is disposed, we can abort\n                        }\n                        const periodItem = getPeriodItem(this._storedPeriodInfo, periodInfo.period.id);\n                        if (periodItem !== undefined &&\n                            periodItem.isPeriodAdvertised &&\n                            periodItem.text.storedSettings === null) {\n                            (_a = periodItem.text.dispatcher) === null || _a === void 0 ? void 0 : _a.updateTrack(null);\n                        }\n                    }\n                }\n                const curWantedVideoTrack = this._storedPeriodInfo[i].video.storedSettings;\n                if (!isNullOrUndefined(curWantedVideoTrack)) {\n                    const videoAdaptations = getSupportedAdaptations(newPeriod, \"video\");\n                    const stillHere = videoAdaptations.some((a) => a.id === curWantedVideoTrack.adaptation.id);\n                    if (!stillHere) {\n                        log.warn(\"TS: Chosen video Adaptation not available anymore\");\n                        const periodItem = this._storedPeriodInfo[i];\n                        let storedSettings;\n                        if (videoAdaptations.length === 0) {\n                            storedSettings = null;\n                        }\n                        else {\n                            const adaptationBase = videoAdaptations[0];\n                            const adaptation = getRightVideoTrack(adaptationBase, this._isTrickModeTrackEnabled);\n                            const lockedRepresentations = new SharedReference(null);\n                            storedSettings = {\n                                adaptationBase,\n                                adaptation,\n                                switchingMode: DEFAULT_VIDEO_TRACK_SWITCHING_MODE,\n                                lockedRepresentations,\n                            };\n                        }\n                        periodItem.video.storedSettings = storedSettings;\n                        this.trigger(\"trackUpdate\", {\n                            period: toExposedPeriod(newPeriod),\n                            trackType: \"video\",\n                            reason: \"missing\",\n                        });\n                        // The previous event trigger could have had side-effects, so we\n                        // re-check if we're still mostly in the same state\n                        if (this._isDisposed) {\n                            return; // Someone disposed the `TracksStore` on the previous side-effect\n                        }\n                        const newPeriodItem = getPeriodItem(this._storedPeriodInfo, periodItem.period.id);\n                        if (newPeriodItem !== undefined &&\n                            newPeriodItem.isPeriodAdvertised &&\n                            newPeriodItem.video.storedSettings === storedSettings) {\n                            (_b = newPeriodItem.video.dispatcher) === null || _b === void 0 ? void 0 : _b.updateTrack(storedSettings);\n                        }\n                    }\n                }\n                const curWantedAudioTrack = this._storedPeriodInfo[i].audio.storedSettings;\n                if (!isNullOrUndefined(curWantedAudioTrack)) {\n                    const audioAdaptations = getSupportedAdaptations(newPeriod, \"audio\");\n                    const stillHere = audioAdaptations.some((a) => a.id === curWantedAudioTrack.adaptation.id);\n                    if (!stillHere) {\n                        log.warn(\"TS: Chosen audio Adaptation not available anymore\");\n                        const periodItem = this._storedPeriodInfo[i];\n                        const storedSettings = audioAdaptations.length === 0\n                            ? null\n                            : {\n                                adaptation: audioAdaptations[0],\n                                switchingMode: this._defaultAudioTrackSwitchingMode,\n                                lockedRepresentations: new SharedReference(null),\n                            };\n                        periodItem.audio.storedSettings = storedSettings;\n                        this.trigger(\"trackUpdate\", {\n                            period: toExposedPeriod(newPeriod),\n                            trackType: \"audio\",\n                            reason: \"missing\",\n                        });\n                        // The previous event trigger could have had side-effects, so we\n                        // re-check if we're still mostly in the same state\n                        if (this._isDisposed) {\n                            return; // Someone disposed the `TracksStore` on the previous side-effect\n                        }\n                        const newPeriodItem = getPeriodItem(this._storedPeriodInfo, periodItem.period.id);\n                        if (newPeriodItem !== undefined &&\n                            newPeriodItem.isPeriodAdvertised &&\n                            newPeriodItem.audio.storedSettings === storedSettings) {\n                            (_c = newPeriodItem.audio.dispatcher) === null || _c === void 0 ? void 0 : _c.updateTrack(storedSettings);\n                        }\n                    }\n                }\n                // (If not, what do?)\n            }\n            else if (oldPeriod.start <= newPeriod.start) {\n                // This old Period does not exist anymore.\n                this._storedPeriodInfo[i].inManifest = false;\n                if (isPeriodItemRemovable(this._storedPeriodInfo[i])) {\n                    this._removePeriodObject(i);\n                    i--;\n                }\n            }\n            else {\n                const newPeriodInfo = generatePeriodInfo(newPeriod, true);\n                // oldPeriod.start > newPeriod.start: insert newPeriod before\n                this._storedPeriodInfo.splice(i, 0, newPeriodInfo);\n                addedPeriods.push(newPeriodInfo);\n                newPListIdx++;\n                // Note: we don't increment `i` on purpose here, as we want to check the\n                // same oldPeriod at the next loop iteration\n            }\n        }\n        if (newPListIdx < periods.length) {\n            // Add further new Period\n            const periodsToAdd = periods\n                .slice(newPListIdx)\n                .map((p) => generatePeriodInfo(p, true));\n            this._storedPeriodInfo.push(...periodsToAdd);\n            addedPeriods.push(...periodsToAdd);\n        }\n        for (const storedPeriodInfo of this._storedPeriodInfo) {\n            (_d = storedPeriodInfo.audio.dispatcher) === null || _d === void 0 ? void 0 : _d.refresh();\n            (_e = storedPeriodInfo.video.dispatcher) === null || _e === void 0 ? void 0 : _e.refresh();\n            (_f = storedPeriodInfo.text.dispatcher) === null || _f === void 0 ? void 0 : _f.refresh();\n        }\n    }\n    onDecipherabilityUpdates() {\n        var _a, _b, _c;\n        for (const storedPeriodInfo of this._storedPeriodInfo) {\n            (_a = storedPeriodInfo.audio.dispatcher) === null || _a === void 0 ? void 0 : _a.refresh();\n            (_b = storedPeriodInfo.video.dispatcher) === null || _b === void 0 ? void 0 : _b.refresh();\n            (_c = storedPeriodInfo.text.dispatcher) === null || _c === void 0 ? void 0 : _c.refresh();\n        }\n    }\n    /**\n     * Add shared reference to choose Adaptation for new \"audio\", \"video\" or\n     * \"text\" Period.\n     *\n     * Note that such reference has to be removed through `removeTrackReference`\n     * so ressources can be freed.\n     * @param {string} bufferType - The concerned buffer type\n     * @param {Period} period - The concerned Period.\n     * @param {Object} adaptationRef - A reference through which\n     * the choice will be given.\n     */\n    addTrackReference(bufferType, period, adaptationRef) {\n        log.debug(\"TS: Adding Track Reference\", bufferType, period.id);\n        let periodObj = getPeriodItem(this._storedPeriodInfo, period.id);\n        if (periodObj === undefined) {\n            // The Period has not yet been added.\n            periodObj = generatePeriodInfo(period, false);\n            let found = false;\n            for (let i = 0; i < this._storedPeriodInfo.length; i++) {\n                if (this._storedPeriodInfo[i].period.start > period.start) {\n                    this._storedPeriodInfo.splice(i, 0, periodObj);\n                    found = true;\n                }\n            }\n            if (!found) {\n                this._storedPeriodInfo.push(periodObj);\n            }\n        }\n        if (periodObj[bufferType].dispatcher !== null) {\n            log.error(`TS: Subject already added for ${bufferType} ` + `and Period ${period.start}`);\n            periodObj[bufferType].dispatcher.dispose();\n        }\n        const dispatcher = new TrackDispatcher(adaptationRef);\n        periodObj[bufferType].dispatcher = dispatcher;\n        dispatcher.addEventListener(\"noPlayableRepresentation\", () => {\n            var _a, _b, _c, _d;\n            const nextAdaptation = arrayFind((_a = period.adaptations[bufferType]) !== null && _a !== void 0 ? _a : [], (adaptation) => {\n                if (adaptation.supportStatus.hasSupportedCodec === false ||\n                    adaptation.supportStatus.isDecipherable === false) {\n                    return false;\n                }\n                const playableRepresentations = adaptation.representations.filter((r) => isRepresentationPlayable(r) === true);\n                return playableRepresentations.length > 0;\n            });\n            if (nextAdaptation === undefined) {\n                const noRepErr = new MediaError(\"NO_PLAYABLE_REPRESENTATION\", `No ${bufferType} Representation can be played`, { tracks: undefined });\n                this.trigger(\"error\", noRepErr);\n                this.dispose();\n                return;\n            }\n            let typeInfo = (_b = getPeriodItem(this._storedPeriodInfo, period.id)) === null || _b === void 0 ? void 0 : _b[bufferType];\n            if (isNullOrUndefined(typeInfo)) {\n                return;\n            }\n            const switchingMode = bufferType === \"audio\" ? this._defaultAudioTrackSwitchingMode : \"reload\";\n            const storedSettings = {\n                adaptation: nextAdaptation,\n                switchingMode,\n                lockedRepresentations: new SharedReference(null),\n            };\n            typeInfo.storedSettings = storedSettings;\n            this.trigger(\"trackUpdate\", {\n                period: toExposedPeriod(period),\n                trackType: bufferType,\n                reason: \"no-playable-representation\",\n            });\n            // The previous event trigger could have had side-effects, so we\n            // re-check if we're still mostly in the same state\n            if (this._isDisposed) {\n                return; // Someone disposed the `TracksStore` on the previous side-effect\n            }\n            typeInfo = (_c = getPeriodItem(this._storedPeriodInfo, period.id)) === null || _c === void 0 ? void 0 : _c[bufferType];\n            if (isNullOrUndefined(typeInfo) || typeInfo.storedSettings !== storedSettings) {\n                return;\n            }\n            (_d = typeInfo.dispatcher) === null || _d === void 0 ? void 0 : _d.updateTrack(storedSettings);\n        });\n        dispatcher.addEventListener(\"noPlayableLockedRepresentation\", () => {\n            // TODO check that it doesn't already lead to segment loading or MediaSource\n            // reloading\n            if (periodObj === undefined) {\n                return;\n            }\n            this.unlockVideoRepresentations(periodObj);\n            this.trigger(\"brokenRepresentationsLock\", {\n                period: { id: period.id, start: period.start, end: period.end },\n                trackType: bufferType,\n            });\n        });\n        this._selectInitialTrackIfNeeded();\n        // Ensure `newAvailablePeriods` is sent\n        if (this._shouldAdvertisePeriod(periodObj)) {\n            periodObj.isPeriodAdvertised = true;\n            this.trigger(\"newAvailablePeriods\", [\n                {\n                    id: period.id,\n                    start: period.start,\n                    end: period.end,\n                },\n            ]);\n            if (this._isDisposed) {\n                return;\n            }\n        }\n        // Ensure the initial track is set for each type now)\n        const trackTypes = [\"audio\", \"video\", \"text\"];\n        for (const ttype of trackTypes) {\n            const trackObj = periodObj[ttype];\n            if (periodObj.isPeriodAdvertised &&\n                trackObj.dispatcher !== null &&\n                !trackObj.dispatcher.hasSetTrack() &&\n                trackObj.storedSettings !== undefined) {\n                trackObj.dispatcher.updateTrack(trackObj.storedSettings);\n            }\n            if (this._isDisposed) {\n                return;\n            }\n        }\n    }\n    /**\n     * Remove shared reference to choose an \"audio\", \"video\" or \"text\" Adaptation\n     * for a Period.\n     * @param {string} bufferType - The concerned buffer type\n     * @param {string} periodId - The concerned Period's `id`.\n     */\n    removeTrackReference(bufferType, periodId) {\n        log.debug(\"TS: Removing Track Reference\", bufferType, periodId);\n        let periodIndex;\n        for (let i = 0; i < this._storedPeriodInfo.length; i++) {\n            const periodI = this._storedPeriodInfo[i];\n            if (periodI.period.id === periodId) {\n                periodIndex = i;\n                break;\n            }\n        }\n        if (periodIndex === undefined) {\n            log.warn(`TS: ${bufferType} not found for period`, periodId);\n            return;\n        }\n        const periodObj = this._storedPeriodInfo[periodIndex];\n        const choiceItem = periodObj[bufferType];\n        if ((choiceItem === null || choiceItem === void 0 ? void 0 : choiceItem.dispatcher) === null) {\n            log.warn(`TS: TrackDispatcher already removed for ${bufferType} ` +\n                `and Period ${periodId}`);\n            return;\n        }\n        choiceItem.dispatcher.dispose();\n        choiceItem.dispatcher = null;\n        if (isPeriodItemRemovable(periodObj)) {\n            this._removePeriodObject(periodIndex);\n        }\n    }\n    /**\n     * Allows to recuperate a \"Period Object\" - used in get/set methods of the\n     * `TracksStore` - by giving the Period itself.\n     *\n     * This method should be preferred when possible over `getPeriodObjectFromId`\n     * because it is able to fallback on an internal cache in case the\n     * corresponding Period is not stored anymore.\n     * This for example could happen when a Period has been removed from the\n     * Manifest yet may still be needed (e.g. because its linked segments might\n     * still live in the buffers).\n     *\n     * Note however that this cache-retrieval logic is based on a Map whose key\n     * is the Period's JavaScript reference. As such, the cache won't be used if\n     * `Period` corresponds to a copy of the original `Period` object.\n     *\n     * @param {Object} period\n     * @returns {Object}\n     */\n    getPeriodObjectFromPeriod(period) {\n        const periodObj = getPeriodItem(this._storedPeriodInfo, period.id);\n        if (periodObj === undefined && period !== undefined) {\n            return this._cachedPeriodInfo.get(period);\n        }\n        return periodObj;\n    }\n    /**\n     * Allows to recuperate a \"Period Object\" - used in get/set methods of the\n     * `TracksStore` - by giving the Period's id.\n     *\n     * Note that unlike `getPeriodObjectFromPeriod` this method is only going to look\n     * into currently stored Period and as such old Periods not in the Manifest\n     * anymore might not be retrievable.\n     * If you want to retrieve Period objects linked to such Period, you might\n     * prefer to use `getPeriodObjectFromPeriod` (which necessitates the original\n     * Period object).\n     *\n     * @param {string} periodId - The concerned Period's id\n     * @returns {Object}\n     */\n    getPeriodObjectFromId(periodId) {\n        return getPeriodItem(this._storedPeriodInfo, periodId);\n    }\n    disableVideoTrickModeTracks() {\n        if (!this._isTrickModeTrackEnabled) {\n            return;\n        }\n        this._isTrickModeTrackEnabled = false;\n        this._resetVideoTrackChoices(\"trickmode-disabled\");\n    }\n    enableVideoTrickModeTracks() {\n        if (this._isTrickModeTrackEnabled) {\n            return;\n        }\n        this._isTrickModeTrackEnabled = true;\n        this._resetVideoTrackChoices(\"trickmode-enabled\");\n    }\n    /**\n     * Reset the TracksStore's Period objects:\n     *   - All Period which are not in the manifest currently will be removed.\n     *   - All References used to communicate the wanted track will be removed.\n     *\n     * You might want to call this API when restarting playback.\n     */\n    resetPeriodObjects() {\n        var _a, _b, _c;\n        log.debug(\"TS: Resetting Period Objects\");\n        for (let i = this._storedPeriodInfo.length - 1; i >= 0; i--) {\n            const storedObj = this._storedPeriodInfo[i];\n            (_a = storedObj.audio.dispatcher) === null || _a === void 0 ? void 0 : _a.dispose();\n            storedObj.audio.dispatcher = null;\n            (_b = storedObj.video.dispatcher) === null || _b === void 0 ? void 0 : _b.dispose();\n            storedObj.video.dispatcher = null;\n            (_c = storedObj.text.dispatcher) === null || _c === void 0 ? void 0 : _c.dispose();\n            storedObj.text.dispatcher = null;\n            if (!storedObj.inManifest) {\n                this._removePeriodObject(i);\n            }\n        }\n    }\n    /**\n     * @returns {boolean}\n     */\n    isTrickModeEnabled() {\n        return this._isTrickModeTrackEnabled;\n    }\n    /**\n     * Set audio track based on the ID of its Adaptation for a given added Period.\n     * @param {Object} params\n     * @param {Object} params.periodRef - The concerned Period's object.\n     * @param {string} params.trackId - adaptation id of the wanted track.\n     * @param {string} params.switchingMode - Behavior when replacing the track by\n     * another.\n     * @param {Object|null} params.lockedRepresentations - Audio Representations\n     * that should be locked after switching to that track.\n     * `null` if no Audio Representation should be locked.\n     * @param {number} params.relativeResumingPosition\n     */\n    setAudioTrack(payload) {\n        const { periodRef, trackId, switchingMode, lockedRepresentations, relativeResumingPosition, } = payload;\n        return this._setAudioOrTextTrack({\n            bufferType: \"audio\",\n            periodRef,\n            trackId,\n            switchingMode: switchingMode !== null && switchingMode !== void 0 ? switchingMode : this._defaultAudioTrackSwitchingMode,\n            lockedRepresentations,\n            relativeResumingPosition,\n        });\n    }\n    /**\n     * Set text track based on the ID of its Adaptation for a given added Period.\n     * @param {Object} periodObj - The concerned Period's object.\n     * @param {string} wantedId - adaptation id of the wanted track.\n     */\n    setTextTrack(periodObj, wantedId) {\n        return this._setAudioOrTextTrack({\n            bufferType: \"text\",\n            periodRef: periodObj,\n            trackId: wantedId,\n            switchingMode: \"direct\",\n            lockedRepresentations: null,\n            relativeResumingPosition: undefined,\n        });\n    }\n    /**\n     * Set audio track based on the ID of its Adaptation for a given added Period.\n     * @param {Object} params\n     * @param {string} params.bufferType\n     * @param {Object} params.periodRef - The concerned Period's object.\n     * @param {string} params.trackId - adaptation id of the wanted track.\n     * @param {string} params.switchingMode - Behavior when replacing the track by\n     * another.\n     * @param {Array.<string>|null} params.lockedRepresentations - Audio\n     * Representations that should be locked after switchingMode to that track.\n     * `null` if no Audio Representation should be locked.\n     * @param {number|undefined} params.relativeResumingPosition\n     */\n    _setAudioOrTextTrack({ bufferType, periodRef, trackId, switchingMode, lockedRepresentations, relativeResumingPosition, }) {\n        var _a, _b;\n        if (!periodRef.isPeriodAdvertised) {\n            throw new Error(\"Wanted Period not yet advertised.\");\n        }\n        const period = periodRef.period;\n        const wantedAdaptation = arrayFind((_a = period.adaptations[bufferType]) !== null && _a !== void 0 ? _a : [], ({ id, supportStatus }) => supportStatus.hasSupportedCodec !== false &&\n            supportStatus.isDecipherable !== false &&\n            id === trackId);\n        if (wantedAdaptation === undefined) {\n            throw new Error(`Wanted ${bufferType} track not found.`);\n        }\n        const typeInfo = periodRef[bufferType];\n        let lockedRepresentationsRef;\n        if (lockedRepresentations === null) {\n            lockedRepresentationsRef = new SharedReference(null);\n        }\n        else {\n            const representationsToLock = this._getRepresentationsToLock(wantedAdaptation, lockedRepresentations);\n            const repSwitchingMode = bufferType === \"audio\"\n                ? this._defaultAudioTrackSwitchingMode\n                : \"direct\";\n            lockedRepresentationsRef = new SharedReference({\n                representationIds: representationsToLock,\n                switchingMode: repSwitchingMode,\n            });\n        }\n        const storedSettings = {\n            adaptation: wantedAdaptation,\n            switchingMode,\n            lockedRepresentations: lockedRepresentationsRef,\n            relativeResumingPosition,\n        };\n        typeInfo.storedSettings = storedSettings;\n        this.trigger(\"trackUpdate\", {\n            period: toExposedPeriod(period),\n            trackType: bufferType,\n            reason: \"manual\",\n        });\n        // The previous event trigger could have had side-effects, so we\n        // re-check if we're still mostly in the same state\n        if (this._isDisposed) {\n            return; // Someone disposed the `TracksStore` on the previous side-effect\n        }\n        const newPeriodItem = getPeriodItem(this._storedPeriodInfo, period.id);\n        if (newPeriodItem !== undefined &&\n            newPeriodItem[bufferType].storedSettings === storedSettings) {\n            (_b = newPeriodItem[bufferType].dispatcher) === null || _b === void 0 ? void 0 : _b.updateTrack(storedSettings);\n        }\n    }\n    /**\n     * Set video track based on the ID of its Adaptation for a given added Period.\n     * @param {Object} params\n     * @param {Object} params.periodRef - The concerned Period's object.\n     * @param {string} params.trackId - adaptation id of the wanted track.\n     * @param {string} params.switchingMode - Behavior when replacing the track by\n     * another.\n     * @param {Array.<string>|null} params.lockedRepresentations - Video\n     * Representations that should be locked after switching to that track.\n     * `null` if no Video Representation should be locked.\n     * @param {number|undefined} params.relativeResumingPosition\n     */\n    setVideoTrack(payload) {\n        var _a, _b;\n        const { periodRef, trackId, switchingMode, lockedRepresentations, relativeResumingPosition, } = payload;\n        if (!periodRef.isPeriodAdvertised) {\n            throw new Error(\"Wanted Period not yet advertised.\");\n        }\n        const period = periodRef.period;\n        const wantedAdaptation = arrayFind((_a = period.adaptations.video) !== null && _a !== void 0 ? _a : [], ({ id, supportStatus }) => supportStatus.isDecipherable !== false &&\n            supportStatus.hasSupportedCodec !== false &&\n            id === trackId);\n        if (wantedAdaptation === undefined) {\n            throw new Error(\"Wanted video track not found.\");\n        }\n        const { DEFAULT_VIDEO_TRACK_SWITCHING_MODE } = config.getCurrent();\n        const typeInfo = periodRef.video;\n        const newAdaptation = getRightVideoTrack(wantedAdaptation, this._isTrickModeTrackEnabled);\n        let lockedRepresentationsRef;\n        if (lockedRepresentations === null) {\n            lockedRepresentationsRef = new SharedReference(null);\n        }\n        else {\n            const representationsToLock = this._getRepresentationsToLock(wantedAdaptation, lockedRepresentations);\n            const repSwitchingMode = DEFAULT_VIDEO_TRACK_SWITCHING_MODE;\n            lockedRepresentationsRef = new SharedReference({\n                representationIds: representationsToLock,\n                switchingMode: repSwitchingMode,\n            });\n        }\n        const storedSettings = {\n            adaptationBase: wantedAdaptation,\n            switchingMode: switchingMode !== null && switchingMode !== void 0 ? switchingMode : DEFAULT_VIDEO_TRACK_SWITCHING_MODE,\n            adaptation: newAdaptation,\n            relativeResumingPosition,\n            lockedRepresentations: lockedRepresentationsRef,\n        };\n        typeInfo.storedSettings = storedSettings;\n        this.trigger(\"trackUpdate\", {\n            period: toExposedPeriod(period),\n            trackType: \"video\",\n            reason: \"manual\",\n        });\n        // The previous event trigger could have had side-effects, so we\n        // re-check if we're still mostly in the same state\n        if (this._isDisposed) {\n            return; // Someone disposed the `TracksStore` on the previous side-effect\n        }\n        const newPeriodItem = getPeriodItem(this._storedPeriodInfo, period.id);\n        if (newPeriodItem !== undefined &&\n            newPeriodItem.video.storedSettings === storedSettings) {\n            (_b = newPeriodItem.video.dispatcher) === null || _b === void 0 ? void 0 : _b.updateTrack(storedSettings);\n        }\n    }\n    /**\n     * Disable the current text track for a given period.\n     *\n     * @param {Object} periodObj - The concerned Period's object\n     * @param {string} bufferType - The type of track to disable.\n     * @throws Error - Throws if the period given has not been added\n     */\n    disableTrack(periodObj, bufferType) {\n        var _a, _b;\n        if (!periodObj.isPeriodAdvertised) {\n            throw new Error(\"Wanted Period not yet advertised.\");\n        }\n        const trackInfo = periodObj[bufferType];\n        if (trackInfo.storedSettings === null) {\n            return;\n        }\n        if (bufferType !== \"text\") {\n            // Potentially unneeded, but let's be clean\n            (_a = periodObj[bufferType].storedSettings) === null || _a === void 0 ? void 0 : _a.lockedRepresentations.finish();\n        }\n        trackInfo.storedSettings = null;\n        this.trigger(\"trackUpdate\", {\n            period: toExposedPeriod(periodObj.period),\n            trackType: bufferType,\n            reason: \"manual\",\n        });\n        // The previous event trigger could have had side-effects, so we\n        // re-check if we're still mostly in the same state\n        if (this._isDisposed) {\n            return; // Someone disposed the `TracksStore` on the previous side-effect\n        }\n        const newPeriodItem = getPeriodItem(this._storedPeriodInfo, periodObj.period.id);\n        if (newPeriodItem !== undefined &&\n            newPeriodItem[bufferType].storedSettings === null) {\n            (_b = newPeriodItem[bufferType].dispatcher) === null || _b === void 0 ? void 0 : _b.updateTrack(null);\n        }\n    }\n    /**\n     * Returns an object describing the chosen audio track for the given audio\n     * Period.\n     *\n     * Returns `null` is the the current audio track is disabled or not\n     * set yet.a pas bcp de marge de manoeuvre j'ai l'impression\n     *\n     * Returns `undefined` if the given Period's id is not currently found in the\n     * `TracksStore`. The cause being most probably that the corresponding\n     * Period is not available anymore.\n     * If you're in that case and if still have the corresponding JavaScript\n     * reference to the wanted Period, you can call `getOldAudioTrack` with it. It\n     * will try retrieving the choice it made from its cache.\n     * @param {Object} periodObj - The concerned Period's object\n     * @returns {Object|null|undefined} - The audio track chosen for this Period.\n     * `null` if audio tracks were disabled and `undefined` if the Period is not\n     * known.\n     */\n    getChosenAudioTrack(periodObj, filterPlayableRepresentations) {\n        return isNullOrUndefined(periodObj.audio.storedSettings)\n            ? null\n            : toAudioTrack(periodObj.audio.storedSettings.adaptation, filterPlayableRepresentations);\n    }\n    /**\n     * Returns an object describing the chosen text track for the given text\n     * Period.\n     *\n     * Returns null is the the current text track is disabled or not\n     * set yet.\n     *\n     * @param {Object} periodObj - The concerned Period's object\n     * @returns {Object|null} - The text track chosen for this Period\n     */\n    getChosenTextTrack(periodObj) {\n        return isNullOrUndefined(periodObj.text.storedSettings)\n            ? null\n            : toTextTrack(periodObj.text.storedSettings.adaptation);\n    }\n    /**\n     * Returns an object describing the chosen video track for the given video\n     * Period.\n     *\n     * Returns null is the the current video track is disabled or not\n     * set yet.\n     *\n     * @param {Object} periodObj - The concerned Period's object\n     * @returns {Object|null} - The video track chosen for this Period\n     */\n    getChosenVideoTrack(periodObj, filterPlayableRepresentations) {\n        if (isNullOrUndefined(periodObj.video.storedSettings)) {\n            return null;\n        }\n        return toVideoTrack(periodObj.video.storedSettings.adaptation, filterPlayableRepresentations);\n    }\n    /**\n     * Returns all available audio tracks for a given Period, as an array of\n     * objects.\n     *\n     * Returns `undefined` if the given Period's id is not known.\n     *\n     * @param {Object} periodObj - The concerned Period's object\n     * @param {boolean} filterPlayableRepresentations - If `true`, only\n     * representations considered to be \"playable\" will be included in the\n     * returned response.\n     * If `false`, the response should contain all linked representations.\n     * @returns {Array.<Object>}\n     */\n    getAvailableAudioTracks(periodObj, filterPlayableRepresentations) {\n        const storedSettings = periodObj.audio.storedSettings;\n        const currentId = !isNullOrUndefined(storedSettings)\n            ? storedSettings.adaptation.id\n            : null;\n        const adaptations = getSupportedAdaptations(periodObj.period, \"audio\");\n        return adaptations.map((adaptation) => {\n            const active = currentId === null ? false : currentId === adaptation.id;\n            return objectAssign(toAudioTrack(adaptation, filterPlayableRepresentations), {\n                active,\n            });\n        });\n    }\n    /**\n     * Returns all available text tracks for a given Period, as an array of\n     * objects.\n     *\n     * Returns `undefined` if the given Period's id is not known.\n     *\n     * @param {Object} periodObj - The concerned Period's object\n     * @returns {Array.<Object>}\n     */\n    getAvailableTextTracks(periodObj) {\n        const storedSettings = periodObj.text.storedSettings;\n        const currentId = !isNullOrUndefined(storedSettings)\n            ? storedSettings.adaptation.id\n            : null;\n        const adaptations = getSupportedAdaptations(periodObj.period, \"text\");\n        return adaptations.map((adaptation) => {\n            const active = currentId === null ? false : currentId === adaptation.id;\n            return objectAssign(toTextTrack(adaptation), { active });\n        });\n    }\n    /**\n     * Returns all available video tracks for a given Period, as an array of\n     * objects.\n     *\n     * Returns `undefined` if the given Period's id is not known.\n     *\n     * @param {Object} periodObj - The concerned Period's object\n     * @param {boolean} filterPlayableRepresentations - If `true`, only\n     * representations considered to be \"playable\" will be included in the\n     * returned response.\n     * If `false`, the response should contain all linked representations.\n     * @returns {Array.<Object>}\n     */\n    getAvailableVideoTracks(periodObj, filterPlayableRepresentations) {\n        const storedSettings = periodObj.video.storedSettings;\n        const currentId = isNullOrUndefined(storedSettings)\n            ? undefined\n            : storedSettings.adaptation.id;\n        const adaptations = getSupportedAdaptations(periodObj.period, \"video\");\n        return adaptations.map((adaptation) => {\n            const active = currentId === null ? false : currentId === adaptation.id;\n            const track = toVideoTrack(adaptation, filterPlayableRepresentations);\n            const trickModeTracks = track.trickModeTracks !== undefined\n                ? track.trickModeTracks.map((trickModeAdaptation) => {\n                    const isActive = currentId === null ? false : currentId === trickModeAdaptation.id;\n                    return objectAssign(trickModeAdaptation, { active: isActive });\n                })\n                : [];\n            const availableTrack = objectAssign(track, { active });\n            if (trickModeTracks !== undefined) {\n                availableTrack.trickModeTracks = trickModeTracks;\n            }\n            return availableTrack;\n        });\n    }\n    getLockedAudioRepresentations(periodObj) {\n        const { storedSettings } = periodObj.audio;\n        if (isNullOrUndefined(storedSettings)) {\n            return null;\n        }\n        const lastLockedSettings = storedSettings.lockedRepresentations.getValue();\n        return lastLockedSettings === null ? null : lastLockedSettings.representationIds;\n    }\n    getLockedVideoRepresentations(periodObj) {\n        const { storedSettings } = periodObj.video;\n        if (isNullOrUndefined(storedSettings)) {\n            return null;\n        }\n        const lastLockedSettings = storedSettings.lockedRepresentations.getValue();\n        return lastLockedSettings === null ? null : lastLockedSettings.representationIds;\n    }\n    lockAudioRepresentations(periodObj, lockSettings) {\n        var _a;\n        const { storedSettings } = periodObj.audio;\n        if (isNullOrUndefined(storedSettings)) {\n            return;\n        }\n        const { DEFAULT_AUDIO_REPRESENTATIONS_SWITCHING_MODE } = config.getCurrent();\n        const filtered = this._getRepresentationsToLock(storedSettings.adaptation, lockSettings.representations);\n        const switchingMode = (_a = lockSettings.switchingMode) !== null && _a !== void 0 ? _a : DEFAULT_AUDIO_REPRESENTATIONS_SWITCHING_MODE;\n        storedSettings.lockedRepresentations.setValue({\n            representationIds: filtered,\n            switchingMode,\n        });\n    }\n    lockVideoRepresentations(periodObj, lockSettings) {\n        var _a;\n        const { storedSettings } = periodObj.video;\n        if (isNullOrUndefined(storedSettings)) {\n            return;\n        }\n        const { DEFAULT_VIDEO_REPRESENTATIONS_SWITCHING_MODE } = config.getCurrent();\n        const filtered = this._getRepresentationsToLock(storedSettings.adaptation, lockSettings.representations);\n        const switchingMode = (_a = lockSettings.switchingMode) !== null && _a !== void 0 ? _a : DEFAULT_VIDEO_REPRESENTATIONS_SWITCHING_MODE;\n        storedSettings.lockedRepresentations.setValue({\n            representationIds: filtered,\n            switchingMode,\n        });\n    }\n    unlockAudioRepresentations(periodObj) {\n        const { storedSettings } = periodObj.audio;\n        if (isNullOrUndefined(storedSettings) ||\n            storedSettings.lockedRepresentations.getValue() === null) {\n            return;\n        }\n        storedSettings.lockedRepresentations.setValue(null);\n    }\n    unlockVideoRepresentations(periodObj) {\n        const { storedSettings } = periodObj.video;\n        if (isNullOrUndefined(storedSettings) ||\n            storedSettings.lockedRepresentations.getValue() === null) {\n            return;\n        }\n        storedSettings.lockedRepresentations.setValue(null);\n    }\n    dispose() {\n        this._isDisposed = true;\n        while (true) {\n            const lastPeriod = this._storedPeriodInfo.pop();\n            if (lastPeriod === undefined) {\n                return;\n            }\n            lastPeriod.isRemoved = true;\n        }\n    }\n    _resetVideoTrackChoices(reason) {\n        var _a;\n        for (let i = 0; i < this._storedPeriodInfo.length; i++) {\n            const periodObj = this._storedPeriodInfo[i];\n            if (!isNullOrUndefined(periodObj.video.storedSettings)) {\n                const chosenBaseTrack = periodObj.video.storedSettings.adaptationBase;\n                if (chosenBaseTrack !== null) {\n                    const chosenTrack = getRightVideoTrack(chosenBaseTrack, this._isTrickModeTrackEnabled);\n                    periodObj.video.storedSettings.adaptationBase = chosenBaseTrack;\n                    periodObj.video.storedSettings.adaptation = chosenTrack;\n                }\n            }\n        }\n        // Clone the current Period list to not be influenced if Periods are removed\n        // or added while the loop is running.\n        const sliced = this._storedPeriodInfo.slice();\n        for (let i = 0; i < sliced.length; i++) {\n            const period = sliced[i].period;\n            const videoItem = sliced[i].video;\n            const storedSettings = videoItem.storedSettings;\n            if (storedSettings !== undefined) {\n                this.trigger(\"trackUpdate\", {\n                    period: toExposedPeriod(period),\n                    trackType: \"video\",\n                    reason,\n                });\n                // The previous event trigger could have had side-effects, so we\n                // re-check if we're still mostly in the same state\n                if (this._isDisposed) {\n                    return; // Someone disposed the `TracksStore` on the previous side-effect\n                }\n                const newPeriodItem = getPeriodItem(this._storedPeriodInfo, period.id);\n                if (newPeriodItem !== undefined &&\n                    newPeriodItem.isPeriodAdvertised &&\n                    newPeriodItem.video.storedSettings === storedSettings) {\n                    (_a = newPeriodItem.video.dispatcher) === null || _a === void 0 ? void 0 : _a.updateTrack(storedSettings);\n                }\n            }\n        }\n    }\n    _removePeriodObject(index) {\n        if (0 /* __ENVIRONMENT__.CURRENT_ENV */ === 1 /* __ENVIRONMENT__.DEV */) {\n            assert(index < this._storedPeriodInfo.length, \"Invalid index for Period removal\");\n        }\n        const oldPeriodItem = this._storedPeriodInfo[index];\n        this._storedPeriodInfo[index].isRemoved = true;\n        this._storedPeriodInfo.splice(index, 1);\n        this._cachedPeriodInfo.set(oldPeriodItem.period, oldPeriodItem);\n    }\n    _getRepresentationsToLock(adaptation, representationIds) {\n        const filtered = representationIds.reduce((acc, repId) => {\n            const foundRep = arrayFind(adaptation.representations, (r) => {\n                return r.id === repId;\n            });\n            if (foundRep === undefined) {\n                log.warn(\"API: Wanted locked Representation not found.\");\n            }\n            else {\n                acc.push(foundRep.id);\n            }\n            return acc;\n        }, []);\n        if (filtered.length === 0) {\n            throw new Error(\"Cannot lock Representations: \" + \"None of the given Representation id are found\");\n        }\n        return filtered;\n    }\n    /**\n     * Check or re-check all Periods for which both an initial track can be chosen\n     * and for which the `newAvailablePeriods` event can be triggered.\n     */\n    _selectInitialTrackIfNeeded() {\n        var _a, _b, _c, _d;\n        const { DEFAULT_VIDEO_TRACK_SWITCHING_MODE } = config.getCurrent();\n        const periodsToAdvertise = [];\n        const toDispatchTrack = [];\n        for (const trackStorePeriod of this._storedPeriodInfo) {\n            const { period } = trackStorePeriod;\n            if (trackStorePeriod.audio.storedSettings !== undefined &&\n                trackStorePeriod.video.storedSettings !== undefined &&\n                trackStorePeriod.text.storedSettings !== undefined) {\n                // already processed, continue\n                continue;\n            }\n            const adaptations = [\n                ...((_a = period.adaptations.audio) !== null && _a !== void 0 ? _a : []),\n                ...((_b = period.adaptations.video) !== null && _b !== void 0 ? _b : []),\n            ];\n            const hasCodecWithUndefinedSupport = adaptations.every((a) => a.supportStatus.hasCodecWithUndefinedSupport);\n            if (adaptations.length > 0 && hasCodecWithUndefinedSupport) {\n                // Not all codecs for that Period are known yet.\n                // Await until this is the case.\n                continue;\n            }\n            const audioAdaptation = getSupportedAdaptations(period, \"audio\")[0];\n            trackStorePeriod.audio.storedSettings =\n                audioAdaptation === undefined\n                    ? null\n                    : {\n                        adaptation: audioAdaptation,\n                        switchingMode: this._defaultAudioTrackSwitchingMode,\n                        lockedRepresentations: new SharedReference(null),\n                    };\n            const baseVideoAdaptation = getSupportedAdaptations(period, \"video\")[0];\n            const videoAdaptation = getRightVideoTrack(baseVideoAdaptation, this._isTrickModeTrackEnabled);\n            trackStorePeriod.video.storedSettings =\n                videoAdaptation === undefined\n                    ? null\n                    : {\n                        adaptation: videoAdaptation,\n                        adaptationBase: baseVideoAdaptation,\n                        switchingMode: DEFAULT_VIDEO_TRACK_SWITCHING_MODE,\n                        lockedRepresentations: new SharedReference(null),\n                    };\n            let textAdaptation = null;\n            const forcedSubtitles = ((_c = period.adaptations.text) !== null && _c !== void 0 ? _c : []).filter((ad) => ad.isForcedSubtitles === true);\n            if (forcedSubtitles.length > 0) {\n                if (audioAdaptation !== null && audioAdaptation !== undefined) {\n                    const sameLanguage = arrayFind(forcedSubtitles, (f) => f.normalizedLanguage === audioAdaptation.normalizedLanguage);\n                    if (sameLanguage !== undefined) {\n                        textAdaptation = sameLanguage;\n                    }\n                }\n                if (textAdaptation === null) {\n                    textAdaptation =\n                        (_d = arrayFind(forcedSubtitles, (f) => f.normalizedLanguage === undefined)) !== null && _d !== void 0 ? _d : null;\n                }\n            }\n            trackStorePeriod.text.storedSettings =\n                textAdaptation === null\n                    ? null\n                    : {\n                        adaptation: textAdaptation,\n                        switchingMode: \"direct\",\n                        lockedRepresentations: new SharedReference(null),\n                    };\n            toDispatchTrack.push(trackStorePeriod);\n            if (this._shouldAdvertisePeriod(trackStorePeriod)) {\n                trackStorePeriod.isPeriodAdvertised = true;\n                periodsToAdvertise.push({ id: period.id, start: period.start, end: period.end });\n            }\n        }\n        if (periodsToAdvertise.length > 0) {\n            this.trigger(\"newAvailablePeriods\", periodsToAdvertise);\n            if (this._isDisposed) {\n                return;\n            }\n        }\n        for (const trackStorePeriod of toDispatchTrack) {\n            if (!trackStorePeriod.isPeriodAdvertised) {\n                continue;\n            }\n            const bufferTypes = [\"audio\", \"video\", \"text\"];\n            for (const bufferType of bufferTypes) {\n                const trackInfo = trackStorePeriod[bufferType];\n                if (trackInfo.dispatcher !== null &&\n                    trackInfo.storedSettings !== undefined &&\n                    !trackInfo.dispatcher.hasSetTrack()) {\n                    trackInfo.dispatcher.updateTrack(trackInfo.storedSettings);\n                    if (this._isDisposed) {\n                        return;\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Returns `true` once a Period can be advertised through a `newAvailablePeriods`\n     * event, after which track can begin to be set and updated.\n     * @param {Object} periodObj\n     * @returns {boolean}\n     */\n    _shouldAdvertisePeriod(periodObj) {\n        return (!periodObj.isPeriodAdvertised &&\n            periodObj.text.dispatcher !== null &&\n            periodObj.video.dispatcher !== null &&\n            periodObj.audio.dispatcher !== null);\n    }\n}\n/**\n * Returns element in the given `periods` Array that corresponds to the\n * `period` given.\n * Returns `undefined` if that `period` is not found.\n * @param {Object} periods\n * @param {string} periodId\n * @returns {Object|undefined}\n */\nfunction getPeriodItem(periods, periodId) {\n    for (let i = 0; i < periods.length; i++) {\n        const periodI = periods[i];\n        if (periodI.period.id === periodId) {\n            return periodI;\n        }\n    }\n}\n/**\n * A `ITSPeriodObject` should only be removed once all References linked to it\n * do not exist anymore, to keep the possibility of making track choices.\n * @param {Object} periodObj\n * @returns {boolean}\n */\nfunction isPeriodItemRemovable(periodObj) {\n    var _a, _b, _c;\n    return (!periodObj.inManifest &&\n        ((_a = periodObj.text) === null || _a === void 0 ? void 0 : _a.dispatcher) === null &&\n        ((_b = periodObj.audio) === null || _b === void 0 ? void 0 : _b.dispatcher) === null &&\n        ((_c = periodObj.video) === null || _c === void 0 ? void 0 : _c.dispatcher) === null);\n}\nfunction getRightVideoTrack(adaptation, isTrickModeEnabled) {\n    var _a;\n    if (isTrickModeEnabled && ((_a = adaptation.trickModeTracks) === null || _a === void 0 ? void 0 : _a[0]) !== undefined) {\n        return adaptation.trickModeTracks[0];\n    }\n    return adaptation;\n}\n/**\n * Generate an `ITSPeriodObject` object for the given Period, selecting the\n * default track for each type.\n * @param {Object} period\n * @param {boolean} inManifest\n * @returns {object}\n */\nfunction generatePeriodInfo(period, inManifest) {\n    return {\n        period,\n        inManifest,\n        isPeriodAdvertised: false,\n        isRemoved: false,\n        audio: { storedSettings: undefined, dispatcher: null },\n        video: { storedSettings: undefined, dispatcher: null },\n        text: { storedSettings: undefined, dispatcher: null },\n    };\n}\nfunction toExposedPeriod(p) {\n    return { start: p.start, end: p.end, id: p.id };\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../log\";\nimport arrayFind from \"../../utils/array_find\";\nimport isNullOrUndefined from \"../../utils/is_null_or_undefined\";\nimport normalizeLanguage from \"../../utils/languages\";\nimport Representation from \"./representation\";\n/**\n * Normalized Adaptation structure.\n * An `Adaptation` describes a single `Track`. For example a specific audio\n * track (in a given language) or a specific video track.\n * It istelf can be represented in different qualities, which we call here\n * `Representation`.\n * @class Adaptation\n */\nexport default class Adaptation {\n    /**\n     * @constructor\n     * @param {Object} parsedAdaptation\n     * @param {Object|undefined} [options]\n     */\n    constructor(parsedAdaptation, cachedCodecSupport, options = {}) {\n        const { trickModeTracks } = parsedAdaptation;\n        const { representationFilter, isManuallyAdded } = options;\n        this.id = parsedAdaptation.id;\n        this.type = parsedAdaptation.type;\n        if (parsedAdaptation.isTrickModeTrack !== undefined) {\n            this.isTrickModeTrack = parsedAdaptation.isTrickModeTrack;\n        }\n        if (parsedAdaptation.language !== undefined) {\n            this.language = parsedAdaptation.language;\n            this.normalizedLanguage = normalizeLanguage(parsedAdaptation.language);\n        }\n        if (parsedAdaptation.closedCaption !== undefined) {\n            this.isClosedCaption = parsedAdaptation.closedCaption;\n        }\n        if (parsedAdaptation.audioDescription !== undefined) {\n            this.isAudioDescription = parsedAdaptation.audioDescription;\n        }\n        if (parsedAdaptation.isDub !== undefined) {\n            this.isDub = parsedAdaptation.isDub;\n        }\n        if (parsedAdaptation.forcedSubtitles !== undefined) {\n            this.isForcedSubtitles = parsedAdaptation.forcedSubtitles;\n        }\n        if (parsedAdaptation.isSignInterpreted !== undefined) {\n            this.isSignInterpreted = parsedAdaptation.isSignInterpreted;\n        }\n        if (parsedAdaptation.label !== undefined) {\n            this.label = parsedAdaptation.label;\n        }\n        if (trickModeTracks !== undefined && trickModeTracks.length > 0) {\n            this.trickModeTracks = trickModeTracks.map((track) => new Adaptation(track, cachedCodecSupport));\n        }\n        const argsRepresentations = parsedAdaptation.representations;\n        const representations = [];\n        this.supportStatus = {\n            hasSupportedCodec: false,\n            hasCodecWithUndefinedSupport: false,\n            isDecipherable: false,\n        };\n        for (let i = 0; i < argsRepresentations.length; i++) {\n            const representation = new Representation(argsRepresentations[i], this.type, cachedCodecSupport);\n            let shouldAdd = true;\n            if (!isNullOrUndefined(representationFilter)) {\n                const reprObject = {\n                    id: representation.id,\n                    bitrate: representation.bitrate,\n                    codecs: representation.codecs,\n                    height: representation.height,\n                    width: representation.width,\n                    frameRate: representation.frameRate,\n                    hdrInfo: representation.hdrInfo,\n                };\n                if (representation.contentProtections !== undefined) {\n                    reprObject.contentProtections = {};\n                    if (representation.contentProtections.keyIds !== undefined) {\n                        const keyIds = representation.contentProtections.keyIds;\n                        reprObject.contentProtections.keyIds = keyIds;\n                    }\n                }\n                shouldAdd = representationFilter(reprObject, {\n                    trackType: this.type,\n                    language: this.language,\n                    normalizedLanguage: this.normalizedLanguage,\n                    isClosedCaption: this.isClosedCaption,\n                    isDub: this.isDub,\n                    isAudioDescription: this.isAudioDescription,\n                    isSignInterpreted: this.isSignInterpreted,\n                });\n            }\n            if (shouldAdd) {\n                representations.push(representation);\n                if (representation.isSupported === undefined) {\n                    this.supportStatus.hasCodecWithUndefinedSupport = true;\n                    if (this.supportStatus.hasSupportedCodec === false) {\n                        this.supportStatus.hasSupportedCodec = undefined;\n                    }\n                }\n                else if (representation.isSupported) {\n                    this.supportStatus.hasSupportedCodec = true;\n                }\n                if (representation.decipherable === undefined) {\n                    if (this.supportStatus.isDecipherable === false) {\n                        this.supportStatus.isDecipherable = undefined;\n                    }\n                }\n                else if (representation.decipherable) {\n                    this.supportStatus.isDecipherable = true;\n                }\n            }\n            else {\n                log.debug(\"Filtering Representation due to representationFilter\", this.type, `Adaptation: ${this.id}`, `Representation: ${representation.id}`, `(${representation.bitrate})`);\n            }\n        }\n        representations.sort((a, b) => a.bitrate - b.bitrate);\n        this.representations = representations;\n        // for manuallyAdded adaptations (not in the manifest)\n        this.manuallyAdded = isManuallyAdded === true;\n    }\n    /**\n     * Some environments (e.g. in a WebWorker) may not have the capability to know\n     * if a mimetype+codec combination is supported on the current platform.\n     *\n     * Calling `refreshCodecSupport` manually once the codecs supported are known\n     * by the current environnement allows to work-around this issue.\n     *\n     *\n     * If the right mimetype+codec combination is found in the provided object,\n     * this `Adaptation`'s `isSupported` property will be updated accordingly as\n     * well as all of its inner `Representation`'s `isSupported` attributes.\n     *\n     * @param {Array.<Object>} cachedCodecSupport\n     */\n    refreshCodecSupport(cachedCodecSupport) {\n        let hasCodecWithUndefinedSupport = false;\n        let hasSupportedRepresentation = false;\n        for (const representation of this.representations) {\n            representation.refreshCodecSupport(cachedCodecSupport);\n            if (representation.isSupported === undefined) {\n                hasCodecWithUndefinedSupport = true;\n            }\n            else if (representation.isSupported) {\n                hasSupportedRepresentation = true;\n            }\n        }\n        if (hasSupportedRepresentation) {\n            /* The adaptation is supported because at least one representation is supported */\n            this.supportStatus.hasSupportedCodec = true;\n        }\n        else if (hasCodecWithUndefinedSupport) {\n            /* The adaptation support is unknown because there is no representation explicitly\n            supported but there is codec with unknown support */\n            this.supportStatus.hasSupportedCodec = undefined;\n        }\n        else {\n            /* All codecs support are known and no codecs are supported, adaptation\n            is not supported */\n            this.supportStatus.hasSupportedCodec = false;\n        }\n        this.supportStatus.hasCodecWithUndefinedSupport = hasCodecWithUndefinedSupport;\n    }\n    /**\n     * Returns the Representation linked to the given ID.\n     * @param {number|string} wantedId\n     * @returns {Object|undefined}\n     */\n    getRepresentation(wantedId) {\n        return arrayFind(this.representations, ({ id }) => wantedId === id);\n    }\n    /**\n     * Format the current `Adaptation`'s properties into a\n     * `IAdaptationMetadata` format which can better be communicated through\n     * another thread.\n     *\n     * Please bear in mind however that the returned object will not be updated\n     * when the current `Adaptation` instance is updated, it is only a\n     * snapshot at the current time.\n     *\n     * If you want to keep that data up-to-date with the current `Adaptation`\n     * instance, you will have to do it yourself.\n     *\n     * @returns {Object}\n     */\n    getMetadataSnapshot() {\n        const representations = [];\n        const baseRepresentations = this.representations;\n        for (const representation of baseRepresentations) {\n            representations.push(representation.getMetadataSnapshot());\n        }\n        return {\n            id: this.id,\n            type: this.type,\n            supportStatus: this.supportStatus,\n            language: this.language,\n            isForcedSubtitles: this.isForcedSubtitles,\n            isClosedCaption: this.isClosedCaption,\n            isAudioDescription: this.isAudioDescription,\n            isSignInterpreted: this.isSignInterpreted,\n            normalizedLanguage: this.normalizedLanguage,\n            representations,\n            label: this.label,\n            isDub: this.isDub,\n        };\n    }\n}\n","/**\n * Class setting up a cache of which codec is currently known to be supported or\n * not.\n *\n * We keep this only at the Manifest level because external conditions can change\n * from Manifest to Manifest (e.g. not the same decryption cabalities used etc.).\n */\nexport default class CodecSupportCache {\n    /**\n     * Constructs an CodecSupportCache instance.\n     * @param {Array} codecList - List of codec support information.\n     */\n    constructor(codecList) {\n        this.supportMap = new Map();\n        this.addCodecs(codecList);\n    }\n    /**\n     * Adds codec support information to this `CodecSupportCache`.\n     * @param {Array} codecList - List of codec support information.\n     */\n    addCodecs(codecList) {\n        for (const codec of codecList) {\n            let mimeTypeMap = this.supportMap.get(codec.mimeType);\n            if (mimeTypeMap === undefined) {\n                mimeTypeMap = new Map();\n                this.supportMap.set(codec.mimeType, mimeTypeMap);\n            }\n            mimeTypeMap.set(codec.codec, {\n                supported: codec.supported,\n                supportedIfEncrypted: codec.supportedIfEncrypted,\n            });\n        }\n    }\n    /**\n     * Checks if a codec is supported for a given MIME type.\n     * @param {string} mimeType - The MIME type to check.\n     * @param {string} codec - The codec to check.\n     * @param {boolean} isEncrypted - Whether the content is encrypted.\n     * @returns {boolean | undefined} - `true` if the codec is supported, `false`\n     * if not, or `undefined` if no support information is found.\n     */\n    isSupported(mimeType, codec, isEncrypted) {\n        const mimeTypeMap = this.supportMap.get(mimeType);\n        if (mimeTypeMap === undefined) {\n            return undefined;\n        }\n        const result = mimeTypeMap.get(codec);\n        if (result === undefined) {\n            return undefined;\n        }\n        if (isEncrypted) {\n            return result.supportedIfEncrypted;\n        }\n        else {\n            return result.supported;\n        }\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport Adaptation from \"./adaptation\";\nimport Manifest from \"./manifest\";\nimport Period from \"./period\";\nimport Representation from \"./representation\";\nimport { StaticRepresentationIndex } from \"./representation_index\";\nimport { areSameContent, getLoggableSegmentId } from \"./utils\";\nexport default Manifest;\nexport * from \"./types\";\nexport { areSameContent, getLoggableSegmentId, Period, Adaptation, Representation, StaticRepresentationIndex, };\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { MediaError } from \"../../errors\";\nimport log from \"../../log\";\nimport { getCodecsWithUnknownSupport } from \"../../main_thread/init/utils/update_manifest_codec_support\";\nimport arrayFind from \"../../utils/array_find\";\nimport EventEmitter from \"../../utils/event_emitter\";\nimport idGenerator from \"../../utils/id_generator\";\nimport warnOnce from \"../../utils/warn_once\";\nimport { getLivePosition, getMaximumSafePosition, getMinimumSafePosition, getPeriodForTime, getPeriodAfter, toTaggedTrack, } from \"../utils\";\nimport CodecSupportCache from \"./codec_support_cache\";\nimport Period from \"./period\";\nimport { MANIFEST_UPDATE_TYPE } from \"./types\";\nimport { replacePeriods, updatePeriods } from \"./update_periods\";\nconst generateNewManifestId = idGenerator();\n/**\n * Normalized Manifest structure.\n *\n * Details the current content being played:\n *   - the duration of the content\n *   - the available tracks\n *   - the available qualities\n *   - the segments defined in those qualities\n *   - ...\n * while staying agnostic of the transport protocol used (Smooth, DASH etc.).\n *\n * The Manifest and its contained information can evolve over time (like when\n * updating a dynamic manifest or when right management forbid some tracks from\n * being played).\n * To perform actions on those changes, any module using this Manifest can\n * listen to its sent events and react accordingly.\n *\n * @class Manifest\n */\nexport default class Manifest extends EventEmitter {\n    /**\n     * Construct a Manifest instance from a parsed Manifest object (as returned by\n     * Manifest parsers) and options.\n     *\n     * Some minor errors can arise during that construction. `warnings`\n     * will contain all such errors, in the order they have been encountered.\n     * @param {Object} parsedManifest\n     * @param {Object} options\n     * @param {Array.<Object>} warnings - After construction, will be optionally\n     * filled by errors expressing minor issues seen while parsing the Manifest.\n     */\n    constructor(parsedManifest, options, warnings) {\n        var _a;\n        super();\n        const { representationFilter, manifestUpdateUrl } = options;\n        this.manifestFormat = 0 /* ManifestMetadataFormat.Class */;\n        this.id = generateNewManifestId();\n        this.expired = (_a = parsedManifest.expired) !== null && _a !== void 0 ? _a : null;\n        this.transport = parsedManifest.transportType;\n        this.clockOffset = parsedManifest.clockOffset;\n        this._cachedCodecSupport = new CodecSupportCache([]);\n        const unsupportedAdaptations = [];\n        this.periods = parsedManifest.periods\n            .map((parsedPeriod) => {\n            const period = new Period(parsedPeriod, unsupportedAdaptations, this._cachedCodecSupport, representationFilter);\n            return period;\n        })\n            .sort((a, b) => a.start - b.start);\n        if (unsupportedAdaptations.length > 0) {\n            const error = new MediaError(\"MANIFEST_INCOMPATIBLE_CODECS_ERROR\", \"An Adaptation contains only incompatible codecs.\", { tracks: unsupportedAdaptations.map(toTaggedTrack) });\n            warnings.push(error);\n        }\n        /**\n         * @deprecated It is here to ensure compatibility with the way the\n         * v3.x.x manages adaptations at the Manifest level\n         */\n        this.adaptations = this.periods[0] === undefined ? {} : this.periods[0].adaptations;\n        this.timeBounds = parsedManifest.timeBounds;\n        this.isDynamic = parsedManifest.isDynamic;\n        this.isLive = parsedManifest.isLive;\n        this.isLastPeriodKnown = parsedManifest.isLastPeriodKnown;\n        this.uris = parsedManifest.uris === undefined ? [] : parsedManifest.uris;\n        this.updateUrl = manifestUpdateUrl;\n        this.lifetime = parsedManifest.lifetime;\n        this.clockOffset = parsedManifest.clockOffset;\n        this.suggestedPresentationDelay = parsedManifest.suggestedPresentationDelay;\n        this.availabilityStartTime = parsedManifest.availabilityStartTime;\n        this.publishTime = parsedManifest.publishTime;\n    }\n    /**\n     * Some environments (e.g. in a WebWorker) may not have the capability to know\n     * if a mimetype+codec combination is supported on the current platform.\n     *\n     * Calling `updateCodecSupport` manually once the codecs supported are known\n     * by the current environnement allows to work-around this issue.\n     *\n     * @param {Array<Object>} [updatedCodecSupportInfo]\n     * @returns {Error|null} - Refreshing codec support might reveal that some\n     * `Adaptation` don't have any of their `Representation`s supported.\n     * In that case, an error object will be created and returned, so you can\n     * e.g. later emit it as a warning through the RxPlayer API.\n     */\n    updateCodecSupport(updatedCodecSupportInfo = []) {\n        if (updatedCodecSupportInfo.length === 0) {\n            return null;\n        }\n        this._cachedCodecSupport.addCodecs(updatedCodecSupportInfo);\n        const unsupportedAdaptations = [];\n        for (const period of this.periods) {\n            period.refreshCodecSupport(unsupportedAdaptations, this._cachedCodecSupport);\n        }\n        this.trigger(\"supportUpdate\", null);\n        if (unsupportedAdaptations.length > 0) {\n            return new MediaError(\"MANIFEST_INCOMPATIBLE_CODECS_ERROR\", \"An Adaptation contains only incompatible codecs.\", { tracks: unsupportedAdaptations.map(toTaggedTrack) });\n        }\n        return null;\n    }\n    /**\n     * Returns the Period corresponding to the given `id`.\n     * Returns `undefined` if there is none.\n     * @param {string} id\n     * @returns {Object|undefined}\n     */\n    getPeriod(id) {\n        return arrayFind(this.periods, (period) => {\n            return id === period.id;\n        });\n    }\n    /**\n     * Returns the Period encountered at the given time.\n     * Returns `undefined` if there is no Period exactly at the given time.\n     * @param {number} time\n     * @returns {Object|undefined}\n     */\n    getPeriodForTime(time) {\n        return getPeriodForTime(this, time);\n    }\n    /**\n     * Returns the first Period starting strictly after the given time.\n     * Returns `undefined` if there is no Period starting after that time.\n     * @param {number} time\n     * @returns {Object|undefined}\n     */\n    getNextPeriod(time) {\n        return arrayFind(this.periods, (period) => {\n            return period.start > time;\n        });\n    }\n    /**\n     * Returns the Period coming chronologically just after another given Period.\n     * Returns `undefined` if not found.\n     * @param {Object} period\n     * @returns {Object|null}\n     */\n    getPeriodAfter(period) {\n        return getPeriodAfter(this, period);\n    }\n    /**\n     * Returns the most important URL from which the Manifest can be refreshed.\n     * `undefined` if no URL is found.\n     * @returns {Array.<string>}\n     */\n    getUrls() {\n        return this.uris;\n    }\n    /**\n     * Update the current Manifest properties by giving a new updated version.\n     * This instance will be updated with the new information coming from it.\n     * @param {Object} newManifest\n     */\n    replace(newManifest) {\n        this._performUpdate(newManifest, MANIFEST_UPDATE_TYPE.Full);\n    }\n    /**\n     * Update the current Manifest properties by giving a new but shorter version\n     * of it.\n     * This instance will add the new information coming from it and will\n     * automatically clean old Periods that shouldn't be available anymore.\n     *\n     * /!\\ Throws if the given Manifest cannot be used or is not sufficient to\n     * update the Manifest.\n     * @param {Object} newManifest\n     */\n    update(newManifest) {\n        this._performUpdate(newManifest, MANIFEST_UPDATE_TYPE.Partial);\n    }\n    /**\n     * Returns the theoretical minimum playable position on the content\n     * regardless of the current Adaptation chosen, as estimated at parsing\n     * time.\n     * @returns {number}\n     */\n    getMinimumSafePosition() {\n        return getMinimumSafePosition(this);\n    }\n    /**\n     * Get the position of the live edge - that is, the position of what is\n     * currently being broadcasted, in seconds.\n     * @returns {number|undefined}\n     */\n    getLivePosition() {\n        return getLivePosition(this);\n    }\n    /**\n     * Returns the theoretical maximum playable position on the content\n     * regardless of the current Adaptation chosen, as estimated at parsing\n     * time.\n     */\n    getMaximumSafePosition() {\n        return getMaximumSafePosition(this);\n    }\n    updateCodecSupportList(cachedCodecSupport) {\n        this._cachedCodecSupport = cachedCodecSupport;\n    }\n    /**\n     * Look in the Manifest for Representations linked to the given key ID,\n     * and mark them as being impossible to decrypt.\n     * Then trigger a \"decipherabilityUpdate\" event to notify everyone of the\n     * changes performed.\n     * @param {Function} isDecipherableCb\n     */\n    updateRepresentationsDeciperability(isDecipherableCb) {\n        const updates = updateDeciperability(this, isDecipherableCb);\n        if (updates.length > 0) {\n            this.trigger(\"decipherabilityUpdate\", updates);\n        }\n    }\n    /**\n     * Indicate that some `Representation` needs to be avoided due to playback\n     * issues.\n     * @param {Array.<Object>} items\n     */\n    addRepresentationsToAvoid(items) {\n        const updates = [];\n        for (const item of items) {\n            const period = this.getPeriod(item.period.id);\n            if (period === undefined) {\n                continue;\n            }\n            const adaptation = period.getAdaptation(item.adaptation.id);\n            if (adaptation === undefined) {\n                continue;\n            }\n            const representation = adaptation.getRepresentation(item.representation.id);\n            if (representation === undefined) {\n                continue;\n            }\n            representation.shouldBeAvoided = true;\n            updates.push({\n                manifest: this,\n                period,\n                adaptation,\n                representation,\n            });\n        }\n        if (updates.length > 0) {\n            this.trigger(\"representationAvoidanceUpdate\", updates);\n        }\n    }\n    /**\n     * @deprecated only returns adaptations for the first period\n     * @returns {Array.<Object>}\n     */\n    getAdaptations() {\n        warnOnce(\"manifest.getAdaptations() is deprecated.\" +\n            \" Please use manifest.period[].getAdaptations() instead\");\n        const firstPeriod = this.periods[0];\n        if (firstPeriod === undefined) {\n            return [];\n        }\n        const adaptationsByType = firstPeriod.adaptations;\n        const adaptationsList = [];\n        for (const adaptationType in adaptationsByType) {\n            if (Object.prototype.hasOwnProperty.call(adaptationsByType, adaptationType)) {\n                const adaptations = adaptationsByType[adaptationType];\n                adaptationsList.push(...adaptations);\n            }\n        }\n        return adaptationsList;\n    }\n    /**\n     * @deprecated only returns adaptations for the first period\n     * @returns {Array.<Object>}\n     */\n    getAdaptationsForType(adaptationType) {\n        warnOnce(\"manifest.getAdaptationsForType(type) is deprecated.\" +\n            \" Please use manifest.period[].getAdaptationsForType(type) instead\");\n        const firstPeriod = this.periods[0];\n        if (firstPeriod === undefined) {\n            return [];\n        }\n        const adaptationsForType = firstPeriod.adaptations[adaptationType];\n        return adaptationsForType === undefined ? [] : adaptationsForType;\n    }\n    /**\n     * @deprecated only returns adaptations for the first period\n     * @returns {Array.<Object>}\n     */\n    getAdaptation(wantedId) {\n        warnOnce(\"manifest.getAdaptation(id) is deprecated.\" +\n            \" Please use manifest.period[].getAdaptation(id) instead\");\n        return arrayFind(this.getAdaptations(), ({ id }) => wantedId === id);\n    }\n    /**\n     * Format the current `Manifest`'s properties into a\n     * `IManifestMetadata` format which can better be communicated through\n     * another thread.\n     *\n     * Please bear in mind however that the returned object will not be updated\n     * when the current `Manifest` instance is updated, it is only a\n     * snapshot at the current time.\n     *\n     * If you want to keep that data up-to-date with the current `Manifest`\n     * instance, you will have to do it yourself.\n     *\n     * @returns {Object}\n     */\n    getMetadataSnapshot() {\n        const periods = [];\n        for (const period of this.periods) {\n            periods.push(period.getMetadataSnapshot());\n        }\n        return {\n            manifestFormat: 1 /* ManifestMetadataFormat.MetadataObject */,\n            id: this.id,\n            periods,\n            isDynamic: this.isDynamic,\n            isLive: this.isLive,\n            isLastPeriodKnown: this.isLastPeriodKnown,\n            suggestedPresentationDelay: this.suggestedPresentationDelay,\n            clockOffset: this.clockOffset,\n            uris: this.uris,\n            availabilityStartTime: this.availabilityStartTime,\n            timeBounds: this.timeBounds,\n        };\n    }\n    /**\n     * Returns a list of all codecs that the support is not known yet.\n     * If a representation with (`isSupported`) is undefined, we consider the\n     * codec support as unknown.\n     *\n     * This function iterates through all periods, adaptations, and representations,\n     * and collects unknown codecs.\n     *\n     * @returns {Array} The list of codecs with unknown support status.\n     */\n    getCodecsWithUnknownSupport() {\n        return getCodecsWithUnknownSupport(this);\n    }\n    /**\n     * @param {Object} newManifest\n     * @param {number} updateType\n     */\n    _performUpdate(newManifest, updateType) {\n        this.availabilityStartTime = newManifest.availabilityStartTime;\n        this.expired = newManifest.expired;\n        this.isDynamic = newManifest.isDynamic;\n        this.isLive = newManifest.isLive;\n        this.isLastPeriodKnown = newManifest.isLastPeriodKnown;\n        this.lifetime = newManifest.lifetime;\n        this.clockOffset = newManifest.clockOffset;\n        this.suggestedPresentationDelay = newManifest.suggestedPresentationDelay;\n        this.transport = newManifest.transport;\n        this.publishTime = newManifest.publishTime;\n        let updatedPeriodsResult;\n        if (updateType === MANIFEST_UPDATE_TYPE.Full) {\n            this.timeBounds = newManifest.timeBounds;\n            this.uris = newManifest.uris;\n            updatedPeriodsResult = replacePeriods(this.periods, newManifest.periods);\n        }\n        else {\n            this.timeBounds.maximumTimeData = newManifest.timeBounds.maximumTimeData;\n            this.updateUrl = newManifest.uris[0];\n            updatedPeriodsResult = updatePeriods(this.periods, newManifest.periods);\n            // Partial updates do not remove old Periods.\n            // This can become a memory problem when playing a content long enough.\n            // Let's clean manually Periods behind the minimum possible position.\n            const min = this.getMinimumSafePosition();\n            while (this.periods.length > 0) {\n                const period = this.periods[0];\n                if (period.end === undefined || period.end > min) {\n                    break;\n                }\n                this.periods.shift();\n            }\n        }\n        this.updateCodecSupport();\n        // Re-set this.adaptations for retro-compatibility in v3.x.x\n        this.adaptations = this.periods[0] === undefined ? {} : this.periods[0].adaptations;\n        // Let's trigger events at the end, as those can trigger side-effects.\n        // We do not want the current Manifest object to be incomplete when those\n        // happen.\n        this.trigger(\"manifestUpdate\", updatedPeriodsResult);\n    }\n}\n/**\n * Update `decipherable` property of every `Representation` found in the\n * Manifest based on the result of a `isDecipherable` callback:\n *   - When that callback returns `true`, update `decipherable` to `true`\n *   - When that callback returns `false`, update `decipherable` to `false`\n *   - When that callback returns `undefined`, update `decipherable` to\n *     `undefined`\n * @param {Manifest} manifest\n * @param {Function} isDecipherable\n * @returns {Array.<Object>}\n */\nfunction updateDeciperability(manifest, isDecipherable) {\n    const updates = [];\n    for (const period of manifest.periods) {\n        for (const adaptation of period.getAdaptations()) {\n            let hasOnlyUndecipherableRepresentations = true;\n            for (const representation of adaptation.representations) {\n                const content = { manifest, period, adaptation, representation };\n                const result = isDecipherable(content);\n                if (result !== false) {\n                    hasOnlyUndecipherableRepresentations = false;\n                }\n                if (result !== representation.decipherable) {\n                    updates.push(content);\n                    representation.decipherable = result;\n                    if (result === true) {\n                        adaptation.supportStatus.isDecipherable = true;\n                    }\n                    else if (result === undefined &&\n                        adaptation.supportStatus.isDecipherable === false) {\n                        adaptation.supportStatus.isDecipherable = undefined;\n                    }\n                    log.debug(`Decipherability changed for \"${representation.id}\"`, `(${representation.bitrate})`, String(representation.decipherable));\n                }\n            }\n            if (hasOnlyUndecipherableRepresentations) {\n                adaptation.supportStatus.isDecipherable = false;\n            }\n        }\n    }\n    return updates;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { MediaError } from \"../../errors\";\nimport arrayFind from \"../../utils/array_find\";\nimport isNullOrUndefined from \"../../utils/is_null_or_undefined\";\nimport { getAdaptations, getSupportedAdaptations, periodContainsTime } from \"../utils\";\nimport Adaptation from \"./adaptation\";\n/**\n * Class representing the tracks and qualities available from a given time\n * period in the the Manifest.\n * @class Period\n */\nexport default class Period {\n    /**\n     * @constructor\n     * @param {Object} args\n     * @param {Array.<Object>} unsupportedAdaptations - Array on which\n     * `Adaptation`s objects which have no supported `Representation` will be\n     * pushed.\n     * This array might be useful for minor error reporting.\n     * @param {function|undefined} [representationFilter]\n     */\n    constructor(args, unsupportedAdaptations, cachedCodecSupport, representationFilter) {\n        this.id = args.id;\n        this.adaptations = Object.keys(args.adaptations).reduce((acc, type) => {\n            const adaptationsForType = args.adaptations[type];\n            if (isNullOrUndefined(adaptationsForType)) {\n                return acc;\n            }\n            const filteredAdaptations = adaptationsForType\n                .map((adaptation) => {\n                const newAdaptation = new Adaptation(adaptation, cachedCodecSupport, {\n                    representationFilter,\n                });\n                if (newAdaptation.representations.length > 0 &&\n                    newAdaptation.supportStatus.hasSupportedCodec === false) {\n                    unsupportedAdaptations.push(newAdaptation);\n                }\n                return newAdaptation;\n            })\n                .filter((adaptation) => adaptation.representations.length > 0);\n            if (filteredAdaptations.every((adaptation) => adaptation.supportStatus.hasSupportedCodec === false) &&\n                adaptationsForType.length > 0 &&\n                (type === \"video\" || type === \"audio\")) {\n                throw new MediaError(\"MANIFEST_INCOMPATIBLE_CODECS_ERROR\", \"No supported \" + type + \" adaptations\", { tracks: undefined });\n            }\n            if (filteredAdaptations.length > 0) {\n                acc[type] = filteredAdaptations;\n            }\n            return acc;\n        }, {});\n        if (!Array.isArray(this.adaptations.video) &&\n            !Array.isArray(this.adaptations.audio)) {\n            throw new MediaError(\"MANIFEST_PARSE_ERROR\", \"No supported audio and video tracks.\");\n        }\n        this.thumbnailTracks = args.thumbnailTracks.map((thumbnailTrack) => ({\n            id: thumbnailTrack.id,\n            mimeType: thumbnailTrack.mimeType,\n            index: thumbnailTrack.index,\n            cdnMetadata: thumbnailTrack.cdnMetadata,\n            height: thumbnailTrack.height,\n            width: thumbnailTrack.width,\n            horizontalTiles: thumbnailTrack.horizontalTiles,\n            verticalTiles: thumbnailTrack.verticalTiles,\n            start: thumbnailTrack.start,\n            end: thumbnailTrack.end,\n            tileDuration: thumbnailTrack.tileDuration,\n        }));\n        this.duration = args.duration;\n        this.start = args.start;\n        if (!isNullOrUndefined(this.duration) && !isNullOrUndefined(this.start)) {\n            this.end = this.start + this.duration;\n        }\n        this.streamEvents = args.streamEvents === undefined ? [] : args.streamEvents;\n    }\n    /**\n     * Some environments (e.g. in a WebWorker) may not have the capability to know\n     * if a mimetype+codec combination is supported on the current platform.\n     *\n     * Calling `refreshCodecSupport` manually once the codecs supported are known\n     * by the current environnement allows to work-around this issue.\n     *\n     * @param {Array.<Object>} unsupportedAdaptations - Array on which\n     * `Adaptation`s objects which are now known to have no supported\n     * `Representation` will be pushed.\n     * This array might be useful for minor error reporting.\n     * @param {Array.<Object>} cachedCodecSupport\n     */\n    refreshCodecSupport(unsupportedAdaptations, cachedCodecSupport) {\n        Object.keys(this.adaptations).forEach((ttype) => {\n            const adaptationsForType = this.adaptations[ttype];\n            if (adaptationsForType === undefined) {\n                return;\n            }\n            let hasSupportedAdaptations = false;\n            for (const adaptation of adaptationsForType) {\n                if (!adaptation.supportStatus.hasCodecWithUndefinedSupport) {\n                    // Go to next adaptation as an optimisation measure.\n                    // NOTE this only is true if we never change a codec from supported\n                    // to unsuported and its opposite.\n                    if (adaptation.supportStatus.hasSupportedCodec === true) {\n                        hasSupportedAdaptations = true;\n                    }\n                    continue;\n                }\n                const wasSupported = adaptation.supportStatus.hasSupportedCodec;\n                adaptation.refreshCodecSupport(cachedCodecSupport);\n                if (wasSupported !== false &&\n                    adaptation.supportStatus.hasSupportedCodec === false) {\n                    unsupportedAdaptations.push(adaptation);\n                }\n                if (hasSupportedAdaptations === false) {\n                    hasSupportedAdaptations = adaptation.supportStatus.hasSupportedCodec;\n                }\n                else if (hasSupportedAdaptations === undefined &&\n                    adaptation.supportStatus.hasSupportedCodec === true) {\n                    hasSupportedAdaptations = true;\n                }\n            }\n            if ((ttype === \"video\" || ttype === \"audio\") && hasSupportedAdaptations === false) {\n                throw new MediaError(\"MANIFEST_INCOMPATIBLE_CODECS_ERROR\", \"No supported \" + ttype + \" adaptations\", { tracks: undefined });\n            }\n        }, {});\n    }\n    /**\n     * Returns every `Adaptations` (or `tracks`) linked to that Period, in an\n     * Array.\n     * @returns {Array.<Object>}\n     */\n    getAdaptations() {\n        return getAdaptations(this);\n    }\n    /**\n     * Returns every `Adaptations` (or `tracks`) linked to that Period for a\n     * given type.\n     * @param {string} adaptationType\n     * @returns {Array.<Object>}\n     */\n    getAdaptationsForType(adaptationType) {\n        const adaptationsForType = this.adaptations[adaptationType];\n        return adaptationsForType !== null && adaptationsForType !== void 0 ? adaptationsForType : [];\n    }\n    /**\n     * Returns the Adaptation linked to the given ID.\n     * @param {number|string} wantedId\n     * @returns {Object|undefined}\n     */\n    getAdaptation(wantedId) {\n        return arrayFind(this.getAdaptations(), ({ id }) => wantedId === id);\n    }\n    /**\n     * Returns Adaptations that contain Representations in supported codecs.\n     * @param {string|undefined} type - If set filter on a specific Adaptation's\n     * type. Will return for all types if `undefined`.\n     * @returns {Array.<Adaptation>}\n     */\n    getSupportedAdaptations(type) {\n        return getSupportedAdaptations(this, type);\n    }\n    /**\n     * Returns true if the give time is in the time boundaries of this `Period`.\n     * @param {number} time\n     * @param {object|null} nextPeriod - Period coming chronologically just\n     * after in the same Manifest. `null` if this instance is the last `Period`.\n     * @returns {boolean}\n     */\n    containsTime(time, nextPeriod) {\n        return periodContainsTime(this, time, nextPeriod);\n    }\n    /**\n     * Format the current `Period`'s properties into a\n     * `IPeriodMetadata` format which can better be communicated through\n     * another thread.\n     *\n     * Please bear in mind however that the returned object will not be updated\n     * when the current `Period` instance is updated, it is only a\n     * snapshot at the current time.\n     *\n     * If you want to keep that data up-to-date with the current `Period`\n     * instance, you will have to do it yourself.\n     *\n     * @returns {Object}\n     */\n    getMetadataSnapshot() {\n        const adaptations = {};\n        const baseAdaptations = this.getAdaptations();\n        for (const adaptation of baseAdaptations) {\n            let currentAdaps = adaptations[adaptation.type];\n            if (currentAdaps === undefined) {\n                currentAdaps = [];\n                adaptations[adaptation.type] = currentAdaps;\n            }\n            currentAdaps.push(adaptation.getMetadataSnapshot());\n        }\n        return {\n            start: this.start,\n            end: this.end,\n            id: this.id,\n            streamEvents: this.streamEvents,\n            adaptations,\n            thumbnailTracks: this.thumbnailTracks.map((thumbnailTrack) => ({\n                id: thumbnailTrack.id,\n                mimeType: thumbnailTrack.mimeType,\n                height: thumbnailTrack.height,\n                width: thumbnailTrack.width,\n                horizontalTiles: thumbnailTrack.horizontalTiles,\n                verticalTiles: thumbnailTrack.verticalTiles,\n                start: thumbnailTrack.start,\n                end: thumbnailTrack.end,\n                tileDuration: thumbnailTrack.tileDuration,\n            })),\n        };\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../log\";\nimport { isRepresentationPlayable } from \"../../manifest\";\nimport areArraysOfNumbersEqual from \"../../utils/are_arrays_of_numbers_equal\";\nimport idGenerator from \"../../utils/id_generator\";\nconst generateRepresentationUniqueId = idGenerator();\n/**\n * Normalized Representation structure.\n * @class Representation\n */\nclass Representation {\n    /**\n     * @param {Object} args\n     * @param {string} trackType\n     */\n    constructor(args, trackType, cachedCodecSupport) {\n        var _a, _b, _c, _d, _e;\n        this.id = args.id;\n        this.uniqueId = generateRepresentationUniqueId();\n        this.shouldBeAvoided = false;\n        this.bitrate = args.bitrate;\n        this.codecs = [];\n        this.trackType = trackType;\n        if (args.isSpatialAudio !== undefined) {\n            this.isSpatialAudio = args.isSpatialAudio;\n        }\n        if (args.height !== undefined) {\n            this.height = args.height;\n        }\n        if (args.width !== undefined) {\n            this.width = args.width;\n        }\n        if (args.mimeType !== undefined) {\n            this.mimeType = args.mimeType;\n        }\n        if (args.contentProtections !== undefined) {\n            this.contentProtections = args.contentProtections;\n        }\n        if (args.frameRate !== undefined) {\n            this.frameRate = args.frameRate;\n        }\n        if (args.hdrInfo !== undefined) {\n            this.hdrInfo = args.hdrInfo;\n        }\n        this.cdnMetadata = args.cdnMetadata;\n        this.index = args.index;\n        const isEncrypted = this.contentProtections !== undefined;\n        if (trackType === \"audio\" || trackType === \"video\") {\n            // Supplemental codecs are defined as backwards-compatible codecs enhancing\n            // the experience of a base layer codec\n            if (args.supplementalCodecs !== undefined) {\n                const isSupplementaryCodecSupported = cachedCodecSupport.isSupported((_a = this.mimeType) !== null && _a !== void 0 ? _a : \"\", (_b = args.supplementalCodecs) !== null && _b !== void 0 ? _b : \"\", isEncrypted);\n                if (isSupplementaryCodecSupported !== false) {\n                    this.codecs = [args.supplementalCodecs];\n                    this.isSupported = isSupplementaryCodecSupported;\n                }\n            }\n            if (this.isSupported !== true) {\n                if (this.codecs.length > 0) {\n                    // We couldn't check for support of another supplemental codec.\n                    // Just push that codec without testing support yet, we'll check\n                    // support later.\n                    this.codecs.push((_c = args.codecs) !== null && _c !== void 0 ? _c : \"\");\n                }\n                else {\n                    this.codecs = args.codecs === undefined ? [] : [args.codecs];\n                    this.isSupported = cachedCodecSupport.isSupported((_d = this.mimeType) !== null && _d !== void 0 ? _d : \"\", (_e = args.codecs) !== null && _e !== void 0 ? _e : \"\", isEncrypted);\n                }\n            }\n        }\n        else {\n            if (args.codecs !== undefined) {\n                this.codecs.push(args.codecs);\n            }\n            this.isSupported = true;\n        }\n    }\n    /**\n     * Some environments (e.g. in a WebWorker) may not have the capability to know\n     * if a mimetype+codec combination is supported on the current platform.\n     *\n     * Calling `refreshCodecSupport` manually once the codecs supported are known\n     * by the current environnement allows to work-around this issue.\n     *\n     * If the right mimetype+codec combination is found in the provided object,\n     * this `Representation`'s `isSupported` property will be updated accordingly.\n     *\n     * @param {Array.<Object>} cachedCodecSupport;\n     */\n    refreshCodecSupport(cachedCodecSupport) {\n        var _a, _b;\n        if (this.isSupported !== undefined) {\n            return;\n        }\n        const isEncrypted = this.contentProtections !== undefined;\n        let isSupported = false;\n        const mimeType = (_a = this.mimeType) !== null && _a !== void 0 ? _a : \"\";\n        let codecs = (_b = this.codecs) !== null && _b !== void 0 ? _b : [];\n        if (codecs.length === 0) {\n            codecs = [\"\"];\n        }\n        let representationHasUnknownCodecs = false;\n        for (const codec of codecs) {\n            isSupported = cachedCodecSupport.isSupported(mimeType, codec, isEncrypted);\n            if (isSupported === true) {\n                this.codecs = [codec];\n                break;\n            }\n            if (isSupported === undefined) {\n                representationHasUnknownCodecs = true;\n            }\n        }\n        /** If any codec is supported, the representation is supported */\n        if (isSupported === true) {\n            this.isSupported = true;\n        }\n        else {\n            /** If some codecs support are not known it's too early to assume\n             *  representation is unsupported */\n            if (representationHasUnknownCodecs) {\n                this.isSupported = undefined;\n            }\n            else {\n                /** If all codecs support are known and none are supported,\n                 * the representation is not supported.\n                 */\n                this.isSupported = false;\n            }\n        }\n    }\n    /**\n     * Returns \"mime-type string\" which includes both the mime-type and the codec,\n     * which is often needed when interacting with the browser's APIs.\n     * @returns {string}\n     */\n    getMimeTypeString() {\n        var _a, _b, _c;\n        return `${(_a = this.mimeType) !== null && _a !== void 0 ? _a : \"\"};codecs=\"${(_c = (_b = this.codecs) === null || _b === void 0 ? void 0 : _b[0]) !== null && _c !== void 0 ? _c : \"\"}\"`;\n    }\n    /**\n     * Returns encryption initialization data linked to the given DRM's system ID.\n     * This data may be useful to decrypt encrypted media segments.\n     *\n     * Returns an empty array if there is no data found for that system ID at the\n     * moment.\n     *\n     * When you know that all encryption data has been added to this\n     * Representation, you can also call the `getAllEncryptionData` method.\n     * This second function will return all encryption initialization data\n     * regardless of the DRM system, and might thus be used in all cases.\n     *\n     * /!\\ Note that encryption initialization data may be progressively added to\n     * this Representation after `_addProtectionData` calls or Manifest updates.\n     * Because of this, the return value of this function might change after those\n     * events.\n     *\n     * @param {string} drmSystemId - The hexa-encoded DRM system ID\n     * @returns {Array.<Object>}\n     */\n    getEncryptionData(drmSystemId) {\n        var _a;\n        const allInitData = this.getAllEncryptionData();\n        const filtered = [];\n        for (let i = 0; i < allInitData.length; i++) {\n            let createdObjForType = false;\n            const initData = allInitData[i];\n            for (let j = 0; j < initData.values.length; j++) {\n                if (initData.values[j].systemId.toLowerCase() === drmSystemId.toLowerCase()) {\n                    if (!createdObjForType) {\n                        const keyIds = (_a = this.contentProtections) === null || _a === void 0 ? void 0 : _a.keyIds;\n                        filtered.push({\n                            type: initData.type,\n                            keyIds,\n                            values: [initData.values[j]],\n                        });\n                        createdObjForType = true;\n                    }\n                    else {\n                        filtered[filtered.length - 1].values.push(initData.values[j]);\n                    }\n                }\n            }\n        }\n        return filtered;\n    }\n    /**\n     * Returns all currently-known encryption initialization data linked to this\n     * Representation.\n     * Encryption initialization data is generally required to be able to decrypt\n     * those Representation's media segments.\n     *\n     * Unlike `getEncryptionData`, this method will return all available\n     * encryption data.\n     * It might as such might be used when either the current drm's system id is\n     * not known or when no encryption data specific to it was found. In that\n     * case, providing every encryption data linked to this Representation might\n     * still allow decryption.\n     *\n     * Returns an empty array in two cases:\n     *   - the content is not encrypted.\n     *   - We don't have any decryption data yet.\n     *\n     * /!\\ Note that new encryption initialization data can be added progressively\n     * through the `_addProtectionData` method or through Manifest updates.\n     * It is thus highly advised to only rely on this method once every protection\n     * data related to this Representation has been known to be added.\n     *\n     * The main situation where new encryption initialization data is added is\n     * after parsing this Representation's initialization segment, if one exists.\n     * @returns {Array.<Object>}\n     */\n    getAllEncryptionData() {\n        var _a;\n        if (this.contentProtections === undefined ||\n            this.contentProtections.initData.length === 0) {\n            return [];\n        }\n        const keyIds = (_a = this.contentProtections) === null || _a === void 0 ? void 0 : _a.keyIds;\n        return this.contentProtections.initData.map((x) => {\n            return { type: x.type, keyIds, values: x.values };\n        });\n    }\n    /**\n     * Add new encryption initialization data to this Representation if it was not\n     * already included.\n     *\n     * Returns `true` if new encryption initialization data has been added.\n     * Returns `false` if none has been added (e.g. because it was already known).\n     *\n     * /!\\ Mutates the current Representation\n     *\n     * TODO better handle use cases like key rotation by not always grouping\n     * every protection data together? To check.\n     * @param {string} initDataType\n     * @param {Uint8Array|undefined} keyId\n     * @param {Uint8Array} data\n     * @returns {boolean}\n     */\n    addProtectionData(initDataType, keyId, data) {\n        let hasUpdatedProtectionData = false;\n        if (this.contentProtections === undefined) {\n            this.contentProtections = {\n                keyIds: keyId !== undefined ? [keyId] : [],\n                initData: [{ type: initDataType, values: data }],\n            };\n            return true;\n        }\n        if (keyId !== undefined) {\n            const keyIds = this.contentProtections.keyIds;\n            if (keyIds === undefined) {\n                this.contentProtections.keyIds = [keyId];\n            }\n            else {\n                let foundKeyId = false;\n                for (const knownKeyId of keyIds) {\n                    if (areArraysOfNumbersEqual(knownKeyId, keyId)) {\n                        foundKeyId = true;\n                    }\n                }\n                if (!foundKeyId) {\n                    log.warn(\"Manifest: found unanounced key id.\");\n                    keyIds.push(keyId);\n                }\n            }\n        }\n        const cInitData = this.contentProtections.initData;\n        for (let i = 0; i < cInitData.length; i++) {\n            if (cInitData[i].type === initDataType) {\n                const cValues = cInitData[i].values;\n                // loop through data\n                for (let dataI = 0; dataI < data.length; dataI++) {\n                    const dataToAdd = data[dataI];\n                    let cValuesIdx;\n                    for (cValuesIdx = 0; cValuesIdx < cValues.length; cValuesIdx++) {\n                        if (dataToAdd.systemId === cValues[cValuesIdx].systemId) {\n                            if (areArraysOfNumbersEqual(dataToAdd.data, cValues[cValuesIdx].data)) {\n                                // go to next dataToAdd\n                                break;\n                            }\n                            else {\n                                log.warn(\"Manifest: different init data for the same system ID\");\n                            }\n                        }\n                    }\n                    if (cValuesIdx === cValues.length) {\n                        // we didn't break the loop === we didn't already find that value\n                        cValues.push(dataToAdd);\n                        hasUpdatedProtectionData = true;\n                    }\n                }\n                return hasUpdatedProtectionData;\n            }\n        }\n        // If we are here, this means that we didn't find the corresponding\n        // init data type in this.contentProtections.initData.\n        this.contentProtections.initData.push({ type: initDataType, values: data });\n        return true;\n    }\n    /**\n     * Returns `true` if the `Representation` has a high chance of being playable on\n     * the current device (its codec seems supported and we don't consider it to be\n     * un-decipherable).\n     *\n     * Returns `false` if the `Representation` has a high chance of being unplayable\n     * on the current device (its codec seems unsupported and/or we consider it to\n     * be un-decipherable).\n     *\n     * Returns `undefined` if we don't know as the codec has not been checked yet.\n     *\n     * @returns {boolean|undefined}\n     */\n    isPlayable() {\n        return isRepresentationPlayable(this);\n    }\n    /**\n     * Format the current `Representation`'s properties into a\n     * `IRepresentationMetadata` format which can better be communicated through\n     * another thread.\n     *\n     * Please bear in mind however that the returned object will not be updated\n     * when the current `Representation` instance is updated, it is only a\n     * snapshot at the current time.\n     *\n     * If you want to keep that data up-to-date with the current `Representation`\n     * instance, you will have to do it yourself.\n     *\n     * @returns {Object}\n     */\n    getMetadataSnapshot() {\n        return {\n            id: this.id,\n            uniqueId: this.uniqueId,\n            bitrate: this.bitrate,\n            codecs: this.codecs,\n            mimeType: this.mimeType,\n            width: this.width,\n            height: this.height,\n            frameRate: this.frameRate,\n            isSupported: this.isSupported,\n            hdrInfo: this.hdrInfo,\n            contentProtections: this.contentProtections,\n            decipherable: this.decipherable,\n            isCodecSupportedInWebWorker: this.isCodecSupportedInWebWorker,\n        };\n    }\n}\nexport default Representation;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../../log\";\n/**\n * Simple RepresentationIndex implementation for static files.\n * @class StaticRepresentationIndex\n */\nexport default class StaticRepresentationIndex {\n    /**\n     * @param {Object} infos\n     */\n    constructor(infos) {\n        this._url = infos.media;\n    }\n    /**\n     * Static contents do not have any initialization segments.\n     * Just return null.\n     * @returns {null}\n     */\n    getInitSegment() {\n        return null;\n    }\n    /**\n     * Returns the only Segment available here.\n     * @returns {Array.<Object>}\n     */\n    getSegments() {\n        return [\n            {\n                id: \"0\",\n                isInit: false,\n                number: 0,\n                url: this._url,\n                time: 0,\n                end: Number.MAX_VALUE,\n                duration: Number.MAX_VALUE,\n                complete: true,\n                privateInfos: {},\n                timescale: 1,\n            },\n        ];\n    }\n    /**\n     * Returns first position in index.\n     * @returns {undefined}\n     */\n    getFirstAvailablePosition() {\n        return;\n    }\n    /**\n     * Returns last position in index.\n     * @returns {undefined}\n     */\n    getLastAvailablePosition() {\n        return;\n    }\n    /**\n     * Returns the absolute end in seconds this RepresentationIndex can reach once\n     * all segments are available.\n     * @returns {number|null|undefined}\n     */\n    getEnd() {\n        return;\n    }\n    /**\n     * Returns:\n     *   - `true` if in the given time interval, at least one new segment is\n     *     expected to be available in the future.\n     *   - `false` either if all segments in that time interval are already\n     *     available for download or if none will ever be available for it.\n     *   - `undefined` when it is not possible to tell.\n     *\n     * Always `false` in a `StaticRepresentationIndex` because all segments should\n     * be directly available.\n     * @returns {boolean}\n     */\n    awaitSegmentBetween() {\n        return false;\n    }\n    /**\n     * Returns false as a static file never need to be refreshed.\n     * @returns {Boolean}\n     */\n    shouldRefresh() {\n        return false;\n    }\n    /**\n     * @returns {null}\n     */\n    checkDiscontinuity() {\n        return null;\n    }\n    /**\n     * Returns true as a static file should never need lose availability.\n     * @returns {Boolean}\n     */\n    isSegmentStillAvailable() {\n        return true;\n    }\n    /**\n     * @returns {Boolean}\n     */\n    canBeOutOfSyncError() {\n        return false;\n    }\n    /**\n     * @returns {Boolean}\n     */\n    isStillAwaitingFutureSegments() {\n        return false;\n    }\n    /**\n     * @returns {Boolean}\n     */\n    isInitialized() {\n        return true;\n    }\n    initialize() {\n        log.error(\"A `StaticRepresentationIndex` does not need to be initialized\");\n    }\n    /**\n     * Returns the `duration` of each segment in the context of its Manifest (i.e.\n     * as the Manifest anounces them, actual segment duration may be different due\n     * to approximations), in seconds.\n     *\n     * NOTE: we could here do a median or a mean but I chose to be lazy (and\n     * more performant) by returning the duration of the first element instead.\n     * As `isPrecize` is `false`, the rest of the code should be notified that\n     * this is only an approximation.\n     * @returns {number}\n     */\n    getTargetSegmentDuration() {\n        return {\n            duration: Number.MAX_VALUE,\n            isPrecize: false,\n        };\n    }\n    addPredictedSegments() {\n        log.warn(\"Cannot add predicted segments to a `StaticRepresentationIndex`\");\n    }\n    _replace() {\n        log.warn(\"Tried to replace a static RepresentationIndex\");\n    }\n    _update() {\n        log.warn(\"Tried to update a static RepresentationIndex\");\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Enumerate the different ways a Manifest update can be done. */\nexport var MANIFEST_UPDATE_TYPE;\n(function (MANIFEST_UPDATE_TYPE) {\n    /**\n     * Manifest is updated entirely thanks to a re-downloaded version of\n     * the original manifest document.\n     */\n    MANIFEST_UPDATE_TYPE[MANIFEST_UPDATE_TYPE[\"Full\"] = 0] = \"Full\";\n    /**\n     * Manifest is updated partially thanks to a shortened version\n     * of the manifest document. The latter's URL might be different\n     * from the original one.\n     */\n    MANIFEST_UPDATE_TYPE[MANIFEST_UPDATE_TYPE[\"Partial\"] = 1] = \"Partial\";\n})(MANIFEST_UPDATE_TYPE || (MANIFEST_UPDATE_TYPE = {}));\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../log\";\nimport arrayFindIndex from \"../../utils/array_find_index\";\nimport { MANIFEST_UPDATE_TYPE } from \"./types\";\n/**\n * Update oldPeriod attributes with the one from newPeriod (e.g. when updating\n * the Manifest).\n * @param {Object} oldPeriod\n * @param {Object} newPeriod\n * @param {number} updateType\n * @returns {Object}\n */\nexport default function updatePeriodInPlace(oldPeriod, newPeriod, updateType) {\n    const res = {\n        updatedAdaptations: [],\n        removedAdaptations: [],\n        addedAdaptations: [],\n        updatedThumbnailTracks: [],\n        removedThumbnailTracks: [],\n        addedThumbnailTracks: [],\n    };\n    oldPeriod.start = newPeriod.start;\n    oldPeriod.end = newPeriod.end;\n    oldPeriod.duration = newPeriod.duration;\n    oldPeriod.streamEvents = newPeriod.streamEvents;\n    const oldThumbnailTracks = oldPeriod.thumbnailTracks;\n    const newThumbnailTracks = newPeriod.thumbnailTracks;\n    for (let j = 0; j < oldThumbnailTracks.length; j++) {\n        const oldThumbnailTrack = oldThumbnailTracks[j];\n        const newThumbnailTrackIdx = arrayFindIndex(newThumbnailTracks, (a) => a.id === oldThumbnailTrack.id);\n        if (newThumbnailTrackIdx === -1) {\n            log.warn('Manifest: ThumbnailTrack \"' +\n                oldThumbnailTracks[j].id +\n                '\" not found when merging.');\n            const [removed] = oldThumbnailTracks.splice(j, 1);\n            j--;\n            res.removedThumbnailTracks.push({\n                id: removed.id,\n            });\n        }\n        else {\n            const [newThumbnailTrack] = newThumbnailTracks.splice(newThumbnailTrackIdx, 1);\n            oldThumbnailTrack.mimeType = newThumbnailTrack.mimeType;\n            oldThumbnailTrack.height = newThumbnailTrack.height;\n            oldThumbnailTrack.width = newThumbnailTrack.width;\n            oldThumbnailTrack.horizontalTiles = newThumbnailTrack.horizontalTiles;\n            oldThumbnailTrack.verticalTiles = newThumbnailTrack.verticalTiles;\n            oldThumbnailTrack.start = newThumbnailTrack.start;\n            oldThumbnailTrack.end = newThumbnailTrack.end;\n            oldThumbnailTrack.tileDuration = newThumbnailTrack.tileDuration;\n            oldThumbnailTrack.cdnMetadata = newThumbnailTrack.cdnMetadata;\n            if (updateType === MANIFEST_UPDATE_TYPE.Full) {\n                oldThumbnailTrack.index._replace(newThumbnailTrack.index);\n            }\n            else {\n                oldThumbnailTrack.index._update(newThumbnailTrack.index);\n            }\n            res.updatedThumbnailTracks.push({\n                id: oldThumbnailTrack.id,\n                mimeType: oldThumbnailTrack.mimeType,\n                height: oldThumbnailTrack.height,\n                width: oldThumbnailTrack.width,\n                horizontalTiles: oldThumbnailTrack.horizontalTiles,\n                verticalTiles: oldThumbnailTrack.verticalTiles,\n                start: oldThumbnailTrack.start,\n                end: oldThumbnailTrack.end,\n                tileDuration: oldThumbnailTrack.tileDuration,\n            });\n        }\n    }\n    if (newThumbnailTracks.length > 0) {\n        log.warn(`Manifest: ${newThumbnailTracks.length} new Thumbnail tracks ` +\n            \"found when merging.\");\n        res.addedThumbnailTracks.push(...newThumbnailTracks.map((t) => ({\n            id: t.id,\n            mimeType: t.mimeType,\n            height: t.height,\n            width: t.width,\n            horizontalTiles: t.horizontalTiles,\n            verticalTiles: t.verticalTiles,\n            start: t.start,\n            end: t.end,\n            tileDuration: t.tileDuration,\n        })));\n        oldPeriod.thumbnailTracks.push(...newThumbnailTracks);\n    }\n    const oldAdaptations = oldPeriod.getAdaptations();\n    const newAdaptations = newPeriod.getAdaptations();\n    for (let j = 0; j < oldAdaptations.length; j++) {\n        const oldAdaptation = oldAdaptations[j];\n        const newAdaptationIdx = arrayFindIndex(newAdaptations, (a) => a.id === oldAdaptation.id);\n        if (newAdaptationIdx === -1) {\n            log.warn('Manifest: Adaptation \"' + oldAdaptations[j].id + '\" not found when merging.');\n            const [removed] = oldAdaptations.splice(j, 1);\n            j--;\n            res.removedAdaptations.push({\n                id: removed.id,\n                trackType: removed.type,\n            });\n        }\n        else {\n            const [newAdaptation] = newAdaptations.splice(newAdaptationIdx, 1);\n            const updatedRepresentations = [];\n            const addedRepresentations = [];\n            const removedRepresentations = [];\n            res.updatedAdaptations.push({\n                adaptation: oldAdaptation.id,\n                trackType: oldAdaptation.type,\n                updatedRepresentations,\n                addedRepresentations,\n                removedRepresentations,\n            });\n            const oldRepresentations = oldAdaptation.representations;\n            const newRepresentations = newAdaptation.representations.slice();\n            for (let k = 0; k < oldRepresentations.length; k++) {\n                const oldRepresentation = oldRepresentations[k];\n                const newRepresentationIdx = arrayFindIndex(newRepresentations, (representation) => representation.id === oldRepresentation.id);\n                if (newRepresentationIdx === -1) {\n                    log.warn(`Manifest: Representation \"${oldRepresentations[k].id}\" ` +\n                        \"not found when merging.\");\n                    const [removed] = oldRepresentations.splice(k, 1);\n                    k--;\n                    removedRepresentations.push(removed.id);\n                }\n                else {\n                    const [newRepresentation] = newRepresentations.splice(newRepresentationIdx, 1);\n                    updatedRepresentations.push(oldRepresentation.getMetadataSnapshot());\n                    oldRepresentation.cdnMetadata = newRepresentation.cdnMetadata;\n                    if (updateType === MANIFEST_UPDATE_TYPE.Full) {\n                        oldRepresentation.index._replace(newRepresentation.index);\n                    }\n                    else {\n                        oldRepresentation.index._update(newRepresentation.index);\n                    }\n                }\n            }\n            if (newRepresentations.length > 0) {\n                log.warn(`Manifest: ${newRepresentations.length} new Representations ` +\n                    \"found when merging.\");\n                oldAdaptation.representations.push(...newRepresentations);\n                addedRepresentations.push(...newRepresentations.map((r) => r.getMetadataSnapshot()));\n            }\n        }\n    }\n    if (newAdaptations.length > 0) {\n        log.warn(`Manifest: ${newAdaptations.length} new Adaptations ` + \"found when merging.\");\n        for (const adap of newAdaptations) {\n            const prevAdaps = oldPeriod.adaptations[adap.type];\n            if (prevAdaps === undefined) {\n                oldPeriod.adaptations[adap.type] = [adap];\n            }\n            else {\n                prevAdaps.push(adap);\n            }\n            res.addedAdaptations.push(adap.getMetadataSnapshot());\n        }\n    }\n    return res;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { MediaError } from \"../../errors\";\nimport log from \"../../log\";\nimport arrayFindIndex from \"../../utils/array_find_index\";\nimport objectAssign from \"../../utils/object_assign\";\nimport { MANIFEST_UPDATE_TYPE } from \"./types\";\nimport updatePeriodInPlace from \"./update_period_in_place\";\n/**\n * Update old periods by adding new periods and removing\n * not available ones.\n * @param {Array.<Object>} oldPeriods\n * @param {Array.<Object>} newPeriods\n * @returns {Object}\n */\nexport function replacePeriods(oldPeriods, newPeriods) {\n    const res = {\n        updatedPeriods: [],\n        addedPeriods: [],\n        removedPeriods: [],\n    };\n    let firstUnhandledPeriodIdx = 0;\n    for (let i = 0; i < newPeriods.length; i++) {\n        const newPeriod = newPeriods[i];\n        let j = firstUnhandledPeriodIdx;\n        let oldPeriod = oldPeriods[j];\n        while (oldPeriod !== undefined && oldPeriod.id !== newPeriod.id) {\n            j++;\n            oldPeriod = oldPeriods[j];\n        }\n        if (oldPeriod !== undefined) {\n            const result = updatePeriodInPlace(oldPeriod, newPeriod, MANIFEST_UPDATE_TYPE.Full);\n            res.updatedPeriods.push({\n                period: {\n                    id: oldPeriod.id,\n                    start: oldPeriod.start,\n                    end: oldPeriod.end,\n                    duration: oldPeriod.duration,\n                    streamEvents: oldPeriod.streamEvents,\n                },\n                result,\n            });\n            const periodsToInclude = newPeriods.slice(firstUnhandledPeriodIdx, i);\n            const nbrOfPeriodsToRemove = j - firstUnhandledPeriodIdx;\n            const removed = oldPeriods.splice(firstUnhandledPeriodIdx, nbrOfPeriodsToRemove, ...periodsToInclude);\n            res.removedPeriods.push(...removed.map((p) => ({\n                id: p.id,\n                start: p.start,\n                end: p.end,\n            })));\n            res.addedPeriods.push(...periodsToInclude.map((p) => p.getMetadataSnapshot()));\n            firstUnhandledPeriodIdx = i + 1;\n        }\n    }\n    if (firstUnhandledPeriodIdx > oldPeriods.length) {\n        log.error(\"Manifest: error when updating Periods\");\n        return res;\n    }\n    if (firstUnhandledPeriodIdx < oldPeriods.length) {\n        const removed = oldPeriods.splice(firstUnhandledPeriodIdx, oldPeriods.length - firstUnhandledPeriodIdx);\n        res.removedPeriods.push(...removed.map((p) => ({\n            id: p.id,\n            start: p.start,\n            end: p.end,\n        })));\n    }\n    const remainingNewPeriods = newPeriods.slice(firstUnhandledPeriodIdx, newPeriods.length);\n    if (remainingNewPeriods.length > 0) {\n        oldPeriods.push(...remainingNewPeriods);\n        res.addedPeriods.push(...remainingNewPeriods.map((p) => p.getMetadataSnapshot()));\n    }\n    return res;\n}\n/**\n * Update old periods by adding new periods and removing\n * not available ones.\n * @param {Array.<Object>} oldPeriods\n * @param {Array.<Object>} newPeriods\n * @returns {Object}\n */\nexport function updatePeriods(oldPeriods, newPeriods) {\n    const res = {\n        updatedPeriods: [],\n        addedPeriods: [],\n        removedPeriods: [],\n    };\n    if (oldPeriods.length === 0) {\n        oldPeriods.splice(0, 0, ...newPeriods);\n        res.addedPeriods.push(...newPeriods.map((p) => p.getMetadataSnapshot()));\n        return res;\n    }\n    if (newPeriods.length === 0) {\n        return res;\n    }\n    const oldLastPeriod = oldPeriods[oldPeriods.length - 1];\n    if (oldLastPeriod.start < newPeriods[0].start) {\n        if (oldLastPeriod.end !== newPeriods[0].start) {\n            throw new MediaError(\"MANIFEST_UPDATE_ERROR\", \"Cannot perform partial update: not enough data\");\n        }\n        oldPeriods.push(...newPeriods);\n        res.addedPeriods.push(...newPeriods.map((p) => p.getMetadataSnapshot()));\n        return res;\n    }\n    /** Index, in `oldPeriods` of the first element of `newPeriods` */\n    const indexOfNewFirstPeriod = arrayFindIndex(oldPeriods, ({ id }) => id === newPeriods[0].id);\n    if (indexOfNewFirstPeriod < 0) {\n        throw new MediaError(\"MANIFEST_UPDATE_ERROR\", \"Cannot perform partial update: incoherent data\");\n    }\n    // The first updated Period can only be a partial part\n    const updateRes = updatePeriodInPlace(oldPeriods[indexOfNewFirstPeriod], newPeriods[0], MANIFEST_UPDATE_TYPE.Partial);\n    res.updatedPeriods.push({\n        period: objectAssign(oldPeriods[indexOfNewFirstPeriod].getMetadataSnapshot(), {\n            adaptations: undefined,\n        }),\n        result: updateRes,\n    });\n    // Search each consecutive elements of `newPeriods` - after the initial one already\n    // processed - in `oldPeriods`, removing and adding unfound Periods in the process\n    let prevIndexOfNewPeriod = indexOfNewFirstPeriod + 1;\n    for (let i = 1; i < newPeriods.length; i++) {\n        const newPeriod = newPeriods[i];\n        let indexOfNewPeriod = -1;\n        for (let j = prevIndexOfNewPeriod; j < oldPeriods.length; j++) {\n            if (newPeriod.id === oldPeriods[j].id) {\n                indexOfNewPeriod = j;\n                break; // end the loop\n            }\n        }\n        if (indexOfNewPeriod < 0) {\n            // Next element of `newPeriods` not found: insert it\n            let toRemoveUntil = -1;\n            for (let j = prevIndexOfNewPeriod; j < oldPeriods.length; j++) {\n                if (newPeriod.start < oldPeriods[j].start) {\n                    toRemoveUntil = j;\n                    break; // end the loop\n                }\n            }\n            const nbElementsToRemove = toRemoveUntil - prevIndexOfNewPeriod;\n            const removed = oldPeriods.splice(prevIndexOfNewPeriod, nbElementsToRemove, newPeriod);\n            res.addedPeriods.push(newPeriod.getMetadataSnapshot());\n            res.removedPeriods.push(...removed.map((p) => ({\n                id: p.id,\n                start: p.start,\n                end: p.end,\n            })));\n        }\n        else {\n            if (indexOfNewPeriod > prevIndexOfNewPeriod) {\n                // Some old periods were not found: remove\n                log.warn(\"Manifest: old Periods not found in new when updating, removing\");\n                const removed = oldPeriods.splice(prevIndexOfNewPeriod, indexOfNewPeriod - prevIndexOfNewPeriod);\n                res.removedPeriods.push(...removed.map((p) => ({\n                    id: p.id,\n                    start: p.start,\n                    end: p.end,\n                })));\n                indexOfNewPeriod = prevIndexOfNewPeriod;\n            }\n            // Later Periods can be fully replaced\n            const result = updatePeriodInPlace(oldPeriods[indexOfNewPeriod], newPeriod, MANIFEST_UPDATE_TYPE.Full);\n            res.updatedPeriods.push({\n                period: objectAssign(oldPeriods[indexOfNewPeriod].getMetadataSnapshot(), {\n                    adaptations: undefined,\n                }),\n                result,\n            });\n        }\n        prevIndexOfNewPeriod++;\n    }\n    if (prevIndexOfNewPeriod < oldPeriods.length) {\n        log.warn(\"Manifest: Ending Periods not found in new when updating, removing\");\n        const removed = oldPeriods.splice(prevIndexOfNewPeriod, oldPeriods.length - prevIndexOfNewPeriod);\n        res.removedPeriods.push(...removed.map((p) => ({\n            id: p.id,\n            start: p.start,\n            end: p.end,\n        })));\n    }\n    return res;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport isNullOrUndefined from \"../../utils/is_null_or_undefined\";\n/**\n * Check if two contents are the same\n * @param {Object} content1\n * @param {Object} content2\n * @returns {boolean}\n */\nexport function areSameContent(content1, content2) {\n    return (content1.segment.id === content2.segment.id &&\n        content1.representation.uniqueId === content2.representation.uniqueId);\n}\n/**\n * Get string describing a given ISegment, useful for log functions.\n * @param {Object} content\n * @returns {string|null|undefined}\n */\nexport function getLoggableSegmentId(content) {\n    if (isNullOrUndefined(content)) {\n        return \"\";\n    }\n    const { period, adaptation, representation, segment } = content;\n    let segmentString;\n    if (segment.isInit) {\n        segmentString = \"init\";\n    }\n    else if (segment.complete) {\n        segmentString = `${segment.time}-${segment.duration}`;\n    }\n    else {\n        segmentString = `${segment.time}`;\n    }\n    return (`${adaptation.type} P: ${period.id} A: ${adaptation.id} ` +\n        `R: ${representation.id} S: ${segmentString}`);\n}\n","import areArraysOfNumbersEqual from \"../utils/are_arrays_of_numbers_equal\";\nimport arrayFind from \"../utils/array_find\";\nimport isNullOrUndefined from \"../utils/is_null_or_undefined\";\nimport getMonotonicTimeStamp from \"../utils/monotonic_timestamp\";\nimport { objectValues } from \"../utils/object_values\";\n/** List in an array every possible value for the Adaptation's `type` property. */\nexport const SUPPORTED_ADAPTATIONS_TYPE = [\"audio\", \"video\", \"text\"];\n/**\n * Returns the theoretical minimum playable position on the content\n * regardless of the current Adaptation chosen, as estimated at parsing\n * time.\n * @param {Object} manifest\n * @returns {number}\n */\nexport function getMinimumSafePosition(manifest) {\n    var _a, _b;\n    const windowData = manifest.timeBounds;\n    if (windowData.timeshiftDepth === null) {\n        return (_a = windowData.minimumSafePosition) !== null && _a !== void 0 ? _a : 0;\n    }\n    const { maximumTimeData } = windowData;\n    let maximumTime;\n    if (!windowData.maximumTimeData.isLinear) {\n        maximumTime = maximumTimeData.maximumSafePosition;\n    }\n    else {\n        const timeDiff = getMonotonicTimeStamp() - maximumTimeData.time;\n        maximumTime = maximumTimeData.maximumSafePosition + timeDiff / 1000;\n    }\n    const theoricalMinimum = maximumTime - windowData.timeshiftDepth;\n    return Math.max((_b = windowData.minimumSafePosition) !== null && _b !== void 0 ? _b : 0, theoricalMinimum);\n}\n/**\n * Get the position of the live edge - that is, the position of what is\n * currently being broadcasted, in seconds.\n * @param {Object} manifest\n * @returns {number|undefined}\n */\nexport function getLivePosition(manifest) {\n    const { maximumTimeData } = manifest.timeBounds;\n    if (!manifest.isLive || maximumTimeData.livePosition === undefined) {\n        return undefined;\n    }\n    if (!maximumTimeData.isLinear) {\n        return maximumTimeData.livePosition;\n    }\n    const timeDiff = getMonotonicTimeStamp() - maximumTimeData.time;\n    return maximumTimeData.livePosition + timeDiff / 1000;\n}\n/**\n * Returns the theoretical maximum playable position on the content\n * regardless of the current Adaptation chosen, as estimated at parsing\n * time.\n * @param {Object} manifest\n * @returns {number}\n */\nexport function getMaximumSafePosition(manifest) {\n    const { maximumTimeData } = manifest.timeBounds;\n    if (!maximumTimeData.isLinear) {\n        return maximumTimeData.maximumSafePosition;\n    }\n    const timeDiff = getMonotonicTimeStamp() - maximumTimeData.time;\n    return maximumTimeData.maximumSafePosition + timeDiff / 1000;\n}\nexport function getSupportedAdaptations(period, type) {\n    if (type === undefined) {\n        return getAdaptations(period).filter((ada) => {\n            return (ada.supportStatus.hasSupportedCodec !== false &&\n                ada.supportStatus.isDecipherable !== false);\n        });\n    }\n    const adaptationsForType = period.adaptations[type];\n    if (adaptationsForType === undefined) {\n        return [];\n    }\n    return adaptationsForType.filter((ada) => {\n        return (ada.supportStatus.hasSupportedCodec !== false &&\n            ada.supportStatus.isDecipherable !== false);\n    });\n}\nexport function getPeriodForTime(manifest, time) {\n    let nextPeriod = null;\n    for (const period of manifest.periods) {\n        if (periodContainsTime(period, time, nextPeriod)) {\n            return period;\n        }\n        nextPeriod = period;\n    }\n}\nexport function getPeriodAfter(manifest, period) {\n    const endOfPeriod = period.end;\n    if (endOfPeriod === undefined) {\n        return null;\n    }\n    const nextPeriod = arrayFind(manifest.periods, (_period) => {\n        return _period.end === undefined || endOfPeriod < _period.end;\n    });\n    return nextPeriod === undefined ? null : nextPeriod;\n}\n/**\n * Returns true if the give time is in the time boundaries of this `Period`.\n * @param {Object} period - The `Period` which we want to check.\n * @param {number} time\n * @param {object|null} nextPeriod - Period coming chronologically just\n * after in the same Manifest. `null` if this instance is the last `Period`.\n * @returns {boolean}\n */\nexport function periodContainsTime(period, time, nextPeriod) {\n    if (time >= period.start && (period.end === undefined || time < period.end)) {\n        return true;\n    }\n    else if (time === period.end &&\n        (nextPeriod === null || nextPeriod.start > period.end)) {\n        // The last possible timed position of a Period is ambiguous as it is\n        // frequently in common with the start of the next one: is it part of\n        // the current or of the next Period?\n        // Here we only consider it part of the current Period if it is the\n        // only one with that position.\n        return true;\n    }\n    return false;\n}\nexport function getAdaptations(period) {\n    const adaptationsByType = period.adaptations;\n    return objectValues(adaptationsByType).reduce(\n    // Note: the second case cannot happen. TS is just being dumb here\n    (acc, adaptations) => !isNullOrUndefined(adaptations) ? acc.concat(adaptations) : acc, []);\n}\n/**\n * Format an `Adaptation`, generally of type `\"audio\"`, as an `IAudioTrack`.\n * @param {Object} adaptation\n * @param {boolean} filterPlayable - If `true` only \"playable\" Representation\n * will be returned.\n * @returns {Object}\n */\nexport function toAudioTrack(adaptation, filterPlayable) {\n    var _a, _b;\n    const formatted = {\n        language: (_a = adaptation.language) !== null && _a !== void 0 ? _a : \"\",\n        normalized: (_b = adaptation.normalizedLanguage) !== null && _b !== void 0 ? _b : \"\",\n        audioDescription: adaptation.isAudioDescription === true,\n        id: adaptation.id,\n        representations: (filterPlayable\n            ? adaptation.representations.filter((r) => isRepresentationPlayable(r) === true)\n            : adaptation.representations).map(toAudioRepresentation),\n        label: adaptation.label,\n    };\n    if (adaptation.isDub === true) {\n        formatted.dub = true;\n    }\n    return formatted;\n}\n/**\n * Format an `Adaptation`, generally of type `\"audio\"`, as an `IAudioTrack`.\n * @param {Object} adaptation\n * @returns {Object}\n */\nexport function toTextTrack(adaptation) {\n    var _a, _b;\n    return {\n        language: (_a = adaptation.language) !== null && _a !== void 0 ? _a : \"\",\n        normalized: (_b = adaptation.normalizedLanguage) !== null && _b !== void 0 ? _b : \"\",\n        closedCaption: adaptation.isClosedCaption === true,\n        id: adaptation.id,\n        label: adaptation.label,\n        forced: adaptation.isForcedSubtitles,\n    };\n}\n/**\n * Format an `Adaptation`, generally of type `\"video\"`, as an `IAudioTrack`.\n * @param {Object} adaptation\n * @param {boolean} filterPlayable - If `true` only \"playable\" Representation\n * will be returned.\n * @returns {Object}\n */\nexport function toVideoTrack(adaptation, filterPlayable) {\n    const trickModeTracks = adaptation.trickModeTracks !== undefined\n        ? adaptation.trickModeTracks.map((trickModeAdaptation) => {\n            const representations = (filterPlayable\n                ? trickModeAdaptation.representations.filter((r) => isRepresentationPlayable(r) === true)\n                : trickModeAdaptation.representations).map(toVideoRepresentation);\n            const trickMode = {\n                id: trickModeAdaptation.id,\n                representations,\n                isTrickModeTrack: true,\n            };\n            if (trickModeAdaptation.isSignInterpreted === true) {\n                trickMode.signInterpreted = true;\n            }\n            return trickMode;\n        })\n        : undefined;\n    const videoTrack = {\n        id: adaptation.id,\n        representations: (filterPlayable\n            ? adaptation.representations.filter((r) => isRepresentationPlayable(r) === true)\n            : adaptation.representations).map(toVideoRepresentation),\n        label: adaptation.label,\n    };\n    if (adaptation.isSignInterpreted === true) {\n        videoTrack.signInterpreted = true;\n    }\n    if (adaptation.isTrickModeTrack === true) {\n        videoTrack.isTrickModeTrack = true;\n    }\n    if (trickModeTracks !== undefined) {\n        videoTrack.trickModeTracks = trickModeTracks;\n    }\n    return videoTrack;\n}\n/**\n * Format Representation as an `IAudioRepresentation`.\n * @returns {Object}\n */\nfunction toAudioRepresentation(representation) {\n    const { id, bitrate, codecs, isSpatialAudio, isSupported, decipherable } = representation;\n    return {\n        id,\n        bitrate,\n        codec: codecs === null || codecs === void 0 ? void 0 : codecs[0],\n        isSpatialAudio,\n        isCodecSupported: isSupported,\n        decipherable,\n    };\n}\n/**\n * Format Representation as an `IVideoRepresentation`.\n * @returns {Object}\n */\nfunction toVideoRepresentation(representation) {\n    const { id, bitrate, frameRate, width, height, codecs, hdrInfo, isSupported, decipherable, contentProtections, } = representation;\n    return {\n        id,\n        bitrate,\n        frameRate,\n        width,\n        height,\n        codec: codecs === null || codecs === void 0 ? void 0 : codecs[0],\n        hdrInfo,\n        isCodecSupported: isSupported,\n        decipherable,\n        contentProtections: contentProtections !== undefined\n            ? {\n                keyIds: contentProtections.keyIds,\n            }\n            : undefined,\n    };\n}\nexport function toTaggedTrack(adaptation) {\n    switch (adaptation.type) {\n        case \"audio\":\n            return { type: \"audio\", track: toAudioTrack(adaptation, false) };\n        case \"video\":\n            return { type: \"video\", track: toVideoTrack(adaptation, false) };\n        case \"text\":\n            return { type: \"text\", track: toTextTrack(adaptation) };\n    }\n}\n/**\n * Returns `true` if the `Representation` has a high chance of being playable on\n * the current device (its codec seems supported and we don't consider it to be\n * un-decipherable).\n *\n * Returns `false` if the `Representation` has a high chance of being unplayable\n * on the current device (its codec seems unsupported and/or we consider it to\n * be un-decipherable).\n *\n * Returns `undefined` if we don't know as the codec has not been checked yet.\n *\n * @param {Object} representation\n * @returns {boolean|undefined}\n */\nexport function isRepresentationPlayable(representation) {\n    if (representation.decipherable === false) {\n        return false;\n    }\n    return representation.isSupported;\n}\n/**\n * Change the decipherability of Representations which have their key id in one\n * of the given Arrays:\n *\n *   - Those who have a key id listed in `whitelistedKeyIds` will have their\n *     decipherability updated to `true`\n *\n *   - Those who have a key id listed in `blacklistedKeyIds` will have their\n *     decipherability updated to `false`\n *\n *   - Those who have a key id listed in `delistedKeyIds` will have their\n *     decipherability updated to `undefined`.\n *\n * @param {Object} manifest\n * @param {Object} updates\n * @param {Array.<Uint8Array>} updates.whitelistedKeyIds\n * @param {Array.<Uint8Array>} updates.blacklistedKeyIds\n * @param {Array.<Uint8Array>} updates.delistedKeyIds\n */\nexport function updateDecipherabilityFromKeyIds(manifest, updates) {\n    const { whitelistedKeyIds, blacklistedKeyIds, delistedKeyIds } = updates;\n    return updateRepresentationsDeciperability(manifest, (representation) => {\n        if (representation.contentProtections === undefined) {\n            return representation.decipherable;\n        }\n        const contentKIDs = representation.contentProtections.keyIds;\n        if (contentKIDs !== undefined) {\n            for (const elt of contentKIDs) {\n                for (const blacklistedKeyId of blacklistedKeyIds) {\n                    if (areArraysOfNumbersEqual(blacklistedKeyId, elt)) {\n                        return false;\n                    }\n                }\n                for (const whitelistedKeyId of whitelistedKeyIds) {\n                    if (areArraysOfNumbersEqual(whitelistedKeyId, elt)) {\n                        return true;\n                    }\n                }\n                for (const delistedKeyId of delistedKeyIds) {\n                    if (areArraysOfNumbersEqual(delistedKeyId, elt)) {\n                        return undefined;\n                    }\n                }\n            }\n        }\n        return representation.decipherable;\n    });\n}\n/**\n * Update decipherability to `false` to any Representation which is linked to\n * the given initialization data.\n * @param {Object} manifest\n * @param {Object} initData\n */\nexport function updateDecipherabilityFromProtectionData(manifest, initData) {\n    return updateRepresentationsDeciperability(manifest, (representation) => {\n        var _a, _b;\n        if (representation.decipherable === false) {\n            return false;\n        }\n        const segmentProtections = (_b = (_a = representation.contentProtections) === null || _a === void 0 ? void 0 : _a.initData) !== null && _b !== void 0 ? _b : [];\n        for (const protection of segmentProtections) {\n            if (initData.type === undefined || protection.type === initData.type) {\n                const containedInitData = initData.values\n                    .getFormattedValues()\n                    .every((undecipherableVal) => {\n                    return protection.values.some((currVal) => {\n                        return ((undecipherableVal.systemId === undefined ||\n                            currVal.systemId === undecipherableVal.systemId) &&\n                            areArraysOfNumbersEqual(currVal.data, undecipherableVal.data));\n                    });\n                });\n                if (containedInitData) {\n                    return false;\n                }\n            }\n        }\n        return representation.decipherable;\n    });\n}\n/**\n * Update `decipherable` property of every `Representation` found in the\n * Manifest based on the result of a `isDecipherable` callback:\n *   - When that callback returns `true`, update `decipherable` to `true`\n *   - When that callback returns `false`, update `decipherable` to `false`\n *   - When that callback returns `undefined`, update `decipherable` to\n *     `undefined`\n * @param {Manifest} manifest\n * @param {Function} isDecipherable\n * @returns {Array.<Object>}\n */\nfunction updateRepresentationsDeciperability(manifest, isDecipherable) {\n    const updates = [];\n    for (const period of manifest.periods) {\n        const adaptationsByType = period.adaptations;\n        const adaptations = objectValues(adaptationsByType).reduce(\n        // Note: the second case cannot happen. TS is just being dumb here\n        (acc, adaps) => (!isNullOrUndefined(adaps) ? acc.concat(adaps) : acc), []);\n        for (const adaptation of adaptations) {\n            let hasOnlyUndecipherableRepresentations = true;\n            for (const representation of adaptation.representations) {\n                const result = isDecipherable(representation);\n                if (result !== false) {\n                    hasOnlyUndecipherableRepresentations = false;\n                }\n                if (result !== representation.decipherable) {\n                    if (result === true) {\n                        adaptation.supportStatus.isDecipherable = true;\n                    }\n                    else if (result === undefined &&\n                        adaptation.supportStatus.isDecipherable === false) {\n                        adaptation.supportStatus.isDecipherable = undefined;\n                    }\n                    updates.push({ manifest, period, adaptation, representation });\n                    representation.decipherable = result;\n                }\n            }\n            if (hasOnlyUndecipherableRepresentations) {\n                adaptation.supportStatus.isDecipherable = false;\n            }\n        }\n    }\n    return updates;\n}\n/**\n *\n * TODO that function is kind of very ugly, yet should work.\n * Maybe find out a better system for Manifest updates.\n * @param {Object} baseManifest\n * @param {Object} newManifest\n * @param {Array.<Object>} updates\n */\nexport function replicateUpdatesOnManifestMetadata(baseManifest, newManifest, updates) {\n    var _a, _b;\n    for (const prop of Object.keys(newManifest)) {\n        if (prop !== \"periods\") {\n            // trust me bro\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n            baseManifest[prop] = newManifest[prop];\n        }\n    }\n    for (const removedPeriod of updates.removedPeriods) {\n        for (let periodIdx = 0; periodIdx < baseManifest.periods.length; periodIdx++) {\n            if (baseManifest.periods[periodIdx].id === removedPeriod.id) {\n                baseManifest.periods.splice(periodIdx, 1);\n                break;\n            }\n        }\n    }\n    for (const updatedPeriod of updates.updatedPeriods) {\n        for (let periodIdx = 0; periodIdx < baseManifest.periods.length; periodIdx++) {\n            const newPeriod = updatedPeriod.period;\n            if (baseManifest.periods[periodIdx].id === updatedPeriod.period.id) {\n                const basePeriod = baseManifest.periods[periodIdx];\n                for (const prop of Object.keys(newPeriod)) {\n                    if (prop !== \"adaptations\") {\n                        // trust me bro\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n                        basePeriod[prop] = newPeriod[prop];\n                    }\n                }\n                for (const removedThumbnailTrack of updatedPeriod.result.removedThumbnailTracks) {\n                    for (let thumbIdx = 0; thumbIdx < basePeriod.thumbnailTracks.length; thumbIdx++) {\n                        if (basePeriod.thumbnailTracks[thumbIdx].id === removedThumbnailTrack.id) {\n                            basePeriod.thumbnailTracks.splice(thumbIdx, 1);\n                            break;\n                        }\n                    }\n                }\n                for (const updatedThumbnailTrack of updatedPeriod.result.updatedThumbnailTracks) {\n                    const newThumbnailTrack = updatedThumbnailTrack;\n                    for (let thumbIdx = 0; thumbIdx < basePeriod.thumbnailTracks.length; thumbIdx++) {\n                        if (basePeriod.thumbnailTracks[thumbIdx].id === newThumbnailTrack.id) {\n                            const baseThumbnailTrack = basePeriod.thumbnailTracks[thumbIdx];\n                            for (const prop of Object.keys(newThumbnailTrack)) {\n                                // eslint-disable-next-line\n                                baseThumbnailTrack[prop] = newThumbnailTrack[prop];\n                            }\n                            break;\n                        }\n                    }\n                }\n                for (const addedThumbnailTrack of updatedPeriod.result.addedThumbnailTracks) {\n                    basePeriod.thumbnailTracks.push(addedThumbnailTrack);\n                }\n                for (const removedAdaptation of updatedPeriod.result.removedAdaptations) {\n                    const ttype = removedAdaptation.trackType;\n                    const adaptationsForType = (_a = basePeriod.adaptations[ttype]) !== null && _a !== void 0 ? _a : [];\n                    for (let adapIdx = 0; adapIdx < adaptationsForType.length; adapIdx++) {\n                        if (adaptationsForType[adapIdx].id === removedAdaptation.id) {\n                            adaptationsForType.splice(adapIdx, 1);\n                            break;\n                        }\n                    }\n                }\n                for (const updatedAdaptation of updatedPeriod.result.updatedAdaptations) {\n                    const newAdaptation = updatedAdaptation.adaptation;\n                    const ttype = updatedAdaptation.trackType;\n                    const adaptationsForType = (_b = basePeriod.adaptations[ttype]) !== null && _b !== void 0 ? _b : [];\n                    for (let adapIdx = 0; adapIdx < adaptationsForType.length; adapIdx++) {\n                        if (adaptationsForType[adapIdx].id === newAdaptation) {\n                            const baseAdaptation = adaptationsForType[adapIdx];\n                            for (const removedRepresentation of updatedAdaptation.removedRepresentations) {\n                                for (let repIdx = 0; repIdx < baseAdaptation.representations.length; repIdx++) {\n                                    if (baseAdaptation.representations[repIdx].id === removedRepresentation) {\n                                        baseAdaptation.representations.splice(repIdx, 1);\n                                        break;\n                                    }\n                                }\n                            }\n                            for (const newRepresentation of updatedAdaptation.updatedRepresentations) {\n                                for (let repIdx = 0; repIdx < baseAdaptation.representations.length; repIdx++) {\n                                    if (baseAdaptation.representations[repIdx].id === newRepresentation.id) {\n                                        const baseRepresentation = baseAdaptation.representations[repIdx];\n                                        for (const prop of Object.keys(newRepresentation)) {\n                                            if (prop !== \"decipherable\") {\n                                                // eslint-disable-next-line\n                                                baseRepresentation[prop] = newRepresentation[prop];\n                                            }\n                                        }\n                                        break;\n                                    }\n                                }\n                            }\n                            for (const addedRepresentation of updatedAdaptation.addedRepresentations) {\n                                baseAdaptation.representations.push(addedRepresentation);\n                            }\n                            break;\n                        }\n                    }\n                }\n                for (const addedAdaptation of updatedPeriod.result.addedAdaptations) {\n                    const ttype = addedAdaptation.type;\n                    const adaptationsForType = basePeriod.adaptations[ttype];\n                    if (adaptationsForType === undefined) {\n                        basePeriod.adaptations[ttype] = [addedAdaptation];\n                    }\n                    else {\n                        adaptationsForType.push(addedAdaptation);\n                    }\n                }\n                break;\n            }\n        }\n    }\n    for (const addedPeriod of updates.addedPeriods) {\n        for (let periodIdx = 0; periodIdx < baseManifest.periods.length; periodIdx++) {\n            if (baseManifest.periods[periodIdx].start > addedPeriod.start) {\n                baseManifest.periods.splice(periodIdx, 0, addedPeriod);\n                break;\n            }\n        }\n        baseManifest.periods.push(addedPeriod);\n    }\n}\nexport function createRepresentationFilterFromFnString(fnString) {\n    // eslint-disable-next-line @typescript-eslint/no-implied-eval\n    return new Function(`return (${fnString}(arguments[0], arguments[1]))`);\n}\n","import { MediaSource_ } from \"../compat/browser_compatibility_types\";\nimport tryToChangeSourceBufferType from \"../compat/change_source_buffer_type\";\nimport { onSourceClose, onSourceEnded, onSourceOpen } from \"../compat/event_listeners\";\nimport { MediaError, SourceBufferError } from \"../errors\";\nimport log from \"../log\";\nimport { concat } from \"../utils/byte_parsing\";\nimport EventEmitter from \"../utils/event_emitter\";\nimport isNullOrUndefined from \"../utils/is_null_or_undefined\";\nimport objectAssign from \"../utils/object_assign\";\nimport { convertToRanges } from \"../utils/ranges\";\nimport TaskCanceller, { CancellationError } from \"../utils/task_canceller\";\nimport { maintainEndOfStream } from \"./utils/end_of_stream\";\nimport MediaSourceDurationUpdater from \"./utils/media_source_duration_updater\";\n/**\n * `IMediaSourceInterface` object for when the MSE API are directly available.\n * @see IMediaSourceInterface\n * @class {MainMediaSourceInterface}\n */\nexport default class MainMediaSourceInterface extends EventEmitter {\n    /**\n     * Creates a new `MainMediaSourceInterface` alongside its `MediaSource` MSE\n     * object.\n     *\n     * You can then obtain a link to that `MediaSource`, for example to link it\n     * to an `HTMLMediaElement`, through the `handle` property.\n     */\n    constructor(id) {\n        super();\n        this.id = id;\n        this.sourceBuffers = [];\n        this._canceller = new TaskCanceller();\n        if (isNullOrUndefined(MediaSource_)) {\n            throw new MediaError(\"MEDIA_SOURCE_NOT_SUPPORTED\", \"No MediaSource Object was found in the current browser.\");\n        }\n        log.info(\"Init: Creating MediaSource\");\n        const mediaSource = new MediaSource_();\n        const handle = mediaSource.handle;\n        this.handle = isNullOrUndefined(handle)\n            ? // eslint-disable-next-line @typescript-eslint/no-restricted-types\n                { type: \"media-source\", value: mediaSource }\n            : { type: \"handle\", value: handle };\n        this._mediaSource = mediaSource;\n        this.readyState = mediaSource.readyState;\n        this._durationUpdater = new MediaSourceDurationUpdater(mediaSource);\n        this._endOfStreamCanceller = null;\n        onSourceOpen(mediaSource, () => {\n            this.readyState = mediaSource.readyState;\n            this.trigger(\"mediaSourceOpen\", null);\n        }, this._canceller.signal);\n        onSourceEnded(mediaSource, () => {\n            this.readyState = mediaSource.readyState;\n            this.trigger(\"mediaSourceEnded\", null);\n        }, this._canceller.signal);\n        onSourceClose(mediaSource, () => {\n            this.readyState = mediaSource.readyState;\n            this.trigger(\"mediaSourceClose\", null);\n        }, this._canceller.signal);\n        if (this._mediaSource.streaming !== undefined) {\n            this.streaming = this._mediaSource.streaming;\n        }\n        this._mediaSource.addEventListener(\"startstreaming\", () => {\n            this.streaming = true;\n            this.trigger(\"streamingChanged\", null);\n        });\n        this._mediaSource.addEventListener(\"endstreaming\", () => {\n            this.streaming = false;\n            this.trigger(\"streamingChanged\", null);\n        });\n    }\n    /** @see IMediaSourceInterface */\n    addSourceBuffer(sbType, codec) {\n        const sourceBuffer = this._mediaSource.addSourceBuffer(codec);\n        const sb = new MainSourceBufferInterface(sbType, codec, sourceBuffer);\n        this.sourceBuffers.push(sb);\n        return sb;\n    }\n    /** @see IMediaSourceInterface */\n    setDuration(newDuration, isRealEndKnown) {\n        this._durationUpdater.updateDuration(newDuration, isRealEndKnown);\n    }\n    /** @see IMediaSourceInterface */\n    interruptDurationSetting() {\n        this._durationUpdater.stopUpdating();\n    }\n    /** @see IMediaSourceInterface */\n    maintainEndOfStream() {\n        if (this._endOfStreamCanceller === null) {\n            this._endOfStreamCanceller = new TaskCanceller();\n            this._endOfStreamCanceller.linkToSignal(this._canceller.signal);\n            log.debug(\"Init: end-of-stream order received.\");\n            maintainEndOfStream(this._mediaSource, this._endOfStreamCanceller.signal);\n        }\n    }\n    /** @see IMediaSourceInterface */\n    stopEndOfStream() {\n        if (this._endOfStreamCanceller !== null) {\n            log.debug(\"Init: resume-stream order received.\");\n            this._endOfStreamCanceller.cancel();\n            this._endOfStreamCanceller = null;\n        }\n    }\n    /** @see IMediaSourceInterface */\n    dispose() {\n        this.sourceBuffers.forEach((s) => s.dispose());\n        this._canceller.cancel();\n        resetMediaSource(this._mediaSource);\n    }\n}\n/**\n * `ISourceBufferInterface` object for when the MSE API are directly available.\n * @see ISourceBufferInterface\n * @class {MainSourceBufferInterface}\n */\nexport class MainSourceBufferInterface {\n    /**\n     * Creates a new `SourceBufferInterface` linked to the given `SourceBuffer`\n     * instance.\n     * @param {string} sbType\n     * @param {string} codec\n     * @param {SourceBuffer} sourceBuffer\n     */\n    constructor(sbType, codec, sourceBuffer) {\n        this.type = sbType;\n        this.codec = codec;\n        this._canceller = new TaskCanceller();\n        this._sourceBuffer = sourceBuffer;\n        this._operationQueue = [];\n        this._currentOperations = [];\n        const onError = this._onError.bind(this);\n        const onUpdateEnd = this._onUpdateEnd.bind(this);\n        sourceBuffer.addEventListener(\"updateend\", onUpdateEnd);\n        sourceBuffer.addEventListener(\"error\", onError);\n        this._canceller.signal.register(() => {\n            sourceBuffer.removeEventListener(\"updateend\", onUpdateEnd);\n            sourceBuffer.removeEventListener(\"error\", onError);\n        });\n    }\n    /** @see ISourceBufferInterface */\n    appendBuffer(...args) {\n        log.debug(\"SBI: receiving order to push data to the SourceBuffer\", this.type);\n        return this._addToQueue({\n            operationName: 0 /* SbiOperationName.Push */,\n            params: args,\n        });\n    }\n    /** @see ISourceBufferInterface */\n    remove(start, end) {\n        log.debug(\"SBI: receiving order to remove data from the SourceBuffer\", this.type, start, end);\n        return this._addToQueue({\n            operationName: 1 /* SbiOperationName.Remove */,\n            params: [start, end],\n        });\n    }\n    /** @see ISourceBufferInterface */\n    getBuffered() {\n        try {\n            return convertToRanges(this._sourceBuffer.buffered);\n        }\n        catch (err) {\n            log.error(\"Failed to get buffered time range of SourceBuffer\", this.type, err instanceof Error ? err : null);\n            return [];\n        }\n    }\n    /** @see ISourceBufferInterface */\n    abort() {\n        try {\n            this._sourceBuffer.abort();\n        }\n        catch (err) {\n            log.debug(\"Init: Failed to abort SourceBuffer:\", err instanceof Error ? err : null);\n        }\n        this._emptyCurrentQueue();\n    }\n    /** @see ISourceBufferInterface */\n    dispose() {\n        try {\n            this._sourceBuffer.abort();\n        }\n        catch (_) {\n            // we don't care\n        }\n        this._emptyCurrentQueue();\n    }\n    _onError(evt) {\n        let error;\n        if (evt instanceof Error) {\n            error = evt;\n        }\n        else if (evt.error instanceof Error) {\n            error = evt.error;\n        }\n        else {\n            error = new Error(\"Unknown SourceBuffer Error\");\n        }\n        const currentOps = this._currentOperations;\n        this._currentOperations = [];\n        if (currentOps.length === 0) {\n            log.error(\"SBI: error for an unknown operation\", error);\n        }\n        else {\n            const rejected = new SourceBufferError(error.name, error.message, error.name === \"QuotaExceededError\");\n            for (const op of currentOps) {\n                op.reject(rejected);\n            }\n        }\n    }\n    _onUpdateEnd() {\n        const currentOps = this._currentOperations;\n        this._currentOperations = [];\n        try {\n            for (const op of currentOps) {\n                op.resolve(convertToRanges(this._sourceBuffer.buffered));\n            }\n        }\n        catch (err) {\n            for (const op of currentOps) {\n                if (err instanceof Error && err.name === \"InvalidStateError\") {\n                    // Most likely the SourceBuffer just has been removed from the\n                    // `MediaSource`.\n                    // Just return an empty buffered range.\n                    op.resolve([]);\n                }\n                else {\n                    op.reject(err);\n                }\n            }\n        }\n        this._performNextOperation();\n    }\n    _emptyCurrentQueue() {\n        const error = new CancellationError();\n        if (this._currentOperations.length > 0) {\n            this._currentOperations.forEach((op) => {\n                op.reject(error);\n            });\n            this._currentOperations = [];\n        }\n        if (this._operationQueue.length > 0) {\n            this._operationQueue.forEach((op) => {\n                op.reject(error);\n            });\n            this._operationQueue = [];\n        }\n    }\n    _addToQueue(operation) {\n        return new Promise((resolve, reject) => {\n            const shouldRestartQueue = this._operationQueue.length === 0 && this._currentOperations.length === 0;\n            const queueItem = objectAssign({ resolve, reject }, operation);\n            this._operationQueue.push(queueItem);\n            if (shouldRestartQueue) {\n                this._performNextOperation();\n            }\n        });\n    }\n    _performNextOperation() {\n        var _a, _b, _c, _d, _e;\n        if (this._currentOperations.length !== 0 || this._sourceBuffer.updating) {\n            return;\n        }\n        const nextElem = this._operationQueue.shift();\n        if (nextElem === undefined) {\n            return;\n        }\n        else if (nextElem.operationName === 0 /* SbiOperationName.Push */) {\n            this._currentOperations = [\n                {\n                    operationName: 0 /* SbiOperationName.Push */,\n                    resolve: nextElem.resolve,\n                    reject: nextElem.reject,\n                },\n            ];\n            const ogData = nextElem.params[0];\n            const params = nextElem.params[1];\n            let segmentData = ogData;\n            // In some cases with very poor performances, tens of appendBuffer\n            // requests could be waiting for their turn here.\n            //\n            // Instead of pushing each one, one by one, waiting in-between for each\n            // one's `\"updateend\"` event (which would probably have lot of time\n            // overhead involved, even more considering that we're probably\n            // encountering performance issues), the idea is to concatenate all\n            // similar push operations into one huge segment.\n            //\n            // This seems to have a very large positive effect on the more\n            // extreme scenario, such as low-latency CMAF with very small chunks and\n            // huge CPU usage in the thread doing the push operation.\n            //\n            // Because this should still be relatively rare, we pre-check here\n            // the condition.\n            if (this._operationQueue.length > 0 &&\n                this._operationQueue[0].operationName === 0 /* SbiOperationName.Push */) {\n                let prevU8;\n                if (ogData instanceof ArrayBuffer) {\n                    prevU8 = new Uint8Array(ogData);\n                }\n                else if (ogData instanceof Uint8Array) {\n                    prevU8 = ogData;\n                }\n                else {\n                    prevU8 = new Uint8Array(ogData.buffer);\n                }\n                const toConcat = [prevU8];\n                while (((_a = this._operationQueue[0]) === null || _a === void 0 ? void 0 : _a.operationName) === 0 /* SbiOperationName.Push */) {\n                    const followingElem = this._operationQueue[0];\n                    const cAw = (_b = params.appendWindow) !== null && _b !== void 0 ? _b : [undefined, undefined];\n                    const fAw = (_c = followingElem.params[1].appendWindow) !== null && _c !== void 0 ? _c : [undefined, undefined];\n                    const cTo = (_d = params.timestampOffset) !== null && _d !== void 0 ? _d : 0;\n                    const fTo = (_e = followingElem.params[1].timestampOffset) !== null && _e !== void 0 ? _e : 0;\n                    if (cAw[0] === fAw[0] &&\n                        cAw[1] === fAw[1] &&\n                        params.codec === followingElem.params[1].codec &&\n                        cTo === fTo) {\n                        const newData = followingElem.params[0];\n                        let newU8;\n                        if (newData instanceof ArrayBuffer) {\n                            newU8 = new Uint8Array(newData);\n                        }\n                        else if (newData instanceof Uint8Array) {\n                            newU8 = newData;\n                        }\n                        else {\n                            newU8 = new Uint8Array(newData.buffer);\n                        }\n                        toConcat.push(newU8);\n                        this._operationQueue.splice(0, 1);\n                        this._currentOperations.push({\n                            operationName: 0 /* SbiOperationName.Push */,\n                            resolve: followingElem.resolve,\n                            reject: followingElem.reject,\n                        });\n                    }\n                    else {\n                        break;\n                    }\n                }\n                if (toConcat.length > 1) {\n                    log.info(`MMSI: Merging ${toConcat.length} segments together for perf`, this.type);\n                    segmentData = concat(...toConcat);\n                }\n            }\n            try {\n                this._appendBufferNow(segmentData, params);\n            }\n            catch (err) {\n                const error = err instanceof Error\n                    ? new SourceBufferError(err.name, err.message, err.name === \"QuotaExceededError\")\n                    : new SourceBufferError(\"Error\", \"Unknown SourceBuffer Error during appendBuffer\", false);\n                this._currentOperations.forEach((op) => {\n                    op.reject(error);\n                });\n                this._currentOperations = [];\n                // A synchronous error probably will not lead to updateend event, so we need to\n                // go to next queue element manually\n                //\n                // FIXME: This here is needed to ensure that we're not left with a\n                // dangling queue of operations.\n                // However it can potentially be counter-productive if e.g. the `appendBuffer`\n                // error was due to a full buffer and if there are pushing operations awaiting in\n                // the queue.\n                //\n                // A better solution might just be to reject all push operations right away here?\n                // Only for a `QuotaExceededError` (to check MSE)?\n                // However this is too disruptive for what is now a hotfix\n                this._performNextOperation();\n            }\n        }\n        else {\n            // TODO merge contiguous removes?\n            this._currentOperations = [nextElem];\n            const [start, end] = nextElem.params;\n            log.debug(\"SBI: removing data from SourceBuffer\", this.type, start, end);\n            try {\n                this._sourceBuffer.remove(start, end);\n            }\n            catch (err) {\n                const error = err instanceof Error\n                    ? new SourceBufferError(err.name, err.message, false)\n                    : new SourceBufferError(\"Error\", \"Unknown SourceBuffer Error during remove\", false);\n                nextElem.reject(error);\n                this._currentOperations.forEach((op) => {\n                    op.reject(error);\n                });\n                this._currentOperations = [];\n                // A synchronous error probably will not lead to updateend event, so we need to\n                // go to next queue element manually\n                this._performNextOperation();\n            }\n        }\n    }\n    _appendBufferNow(data, params) {\n        const sourceBuffer = this._sourceBuffer;\n        const { codec, timestampOffset, appendWindow = [] } = params;\n        if (codec !== undefined && codec !== this.codec) {\n            log.debug(\"SBI: updating codec\", codec);\n            const hasUpdatedSourceBufferType = tryToChangeSourceBufferType(sourceBuffer, codec);\n            if (hasUpdatedSourceBufferType) {\n                this.codec = codec;\n            }\n            else {\n                log.debug(\"SBI: could not update codec\", codec, this.codec);\n            }\n        }\n        if (timestampOffset !== undefined &&\n            sourceBuffer.timestampOffset !== timestampOffset) {\n            const newTimestampOffset = timestampOffset;\n            log.debug(\"SBI: updating timestampOffset\", codec, sourceBuffer.timestampOffset, newTimestampOffset);\n            sourceBuffer.timestampOffset = newTimestampOffset;\n        }\n        if (appendWindow[0] === undefined) {\n            if (sourceBuffer.appendWindowStart > 0) {\n                log.debug(\"SBI: re-setting `appendWindowStart` to `0`\");\n                sourceBuffer.appendWindowStart = 0;\n            }\n        }\n        else if (appendWindow[0] !== sourceBuffer.appendWindowStart) {\n            if (appendWindow[0] >= sourceBuffer.appendWindowEnd) {\n                const newTmpEnd = appendWindow[0] + 1;\n                log.debug(\"SBI: pre-updating `appendWindowEnd`\", newTmpEnd);\n                sourceBuffer.appendWindowEnd = newTmpEnd;\n            }\n            log.debug(\"SBI: setting `appendWindowStart`\", appendWindow[0]);\n            sourceBuffer.appendWindowStart = appendWindow[0];\n        }\n        if (appendWindow[1] === undefined) {\n            if (sourceBuffer.appendWindowEnd !== Infinity) {\n                log.debug(\"SBI: re-setting `appendWindowEnd` to `Infinity`\");\n                sourceBuffer.appendWindowEnd = Infinity;\n            }\n        }\n        else if (appendWindow[1] !== sourceBuffer.appendWindowEnd) {\n            log.debug(\"SBI: setting `appendWindowEnd`\", appendWindow[1]);\n            sourceBuffer.appendWindowEnd = appendWindow[1];\n        }\n        log.debug(\"SBI: pushing segment\", this.type);\n        sourceBuffer.appendBuffer(data);\n    }\n}\nfunction resetMediaSource(mediaSource) {\n    if (mediaSource.readyState !== \"closed\") {\n        const { readyState, sourceBuffers } = mediaSource;\n        for (let i = sourceBuffers.length - 1; i >= 0; i--) {\n            const sourceBuffer = sourceBuffers[i];\n            try {\n                if (readyState === \"open\") {\n                    log.info(\"Init: Aborting SourceBuffer before removing\");\n                    try {\n                        sourceBuffer.abort();\n                    }\n                    catch (_) {\n                        // We actually don't care at all when resetting\n                    }\n                }\n                log.info(\"Init: Removing SourceBuffer from mediaSource\");\n                mediaSource.removeSourceBuffer(sourceBuffer);\n            }\n            catch (_) {\n                // We actually don't care at all when resetting\n            }\n        }\n        if (sourceBuffers.length > 0) {\n            log.info(\"Init: Not all SourceBuffers could have been removed.\");\n        }\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { onRemoveSourceBuffers, onSourceOpen, onSourceBufferUpdate, } from \"../../compat/event_listeners\";\nimport log from \"../../log\";\nimport TaskCanceller from \"../../utils/task_canceller\";\n/**\n * Get \"updating\" SourceBuffers from a SourceBufferList.\n * @param {SourceBufferList} sourceBuffers\n * @returns {Array.<SourceBuffer>}\n */\nfunction getUpdatingSourceBuffers(sourceBuffers) {\n    const updatingSourceBuffers = [];\n    for (let i = 0; i < sourceBuffers.length; i++) {\n        const SourceBuffer = sourceBuffers[i];\n        if (SourceBuffer.updating) {\n            updatingSourceBuffers.push(SourceBuffer);\n        }\n    }\n    return updatingSourceBuffers;\n}\n/**\n * Trigger the `endOfStream` method of a MediaSource.\n *\n * If the MediaSource is ended/closed, do not call this method.\n * If SourceBuffers are updating, wait for them to be updated before closing\n * it.\n * @param {MediaSource} mediaSource\n * @param {Object} cancelSignal\n */\nexport default function triggerEndOfStream(mediaSource, cancelSignal) {\n    log.debug(\"Init: Trying to call endOfStream\");\n    if (mediaSource.readyState !== \"open\") {\n        log.debug(\"Init: MediaSource not open, cancel endOfStream\");\n        return;\n    }\n    const { sourceBuffers } = mediaSource;\n    const updatingSourceBuffers = getUpdatingSourceBuffers(sourceBuffers);\n    if (updatingSourceBuffers.length === 0) {\n        log.info(\"Init: Triggering end of stream\");\n        try {\n            mediaSource.endOfStream();\n        }\n        catch (err) {\n            log.error(\"Unable to call endOfStream\", err instanceof Error ? err : new Error(\"Unknown error\"));\n        }\n        return;\n    }\n    log.debug(\"Init: Waiting SourceBuffers to be updated before calling endOfStream.\");\n    const innerCanceller = new TaskCanceller();\n    innerCanceller.linkToSignal(cancelSignal);\n    for (const sourceBuffer of updatingSourceBuffers) {\n        onSourceBufferUpdate(sourceBuffer, () => {\n            innerCanceller.cancel();\n            triggerEndOfStream(mediaSource, cancelSignal);\n        }, innerCanceller.signal);\n    }\n    onRemoveSourceBuffers(sourceBuffers, () => {\n        innerCanceller.cancel();\n        triggerEndOfStream(mediaSource, cancelSignal);\n    }, innerCanceller.signal);\n}\n/**\n * Trigger the `endOfStream` method of a MediaSource each times it opens.\n * @see triggerEndOfStream\n * @param {MediaSource} mediaSource\n * @param {Object} cancelSignal\n */\nexport function maintainEndOfStream(mediaSource, cancelSignal) {\n    let endOfStreamCanceller = new TaskCanceller();\n    endOfStreamCanceller.linkToSignal(cancelSignal);\n    onSourceOpen(mediaSource, () => {\n        log.debug(\"Init: MediaSource re-opened while end-of-stream is active\");\n        endOfStreamCanceller.cancel();\n        endOfStreamCanceller = new TaskCanceller();\n        endOfStreamCanceller.linkToSignal(cancelSignal);\n        triggerEndOfStream(mediaSource, endOfStreamCanceller.signal);\n    }, cancelSignal);\n    triggerEndOfStream(mediaSource, endOfStreamCanceller.signal);\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { onSourceOpen, onSourceEnded, onSourceClose } from \"../../compat/event_listeners\";\nimport hasIssuesWithHighMediaSourceDuration from \"../../compat/has_issues_with_high_media_source_duration\";\nimport log from \"../../log\";\nimport SharedReference from \"../../utils/reference\";\nimport TaskCanceller from \"../../utils/task_canceller\";\n/** Number of seconds in a regular year. */\nconst YEAR_IN_SECONDS = 365 * 24 * 3600;\n/**\n * Keep the MediaSource's `duration` attribute up-to-date with the duration of\n * the content played on it.\n * @class MediaSourceDurationUpdater\n */\nexport default class MediaSourceDurationUpdater {\n    /**\n     * Create a new `MediaSourceDurationUpdater`,\n     * @param {MediaSource} mediaSource - The MediaSource on which the content is\n     * played.\n     */\n    constructor(mediaSource) {\n        this._mediaSource = mediaSource;\n        this._currentMediaSourceDurationUpdateCanceller = null;\n    }\n    /**\n     * Indicate to the `MediaSourceDurationUpdater` the currently known duration\n     * of the content.\n     *\n     * The `MediaSourceDurationUpdater` will then use that value to determine\n     * which `duration` attribute should be set on the `MediaSource` associated\n     *\n     * @param {number} newDuration\n     * @param {boolean} isRealEndKnown - If set to `false`, the current content is\n     * a dynamic content (it might evolve in the future) and the `newDuration`\n     * communicated might be greater still. In effect the\n     * `MediaSourceDurationUpdater` will actually set a much higher value to the\n     * `MediaSource`'s duration to prevent being annoyed by the HTML-related\n     * side-effects of having a too low duration (such as the impossibility to\n     * seek over that value).\n     */\n    updateDuration(newDuration, isRealEndKnown) {\n        if (this._currentMediaSourceDurationUpdateCanceller !== null) {\n            this._currentMediaSourceDurationUpdateCanceller.cancel();\n        }\n        this._currentMediaSourceDurationUpdateCanceller = new TaskCanceller();\n        const mediaSource = this._mediaSource;\n        const currentSignal = this._currentMediaSourceDurationUpdateCanceller.signal;\n        const isMediaSourceOpened = createMediaSourceOpenReference(mediaSource, currentSignal);\n        /** TaskCanceller triggered each time the MediaSource switches to and from \"open\". */\n        let msOpenStatusCanceller = new TaskCanceller();\n        msOpenStatusCanceller.linkToSignal(currentSignal);\n        isMediaSourceOpened.onUpdate(onMediaSourceOpenedStatusChanged, {\n            emitCurrentValue: true,\n            clearSignal: currentSignal,\n        });\n        function onMediaSourceOpenedStatusChanged() {\n            msOpenStatusCanceller.cancel();\n            if (!isMediaSourceOpened.getValue()) {\n                return;\n            }\n            msOpenStatusCanceller = new TaskCanceller();\n            msOpenStatusCanceller.linkToSignal(currentSignal);\n            const areSourceBuffersUpdating = createSourceBuffersUpdatingReference(mediaSource.sourceBuffers, msOpenStatusCanceller.signal);\n            /** TaskCanceller triggered each time SourceBuffers' updating status changes */\n            let sourceBuffersUpdatingCanceller = new TaskCanceller();\n            sourceBuffersUpdatingCanceller.linkToSignal(msOpenStatusCanceller.signal);\n            return areSourceBuffersUpdating.onUpdate((areUpdating) => {\n                sourceBuffersUpdatingCanceller.cancel();\n                sourceBuffersUpdatingCanceller = new TaskCanceller();\n                sourceBuffersUpdatingCanceller.linkToSignal(msOpenStatusCanceller.signal);\n                if (areUpdating) {\n                    return;\n                }\n                recursivelyForceDurationUpdate(mediaSource, newDuration, isRealEndKnown, sourceBuffersUpdatingCanceller.signal);\n            }, { clearSignal: msOpenStatusCanceller.signal, emitCurrentValue: true });\n        }\n    }\n    /**\n     * Abort the last duration-setting operation and free its resources.\n     */\n    stopUpdating() {\n        if (this._currentMediaSourceDurationUpdateCanceller !== null) {\n            this._currentMediaSourceDurationUpdateCanceller.cancel();\n            this._currentMediaSourceDurationUpdateCanceller = null;\n        }\n    }\n}\n/**\n * Checks that duration can be updated on the MediaSource, and then\n * sets it.\n *\n * Returns either:\n *   - the new duration it has been updated to if it has\n *   - `null` if it hasn'nt been updated\n *\n * @param {MediaSource} mediaSource\n * @param {number} duration\n * @param {boolean} isRealEndKnown\n * @returns {string}\n */\nfunction setMediaSourceDuration(mediaSource, duration, isRealEndKnown) {\n    let newDuration = duration;\n    if (!isRealEndKnown) {\n        newDuration = hasIssuesWithHighMediaSourceDuration()\n            ? Infinity\n            : getMaximumLiveSeekablePosition(duration);\n    }\n    let maxBufferedEnd = 0;\n    for (let i = 0; i < mediaSource.sourceBuffers.length; i++) {\n        const sourceBuffer = mediaSource.sourceBuffers[i];\n        const sbBufferedLen = sourceBuffer.buffered.length;\n        if (sbBufferedLen > 0) {\n            maxBufferedEnd = Math.max(sourceBuffer.buffered.end(sbBufferedLen - 1));\n        }\n    }\n    if (newDuration === mediaSource.duration) {\n        return \"success\" /* MediaSourceDurationUpdateStatus.Success */;\n    }\n    else if (maxBufferedEnd > newDuration) {\n        // We already buffered further than the duration we want to set.\n        // Keep the duration that was set at that time as a security.\n        if (maxBufferedEnd < mediaSource.duration) {\n            try {\n                log.info(\"Init: Updating duration to what is currently buffered\", maxBufferedEnd);\n                mediaSource.duration = maxBufferedEnd;\n            }\n            catch (err) {\n                log.warn(\"Duration Updater: Can't update duration on the MediaSource.\", err instanceof Error ? err : \"\");\n                return \"failed\" /* MediaSourceDurationUpdateStatus.Failed */;\n            }\n        }\n        return \"partial\" /* MediaSourceDurationUpdateStatus.Partial */;\n    }\n    else {\n        const oldDuration = mediaSource.duration;\n        try {\n            log.info(\"Init: Updating duration\", newDuration);\n            mediaSource.duration = newDuration;\n            if (mediaSource.readyState === \"open\" && !isFinite(newDuration)) {\n                const maxSeekable = getMaximumLiveSeekablePosition(duration);\n                log.info(\"Init: calling `mediaSource.setLiveSeekableRange`\", maxSeekable);\n                mediaSource.setLiveSeekableRange(0, maxSeekable);\n            }\n        }\n        catch (err) {\n            log.warn(\"Duration Updater: Can't update duration on the MediaSource.\", err instanceof Error ? err : \"\");\n            return \"failed\" /* MediaSourceDurationUpdateStatus.Failed */;\n        }\n        const deltaToExpected = Math.abs(mediaSource.duration - newDuration);\n        if (deltaToExpected >= 0.1) {\n            const deltaToBefore = Math.abs(mediaSource.duration - oldDuration);\n            return deltaToExpected < deltaToBefore\n                ? \"partial\" /* MediaSourceDurationUpdateStatus.Partial */\n                : \"failed\" /* MediaSourceDurationUpdateStatus.Failed */;\n        }\n        return \"success\" /* MediaSourceDurationUpdateStatus.Success */;\n    }\n}\n/**\n * Returns a `SharedReference` wrapping a boolean that tells if all the\n * SourceBuffers ended all pending updates.\n * @param {SourceBufferList} sourceBuffers\n * @param {Object} cancelSignal\n * @returns {Object}\n */\nfunction createSourceBuffersUpdatingReference(sourceBuffers, cancelSignal) {\n    if (sourceBuffers.length === 0) {\n        const notOpenedRef = new SharedReference(false);\n        notOpenedRef.finish();\n        return notOpenedRef;\n    }\n    const areUpdatingRef = new SharedReference(false, cancelSignal);\n    reCheck();\n    for (let i = 0; i < sourceBuffers.length; i++) {\n        const sourceBuffer = sourceBuffers[i];\n        sourceBuffer.addEventListener(\"updatestart\", reCheck);\n        sourceBuffer.addEventListener(\"update\", reCheck);\n        cancelSignal.register(() => {\n            sourceBuffer.removeEventListener(\"updatestart\", reCheck);\n            sourceBuffer.removeEventListener(\"update\", reCheck);\n        });\n    }\n    return areUpdatingRef;\n    function reCheck() {\n        for (let i = 0; i < sourceBuffers.length; i++) {\n            const sourceBuffer = sourceBuffers[i];\n            if (sourceBuffer.updating) {\n                areUpdatingRef.setValueIfChanged(true);\n                return;\n            }\n        }\n        areUpdatingRef.setValueIfChanged(false);\n    }\n}\n/**\n * Returns a `SharedReference` wrapping a boolean that tells if the media\n * source is opened or not.\n * @param {MediaSource} mediaSource\n * @param {Object} cancelSignal\n * @returns {Object}\n */\nfunction createMediaSourceOpenReference(mediaSource, cancelSignal) {\n    const isMediaSourceOpen = new SharedReference(mediaSource.readyState === \"open\", cancelSignal);\n    onSourceOpen(mediaSource, () => {\n        log.debug(\"Init: Reacting to MediaSource open in duration updater\");\n        isMediaSourceOpen.setValueIfChanged(true);\n    }, cancelSignal);\n    onSourceEnded(mediaSource, () => {\n        log.debug(\"Init: Reacting to MediaSource ended in duration updater\");\n        isMediaSourceOpen.setValueIfChanged(false);\n    }, cancelSignal);\n    onSourceClose(mediaSource, () => {\n        log.debug(\"Init: Reacting to MediaSource close in duration updater\");\n        isMediaSourceOpen.setValueIfChanged(false);\n    }, cancelSignal);\n    return isMediaSourceOpen;\n}\n/**\n * Immediately tries to set the MediaSource's duration to the most appropriate\n * one.\n *\n * If it fails, wait 2 seconds and retries.\n *\n * @param {MediaSource} mediaSource\n * @param {number} duration\n * @param {boolean} isRealEndKnown\n * @param {Object} cancelSignal\n */\nfunction recursivelyForceDurationUpdate(mediaSource, duration, isRealEndKnown, cancelSignal) {\n    const res = setMediaSourceDuration(mediaSource, duration, isRealEndKnown);\n    if (res === \"success\" /* MediaSourceDurationUpdateStatus.Success */) {\n        return;\n    }\n    const timeoutId = setTimeout(() => {\n        unregisterClear();\n        recursivelyForceDurationUpdate(mediaSource, duration, isRealEndKnown, cancelSignal);\n    }, 2000);\n    const unregisterClear = cancelSignal.register(() => {\n        clearTimeout(timeoutId);\n    });\n}\nfunction getMaximumLiveSeekablePosition(contentLastPosition) {\n    // Some targets poorly support setting a very high number for seekable\n    // ranges.\n    // Yet, in contents whose end is not yet known (e.g. live contents), we\n    // would prefer setting a value as high as possible to still be able to\n    // seek anywhere we want to (even ahead of the Manifest if we want to).\n    // As such, we put it at a safe default value of 2^32 excepted when the\n    // maximum position is already relatively close to that value, where we\n    // authorize exceptionally going over it.\n    return Math.max(Math.pow(2, 32), contentLastPosition + YEAR_IN_SECONDS);\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Maximum integer that can be stored on 32 bits.\n *\n * This can be used for example to know what is the maximum ISOBMFF box size\n * that can be stored on the first four bytes of a box. Any value higher than\n * that will need 8 bytes (64 bits) to be stored.\n */\nexport const MAX_32_BIT_INT = Math.pow(2, 32) - 1;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { concat, itobe4, itobe8 } from \"../../../utils/byte_parsing\";\nimport { strToUtf8 } from \"../../../utils/string_parsing\";\nimport { MAX_32_BIT_INT } from \"./constants\";\n/**\n * Speed up string to bytes conversion by memorizing the result\n *\n * The keys here are ISOBMFF box names. The values are the corresponding\n * bytes conversion for putting as an ISOBMFF boxes.\n *\n * Used by the boxName method.\n * @type {Object}\n */\nconst boxNamesMem = {};\n/**\n * Convert the string name of an ISOBMFF box into the corresponding bytes.\n * Has a memorization mechanism to speed-up if you want to translate the\n * same string multiple times.\n * @param {string} str\n * @returns {Uint8Array}\n */\nfunction boxName(str) {\n    if (boxNamesMem[str] !== undefined) {\n        return boxNamesMem[str];\n    }\n    const nameInBytes = strToUtf8(str);\n    boxNamesMem[str] = nameInBytes;\n    return nameInBytes;\n}\n/**\n * Create a new ISOBMFF \"box\" with the given name.\n * @param {string} name - name of the box you want to create, must always\n * be 4 characters (uuid boxes not supported)\n * @param {Uint8Array} buff - content of the box\n * @returns {Uint8Array} - The entire ISOBMFF box (length+name+content)\n */\nfunction createBox(name, buff) {\n    const len = buff.length + 8;\n    return len <= MAX_32_BIT_INT\n        ? concat(itobe4(len), boxName(name), buff)\n        : concat(itobe4(1), boxName(name), itobe8(len + 8), buff);\n}\n/**\n * @param {string} name\n * @param {Array.<Uint8Array>} children\n * @returns {Uint8Array}\n */\nfunction createBoxWithChildren(name, children) {\n    return createBox(name, concat(...children));\n}\nexport { createBox, createBoxWithChildren };\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { base64ToBytes } from \"../../../../utils/base64\";\nimport { le2toi } from \"../../../../utils/byte_parsing\";\nimport { bytesToHex, guidToUuid, utf16LEToStr } from \"../../../../utils/string_parsing\";\n/**\n * Parse PlayReady privateData to get its Hexa-coded KeyID.\n * @param {Uint8Array} privateData\n * @returns {string}\n */\nexport function getPlayReadyKIDFromPrivateData(data) {\n    const xmlLength = le2toi(data, 8);\n    const xml = utf16LEToStr(data.subarray(10, xmlLength + 10));\n    const doc = new DOMParser().parseFromString(xml, \"application/xml\");\n    const kidElement = doc.querySelector(\"KID\");\n    if (kidElement === null) {\n        throw new Error(\"Cannot parse PlayReady private data: invalid XML\");\n    }\n    const b64guidKid = kidElement.textContent === null ? \"\" : kidElement.textContent;\n    const uuidKid = guidToUuid(base64ToBytes(b64guidKid));\n    return bytesToHex(uuidKid).toLowerCase();\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { be4toi } from \"../../../utils/byte_parsing\";\nimport findCompleteBox from \"./find_complete_box\";\n/**\n * Take a chunk of ISOBMFF data and extract complete `moof`+`mdat` subsegments\n * which are ready to be decoded.\n * Returns a tuple of two containing first an array of those subsegments\n * followed by the last un-decodable part.\n * @param {Uint8Array} buffer\n * @returns {Array}\n */\nexport default function extractCompleteChunks(buffer) {\n    let _position = 0;\n    const chunks = [];\n    let currentBuffer = null;\n    while (_position <= buffer.length) {\n        if (_position === buffer.length) {\n            currentBuffer = null;\n            break;\n        }\n        currentBuffer = buffer.subarray(_position, Infinity);\n        const moofIndex = findCompleteBox(currentBuffer, 0x6d6f6f66 /* moof */);\n        if (moofIndex < 0) {\n            // no moof, not a media segment.\n            break;\n        }\n        const moofLen = be4toi(buffer, moofIndex + _position);\n        const moofEnd = _position + moofIndex + moofLen;\n        if (moofEnd > buffer.length) {\n            // not a complete moof segment\n            break;\n        }\n        const mdatIndex = findCompleteBox(currentBuffer, 0x6d646174 /* mdat */);\n        if (mdatIndex < 0) {\n            // no mdat, not a segment.\n            break;\n        }\n        const mdatLen = be4toi(buffer, mdatIndex + _position);\n        const mdatEnd = _position + mdatIndex + mdatLen;\n        if (mdatEnd > buffer.length) {\n            // not a complete mdat segment\n            break;\n        }\n        const maxEnd = Math.max(moofEnd, mdatEnd);\n        const chunk = buffer.subarray(_position, maxEnd);\n        chunks.push(chunk);\n        _position = maxEnd;\n    }\n    if (chunks.length === 0) {\n        return [null, currentBuffer];\n    }\n    return [chunks, currentBuffer];\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { be4toi, be8toi } from \"../../../utils/byte_parsing\";\n/**\n * Find the offset for the first declaration of the given box in an isobmff.\n * Returns -1 if not found or if incomplete.\n *\n * This function does not throw or log in case of partial segments.\n * @param {Uint8Array} buf - the isobmff\n * @param {Number} wantedName\n * @returns {Number} - Offset where the box begins. -1 if not found.\n */\nexport default function findCompleteBox(buf, wantedName) {\n    const len = buf.length;\n    let i = 0;\n    while (i + 8 <= len) {\n        let size = be4toi(buf, i);\n        if (size === 0) {\n            size = len - i;\n        }\n        else if (size === 1) {\n            if (i + 16 > len) {\n                return -1;\n            }\n            size = be8toi(buf, i + 8);\n        }\n        if (isNaN(size) || size <= 0) {\n            // should not happen\n            return -1;\n        }\n        const name = be4toi(buf, i + 4);\n        if (name === wantedName) {\n            if (i + size <= len) {\n                return i;\n            }\n            return -1;\n        }\n        i += size;\n    }\n    return -1;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../../log\";\nimport assert from \"../../../utils/assert\";\nimport { be4toi, be8toi } from \"../../../utils/byte_parsing\";\n/**\n * From a given buffer representing ISOBMFF data, browses inner boxes in\n * `childNames`, each element being a child box of the one before it.\n * Returns `null` if one of the child (or if the parent) is not found.\n * @param {Uint8Array} buf\n * @param {number[]} childNames\n * @returns {Uint8Array|null}\n */\nfunction getChildBox(buf, childNames) {\n    let currBox = buf;\n    for (const childName of childNames) {\n        const box = getBoxContent(currBox, childName);\n        if (box === null) {\n            return null;\n        }\n        currBox = box;\n    }\n    return currBox;\n}\n/**\n * Returns the content of a box based on its name.\n * `null` if not found.\n * @param {Uint8Array} buf - the isobmff data\n * @param {Number} boxName - the 4-letter 'name' of the box as a 4 byte integer\n * generated from encoding the corresponding ASCII in big endian.\n * @returns {UInt8Array|null}\n */\nfunction getBoxContent(buf, boxName) {\n    const offsets = getBoxOffsets(buf, boxName);\n    return offsets !== null ? buf.subarray(offsets[1], offsets[2]) : null;\n}\n/**\n * Reads the whole ISOBMFF and returns the content of all boxes with the given\n * name, in order.\n * @param {Uint8Array} buf - the isobmff data\n * @param {Number} boxName - the 4-letter 'name' of the box as a 4 byte integer\n * generated from encoding the corresponding ASCII in big endian.\n * @returns {Array.<Uint8Array>}\n */\nfunction getBoxesContent(buf, boxName) {\n    const ret = [];\n    let currentBuf = buf;\n    while (true) {\n        const offsets = getBoxOffsets(currentBuf, boxName);\n        if (offsets === null) {\n            return ret;\n        }\n        // Guard against a (very highly improbable) infinite loop\n        assert(offsets[2] !== 0 && currentBuf.length !== 0);\n        ret.push(currentBuf.subarray(offsets[1], offsets[2]));\n        currentBuf = currentBuf.subarray(offsets[2]);\n    }\n}\n/**\n * Returns an ISOBMFF box - size and name included - based on its name.\n * `null` if not found.\n * @param {Uint8Array} buf - the isobmff data\n * @param {Number} boxName - the 4-letter 'name' of the box as a 4 byte integer\n * generated from encoding the corresponding ASCII in big endian.\n * @returns {UInt8Array|null}\n */\nfunction getBox(buf, boxName) {\n    const offsets = getBoxOffsets(buf, boxName);\n    return offsets !== null ? buf.subarray(offsets[0], offsets[2]) : null;\n}\n/**\n * Returns byte offsets for the start of the box, the start of its content and\n * the end of the box (not inclusive).\n *\n * `null` if not found.\n *\n * If found, the tuple returned has three elements, all numbers:\n *   1. The starting byte corresponding to the start of the box (from its size)\n *   2. The beginning of the box content - meaning the first byte after the\n *      size and the name of the box.\n *   3. The first byte after the end of the box, might be equal to `buf`'s\n *      length if we're considering the last box.\n * @param {Uint8Array} buf - the isobmff data\n * @param {Number} boxName - the 4-letter 'name' of the box as a 4 byte integer\n * generated from encoding the corresponding ASCII in big endian.\n * @returns {Array.<number>|null}\n */\nfunction getBoxOffsets(buf, boxName) {\n    const len = buf.length;\n    let boxBaseOffset = 0;\n    let name;\n    let lastBoxSize = 0;\n    let lastOffset;\n    while (boxBaseOffset + 8 <= len) {\n        lastOffset = boxBaseOffset;\n        lastBoxSize = be4toi(buf, lastOffset);\n        lastOffset += 4;\n        name = be4toi(buf, lastOffset);\n        lastOffset += 4;\n        if (lastBoxSize === 0) {\n            lastBoxSize = len - boxBaseOffset;\n        }\n        else if (lastBoxSize === 1) {\n            if (lastOffset + 8 > len) {\n                return null;\n            }\n            lastBoxSize = be8toi(buf, lastOffset);\n            lastOffset += 8;\n        }\n        if (lastBoxSize < 0) {\n            throw new Error(\"ISOBMFF: Size out of range\");\n        }\n        if (name === boxName) {\n            if (boxName === 0x75756964 /* === \"uuid\" */) {\n                lastOffset += 16; // Skip uuid name\n            }\n            return [boxBaseOffset, lastOffset, boxBaseOffset + lastBoxSize];\n        }\n        else {\n            boxBaseOffset += lastBoxSize;\n        }\n    }\n    return null;\n}\n/**\n * Gives the content of a specific UUID box.\n * `undefined` if that box is not found.\n *\n * If found, the returned Uint8Array contains just the box's content: the box\n * without its name and size.\n * @param {Uint8Array} buf\n * @param {Number} id1\n * @param {Number} id2\n * @param {Number} id3\n * @param {Number} id4\n * @returns {Uint8Array|undefined}\n */\nfunction getUuidContent(buf, id1, id2, id3, id4) {\n    const len = buf.length;\n    let boxSize;\n    for (let boxBaseOffset = 0; boxBaseOffset < len; boxBaseOffset += boxSize) {\n        let currentOffset = boxBaseOffset;\n        boxSize = be4toi(buf, currentOffset);\n        currentOffset += 4;\n        const boxName = be4toi(buf, currentOffset);\n        currentOffset += 4;\n        if (boxSize === 0) {\n            boxSize = len - boxBaseOffset;\n        }\n        else if (boxSize === 1) {\n            if (currentOffset + 8 > len) {\n                return undefined;\n            }\n            boxSize = be8toi(buf, currentOffset);\n            currentOffset += 8;\n        }\n        if (boxName === 0x75756964 /* === \"uuid\" */ &&\n            currentOffset + 16 <= len &&\n            be4toi(buf, currentOffset) === id1 &&\n            be4toi(buf, currentOffset + 4) === id2 &&\n            be4toi(buf, currentOffset + 8) === id3 &&\n            be4toi(buf, currentOffset + 12) === id4) {\n            currentOffset += 16;\n            return buf.subarray(currentOffset, boxBaseOffset + boxSize);\n        }\n    }\n}\n/**\n * For the next encountered box, return byte offsets corresponding to:\n *   1. the starting byte offset for the next box (should always be equal to\n *       `0`).\n *   2. The beginning of the box content - meaning the first byte after the\n *      size and the name of the box.\n *   3. The first byte after the end of the box, might be equal to `buf`'s\n *      length if we're considering the last box.\n *\n * `null` if no box is found.\n * @param {Uint8Array} buf - the isobmff data\n * @param {Number} boxName - the 4-letter 'name' of the box as a 4 byte integer\n * generated from encoding the corresponding ASCII in big endian.\n */\nfunction getNextBoxOffsets(buf) {\n    const len = buf.length;\n    if (len < 8) {\n        log.warn(\"ISOBMFF: box inferior to 8 bytes, cannot find offsets\");\n        return null;\n    }\n    let lastOffset = 0;\n    let boxSize = be4toi(buf, lastOffset);\n    lastOffset += 4;\n    const name = be4toi(buf, lastOffset);\n    lastOffset += 4;\n    if (boxSize === 0) {\n        boxSize = len;\n    }\n    else if (boxSize === 1) {\n        if (lastOffset + 8 > len) {\n            log.warn(\"ISOBMFF: box too short, cannot find offsets\");\n            return null;\n        }\n        boxSize = be8toi(buf, lastOffset);\n        lastOffset += 8;\n    }\n    if (boxSize < 0) {\n        throw new Error(\"ISOBMFF: Size out of range\");\n    }\n    if (name === 0x75756964 /* === \"uuid\" */) {\n        lastOffset += 16; // Skip uuid name\n    }\n    return [0, lastOffset, boxSize];\n}\nexport { getBox, getBoxContent, getBoxesContent, getBoxOffsets, getChildBox, getNextBoxOffsets, getUuidContent, };\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { getBoxContent, getBoxesContent } from \"./get_box\";\n/**\n * Returns the content of the first \"traf\" box encountered in the given ISOBMFF\n * data.\n * Returns null if not found.\n * @param {Uint8Array} buffer\n * @returns {Uint8Array|null}\n */\nfunction getTRAF(buffer) {\n    const moof = getBoxContent(buffer, 0x6d6f6f66 /* moof */);\n    if (moof === null) {\n        return null;\n    }\n    return getBoxContent(moof, 0x74726166 /* traf */);\n}\n/**\n * Returns the content of all \"traf\" boxes encountered in the given ISOBMFF\n * data.\n * Might be preferred to just `getTRAF` if you suspect that your ISOBMFF may\n * have multiple \"moof\" boxes.\n * @param {Uint8Array} buffer\n * @returns {Array.<Uint8Array>}\n */\nfunction getTRAFs(buffer) {\n    const moofs = getBoxesContent(buffer, 0x6d6f6f66 /* moof */);\n    return moofs.reduce((acc, moof) => {\n        const traf = getBoxContent(moof, 0x74726166 /* traf */);\n        if (traf !== null) {\n            acc.push(traf);\n        }\n        return acc;\n    }, []);\n}\n/**\n * Returns the content of the first \"moof\" box encountered in the given ISOBMFF\n * data.\n * Returns null if not found.\n * @param {Uint8Array} buffer\n * @returns {Uint8Array|null}\n */\nfunction getMDAT(buf) {\n    return getBoxContent(buf, 0x6d646174 /* \"mdat\" */);\n}\n/**\n * Returns the content of the first \"mdia\" box encountered in the given ISOBMFF\n * data.\n * Returns null if not found.\n * @param {Uint8Array} buffer\n * @returns {Uint8Array|null}\n */\nfunction getMDIA(buf) {\n    const moov = getBoxContent(buf, 0x6d6f6f76 /* moov */);\n    if (moov === null) {\n        return null;\n    }\n    const trak = getBoxContent(moov, 0x7472616b /* \"trak\" */);\n    if (trak === null) {\n        return null;\n    }\n    return getBoxContent(trak, 0x6d646961 /* \"mdia\" */);\n}\n/**\n * Returns the content of the first \"emsg\" box encountered in the given ISOBMFF\n * data.\n * Returns null if not found.\n * @param {Uint8Array} buffer\n * @returns {Uint8Array|null}\n */\nfunction getEMSG(buffer, offset = 0) {\n    return getBoxContent(buffer.subarray(offset), 0x656d7367 /* emsg */);\n}\nexport { getTRAF, getTRAFs, getMDAT, getMDIA, getEMSG };\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../../log\";\nimport sliceUint8Array from \"../../../utils/slice_uint8array\";\nimport { bytesToHex } from \"../../../utils/string_parsing\";\nimport { getBoxContent, getBoxOffsets } from \"./get_box\";\n/**\n * Replace every PSSH box from an ISOBMFF segment by FREE boxes and returns the\n * removed PSSH in an array.\n * Useful to manually manage encryption while avoiding the round-trip with the\n * browser's encrypted event.\n * @param {Uint8Array} data - the ISOBMFF segment\n * @returns {Array.<Uint8Array>} - The extracted PSSH boxes. In the order they\n * are encountered.\n */\nexport default function takePSSHOut(data) {\n    let i = 0;\n    const moov = getBoxContent(data, 0x6d6f6f76 /* moov */);\n    if (moov === null) {\n        return [];\n    }\n    const psshBoxes = [];\n    while (i < moov.length) {\n        let psshOffsets;\n        try {\n            psshOffsets = getBoxOffsets(moov, 0x70737368 /* pssh */);\n        }\n        catch (e) {\n            const err = e instanceof Error ? e : \"\";\n            log.warn(\"Error while removing PSSH from ISOBMFF\", err);\n            return psshBoxes;\n        }\n        if (psshOffsets === null) {\n            return psshBoxes;\n        }\n        const pssh = sliceUint8Array(moov, psshOffsets[0], psshOffsets[2]);\n        const systemId = getPsshSystemID(pssh, psshOffsets[1] - psshOffsets[0]);\n        if (systemId !== undefined) {\n            psshBoxes.push({ systemId, data: pssh });\n        }\n        // replace by `free` box.\n        moov[psshOffsets[0] + 4] = 0x66;\n        moov[psshOffsets[0] + 5] = 0x72;\n        moov[psshOffsets[0] + 6] = 0x65;\n        moov[psshOffsets[0] + 7] = 0x65;\n        i = psshOffsets[2];\n    }\n    return psshBoxes;\n}\n/**\n * Parse systemId from a \"pssh\" box into an hexadecimal string.\n * `undefined` if we could not extract a systemId.\n * @param {Uint8Array} buff - The pssh box\n * @param {number} initialDataOffset - offset of the first byte after the size\n * and name in this pssh box.\n * @returns {string|undefined}\n */\nexport function getPsshSystemID(buff, initialDataOffset) {\n    if (buff[initialDataOffset] > 1) {\n        log.warn(\"ISOBMFF: un-handled PSSH version\");\n        return undefined;\n    }\n    const offset = initialDataOffset + 4; /* version + flags */\n    if (offset + 16 > buff.length) {\n        return undefined;\n    }\n    const systemIDBytes = sliceUint8Array(buff, offset, offset + 16);\n    return bytesToHex(systemIDBytes);\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../../log\";\nimport assert from \"../../../utils/assert\";\nimport { be2toi, be3toi, be4toi, be8toi, concat, itobe4, itobe8, } from \"../../../utils/byte_parsing\";\nimport isNullOrUndefined from \"../../../utils/is_null_or_undefined\";\nimport { hexToBytes, readNullTerminatedString } from \"../../../utils/string_parsing\";\nimport { MAX_32_BIT_INT } from \"./constants\";\nimport { createBox } from \"./create_box\";\nimport { getPlayReadyKIDFromPrivateData } from \"./drm\";\nimport { getBoxContent, getBoxOffsets, getChildBox } from \"./get_box\";\nimport { getEMSG, getMDIA, getTRAF, getTRAFs } from \"./read\";\n/**\n * Parse the sidx part (segment index) of an ISOBMFF buffer and construct a\n * corresponding Array of available segments.\n *\n * Returns `null` if not found.\n * @param {Uint8Array} buf\n * @param {Number} sidxOffsetInWholeSegment\n * @returns {Object|null} {Array.<Object>} - Information about each subsegment.\n */\nfunction getSegmentsFromSidx(buf, sidxOffsetInWholeSegment) {\n    const sidxOffsets = getBoxOffsets(buf, 0x73696478 /* \"sidx\" */);\n    if (sidxOffsets === null) {\n        return null;\n    }\n    let offset = sidxOffsetInWholeSegment;\n    const boxSize = sidxOffsets[2] - sidxOffsets[0];\n    let cursor = sidxOffsets[1];\n    /* version(8) */\n    /* flags(24) */\n    /* reference_ID(32); */\n    /* timescale(32); */\n    const version = buf[cursor];\n    cursor += 4 + 4;\n    const timescale = be4toi(buf, cursor);\n    cursor += 4;\n    /* earliest_presentation_time(32 / 64) */\n    /* first_offset(32 / 64) */\n    let time;\n    if (version === 0) {\n        time = be4toi(buf, cursor);\n        cursor += 4;\n        offset += be4toi(buf, cursor) + boxSize;\n        cursor += 4;\n    }\n    else if (version === 1) {\n        time = be8toi(buf, cursor);\n        cursor += 8;\n        offset += be8toi(buf, cursor) + boxSize;\n        cursor += 8;\n    }\n    else {\n        return null;\n    }\n    const segments = [];\n    /* reserved(16) */\n    /* reference_count(16) */\n    cursor += 2;\n    let count = be2toi(buf, cursor);\n    cursor += 2;\n    while (--count >= 0) {\n        /* reference_type(1) */\n        /* reference_size(31) */\n        /* segment_duration(32) */\n        /* sap..(32) */\n        const refChunk = be4toi(buf, cursor);\n        cursor += 4;\n        const refType = (refChunk & 0x80000000) >>> 31;\n        const refSize = refChunk & 0x7fffffff;\n        // when set to 1 indicates that the reference is to a sidx, else to media\n        if (refType === 1) {\n            throw new Error(\"sidx with reference_type `1` not yet implemented\");\n        }\n        const duration = be4toi(buf, cursor);\n        cursor += 4;\n        // let sapChunk = be4toi(buf, cursor + 8);\n        cursor += 4;\n        // TODO(pierre): handle sap\n        // let startsWithSap = (sapChunk & 0x80000000) >>> 31;\n        // let sapType = (sapChunk & 0x70000000) >>> 28;\n        // let sapDelta = sapChunk & 0x0FFFFFFF;\n        segments.push({\n            time,\n            duration,\n            timescale,\n            range: [offset, offset + refSize - 1],\n        });\n        time += duration;\n        offset += refSize;\n    }\n    return segments;\n}\n/**\n * Parse track Fragment Decode Time to get a precize initial time for this\n * segment (in the media timescale).\n *\n * Stops at the first tfdt encountered from the beginning of the file.\n * Returns this time.\n * `undefined` if not found.\n * @param {Uint8Array} buffer\n * @returns {Number | undefined}\n */\nfunction getTrackFragmentDecodeTime(buffer) {\n    const traf = getTRAF(buffer);\n    if (traf === null) {\n        return undefined;\n    }\n    const tfdt = getBoxContent(traf, 0x74666474 /* tfdt */);\n    if (tfdt === null) {\n        return undefined;\n    }\n    const version = tfdt[0];\n    if (version === 1) {\n        return be8toi(tfdt, 4);\n    }\n    if (version === 0) {\n        return be4toi(tfdt, 4);\n    }\n    return undefined;\n}\n/**\n * Returns the \"default sample duration\" which is the default value for duration\n * of samples found in a \"traf\" ISOBMFF box.\n *\n * Returns `undefined` if no \"default sample duration\" has been found.\n * @param {Uint8Array} traf\n * @returns {number|undefined}\n */\nfunction getDefaultDurationFromTFHDInTRAF(traf) {\n    const tfhd = getBoxContent(traf, 0x74666864 /* tfhd */);\n    if (tfhd === null) {\n        return undefined;\n    }\n    let cursor = /* version */ 1;\n    const flags = be3toi(tfhd, cursor);\n    cursor += 3;\n    const hasBaseDataOffset = (flags & 0x000001) > 0;\n    const hasSampleDescriptionIndex = (flags & 0x000002) > 0;\n    const hasDefaultSampleDuration = (flags & 0x000008) > 0;\n    if (!hasDefaultSampleDuration) {\n        return undefined;\n    }\n    cursor += 4;\n    if (hasBaseDataOffset) {\n        cursor += 8;\n    }\n    if (hasSampleDescriptionIndex) {\n        cursor += 4;\n    }\n    const defaultDuration = be4toi(tfhd, cursor);\n    return defaultDuration;\n}\n/**\n * Calculate segment duration approximation by additioning the duration from\n * every samples in a trun ISOBMFF box.\n *\n * Returns `undefined` if we could not parse the duration.\n * @param {Uint8Array} buffer\n * @returns {number | undefined}\n */\nfunction getDurationFromTrun(buffer) {\n    const trafs = getTRAFs(buffer);\n    if (trafs.length === 0) {\n        return undefined;\n    }\n    let completeDuration = 0;\n    for (const traf of trafs) {\n        const trun = getBoxContent(traf, 0x7472756e /* trun */);\n        if (trun === null) {\n            return undefined;\n        }\n        let cursor = 0;\n        const version = trun[cursor];\n        cursor += 1;\n        if (version > 1) {\n            return undefined;\n        }\n        const flags = be3toi(trun, cursor);\n        cursor += 3;\n        const hasSampleDuration = (flags & 0x000100) > 0;\n        let defaultDuration = 0;\n        if (!hasSampleDuration) {\n            defaultDuration = getDefaultDurationFromTFHDInTRAF(traf);\n            if (defaultDuration === undefined) {\n                return undefined;\n            }\n        }\n        const hasDataOffset = (flags & 0x000001) > 0;\n        const hasFirstSampleFlags = (flags & 0x000004) > 0;\n        const hasSampleSize = (flags & 0x000200) > 0;\n        const hasSampleFlags = (flags & 0x000400) > 0;\n        const hasSampleCompositionOffset = (flags & 0x000800) > 0;\n        const sampleCounts = be4toi(trun, cursor);\n        cursor += 4;\n        if (hasDataOffset) {\n            cursor += 4;\n        }\n        if (hasFirstSampleFlags) {\n            cursor += 4;\n        }\n        let i = sampleCounts;\n        let duration = 0;\n        while (i-- > 0) {\n            if (hasSampleDuration) {\n                duration += be4toi(trun, cursor);\n                cursor += 4;\n            }\n            else {\n                duration += defaultDuration;\n            }\n            if (hasSampleSize) {\n                cursor += 4;\n            }\n            if (hasSampleFlags) {\n                cursor += 4;\n            }\n            if (hasSampleCompositionOffset) {\n                cursor += 4;\n            }\n        }\n        completeDuration += duration;\n    }\n    return completeDuration;\n}\n/**\n * Get timescale information from a movie header box. Found in init segments.\n * `undefined` if not found or not parsed.\n *\n * This timescale is the default timescale used for segments.\n * @param {Uint8Array} buffer\n * @returns {Number | undefined}\n */\nfunction getMDHDTimescale(buffer) {\n    const mdia = getMDIA(buffer);\n    if (mdia === null) {\n        return undefined;\n    }\n    const mdhd = getBoxContent(mdia, 0x6d646864 /* \"mdhd\" */);\n    if (mdhd === null) {\n        return undefined;\n    }\n    let cursor = 0;\n    const version = mdhd[cursor];\n    cursor += 4;\n    if (version === 1) {\n        return be4toi(mdhd, cursor + 16);\n    }\n    else if (version === 0) {\n        return be4toi(mdhd, cursor + 8);\n    }\n    return undefined;\n}\n/**\n * Creates a PSSH box with the given systemId and data.\n * @param {Array.<Object>} psshInfo\n * @returns {Uint8Array}\n */\nfunction createPssh({ systemId, privateData }) {\n    const _systemId = systemId.replace(/-/g, \"\");\n    assert(_systemId.length === 32);\n    return createBox(\"pssh\", concat(4, // 4 initial zeroed bytes\n    hexToBytes(_systemId), itobe4(privateData.length), privateData));\n}\n/**\n * Update ISOBMFF given to add a \"pssh\" box in the \"moov\" box for every content\n * protection in the psshList array given.\n * @param {Uint8Array} buf - the ISOBMFF file\n * @param {Array.<Object>} psshList\n * @returns {Uint8Array} - The new ISOBMFF generated.\n */\nfunction patchPssh(buf, psshList) {\n    if (isNullOrUndefined(psshList) || psshList.length === 0) {\n        return buf;\n    }\n    const moovOffsets = getBoxOffsets(buf, 0x6d6f6f76 /* = \"moov\" */);\n    if (moovOffsets === null) {\n        return buf;\n    }\n    const moov = buf.subarray(moovOffsets[0], moovOffsets[2]);\n    const moovArr = [moov];\n    for (let i = 0; i < psshList.length; i++) {\n        moovArr.push(createPssh(psshList[i]));\n    }\n    const newmoov = updateBoxLength(concat(...moovArr));\n    return concat(buf.subarray(0, moovOffsets[0]), newmoov, buf.subarray(moovOffsets[2]));\n}\n/**\n * Returns a new version of the given box with the size updated\n * so it reflects its actual size.\n *\n * You can use this function after modifying a ISOBMFF box so its size is\n * updated.\n *\n * /!\\ Please consider that this function might mutate the given Uint8Array\n * in place or might create a new one, depending on the current conditions.\n * @param {Uint8Array} buf - The ISOBMFF box\n * @returns {Uint8Array}\n */\nfunction updateBoxLength(buf) {\n    const newLen = buf.length;\n    if (newLen < 4) {\n        throw new Error(\"Cannot update box length: box too short\");\n    }\n    const oldSize = be4toi(buf, 0);\n    if (oldSize === 0) {\n        if (newLen > MAX_32_BIT_INT) {\n            const newBox = new Uint8Array(newLen + 8);\n            newBox.set(itobe4(1), 0);\n            newBox.set(buf.subarray(4, 8), 4);\n            newBox.set(itobe8(newLen + 8), 8);\n            newBox.set(buf.subarray(8, newLen), 16);\n            return newBox;\n        }\n        else {\n            buf.set(itobe4(newLen), 0);\n            return buf;\n        }\n    }\n    else if (oldSize === 1) {\n        if (newLen < 16) {\n            throw new Error(\"Cannot update box length: box too short\");\n        }\n        buf.set(itobe8(newLen), 8);\n        return buf;\n    }\n    else if (newLen <= MAX_32_BIT_INT) {\n        buf.set(itobe4(newLen), 0);\n        return buf;\n    }\n    else {\n        const newBox = new Uint8Array(newLen + 8);\n        newBox.set(itobe4(1), 0);\n        newBox.set(buf.subarray(4, 8), 4);\n        newBox.set(itobe8(newLen + 8), 8);\n        newBox.set(buf.subarray(8, newLen), 16);\n        return newBox;\n    }\n}\n/**\n * Parse EMSG boxes from ISOBMFF data.\n * @param {Uint8Array} buffer\n * @returns {Array.<Object> | undefined}\n */\nfunction parseEmsgBoxes(buffer) {\n    const emsgs = [];\n    let offset = 0;\n    while (offset < buffer.length) {\n        const emsg = getEMSG(buffer, offset);\n        if (emsg === null) {\n            break;\n        }\n        const length = emsg.length;\n        offset += length;\n        const version = emsg[0];\n        if (version !== 0) {\n            log.warn(\"ISOBMFF: EMSG version \" + version.toString() + \" not supported.\");\n        }\n        else {\n            let position = 4; // skip version + flags\n            const { end: schemeIdEnd, string: schemeIdUri } = readNullTerminatedString(emsg, position);\n            position = schemeIdEnd; // skip schemeIdUri\n            const { end: valueEnd, string: value } = readNullTerminatedString(emsg, position);\n            position = valueEnd; // skip value\n            const timescale = be4toi(emsg, position);\n            position += 4; // skip timescale\n            const presentationTimeDelta = be4toi(emsg, position);\n            position += 4; // skip presentationTimeDelta\n            const eventDuration = be4toi(emsg, position);\n            position += 4; // skip eventDuration\n            const id = be4toi(emsg, position);\n            position += 4; // skip id\n            const messageData = emsg.subarray(position, length);\n            const emsgData = {\n                schemeIdUri,\n                value,\n                timescale,\n                presentationTimeDelta,\n                eventDuration,\n                id,\n                messageData,\n            };\n            emsgs.push(emsgData);\n        }\n    }\n    if (emsgs.length === 0) {\n        return undefined;\n    }\n    return emsgs;\n}\n/**\n * @param {Uint8Array} segment\n * @returns {Uint8Array|null}\n */\nfunction getKeyIdFromInitSegment(segment) {\n    const stsd = getChildBox(segment, [\n        0x6d6f6f76 /* moov */, 0x7472616b /* trak */, 0x6d646961 /* mdia */,\n        0x6d696e66 /* minf */, 0x7374626c /* stbl */, 0x73747364 /* stsd */,\n    ]);\n    if (stsd === null) {\n        return null;\n    }\n    const stsdSubBoxes = stsd.subarray(8);\n    let encBox = getBoxContent(stsdSubBoxes, 0x656e6376 /* encv */);\n    let encContentOffset = 0;\n    if (encBox === null) {\n        encContentOffset =\n            8 + // sample entry header\n                8 + // reserved\n                2 + // channelcount\n                2 + // samplesize\n                2 + // predefined\n                2 + // reserved\n                4; // samplerate\n        encBox = getBoxContent(stsdSubBoxes, 0x656e6361 /* enca */);\n    }\n    else {\n        encContentOffset =\n            8 + // sample entry header\n                2 +\n                2 +\n                12 + // predefined + reserved + predefined\n                2 +\n                2 + // width + height\n                4 +\n                4 + // horizresolution + vertresolution\n                4 + // reserved\n                2 + // frame_count\n                32 +\n                2 + // depth\n                2; // pre-defined;\n    }\n    if (encBox === null) {\n        // There's no encryption data here\n        return null;\n    }\n    const tenc = getChildBox(encBox.subarray(encContentOffset), [0x73696e66 /* sinf */, 0x73636869 /* schi */, 0x74656e63 /* tenc */]);\n    if (tenc === null || tenc.byteLength < 24) {\n        return null;\n    }\n    const keyId = tenc.subarray(8, 24);\n    // Zero-filled keyId should only be valid for unencrypted content\n    return keyId.every((b) => b === 0) ? null : keyId;\n}\nexport { getKeyIdFromInitSegment, getMDHDTimescale, getPlayReadyKIDFromPrivateData, getTrackFragmentDecodeTime, getDurationFromTrun, getSegmentsFromSidx, patchPssh, updateBoxLength, parseEmsgBoxes, };\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../../log\";\nconst SEGMENT_ID = 0x18538067;\nconst INFO_ID = 0x1549a966;\nconst TIMECODESCALE_ID = 0x2ad7b1;\nconst DURATION_ID = 0x4489;\nconst CUES_ID = 0x1c53bb6b;\nconst CUE_POINT_ID = 0xbb;\nconst CUE_TIME_ID = 0xb3;\nconst CUE_TRACK_POSITIONS_ID = 0xb7;\nconst CUE_CLUSTER_POSITIONS_ID = 0xf1;\n/**\n * Find the offsets of the value linked to the given element ID.\n * @param {number} elementID - ID for the searched element.\n * @param {Array.<number>} parents - eventual IDs of the parent elements. From\n * top level to lower level (from the furthest to the closest).\n * @param {Uint8Array} buffer - buffer where the ID will be searched\n * @param {Array.<number>} range - start and end offsets in the buffer where the\n * ID will be searched.\n * @returns {Array.<number>|null}\n */\nfunction findNextElement(elementID, parents, buffer, [initialOffset, maxOffset]) {\n    let currentOffset = initialOffset;\n    while (currentOffset < maxOffset) {\n        const parsedID = getEBMLID(buffer, currentOffset);\n        if (parsedID === null) {\n            return null;\n        }\n        const { value: ebmlTagID, length: ebmlTagLength } = parsedID;\n        const sizeOffset = currentOffset + ebmlTagLength;\n        const parsedValue = getEBMLValue(buffer, sizeOffset);\n        if (parsedValue === null) {\n            return null;\n        }\n        const { length: valueLengthLength, value: valueLength } = parsedValue;\n        const valueOffset = sizeOffset + valueLengthLength;\n        const valueEndOffset = valueOffset + valueLength;\n        if (ebmlTagID === elementID) {\n            return [valueOffset, valueEndOffset];\n        }\n        else if (parents.length > 0) {\n            for (let i = 0; i < parents.length; i++) {\n                if (ebmlTagID === parents[i]) {\n                    const newParents = parents.slice(i + 1, parents.length);\n                    return findNextElement(elementID, newParents, buffer, [\n                        valueOffset,\n                        valueEndOffset,\n                    ]);\n                }\n            }\n        }\n        currentOffset = valueEndOffset;\n    }\n    return null;\n}\n/**\n * Return the timecode scale (basically timescale) of the whole file.\n * @param {Uint8Array} buffer\n * @param {number} initialOffset\n * @returns {number|null}\n */\nexport function getTimeCodeScale(buffer, initialOffset) {\n    const timeCodeScaleOffsets = findNextElement(TIMECODESCALE_ID, [SEGMENT_ID, INFO_ID], buffer, [initialOffset, buffer.length]);\n    if (timeCodeScaleOffsets === null) {\n        return null;\n    }\n    const length = timeCodeScaleOffsets[1] - timeCodeScaleOffsets[0];\n    return 1e9 / bytesToNumber(buffer, timeCodeScaleOffsets[0], length);\n}\n/**\n * Return the duration of the concerned media.\n * @param {Uint8Array} buffer\n * @param {number} initialOffset\n * @returns {number|null}\n */\nfunction getDuration(buffer, initialOffset) {\n    const timeCodeScaleOffsets = findNextElement(DURATION_ID, [SEGMENT_ID, INFO_ID], buffer, [initialOffset, buffer.length]);\n    if (timeCodeScaleOffsets === null) {\n        return null;\n    }\n    const length = timeCodeScaleOffsets[1] - timeCodeScaleOffsets[0];\n    if (length === 4) {\n        return get_IEEE754_32Bits(buffer, timeCodeScaleOffsets[0]);\n    }\n    else if (length === 8) {\n        return get_IEEE754_64Bits(buffer, timeCodeScaleOffsets[0]);\n    }\n    return null;\n}\n/**\n * @param {Uint8Array} buffer\n * @param {number} initialOffset\n * @returns {Array.<Object>|null}\n */\nexport function getSegmentsFromCues(buffer, initialOffset) {\n    const segmentRange = findNextElement(SEGMENT_ID, [], buffer, [\n        initialOffset,\n        buffer.length,\n    ]);\n    if (segmentRange === null) {\n        return null;\n    }\n    const [segmentRangeStart, segmentRangeEnd] = segmentRange;\n    const timescale = getTimeCodeScale(buffer, segmentRangeStart);\n    if (timescale === null) {\n        return null;\n    }\n    const duration = getDuration(buffer, segmentRangeStart);\n    if (duration === null) {\n        return null;\n    }\n    const cuesRange = findNextElement(CUES_ID, [], buffer, [\n        segmentRangeStart,\n        segmentRangeEnd,\n    ]);\n    if (cuesRange === null) {\n        return null;\n    }\n    const rawInfos = [];\n    let currentOffset = cuesRange[0];\n    while (currentOffset < cuesRange[1]) {\n        const cuePointRange = findNextElement(CUE_POINT_ID, [], buffer, [\n            currentOffset,\n            cuesRange[1],\n        ]);\n        if (cuePointRange === null) {\n            break;\n        }\n        const cueTimeRange = findNextElement(CUE_TIME_ID, [], buffer, [\n            cuePointRange[0],\n            cuePointRange[1],\n        ]);\n        if (cueTimeRange === null) {\n            return null;\n        }\n        const time = bytesToNumber(buffer, cueTimeRange[0], cueTimeRange[1] - cueTimeRange[0]);\n        const cueOffsetRange = findNextElement(CUE_CLUSTER_POSITIONS_ID, [CUE_TRACK_POSITIONS_ID], buffer, [cuePointRange[0], cuePointRange[1]]);\n        if (cueOffsetRange === null) {\n            return null;\n        }\n        const rangeStart = bytesToNumber(buffer, cueOffsetRange[0], cueOffsetRange[1] - cueOffsetRange[0]) +\n            segmentRangeStart;\n        rawInfos.push({ time, rangeStart });\n        currentOffset = cuePointRange[1];\n    }\n    const segments = [];\n    for (let i = 0; i < rawInfos.length; i++) {\n        const currentSegment = rawInfos[i];\n        if (i === rawInfos.length - 1) {\n            segments.push({\n                time: currentSegment.time,\n                timescale,\n                duration: i === 0 ? duration : duration - currentSegment.time,\n                range: [currentSegment.rangeStart, Infinity],\n            });\n        }\n        else {\n            segments.push({\n                time: currentSegment.time,\n                timescale,\n                duration: rawInfos[i + 1].time - currentSegment.time,\n                range: [currentSegment.rangeStart, rawInfos[i + 1].rangeStart - 1],\n            });\n        }\n    }\n    return segments;\n}\nfunction getLength(buffer, offset) {\n    for (let length = 1; length <= 8; length++) {\n        if (buffer[offset] >= Math.pow(2, 8 - length)) {\n            return length;\n        }\n    }\n    return undefined;\n}\nfunction getEBMLID(buffer, offset) {\n    const length = getLength(buffer, offset);\n    if (length === undefined) {\n        log.warn(\"webm: unrepresentable length\");\n        return null;\n    }\n    if (offset + length > buffer.length) {\n        log.warn(\"webm: impossible length\");\n        return null;\n    }\n    let value = 0;\n    for (let i = 0; i < length; i++) {\n        value = buffer[offset + i] * Math.pow(2, (length - i - 1) * 8) + value;\n    }\n    return { length, value };\n}\nfunction getEBMLValue(buffer, offset) {\n    const length = getLength(buffer, offset);\n    if (length === undefined) {\n        log.warn(\"webm: unrepresentable length\");\n        return null;\n    }\n    if (offset + length > buffer.length) {\n        log.warn(\"webm: impossible length\");\n        return null;\n    }\n    let value = (buffer[offset] & ((1 << (8 - length)) - 1)) * Math.pow(2, (length - 1) * 8);\n    for (let i = 1; i < length; i++) {\n        value = buffer[offset + i] * Math.pow(2, (length - i - 1) * 8) + value;\n    }\n    return { length, value };\n}\n/**\n * Convert a IEEE754 32 bits floating number as an Uint8Array into its\n * corresponding Number.\n * @param {Uint8Array} buffer\n * @param {number} offset\n * @returns {number}\n */\nfunction get_IEEE754_32Bits(buffer, offset) {\n    return new DataView(buffer.buffer).getFloat32(offset);\n}\n/**\n * Convert a IEEE754 64 bits floating number as an Uint8Array into its\n * corresponding Number.\n * @param {Uint8Array} buffer\n * @param {number} offset\n * @returns {number}\n */\nfunction get_IEEE754_64Bits(buffer, offset) {\n    return new DataView(buffer.buffer).getFloat64(offset);\n}\nfunction bytesToNumber(buffer, offset, length) {\n    let value = 0;\n    for (let i = 0; i < length; i++) {\n        value = buffer[offset + i] * Math.pow(2, (length - i - 1) * 8) + value;\n    }\n    return value;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SUPPORTED_ADAPTATIONS_TYPE } from \"../../../../manifest\";\n/**\n * Attach trick mode tracks to adaptations by assigning to the trickModeTracks\n * property an array of trick mode track adaptations.\n * @param {Object} adaptations\n * @param {Array.<Object>} trickModeTracks\n * @returns {void}\n */\nfunction attachTrickModeTrack(adaptations, trickModeTracks) {\n    for (const track of trickModeTracks) {\n        const { adaptation, trickModeAttachedAdaptationIds } = track;\n        for (const trickModeAttachedAdaptationId of trickModeAttachedAdaptationIds) {\n            for (const adaptationType of SUPPORTED_ADAPTATIONS_TYPE) {\n                const adaptationsByType = adaptations[adaptationType];\n                if (adaptationsByType !== undefined) {\n                    for (const adaptationByType of adaptationsByType) {\n                        if (adaptationByType.id === trickModeAttachedAdaptationId) {\n                            if (adaptationByType.trickModeTracks === undefined) {\n                                adaptationByType.trickModeTracks = [];\n                            }\n                            adaptationByType.trickModeTracks.push(adaptation);\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\nexport default attachTrickModeTrack;\n","import log from \"../../../../log\";\nimport arrayFind from \"../../../../utils/array_find\";\n/**\n * Class whose purpose is to parse `<ContentProtection>` elements in a DASH MPD.\n *\n * This element has to be particularly considered because a ContentProtection\n * element can inherit another ContentProtection element coming before it yet\n * even after it in the MPD, through a system of \"reference IDs\".\n *\n * The idea here is that the main MPD parsing logic just needs to signal to this\n * class when a `ContentProtection` element is encountered - and to which\n * `Representation` it is associated, and this class will then perform the\n * ContentProtection-parsing operation as soon as it has all referenced\n * ContentProtection elements.\n *\n * @class ContentProtectionParser\n */\nexport default class ContentProtectionParser {\n    constructor() {\n        this._refs = new Map();\n        this._stored = [];\n    }\n    /**\n     * Add new `IContentProtectionIntermediateRepresentation` objects that can\n     * be relied on as a reference by later\n     * `IContentProtectionIntermediateRepresentation` objects, without the need\n     * to actually apply it to a Representation.\n     * @param {Object} contentProtections\n     */\n    addReferences(contentProtections) {\n        for (const contentProt of contentProtections) {\n            if (contentProt.attributes.refId !== undefined) {\n                this._refs.set(contentProt.attributes.refId, contentProt);\n            }\n        }\n    }\n    /**\n     * Add a new `IContentProtectionIntermediateRepresentation` object that should\n     * be parsed with the result linked to the given `IParsedRepresentation`.\n     * @param {Object} representation\n     * @param {Object} contentProt\n     */\n    add(representation, contentProt) {\n        if (!this._tryParsing(representation, contentProt, false)) {\n            this._stored.push([representation, contentProt]);\n        }\n        if (contentProt.attributes.refId !== undefined) {\n            this._refs.set(contentProt.attributes.refId, contentProt);\n            this._resolveStoredRefs(false);\n        }\n    }\n    /**\n     * It is possible that even after parsing the full MPD,\n     */\n    finalize() {\n        this._resolveStoredRefs(true);\n    }\n    /**\n     * Try to parse all ContentProtection that are currently waiting due to a\n     * referenced ContentProtection not being known yet.\n     *\n     * Return `true` if all ContentProtection references could have been found\n     * and `false` if at least one wasn't.\n     *\n     * The `force` parameter indicate what should be done if a reference linked\n     * to a ContentProtection couldn't be resolved: if `false`, we just keep that\n     * ContentProtection aside for later, if `true` we parse it right now even if\n     * information could be missing.\n     *\n     * @param {boolean} force\n     * @returns {boolean}\n     */\n    _resolveStoredRefs(force) {\n        for (let i = this._stored.length - 1; i >= 0; i--) {\n            const [representation, contentProt] = this._stored[i];\n            if (this._tryParsing(representation, contentProt, force) || force) {\n                this._stored.splice(i, 1);\n            }\n        }\n        return this._stored.length === 0;\n    }\n    /**\n     * Parse the `IContentProtectionIntermediateRepresentation` given and add the\n     * corresponding attributes to the given `IParsedRepresentation` when done.\n     *\n     * Because the `IContentProtectionIntermediateRepresentation` may be\n     * referencing another `IContentProtectionIntermediateRepresentation`, this\n     * method might not succeed to do so if the referenced\n     * `IContentProtectionIntermediateRepresentation` has not yet been encountered.\n     *\n     * In that last scenario, this method returns `false` and:\n     *   - Either `force` is set to `true`, in which case what could be parsed\n     *     will still be set on the `IParsedRepresentation`.\n     *   - Either `force` is set to `false`, in which case the parsing of this\n     *     `IContentProtectionIntermediateRepresentation` is skipped.\n     * @param {Object} representation\n     * @param {Object} contentProt\n     * @param {boolean} force\n     * @returns {boolean}\n     */\n    _tryParsing(representation, contentProt, force) {\n        if (contentProt.attributes.ref === undefined) {\n            // There's no reference, we can parse right away\n            parseContentProtection(representation, contentProt);\n            return true;\n        }\n        const referenced = this._getReferenced(contentProt.attributes.ref);\n        if (referenced === undefined) {\n            // Referenced ContentProtection not found, exit\n            if (force) {\n                log.warn(\"DASH: forcing the parsing of a referencing ContentProtection\");\n                parseContentProtection(representation, contentProt);\n            }\n            return false;\n        }\n        // Referenced ContentProtection found, let's inherit its attributes\n        contentProt.children.cencPssh.push(...referenced.children.cencPssh);\n        if (contentProt.attributes.keyId === undefined &&\n            referenced.attributes.keyId !== undefined) {\n            contentProt.attributes.keyId = referenced.attributes.keyId;\n        }\n        if (contentProt.attributes.schemeIdUri === undefined &&\n            referenced.attributes.schemeIdUri !== undefined) {\n            contentProt.attributes.schemeIdUri = referenced.attributes.schemeIdUri;\n        }\n        if (contentProt.attributes.value === undefined &&\n            referenced.attributes.value !== undefined) {\n            contentProt.attributes.value = referenced.attributes.value;\n        }\n        parseContentProtection(representation, contentProt);\n        return true;\n    }\n    /**\n     * Returns an `IContentProtectionIntermediateRepresentation` based on its\n     * \"refId\".\n     * Returns `undefined` if it is not known yet.\n     *\n     * @param {string} refId\n     * @returns {Object|undefined}\n     */\n    _getReferenced(refId) {\n        return this._refs.get(refId);\n    }\n}\n/**\n * Parses an `IContentProtectionIntermediateRepresentation` and update the\n * corresponding attributes on the given `IParsedRepresentation`.\n * @param {Object} representation\n * @param {Object} contentProtectionIr\n */\nfunction parseContentProtection(representation, contentProtectionIr) {\n    let systemId;\n    if (contentProtectionIr.attributes.schemeIdUri !== undefined &&\n        contentProtectionIr.attributes.schemeIdUri.substring(0, 9) === \"urn:uuid:\") {\n        systemId = contentProtectionIr.attributes.schemeIdUri\n            .substring(9)\n            .replace(/-/g, \"\")\n            .toLowerCase();\n    }\n    if (contentProtectionIr.attributes.keyId !== undefined &&\n        contentProtectionIr.attributes.keyId.length > 0) {\n        const kid = contentProtectionIr.attributes.keyId;\n        if (representation.contentProtections === undefined) {\n            representation.contentProtections = { keyIds: [kid], initData: [] };\n        }\n        else if (representation.contentProtections.keyIds === undefined) {\n            representation.contentProtections.keyIds = [kid];\n        }\n        else {\n            representation.contentProtections.keyIds.push(kid);\n        }\n    }\n    if (systemId === undefined) {\n        return;\n    }\n    const { cencPssh } = contentProtectionIr.children;\n    const values = [];\n    for (const data of cencPssh) {\n        values.push({ systemId, data });\n    }\n    if (values.length === 0) {\n        return;\n    }\n    if (representation.contentProtections === undefined) {\n        representation.contentProtections = {\n            keyIds: [],\n            initData: [{ type: \"cenc\", values }],\n        };\n        return;\n    }\n    const cencInitData = arrayFind(representation.contentProtections.initData, (i) => i.type === \"cenc\");\n    if (cencInitData === undefined) {\n        representation.contentProtections.initData.push({ type: \"cenc\", values });\n    }\n    else {\n        cencInitData.values.push(...values);\n    }\n}\n","import isNonEmptyString from \"../../../../utils/is_non_empty_string\";\nconst supplementalCodecSeparator = /[, ]+/g;\n/**\n * Converts SCTE 214 supplemental codec string into RFC4281 codec string\n *\n * The returned value is a codec string respecting RFC6381\n *\n * SCTE 214 defines supplemental codecs as a whitespace-separated multiple list of\n * codec strings\n *\n * RFC6381 defines codecs as a comma-separated list of codec strings.\n *\n * This two syntax differs and this parser is used to convert SCTE214\n * to be compliant with what MSE APIs expect\n *\n * @param {string} val - The codec string to parse\n * @returns { Array.<string | undefined | null>}\n */\nexport function convertSupplementalCodecsToRFC6381(val) {\n    if (isNonEmptyString(val)) {\n        return val.trim().replace(supplementalCodecSeparator, \", \");\n    }\n    return \"\";\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../../../log\";\n/**\n * Avoid periods to overlap.\n *\n * According to DASH guidelines, if a period has media duration longer than\n * the distance between the start of this period and the start of the next period,\n * use of start times implies that the client will start the playout of the next\n * period at the time stated, rather than finishing the playout of the last period.\n *\n * Even if that case if defined when period last(s) segment(s) is/are a bit longer,\n * it can be meaningful when two periods are overlapping. We will always shorten\n * the first period, and even erase it if its duration is equal to zero.\n *\n * Example (Periods are numbered under their manifest order) :\n *\n * [ Period 1 ][ Period 2 ]       ------>  [ Period 1 ][ Period 3 ]\n *             [ Period 3 ]\n *\n * [ Period 1 ][ Period 2 ]       ------>  [ Period 1 ][  2  ][ Period 3 ]\n *                  [ Period 3 ]\n *\n * [ Period 1 ][ Period 2 ]       ------>  [  1  ][      Period 3     ]\n *        [      Period 3     ]\n *\n * @param {Array.<Object>} parsedPeriods\n * @return {Array.<Object>}\n */\nexport default function flattenOverlappingPeriods(parsedPeriods) {\n    if (parsedPeriods.length === 0) {\n        return [];\n    }\n    const flattenedPeriods = [parsedPeriods[0]];\n    for (let i = 1; i < parsedPeriods.length; i++) {\n        const parsedPeriod = parsedPeriods[i];\n        let lastFlattenedPeriod = flattenedPeriods[flattenedPeriods.length - 1];\n        while (lastFlattenedPeriod.duration === undefined ||\n            lastFlattenedPeriod.start + lastFlattenedPeriod.duration > parsedPeriod.start) {\n            log.warn(\"DASH: Updating overlapping Periods.\", lastFlattenedPeriod === null || lastFlattenedPeriod === void 0 ? void 0 : lastFlattenedPeriod.start, parsedPeriod.start);\n            lastFlattenedPeriod.duration = parsedPeriod.start - lastFlattenedPeriod.start;\n            lastFlattenedPeriod.end = parsedPeriod.start;\n            if (lastFlattenedPeriod.duration > 0) {\n                // Note: Calling `break` to quit the while loop should theoritically be\n                // unnecessary as the previous operations should ensure we do not re-enter\n                // the loop's condition.\n                // Yet we dit encounter infinite loops without it because of float-related\n                // rounding errors.\n                break;\n            }\n            else {\n                // `lastFlattenedPeriod` has now a negative or `0` duration.\n                // Remove it, consider the next Period in its place, and re-start the loop.\n                flattenedPeriods.pop();\n                if (flattenedPeriods.length === 0) {\n                    // There's no remaining Period to compare to `parsedPeriod`\n                    break;\n                }\n                // Take the previous Period as reference and compare it now to `parsedPeriod`\n                lastFlattenedPeriod = flattenedPeriods[flattenedPeriods.length - 1];\n            }\n        }\n        flattenedPeriods.push(parsedPeriod);\n    }\n    return flattenedPeriods;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../../../log\";\nimport getMonotonicTimeStamp from \"../../../../utils/monotonic_timestamp\";\n/**\n * Get difference between the server's clock, in milliseconds, and the\n * monotonically-raising timestamp used by the RxPlayer.\n * This property allows to calculate the server time at any moment.\n *\n * `undefined` if we could not define such offset (in which case, you could have\n * to rely on the user's clock instead).\n *\n * For example, a response of 1000 would mean that the timestamp is 1 second\n * behind the server's time.\n * @param {string} serverClock\n * @returns {number|undefined}\n */\nexport default function getClockOffset(serverClock) {\n    const httpOffset = Date.parse(serverClock) - getMonotonicTimeStamp();\n    if (isNaN(httpOffset)) {\n        log.warn(\"DASH Parser: Invalid clock received: \", serverClock);\n        return undefined;\n    }\n    return httpOffset;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Extract the webm HDR information out of the codec string.\n * The syntax of the codec string is defined in VP Codec ISO Media File Format\n * Binding, in the section Codecs Parameter String.\n * @param {string} codecString\n * @returns {Object | undefined}\n */\nexport function getWEBMHDRInformation(codecString) {\n    // cccc.PP.LL.DD.CC[.cp[.tc[.mc[.FF]]]]\n    const [cccc, _PP, _LL, DD, _CC, cp, tc, mc] = codecString.split(\".\");\n    if (cccc !== \"vp08\" && cccc !== \"vp09\" && cccc !== \"vp10\") {\n        return undefined;\n    }\n    let colorDepth;\n    let eotf;\n    let colorSpace;\n    if ((DD !== undefined && DD === \"10\") || DD === \"12\") {\n        colorDepth = parseInt(DD, 10);\n    }\n    if (tc !== undefined) {\n        // 1: ITU-R BT.709\n        // 2: Unspecified\n        // 4: Gamma 2.2 curve\n        // 5: Gamma 2.8 curve\n        // 6: SMPTE 170M\n        // 7: SMPTE 240M\n        // 8: Linear\n        // 9: Logarithmic (100:1 range)\n        // 10: Logarithmic (100 * Sqrt(10) : 1 range)\n        // 11: IEC 61966-2-4\n        // 12: ITU-R BT.1361 Extended Colour Gamut\n        // 13: IEC 61966-2-1 (sRGB or sYCC)\n        // 14: ITU-R BT.2020 10-bit system\n        // 15: ITU-R BT.2020 12-bit system\n        // 16: SMPTE ST 2084, ITU-R BT.2100 PQ\n        // 17: SMPTE ST 428-1\n        // 18: ARIB STD-B67 (HLG)\n        if (tc === \"16\") {\n            eotf = \"pq\";\n        }\n        else if (tc === \"18\") {\n            eotf = \"hlg\";\n        }\n    }\n    if (cp !== undefined && mc !== undefined && cp === \"09\" && mc === \"09\") {\n        colorSpace = \"rec2020\";\n    }\n    if (colorDepth === undefined || eotf === undefined) {\n        return undefined;\n    }\n    return { colorDepth, eotf, colorSpace };\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @param {Object} mpdIR\n * @returns {string|undefined}\n */\nexport default function getHTTPUTCTimingURL(mpdIR) {\n    const UTCTimingHTTP = mpdIR.children.utcTimings.filter((utcTiming) => (utcTiming.schemeIdUri === \"urn:mpeg:dash:utc:http-iso:2014\" ||\n        utcTiming.schemeIdUri === \"urn:mpeg:dash:utc:http-xsdate:2014\") &&\n        utcTiming.value !== undefined);\n    return UTCTimingHTTP.length > 0 ? UTCTimingHTTP[0].value : undefined;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport getMaximumPositions from \"../../utils/get_maximum_positions\";\nimport getMinimumPosition from \"../../utils/get_minimum_position\";\n/**\n * @param {Object} periods\n * @returns {Array.<number>}\n */\nexport default function getMinimumAndMaximumPositions(periods) {\n    if (periods.length === 0) {\n        throw new Error(\"DASH Parser: no period available for a dynamic content\");\n    }\n    const minimumSafePosition = getMinimumPosition(periods);\n    const maxPositions = getMaximumPositions(periods);\n    return {\n        minimumSafePosition,\n        maximumSafePosition: maxPositions.safe,\n        maximumUnsafePosition: maxPositions.unsafe,\n    };\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport isNullOrUndefined from \"../../../../utils/is_null_or_undefined\";\n/**\n * Get periods time information from current, next and previous\n * periods.\n * @param {Array.<Object>} periodsIR\n * @param {Object} manifestInfos\n * @return {Array.<Object>}\n */\nexport default function getPeriodsTimeInformation(periodsIR, manifestInfos) {\n    const periodsTimeInformation = [];\n    periodsIR.forEach((currentPeriod, i) => {\n        let periodStart;\n        if (!isNullOrUndefined(currentPeriod.attributes.start)) {\n            periodStart = currentPeriod.attributes.start;\n        }\n        else {\n            if (i === 0) {\n                periodStart =\n                    !manifestInfos.isDynamic ||\n                        isNullOrUndefined(manifestInfos.availabilityStartTime)\n                        ? 0\n                        : manifestInfos.availabilityStartTime;\n            }\n            else {\n                // take time information from previous period\n                const prevPeriodInfos = periodsTimeInformation[periodsTimeInformation.length - 1];\n                if (!isNullOrUndefined(prevPeriodInfos) &&\n                    !isNullOrUndefined(prevPeriodInfos.periodEnd)) {\n                    periodStart = prevPeriodInfos.periodEnd;\n                }\n                else {\n                    throw new Error(\"Missing start time when parsing periods.\");\n                }\n            }\n        }\n        let periodDuration;\n        const nextPeriod = periodsIR[i + 1];\n        if (!isNullOrUndefined(currentPeriod.attributes.duration)) {\n            periodDuration = currentPeriod.attributes.duration;\n        }\n        else if (i === periodsIR.length - 1) {\n            periodDuration = manifestInfos.duration;\n        }\n        else if (!isNullOrUndefined(nextPeriod.attributes.start)) {\n            periodDuration = nextPeriod.attributes.start - periodStart;\n        }\n        const periodEnd = !isNullOrUndefined(periodDuration)\n            ? periodStart + periodDuration\n            : undefined;\n        periodsTimeInformation.push({ periodStart, periodDuration, periodEnd });\n    });\n    return periodsTimeInformation;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { BaseRepresentationIndex, ListRepresentationIndex, TemplateRepresentationIndex, TimelineRepresentationIndex, } from \"./indexes\";\nimport parseMpdIr from \"./parse_mpd\";\nexport default parseMpdIr;\nexport { BaseRepresentationIndex, ListRepresentationIndex, TemplateRepresentationIndex, TimelineRepresentationIndex, };\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../../../../log\";\nimport isNullOrUndefined from \"../../../../../utils/is_null_or_undefined\";\nimport { fromIndexTime, getIndexSegmentEnd, toIndexTime, } from \"../../../utils/index_helpers\";\nimport getInitSegment from \"./get_init_segment\";\nimport getSegmentsFromTimeline from \"./get_segments_from_timeline\";\nimport { constructRepresentationUrl } from \"./tokens\";\n/**\n * Add a new segment to the index.\n *\n * /!\\ Mutate the given index\n * @param {Object} index\n * @param {Object} segmentInfos\n * @returns {Boolean} - true if the segment has been added\n */\nfunction _addSegmentInfos(index, segmentInfos) {\n    if (segmentInfos.timescale !== index.timescale) {\n        const { timescale } = index;\n        index.timeline.push({\n            start: (segmentInfos.time / segmentInfos.timescale) * timescale,\n            duration: (segmentInfos.duration / segmentInfos.timescale) * timescale,\n            repeatCount: segmentInfos.count === undefined ? 0 : segmentInfos.count,\n            range: segmentInfos.range,\n        });\n    }\n    else {\n        index.timeline.push({\n            start: segmentInfos.time,\n            duration: segmentInfos.duration,\n            repeatCount: segmentInfos.count === undefined ? 0 : segmentInfos.count,\n            range: segmentInfos.range,\n        });\n    }\n    return true;\n}\nexport default class BaseRepresentationIndex {\n    /**\n     * @param {Object} index\n     * @param {Object} context\n     */\n    constructor(index, context) {\n        var _a, _b, _c, _d;\n        const { periodStart, periodEnd, representationId, representationBitrate, isEMSGWhitelisted, } = context;\n        const timescale = (_a = index.timescale) !== null && _a !== void 0 ? _a : 1;\n        const presentationTimeOffset = (_b = index.presentationTimeOffset) !== null && _b !== void 0 ? _b : 0;\n        const indexTimeOffset = presentationTimeOffset - periodStart * timescale;\n        const initializationUrl = ((_c = index.initialization) === null || _c === void 0 ? void 0 : _c.media) === undefined\n            ? null\n            : constructRepresentationUrl(index.initialization.media, representationId, representationBitrate);\n        const segmentUrlTemplate = index.media === undefined\n            ? null\n            : constructRepresentationUrl(index.media, representationId, representationBitrate);\n        // TODO If indexRange is either undefined or behind the initialization segment\n        // the following logic will not work.\n        // However taking the nth first bytes like `dash.js` does (where n = 1500) is\n        // not straightforward as we would need to clean-up the segment after that.\n        // The following logic corresponds to 100% of tested cases, so good enough for\n        // now.\n        let range;\n        if (index.initialization !== undefined) {\n            range = index.initialization.range;\n        }\n        else if (index.indexRange !== undefined) {\n            range = [0, index.indexRange[0] - 1];\n        }\n        this._index = {\n            indexRange: index.indexRange,\n            indexTimeOffset,\n            initialization: { url: initializationUrl, range },\n            segmentUrlTemplate,\n            startNumber: index.startNumber,\n            endNumber: index.endNumber,\n            timeline: (_d = index.timeline) !== null && _d !== void 0 ? _d : [],\n            timescale,\n        };\n        this._manifestBoundsCalculator = context.manifestBoundsCalculator;\n        this._scaledPeriodStart = toIndexTime(periodStart, this._index);\n        this._scaledPeriodEnd = isNullOrUndefined(periodEnd)\n            ? undefined\n            : toIndexTime(periodEnd, this._index);\n        this._isInitialized = this._index.timeline.length > 0;\n        this._isEMSGWhitelisted = isEMSGWhitelisted;\n    }\n    /**\n     * Construct init Segment.\n     * @returns {Object}\n     */\n    getInitSegment() {\n        return getInitSegment(this._index, this._isEMSGWhitelisted);\n    }\n    /**\n     * Get the list of segments that are currently available from the `from`\n     * position, in seconds, ending `dur` seconds after that position.\n     *\n     * Note that if not already done, you might need to \"initialize\" the\n     * `BaseRepresentationIndex` first so that the list of available segments\n     * is known.\n     *\n     * @see isInitialized for more information on `BaseRepresentationIndex`\n     * initialization.\n     * @param {Number} from\n     * @param {Number} dur\n     * @returns {Array.<Object>}\n     */\n    getSegments(from, dur) {\n        return getSegmentsFromTimeline(this._index, from, dur, this._manifestBoundsCalculator, this._scaledPeriodEnd, this._isEMSGWhitelisted);\n    }\n    /**\n     * Returns false as no Segment-Base based index should need to be refreshed.\n     * @returns {Boolean}\n     */\n    shouldRefresh() {\n        return false;\n    }\n    /**\n     * Returns first position in index.\n     * @returns {Number|null}\n     */\n    getFirstAvailablePosition() {\n        const index = this._index;\n        if (index.timeline.length === 0) {\n            return null;\n        }\n        return fromIndexTime(Math.max(this._scaledPeriodStart, index.timeline[0].start), index);\n    }\n    /**\n     * Returns last position in index.\n     * @returns {Number|null}\n     */\n    getLastAvailablePosition() {\n        var _a;\n        const { timeline } = this._index;\n        if (timeline.length === 0) {\n            return null;\n        }\n        const lastTimelineElement = timeline[timeline.length - 1];\n        const lastTime = Math.min(getIndexSegmentEnd(lastTimelineElement, null, this._scaledPeriodEnd), (_a = this._scaledPeriodEnd) !== null && _a !== void 0 ? _a : Infinity);\n        return fromIndexTime(lastTime, this._index);\n    }\n    /**\n     * Returns the absolute end in seconds this RepresentationIndex can reach once\n     * all segments are available.\n     * @returns {number|null|undefined}\n     */\n    getEnd() {\n        return this.getLastAvailablePosition();\n    }\n    /**\n     * Returns:\n     *   - `true` if in the given time interval, at least one new segment is\n     *     expected to be available in the future.\n     *   - `false` either if all segments in that time interval are already\n     *     available for download or if none will ever be available for it.\n     *   - `undefined` when it is not possible to tell.\n     *\n     * Always `false` in a `BaseRepresentationIndex` because all segments should\n     * be directly available.\n     * @returns {boolean}\n     */\n    awaitSegmentBetween() {\n        return false;\n    }\n    /**\n     * Segments in a segmentBase scheme should stay available.\n     * @returns {Boolean|undefined}\n     */\n    isSegmentStillAvailable() {\n        return true;\n    }\n    /**\n     * We do not check for discontinuity in SegmentBase-based indexes.\n     * @returns {null}\n     */\n    checkDiscontinuity() {\n        return null;\n    }\n    /**\n     * Returns `false` as a `BaseRepresentationIndex` should not be dynamic and as\n     * such segments should never fall out-of-sync.\n     * @returns {Boolean}\n     */\n    canBeOutOfSyncError() {\n        return false;\n    }\n    /**\n     * Returns `true` as SegmentBase are not dynamic and as such no new segment\n     * should become available in the future.\n     * @returns {Boolean}\n     */\n    isStillAwaitingFutureSegments() {\n        return false;\n    }\n    /**\n     * No segment in a `BaseRepresentationIndex` are known initially.\n     * It is only defined generally in an \"index segment\" that will thus need to\n     * be first loaded and parsed.\n     *\n     * Once the index segment or equivalent has been parsed, the `initializeIndex`\n     * method have to be called with the corresponding segment information so the\n     * `BaseRepresentationIndex` can be considered as \"initialized\" (and so this\n     * method can return `true`).\n     * Until then this method will return `false` and segments linked to that\n     * Representation may be missing.\n     * @returns {Boolean}\n     */\n    isInitialized() {\n        return this._isInitialized;\n    }\n    /**\n     * No segment in a `BaseRepresentationIndex` are known initially.\n     *\n     * It is only defined generally in an \"index segment\" that will thus need to\n     * be first loaded and parsed.\n     * Until then, this `BaseRepresentationIndex` is considered as `uninitialized`\n     * (@see isInitialized).\n     *\n     * Once that those information are available, the present\n     * `BaseRepresentationIndex` can be \"initialized\" by adding that parsed\n     * segment information through this method.\n     * @param {Array.<Object>} indexSegments\n     * @returns {Array.<Object>}\n     */\n    initialize(indexSegments) {\n        if (this._isInitialized) {\n            return;\n        }\n        for (let i = 0; i < indexSegments.length; i++) {\n            _addSegmentInfos(this._index, indexSegments[i]);\n        }\n        this._isInitialized = true;\n    }\n    addPredictedSegments() {\n        log.warn(\"Cannot add predicted segments to a `BaseRepresentationIndex`\");\n    }\n    /**\n     * Returns the `duration` of each segment in the context of its Manifest (i.e.\n     * as the Manifest anounces them, actual segment duration may be different due\n     * to approximations), in seconds.\n     *\n     * NOTE: we could here do a median or a mean but I chose to be lazy (and\n     * more performant) by returning the duration of the first element instead.\n     * As `isPrecize` is `false`, the rest of the code should be notified that\n     * this is only an approximation.\n     * @returns {number}\n     */\n    getTargetSegmentDuration() {\n        const { timeline, timescale } = this._index;\n        const firstElementInTimeline = timeline[0];\n        if (firstElementInTimeline === undefined) {\n            return undefined;\n        }\n        return {\n            duration: firstElementInTimeline.duration / timescale,\n            isPrecize: false,\n        };\n    }\n    /**\n     * Replace in-place this `BaseRepresentationIndex` information by the\n     * information from another one.\n     * @param {Object} newIndex\n     */\n    _replace(newIndex) {\n        this._index = newIndex._index;\n        this._isInitialized = newIndex._isInitialized;\n        this._scaledPeriodEnd = newIndex._scaledPeriodEnd;\n        this._isEMSGWhitelisted = newIndex._isEMSGWhitelisted;\n    }\n    _update() {\n        log.error(\"Base RepresentationIndex: Cannot update a SegmentList\");\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport isNullOrUndefined from \"../../../../../utils/is_null_or_undefined\";\n/**\n * Construct init segment for the given index.\n * @param {Object} index\n * @param {function} isEMSGWhitelisted\n * @returns {Object}\n */\nexport default function getInitSegment(index, isEMSGWhitelisted) {\n    var _a;\n    const { initialization } = index;\n    const privateInfos = {};\n    if (isEMSGWhitelisted !== undefined) {\n        privateInfos.isEMSGWhitelisted = isEMSGWhitelisted;\n    }\n    return {\n        id: \"init\",\n        isInit: true,\n        time: 0,\n        end: 0,\n        duration: 0,\n        timescale: 1,\n        range: !isNullOrUndefined(initialization) ? initialization.range : undefined,\n        indexRange: index.indexRange,\n        url: (_a = initialization === null || initialization === void 0 ? void 0 : initialization.url) !== null && _a !== void 0 ? _a : null,\n        complete: true,\n        privateInfos,\n        timestampOffset: -(index.indexTimeOffset / index.timescale),\n    };\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { calculateRepeat, toIndexTime } from \"../../../utils/index_helpers\";\nimport { createDashUrlDetokenizer } from \"./tokens\";\n/**\n * For the given start time and duration of a timeline element, calculate how\n * much this element should be repeated to contain the time given.\n * 0 being the same element, 1 being the next one etc.\n * @param {Number} segmentStartTime\n * @param {Number} segmentDuration\n * @param {Number} wantedTime\n * @returns {Number}\n */\nfunction getWantedRepeatIndex(segmentStartTime, segmentDuration, wantedTime) {\n    const diff = wantedTime - segmentStartTime;\n    return diff > 0 ? Math.floor(diff / segmentDuration) : 0;\n}\n/**\n * Get a list of Segments for the time range wanted.\n * @param {Object} index - index object, constructed by parsing the manifest.\n * @param {number} from - starting timestamp wanted, in seconds\n * @param {number} durationWanted - duration wanted, in seconds\n * @param {Object} manifestBoundsCalculator\n * @param {number|undefined} scaledPeriodEnd\n * @param {function} isEMSGWhitelisted\n * @returns {Array.<Object>}\n */\nexport default function getSegmentsFromTimeline(index, from, durationWanted, manifestBoundsCalculator, scaledPeriodEnd, isEMSGWhitelisted) {\n    var _a;\n    const maximumTime = manifestBoundsCalculator.getEstimatedMaximumPosition((_a = index.availabilityTimeOffset) !== null && _a !== void 0 ? _a : 0);\n    const wantedMaximum = Math.min(from + durationWanted, maximumTime !== null && maximumTime !== void 0 ? maximumTime : Infinity);\n    const scaledUp = toIndexTime(from, index);\n    const scaledTo = toIndexTime(wantedMaximum, index);\n    const { timeline, timescale, segmentUrlTemplate, startNumber, endNumber } = index;\n    let currentNumber = startNumber !== null && startNumber !== void 0 ? startNumber : 1;\n    const segments = [];\n    const timelineLength = timeline.length;\n    for (let i = 0; i < timelineLength; i++) {\n        const timelineItem = timeline[i];\n        const { duration, start, range } = timelineItem;\n        let maxRepeatTime;\n        if (maximumTime === undefined) {\n            maxRepeatTime = scaledPeriodEnd;\n        }\n        else {\n            maxRepeatTime = Math.min(maximumTime * timescale, scaledPeriodEnd !== null && scaledPeriodEnd !== void 0 ? scaledPeriodEnd : Infinity);\n        }\n        const repeat = calculateRepeat(timelineItem, timeline[i + 1], maxRepeatTime);\n        const complete = index.availabilityTimeComplete !== false ||\n            (i !== timelineLength - 1 && repeat !== 0);\n        let segmentNumberInCurrentRange = getWantedRepeatIndex(start, duration, scaledUp);\n        let segmentTime = start + segmentNumberInCurrentRange * duration;\n        while (segmentTime < scaledTo && segmentNumberInCurrentRange <= repeat) {\n            const segmentNumber = currentNumber + segmentNumberInCurrentRange;\n            if (endNumber !== undefined && segmentNumber > endNumber) {\n                break;\n            }\n            const detokenizedURL = segmentUrlTemplate === null\n                ? null\n                : createDashUrlDetokenizer(segmentTime, segmentNumber)(segmentUrlTemplate);\n            let time = segmentTime - index.indexTimeOffset;\n            let realDuration = duration;\n            if (time < 0) {\n                realDuration = duration + time; // Remove from duration the part before `0`\n                time = 0;\n            }\n            const segment = {\n                id: String(segmentTime),\n                time: time / timescale,\n                end: (time + realDuration) / timescale,\n                duration: realDuration / timescale,\n                isInit: false,\n                range,\n                timescale: 1,\n                url: detokenizedURL,\n                number: segmentNumber,\n                timestampOffset: -(index.indexTimeOffset / timescale),\n                complete,\n                privateInfos: { isEMSGWhitelisted },\n            };\n            segments.push(segment);\n            // update segment number and segment time for the next segment\n            segmentNumberInCurrentRange++;\n            segmentTime = start + segmentNumberInCurrentRange * duration;\n        }\n        if (segmentTime >= scaledTo) {\n            // we reached ``scaledTo``, we're done\n            return segments;\n        }\n        currentNumber += repeat + 1;\n        if (endNumber !== undefined && currentNumber > endNumber) {\n            return segments;\n        }\n    }\n    return segments;\n}\n","/*\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../../../../log\";\nimport isNullOrUndefined from \"../../../../../utils/is_null_or_undefined\";\nimport { getTimescaledRange } from \"../../../utils/index_helpers\";\nimport getInitSegment from \"./get_init_segment\";\nimport { constructRepresentationUrl } from \"./tokens\";\nexport default class ListRepresentationIndex {\n    /**\n     * @param {Object} index\n     * @param {Object} context\n     */\n    constructor(index, context) {\n        var _a, _b, _c;\n        if (index.duration === undefined) {\n            throw new Error(\"Invalid SegmentList: no duration\");\n        }\n        const { periodStart, periodEnd, representationId, representationBitrate, isEMSGWhitelisted, } = context;\n        this._isEMSGWhitelisted = isEMSGWhitelisted;\n        this._periodStart = periodStart;\n        this._periodEnd = periodEnd;\n        const presentationTimeOffset = (_a = index.presentationTimeOffset) !== null && _a !== void 0 ? _a : 0;\n        const timescale = (_b = index.timescale) !== null && _b !== void 0 ? _b : 1;\n        const indexTimeOffset = presentationTimeOffset - periodStart * timescale;\n        const initializationUrl = ((_c = index.initialization) === null || _c === void 0 ? void 0 : _c.media) === undefined\n            ? null\n            : constructRepresentationUrl(index.initialization.media, representationId, representationBitrate);\n        const list = index.list.map((lItem) => ({\n            url: lItem.media === undefined\n                ? null\n                : constructRepresentationUrl(lItem.media, representationId, representationBitrate),\n            mediaRange: lItem.mediaRange,\n        }));\n        this._index = {\n            list,\n            timescale,\n            duration: index.duration,\n            indexTimeOffset,\n            indexRange: index.indexRange,\n            initialization: isNullOrUndefined(index.initialization)\n                ? undefined\n                : { url: initializationUrl, range: index.initialization.range },\n        };\n    }\n    /**\n     * Construct init Segment.\n     * @returns {Object}\n     */\n    getInitSegment() {\n        const initSegment = getInitSegment(this._index);\n        if (initSegment.privateInfos === undefined) {\n            initSegment.privateInfos = {};\n        }\n        initSegment.privateInfos.isEMSGWhitelisted = this._isEMSGWhitelisted;\n        return initSegment;\n    }\n    /**\n     * @param {Number} fromTime\n     * @param {Number} dur\n     * @returns {Array.<Object>}\n     */\n    getSegments(fromTime, dur) {\n        const index = this._index;\n        const { duration, list, timescale } = index;\n        const durationInSeconds = duration / timescale;\n        const fromTimeInPeriod = fromTime - this._periodStart;\n        const [up, to] = getTimescaledRange(fromTimeInPeriod, dur, timescale);\n        const length = Math.min(list.length - 1, Math.floor(to / duration));\n        const segments = [];\n        let i = Math.floor(up / duration);\n        while (i <= length) {\n            const range = list[i].mediaRange;\n            const url = list[i].url;\n            const time = i * durationInSeconds + this._periodStart;\n            const segment = {\n                id: String(i),\n                time,\n                isInit: false,\n                range,\n                duration: durationInSeconds,\n                timescale: 1,\n                end: time + durationInSeconds,\n                url,\n                timestampOffset: -(index.indexTimeOffset / timescale),\n                complete: true,\n                privateInfos: { isEMSGWhitelisted: this._isEMSGWhitelisted },\n            };\n            segments.push(segment);\n            i++;\n        }\n        return segments;\n    }\n    /**\n     * Returns whether the Manifest should be refreshed based on the\n     * `ListRepresentationIndex`'s state and the time range the player is\n     * currently considering.\n     * @param {Number} _fromTime\n     * @param {Number} _toTime\n     * @returns {Boolean}\n     */\n    shouldRefresh(_fromTime, _toTime) {\n        // DASH Manifests are usually refreshed through other means, i.e. thanks to\n        // the `minimumUpdatePeriod` attribute.\n        // Moreover, SegmentList are usually only found in static MPDs.\n        return false;\n    }\n    /**\n     * Returns first position in this index, in seconds.\n     * @returns {Number}\n     */\n    getFirstAvailablePosition() {\n        return this._periodStart;\n    }\n    /**\n     * Returns last position in this index, in seconds.\n     * @returns {Number}\n     */\n    getLastAvailablePosition() {\n        var _a;\n        const index = this._index;\n        const { duration, list } = index;\n        return Math.min((list.length * duration) / index.timescale + this._periodStart, (_a = this._periodEnd) !== null && _a !== void 0 ? _a : Infinity);\n    }\n    /**\n     * Returns the absolute end in seconds this RepresentationIndex can reach once\n     * all segments are available.\n     * @returns {number|null|undefined}\n     */\n    getEnd() {\n        return this.getLastAvailablePosition();\n    }\n    /**\n     * Returns:\n     *   - `true` if in the given time interval, at least one new segment is\n     *     expected to be available in the future.\n     *   - `false` either if all segments in that time interval are already\n     *     available for download or if none will ever be available for it.\n     *   - `undefined` when it is not possible to tell.\n     *\n     * Always `false` in a `ListRepresentationIndex` because all segments should\n     * be directly available.\n     * @returns {boolean}\n     */\n    awaitSegmentBetween() {\n        return false;\n    }\n    /**\n     * Returns true if a Segment returned by this index is still considered\n     * available.\n     * @returns {Boolean}\n     */\n    isSegmentStillAvailable() {\n        return true;\n    }\n    /**\n     * We do not check for discontinuity in SegmentList-based indexes.\n     * @returns {null}\n     */\n    checkDiscontinuity() {\n        return null;\n    }\n    /**\n     * SegmentList should not be updated.\n     * @returns {Boolean}\n     */\n    canBeOutOfSyncError() {\n        return false;\n    }\n    /**\n     * @returns {Boolean}\n     */\n    isStillAwaitingFutureSegments() {\n        return false;\n    }\n    /**\n     * @returns {Boolean}\n     */\n    isInitialized() {\n        return true;\n    }\n    initialize() {\n        log.error(\"A `ListRepresentationIndex` does not need to be initialized\");\n    }\n    addPredictedSegments() {\n        log.warn(\"Cannot add predicted segments to a `ListRepresentationIndex`\");\n    }\n    /**\n     * Returns the `duration` of each segment in the context of its Manifest (i.e.\n     * as the Manifest anounces them, actual segment duration may be different due\n     * to approximations), in seconds.\n     *\n     * NOTE: we could here do a median or a mean but I chose to be lazy (and\n     * more performant) by returning the duration of the first element instead.\n     * As `isPrecize` is `false`, the rest of the code should be notified that\n     * this is only an approximation.\n     * @returns {number}\n     */\n    getTargetSegmentDuration() {\n        const { duration, timescale } = this._index;\n        return {\n            duration: duration / timescale,\n            isPrecize: true,\n        };\n    }\n    /**\n     * @param {Object} newIndex\n     */\n    _replace(newIndex) {\n        this._index = newIndex._index;\n    }\n    _update() {\n        log.error(\"A `ListRepresentationIndex` cannot be updated\");\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport config from \"../../../../../config\";\nimport log from \"../../../../../log\";\nimport assert from \"../../../../../utils/assert\";\nimport isNullOrUndefined from \"../../../../../utils/is_null_or_undefined\";\nimport getInitSegment from \"./get_init_segment\";\nimport { createDashUrlDetokenizer, constructRepresentationUrl } from \"./tokens\";\nimport { getSegmentTimeRoundingError } from \"./utils\";\n/**\n * IRepresentationIndex implementation for DASH' SegmentTemplate without a\n * SegmentTimeline.\n * @class TemplateRepresentationIndex\n */\nexport default class TemplateRepresentationIndex {\n    /**\n     * @param {Object} index\n     * @param {Object} context\n     */\n    constructor(index, context) {\n        var _a, _b, _c;\n        const { availabilityTimeOffset, manifestBoundsCalculator, isDynamic, periodEnd, periodStart, representationId, representationBitrate, isEMSGWhitelisted, } = context;\n        const timescale = (_a = index.timescale) !== null && _a !== void 0 ? _a : 1;\n        this._availabilityTimeOffset = availabilityTimeOffset;\n        this._manifestBoundsCalculator = manifestBoundsCalculator;\n        const presentationTimeOffset = (_b = index.presentationTimeOffset) !== null && _b !== void 0 ? _b : 0;\n        const scaledStart = periodStart * timescale;\n        const indexTimeOffset = presentationTimeOffset - scaledStart;\n        if (index.duration === undefined) {\n            throw new Error(\"Invalid SegmentTemplate: no duration\");\n        }\n        const initializationUrl = ((_c = index.initialization) === null || _c === void 0 ? void 0 : _c.media) === undefined\n            ? null\n            : constructRepresentationUrl(index.initialization.media, representationId, representationBitrate);\n        const segmentUrlTemplate = index.media === undefined\n            ? null\n            : constructRepresentationUrl(index.media, representationId, representationBitrate);\n        this._index = {\n            duration: index.duration,\n            timescale,\n            indexRange: index.indexRange,\n            indexTimeOffset,\n            initialization: isNullOrUndefined(index.initialization)\n                ? undefined\n                : { url: initializationUrl, range: index.initialization.range },\n            url: segmentUrlTemplate,\n            presentationTimeOffset,\n            startNumber: index.startNumber,\n            endNumber: index.endNumber,\n        };\n        this._isDynamic = isDynamic;\n        this._periodStart = periodStart;\n        this._scaledRelativePeriodEnd =\n            periodEnd === undefined ? undefined : (periodEnd - periodStart) * timescale;\n        this._isEMSGWhitelisted = isEMSGWhitelisted;\n    }\n    /**\n     * Construct init Segment.\n     * @returns {Object}\n     */\n    getInitSegment() {\n        return getInitSegment(this._index, this._isEMSGWhitelisted);\n    }\n    /**\n     * @param {Number} fromTime\n     * @param {Number} dur\n     * @returns {Array.<Object>}\n     */\n    getSegments(fromTime, dur) {\n        const index = this._index;\n        const { duration, startNumber, endNumber, timescale, url } = index;\n        const scaledStart = this._periodStart * timescale;\n        const scaledEnd = this._scaledRelativePeriodEnd;\n        // Convert the asked position to the right timescales, and consider them\n        // relatively to the Period's start.\n        const upFromPeriodStart = fromTime * timescale - scaledStart;\n        const toFromPeriodStart = (fromTime + dur) * timescale - scaledStart;\n        const firstSegmentStart = this._getFirstSegmentStart();\n        const lastSegmentStart = this._getLastSegmentStart();\n        if (isNullOrUndefined(firstSegmentStart) || isNullOrUndefined(lastSegmentStart)) {\n            return [];\n        }\n        const startPosition = Math.max(firstSegmentStart, upFromPeriodStart);\n        const lastWantedStartPosition = Math.min(lastSegmentStart, toFromPeriodStart);\n        if (lastWantedStartPosition + duration <= startPosition) {\n            return [];\n        }\n        const segments = [];\n        // number corresponding to the Period's start\n        const numberOffset = startNumber !== null && startNumber !== void 0 ? startNumber : 1;\n        // calcul initial time from Period start, where the first segment would have\n        // the `0` number\n        let numberIndexedToZero = Math.floor(startPosition / duration);\n        for (let timeFromPeriodStart = numberIndexedToZero * duration; timeFromPeriodStart <= lastWantedStartPosition; timeFromPeriodStart += duration) {\n            // To obtain the real number, adds the real number from the Period's start\n            const realNumber = numberIndexedToZero + numberOffset;\n            if (endNumber !== undefined && realNumber > endNumber) {\n                return segments;\n            }\n            const realDuration = !isNullOrUndefined(scaledEnd) && timeFromPeriodStart + duration > scaledEnd\n                ? scaledEnd - timeFromPeriodStart\n                : duration;\n            const realTime = timeFromPeriodStart + scaledStart;\n            const manifestTime = timeFromPeriodStart + this._index.presentationTimeOffset;\n            const detokenizedURL = url === null ? null : createDashUrlDetokenizer(manifestTime, realNumber)(url);\n            const args = {\n                id: String(realNumber),\n                number: realNumber,\n                time: realTime / timescale,\n                end: (realTime + realDuration) / timescale,\n                duration: realDuration / timescale,\n                timescale: 1,\n                isInit: false,\n                scaledDuration: realDuration / timescale,\n                url: detokenizedURL,\n                timestampOffset: -(index.indexTimeOffset / timescale),\n                complete: true,\n                privateInfos: {\n                    isEMSGWhitelisted: this._isEMSGWhitelisted,\n                },\n            };\n            segments.push(args);\n            numberIndexedToZero++;\n        }\n        return segments;\n    }\n    /**\n     * Returns first possible position in the index, in seconds.\n     * @returns {number|null|undefined}\n     */\n    getFirstAvailablePosition() {\n        const firstSegmentStart = this._getFirstSegmentStart();\n        if (isNullOrUndefined(firstSegmentStart)) {\n            return firstSegmentStart; // return undefined or null\n        }\n        return firstSegmentStart / this._index.timescale + this._periodStart;\n    }\n    /**\n     * Returns last possible position in the index, in seconds.\n     * @returns {number|null}\n     */\n    getLastAvailablePosition() {\n        const lastSegmentStart = this._getLastSegmentStart();\n        if (isNullOrUndefined(lastSegmentStart)) {\n            // In that case (null or undefined), getLastAvailablePosition should reflect\n            // the result of getLastSegmentStart, as the meaning is the same for\n            // the two functions. So, we return the result of the latter.\n            return lastSegmentStart;\n        }\n        const scaledRelativeIndexEnd = this._estimateRelativeScaledEnd();\n        const lastSegmentEnd = Math.min(lastSegmentStart + this._index.duration, scaledRelativeIndexEnd !== null && scaledRelativeIndexEnd !== void 0 ? scaledRelativeIndexEnd : Infinity);\n        return lastSegmentEnd / this._index.timescale + this._periodStart;\n    }\n    /**\n     * Returns the absolute end in seconds this RepresentationIndex can reach once\n     * all segments are available.\n     * @returns {number|null|undefined}\n     */\n    getEnd() {\n        if (!this._isDynamic) {\n            return this.getLastAvailablePosition();\n        }\n        const scaledRelativeIndexEnd = this._estimateRelativeScaledEnd();\n        if (scaledRelativeIndexEnd === undefined) {\n            return undefined;\n        }\n        const { timescale } = this._index;\n        const absoluteScaledIndexEnd = scaledRelativeIndexEnd + this._periodStart * timescale;\n        return absoluteScaledIndexEnd / timescale;\n    }\n    /**\n     * Returns:\n     *   - `true` if in the given time interval, at least one new segment is\n     *     expected to be available in the future.\n     *   - `false` either if all segments in that time interval are already\n     *     available for download or if none will ever be available for it.\n     *   - `undefined` when it is not possible to tell.\n     *\n     * Always `false` in a `BaseRepresentationIndex` because all segments should\n     * be directly available.\n     * @returns {boolean}\n     */\n    awaitSegmentBetween(start, end) {\n        assert(start <= end);\n        if (!this._isDynamic) {\n            return false;\n        }\n        const { timescale } = this._index;\n        const segmentTimeRounding = getSegmentTimeRoundingError(timescale);\n        const scaledPeriodStart = this._periodStart * timescale;\n        const scaledRelativeStart = start * timescale - scaledPeriodStart;\n        const scaledRelativeEnd = end * timescale - scaledPeriodStart;\n        const lastSegmentStart = this._getLastSegmentStart();\n        if (isNullOrUndefined(lastSegmentStart)) {\n            const relativeScaledIndexEnd = this._estimateRelativeScaledEnd();\n            if (relativeScaledIndexEnd === undefined) {\n                return scaledRelativeEnd + segmentTimeRounding >= 0;\n            }\n            return (scaledRelativeEnd + segmentTimeRounding >= 0 &&\n                scaledRelativeStart < relativeScaledIndexEnd - segmentTimeRounding);\n        }\n        const lastSegmentEnd = lastSegmentStart + this._index.duration;\n        const relativeScaledIndexEnd = this._estimateRelativeScaledEnd();\n        if (relativeScaledIndexEnd === undefined) {\n            return scaledRelativeEnd > lastSegmentEnd - segmentTimeRounding;\n        }\n        return (scaledRelativeEnd > lastSegmentEnd - segmentTimeRounding &&\n            scaledRelativeStart < relativeScaledIndexEnd - segmentTimeRounding);\n    }\n    /**\n     * Returns true if, based on the arguments, the index should be refreshed.\n     * We never have to refresh a SegmentTemplate-based manifest.\n     * @returns {Boolean}\n     */\n    shouldRefresh() {\n        return false;\n    }\n    /**\n     * We cannot check for discontinuity in SegmentTemplate-based indexes.\n     * @returns {null}\n     */\n    checkDiscontinuity() {\n        return null;\n    }\n    /**\n     * Returns `true` if the given segment should still be available as of now\n     * (not removed since and still request-able).\n     * Returns `false` if that's not the case.\n     * Returns `undefined` if we do not know whether that's the case or not.\n     * @param {Object} segment\n     * @returns {boolean|undefined}\n     */\n    isSegmentStillAvailable(segment) {\n        if (segment.isInit) {\n            return true;\n        }\n        const segmentsForTime = this.getSegments(segment.time, 0.1);\n        if (segmentsForTime.length === 0) {\n            return false;\n        }\n        return (segmentsForTime[0].time === segment.time &&\n            segmentsForTime[0].end === segment.end &&\n            segmentsForTime[0].number === segment.number);\n    }\n    /**\n     * SegmentTemplate without a SegmentTimeline should not be updated.\n     * @returns {Boolean}\n     */\n    canBeOutOfSyncError() {\n        return false;\n    }\n    /**\n     * Returns `false` if the last segments in this index have already been\n     * generated so that we can freely go to the next period.\n     * Returns `true` if the index is still waiting on future segments to be\n     * generated.\n     * @returns {Boolean}\n     */\n    isStillAwaitingFutureSegments() {\n        if (!this._isDynamic) {\n            return false;\n        }\n        const scaledRelativeIndexEnd = this._estimateRelativeScaledEnd();\n        if (scaledRelativeIndexEnd === undefined) {\n            return true;\n        }\n        const { timescale } = this._index;\n        const lastSegmentStart = this._getLastSegmentStart();\n        // As last segment start is null if live time is before\n        // current period, consider the index not to be finished.\n        if (isNullOrUndefined(lastSegmentStart)) {\n            return true;\n        }\n        const lastSegmentEnd = lastSegmentStart + this._index.duration;\n        const segmentTimeRounding = getSegmentTimeRoundingError(timescale);\n        return lastSegmentEnd + segmentTimeRounding < scaledRelativeIndexEnd;\n    }\n    /**\n     * @returns {Boolean}\n     */\n    isInitialized() {\n        return true;\n    }\n    initialize() {\n        log.error(\"A `TemplateRepresentationIndex` does not need to be initialized\");\n    }\n    addPredictedSegments() {\n        log.warn(\"Cannot add predicted segments to a `TemplateRepresentationIndex`\");\n    }\n    /**\n     * Returns the `duration` of each segment in the context of its Manifest (i.e.\n     * as the Manifest anounces them, actual segment duration may be different due\n     * to approximations), in seconds.\n     * @returns {number}\n     */\n    getTargetSegmentDuration() {\n        return {\n            duration: this._index.duration / this._index.timescale,\n            isPrecize: true,\n        };\n    }\n    /**\n     * @param {Object} newIndex\n     */\n    _replace(newIndex) {\n        this._index = newIndex._index;\n        this._isDynamic = newIndex._isDynamic;\n        this._periodStart = newIndex._periodStart;\n        this._scaledRelativePeriodEnd = newIndex._scaledRelativePeriodEnd;\n        this._manifestBoundsCalculator = newIndex._manifestBoundsCalculator;\n    }\n    /**\n     * @param {Object} newIndex\n     */\n    _update(newIndex) {\n        // As segments are not declared individually, as long as this Representation\n        // is present, we have every information we need\n        this._replace(newIndex);\n    }\n    /**\n     * Returns the timescaled start of the first segment that should be available,\n     * relatively to the start of the Period.\n     * @returns {number | null | undefined}\n     */\n    _getFirstSegmentStart() {\n        var _a;\n        if (!this._isDynamic) {\n            return 0; // it is the start of the Period\n        }\n        // 1 - check that this index is already available\n        if (this._scaledRelativePeriodEnd === 0 ||\n            this._scaledRelativePeriodEnd === undefined) {\n            // /!\\ The scaled max position augments continuously and might not\n            // reflect exactly the real server-side value. As segments are\n            // generated discretely.\n            const maximumSegmentTime = this._manifestBoundsCalculator.getEstimatedMaximumPosition((_a = this._availabilityTimeOffset) !== null && _a !== void 0 ? _a : 0);\n            if (maximumSegmentTime !== undefined && maximumSegmentTime < this._periodStart) {\n                // Maximum position is before this period.\n                // No segment is yet available here\n                return null;\n            }\n        }\n        const { duration, timescale } = this._index;\n        const firstPosition = this._manifestBoundsCalculator.getEstimatedMinimumSegmentTime(duration / timescale);\n        if (firstPosition === undefined) {\n            return undefined;\n        }\n        const segmentTime = firstPosition > this._periodStart\n            ? (firstPosition - this._periodStart) * timescale\n            : 0;\n        const numberIndexedToZero = Math.floor(segmentTime / duration);\n        return numberIndexedToZero * duration;\n    }\n    /**\n     * Returns the timescaled start of the last segment that should be available,\n     * relatively to the start of the Period.\n     * Returns null if live time is before current period.\n     * @returns {number|null|undefined}\n     */\n    _getLastSegmentStart() {\n        var _a, _b;\n        const { duration, timescale, endNumber, startNumber = 1 } = this._index;\n        if (this._isDynamic) {\n            const liveEdge = this._manifestBoundsCalculator.getEstimatedLiveEdge();\n            if (liveEdge !== undefined &&\n                this._scaledRelativePeriodEnd !== undefined &&\n                this._scaledRelativePeriodEnd <\n                    liveEdge - this._periodStart * this._index.timescale) {\n                let numberOfSegments = Math.ceil(this._scaledRelativePeriodEnd / duration);\n                if (endNumber !== undefined && endNumber - startNumber + 1 < numberOfSegments) {\n                    numberOfSegments = endNumber - startNumber + 1;\n                }\n                return (numberOfSegments - 1) * duration;\n            }\n            const lastPosition = this._manifestBoundsCalculator.getEstimatedMaximumPosition((_a = this._availabilityTimeOffset) !== null && _a !== void 0 ? _a : 0);\n            if (lastPosition === undefined) {\n                return undefined;\n            }\n            // /!\\ The scaled last position augments continuously and might not\n            // reflect exactly the real server-side value. As segments are\n            // generated discretely.\n            const scaledLastPosition = (lastPosition - this._periodStart) * timescale;\n            // Maximum position is before this period.\n            // No segment is yet available here\n            if (scaledLastPosition < 0) {\n                return null;\n            }\n            let numberOfSegmentsAvailable = Math.floor(scaledLastPosition / duration);\n            if (endNumber !== undefined &&\n                endNumber - startNumber + 1 < numberOfSegmentsAvailable) {\n                numberOfSegmentsAvailable = endNumber - startNumber + 1;\n            }\n            return numberOfSegmentsAvailable <= 0\n                ? null\n                : (numberOfSegmentsAvailable - 1) * duration;\n        }\n        else {\n            const maximumTime = (_b = this._scaledRelativePeriodEnd) !== null && _b !== void 0 ? _b : 0;\n            let numberOfSegments = Math.ceil(maximumTime / duration);\n            if (endNumber !== undefined && endNumber - startNumber + 1 < numberOfSegments) {\n                numberOfSegments = endNumber - startNumber + 1;\n            }\n            const regularLastSegmentStart = (numberOfSegments - 1) * duration;\n            // In some SegmentTemplate, we could think that there is one more\n            // segment that there actually is due to a very little difference between\n            // the period's duration and a multiple of a segment's duration.\n            // Check that we're within a good margin\n            const minimumDuration = config.getCurrent().MINIMUM_SEGMENT_SIZE * timescale;\n            if (endNumber !== undefined ||\n                maximumTime - regularLastSegmentStart > minimumDuration ||\n                numberOfSegments < 2) {\n                return regularLastSegmentStart;\n            }\n            return (numberOfSegments - 2) * duration;\n        }\n    }\n    /**\n     * Returns an estimate of the last available position in this\n     * `RepresentationIndex` based on attributes such as the Period's end and\n     * the `endNumber` attribute.\n     * If the estimate cannot be made (e.g. this Period's segments are still being\n     * generated and its end is yet unknown), returns `undefined`.\n     * @returns {number|undefined}\n     */\n    _estimateRelativeScaledEnd() {\n        var _a, _b;\n        if (this._index.endNumber !== undefined) {\n            const numberOfSegments = this._index.endNumber - ((_a = this._index.startNumber) !== null && _a !== void 0 ? _a : 1) + 1;\n            return Math.max(Math.min(numberOfSegments * this._index.duration, (_b = this._scaledRelativePeriodEnd) !== null && _b !== void 0 ? _b : Infinity), 0);\n        }\n        if (this._scaledRelativePeriodEnd === undefined) {\n            return undefined;\n        }\n        return Math.max(this._scaledRelativePeriodEnd, 0);\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport convertElementsToIndexSegment from \"./convert_element_to_index_segment\";\nimport { parseSElementNode, parseSHTMLElement } from \"./parse_s_element\";\n/**\n * Allows to generate the \"timeline\" for the \"Timeline\" RepresentationIndex.\n * Call this function when the timeline is unknown.\n * This function was added to only perform that task lazily, i.e. only when\n * first needed.\n * @param {Array.<Object>|HTMLCollection} elements - All S nodes constituting\n * the corresponding SegmentTimeline node.\n * @returns {Array.<Object>}\n */\nexport default function constructTimelineFromElements(elements) {\n    const initialTimeline = [];\n    if (Array.isArray(elements)) {\n        for (let i = 0; i < elements.length; i++) {\n            initialTimeline.push(parseSElementNode(elements[i]));\n        }\n    }\n    else {\n        for (let i = 0; i < elements.length; i++) {\n            initialTimeline.push(parseSHTMLElement(elements[i]));\n        }\n    }\n    const timeline = [];\n    for (let i = 0; i < initialTimeline.length; i++) {\n        const item = initialTimeline[i];\n        const previousItem = timeline[timeline.length - 1] === undefined ? null : timeline[timeline.length - 1];\n        const nextItem = initialTimeline[i + 1] === undefined ? null : initialTimeline[i + 1];\n        const timelineElement = convertElementsToIndexSegment(item, previousItem, nextItem);\n        if (timelineElement !== null) {\n            timeline.push(timelineElement);\n        }\n    }\n    return timeline;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../../../../../log\";\nimport constructTimelineFromElements from \"./construct_timeline_from_elements\";\nimport convertElementToIndexSegment from \"./convert_element_to_index_segment\";\nimport findFirstCommonStartTime from \"./find_first_common_start_time\";\nimport { parseSElementNode, parseSHTMLElement } from \"./parse_s_element\";\nexport default function constructTimelineFromPreviousTimeline(newElements, prevTimeline) {\n    var _a;\n    // Find first index in both timeline where a common segment is found.\n    const commonStartInfo = findFirstCommonStartTime(prevTimeline, newElements);\n    if (commonStartInfo === null) {\n        log.warn('DASH: Cannot perform \"based\" update. Common segment not found.');\n        return constructTimelineFromElements(newElements);\n    }\n    const { prevSegmentsIdx, newElementsIdx, repeatNumberInPrevSegments, repeatNumberInNewElements, } = commonStartInfo;\n    /** Guess of the number of elements in common. */\n    const numberCommonEltGuess = prevTimeline.length - prevSegmentsIdx;\n    const lastCommonEltNewEltsIdx = numberCommonEltGuess + newElementsIdx - 1;\n    if (lastCommonEltNewEltsIdx >= newElements.length) {\n        log.info('DASH: Cannot perform \"based\" update. New timeline too short');\n        return constructTimelineFromElements(newElements);\n    }\n    // Remove elements which are not available anymore\n    const newTimeline = prevTimeline.slice(prevSegmentsIdx);\n    if (repeatNumberInPrevSegments > 0) {\n        const commonEltInOldTimeline = newTimeline[0];\n        commonEltInOldTimeline.start +=\n            commonEltInOldTimeline.duration * repeatNumberInPrevSegments;\n        newTimeline[0].repeatCount -= repeatNumberInPrevSegments;\n    }\n    if (repeatNumberInNewElements > 0 && newElementsIdx !== 0) {\n        log.info('DASH: Cannot perform \"based\" update. ' + \"The new timeline has a different form.\");\n        return constructTimelineFromElements(newElements);\n    }\n    const prevLastElement = newTimeline[newTimeline.length - 1];\n    const newCommonElt = Array.isArray(newElements)\n        ? parseSElementNode(newElements[lastCommonEltNewEltsIdx])\n        : parseSHTMLElement(newElements[lastCommonEltNewEltsIdx]);\n    const newRepeatCountOffseted = ((_a = newCommonElt.repeatCount) !== null && _a !== void 0 ? _a : 0) - repeatNumberInNewElements;\n    if (newCommonElt.duration !== prevLastElement.duration ||\n        prevLastElement.repeatCount > newRepeatCountOffseted) {\n        log.info('DASH: Cannot perform \"based\" update. ' +\n            \"The new timeline has a different form at the beginning.\");\n        return constructTimelineFromElements(newElements);\n    }\n    if (newCommonElt.repeatCount !== undefined &&\n        newCommonElt.repeatCount > prevLastElement.repeatCount) {\n        prevLastElement.repeatCount = newCommonElt.repeatCount;\n    }\n    const newEltsToPush = [];\n    const items = [];\n    if (Array.isArray(newElements)) {\n        for (let i = lastCommonEltNewEltsIdx + 1; i < newElements.length; i++) {\n            items.push(parseSElementNode(newElements[i]));\n        }\n    }\n    else {\n        for (let i = lastCommonEltNewEltsIdx + 1; i < newElements.length; i++) {\n            items.push(parseSHTMLElement(newElements[i]));\n        }\n    }\n    for (let i = 0; i < items.length; i++) {\n        const item = items[i];\n        const previousItem = newEltsToPush[newEltsToPush.length - 1] === undefined\n            ? prevLastElement\n            : newEltsToPush[newEltsToPush.length - 1];\n        const nextItem = items[i + 1] === undefined ? null : items[i + 1];\n        const timelineElement = convertElementToIndexSegment(item, previousItem, nextItem);\n        if (timelineElement !== null) {\n            newEltsToPush.push(timelineElement);\n        }\n    }\n    return newTimeline.concat(newEltsToPush);\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../../../../../log\";\nimport isNullOrUndefined from \"../../../../../../utils/is_null_or_undefined\";\n/**\n * Translate parsed `S` node into Segment compatible with this index:\n * Find out the start, repeatCount and duration of each of these.\n *\n * @param {Object} item - parsed `S` node\n * @param {Object|null} previousItem - the previously parsed Segment (related\n * to the `S` node coming just before). If `null`, we're talking about the first\n * segment.\n * @param {Object|null} nextItem - the `S` node coming next. If `null`, we're\n * talking about the last segment.\n * @returns {Object|null}\n */\nexport default function convertElementsToIndexSegment(item, previousItem, nextItem) {\n    let start = item.start;\n    let duration = item.duration;\n    const repeatCount = item.repeatCount;\n    if (start === undefined) {\n        if (previousItem === null) {\n            start = 0;\n        }\n        else if (!isNullOrUndefined(previousItem.duration)) {\n            start = previousItem.start + previousItem.duration * (previousItem.repeatCount + 1);\n        }\n    }\n    if ((duration === undefined || isNaN(duration)) &&\n        nextItem !== null &&\n        nextItem.start !== undefined &&\n        !isNaN(nextItem.start) &&\n        start !== undefined &&\n        !isNaN(start)) {\n        duration = nextItem.start - start;\n    }\n    if (start !== undefined &&\n        !isNaN(start) &&\n        duration !== undefined &&\n        !isNaN(duration) &&\n        (repeatCount === undefined || !isNaN(repeatCount))) {\n        return {\n            start,\n            duration,\n            repeatCount: repeatCount === undefined ? 0 : repeatCount,\n        };\n    }\n    log.warn('DASH: A \"S\" Element could not have been parsed.');\n    return null;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport isNullOrUndefined from \"../../../../../../utils/is_null_or_undefined\";\n/**\n * By comparing two timelines for the same content at different points in time,\n * retrieve the index in both timelines of the first segment having the same\n * starting time.\n * Returns `null` if not found.\n * @param {Array.<Object>} prevTimeline\n * @param {Array.<Object>} newElements\n * @returns {Object|null}\n */\nexport default function findFirstCommonStartTime(prevTimeline, newElements) {\n    if (prevTimeline.length === 0 || newElements.length === 0) {\n        return null;\n    }\n    const prevInitialStart = prevTimeline[0].start;\n    const newFirstTAttr = Array.isArray(newElements)\n        ? newElements[0].attributes.t\n        : newElements[0].getAttribute(\"t\");\n    const newInitialStart = isNullOrUndefined(newFirstTAttr)\n        ? null\n        : parseInt(newFirstTAttr, 10);\n    if (newInitialStart === null || Number.isNaN(newInitialStart)) {\n        return null;\n    }\n    if (prevInitialStart === newInitialStart) {\n        return {\n            prevSegmentsIdx: 0,\n            newElementsIdx: 0,\n            repeatNumberInPrevSegments: 0,\n            repeatNumberInNewElements: 0,\n        };\n    }\n    else if (prevInitialStart < newInitialStart) {\n        let prevElt = prevTimeline[0];\n        let prevElementIndex = 0;\n        while (true) {\n            if (prevElt.repeatCount > 0) {\n                const diff = newInitialStart - prevElt.start;\n                if (diff % prevElt.duration === 0 &&\n                    diff / prevElt.duration <= prevElt.repeatCount) {\n                    const repeatNumberInPrevSegments = diff / prevElt.duration;\n                    return {\n                        repeatNumberInPrevSegments,\n                        prevSegmentsIdx: prevElementIndex,\n                        newElementsIdx: 0,\n                        repeatNumberInNewElements: 0,\n                    };\n                }\n            }\n            prevElementIndex++;\n            if (prevElementIndex >= prevTimeline.length) {\n                return null;\n            }\n            prevElt = prevTimeline[prevElementIndex];\n            if (prevElt.start === newInitialStart) {\n                return {\n                    prevSegmentsIdx: prevElementIndex,\n                    newElementsIdx: 0,\n                    repeatNumberInPrevSegments: 0,\n                    repeatNumberInNewElements: 0,\n                };\n            }\n            else if (prevElt.start > newInitialStart) {\n                return null;\n            }\n        }\n    }\n    else {\n        let newElementsIdx = 0;\n        let newNodeElt = Array.isArray(newElements) ? newElements[0] : null;\n        let newDomElt = Array.isArray(newElements) ? null : newElements[0];\n        let currentTimeOffset = newInitialStart;\n        while (true) {\n            const dAttr = newNodeElt !== null ? newNodeElt.attributes.d : newDomElt === null || newDomElt === void 0 ? void 0 : newDomElt.getAttribute(\"d\");\n            const duration = isNullOrUndefined(dAttr) ? null : parseInt(dAttr, 10);\n            if (duration === null || Number.isNaN(duration)) {\n                return null;\n            }\n            const rAttr = newNodeElt !== null ? newNodeElt.attributes.r : newDomElt === null || newDomElt === void 0 ? void 0 : newDomElt.getAttribute(\"r\");\n            const repeatCount = isNullOrUndefined(rAttr) ? null : parseInt(rAttr, 10);\n            if (repeatCount !== null) {\n                if (Number.isNaN(repeatCount) || repeatCount < 0) {\n                    return null;\n                }\n                if (repeatCount > 0) {\n                    const diff = prevInitialStart - currentTimeOffset;\n                    if (diff % duration === 0 && diff / duration <= repeatCount) {\n                        const repeatNumberInNewElements = diff / duration;\n                        return {\n                            repeatNumberInPrevSegments: 0,\n                            repeatNumberInNewElements,\n                            prevSegmentsIdx: 0,\n                            newElementsIdx,\n                        };\n                    }\n                }\n                currentTimeOffset += duration * (repeatCount + 1);\n            }\n            else {\n                currentTimeOffset += duration;\n            }\n            newElementsIdx++;\n            if (newElementsIdx >= newElements.length) {\n                return null;\n            }\n            if (Array.isArray(newElements)) {\n                newNodeElt = newElements[newElementsIdx];\n            }\n            else {\n                newDomElt = newElements[newElementsIdx];\n            }\n            const tAttr = newNodeElt !== null ? newNodeElt.attributes.t : newDomElt === null || newDomElt === void 0 ? void 0 : newDomElt.getAttribute(\"t\");\n            const time = isNullOrUndefined(tAttr) ? null : parseInt(tAttr, 10);\n            if (time !== null) {\n                if (Number.isNaN(time)) {\n                    return null;\n                }\n                currentTimeOffset = time;\n            }\n            if (currentTimeOffset === prevInitialStart) {\n                return {\n                    newElementsIdx,\n                    prevSegmentsIdx: 0,\n                    repeatNumberInPrevSegments: 0,\n                    repeatNumberInNewElements: 0,\n                };\n            }\n            else if (currentTimeOffset > newInitialStart) {\n                return null;\n            }\n        }\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport TimelineRepresentationIndex from \"./timeline_representation_index\";\nexport default TimelineRepresentationIndex;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../../../../../log\";\nimport isNullOrUndefined from \"../../../../../../utils/is_null_or_undefined\";\n/**\n * Parse a given <S> element in the MPD under a parsed Node form into a JS\n * Object.\n * @param {Object} root\n * @returns {Object}\n */\nexport function parseSElementNode(root) {\n    const parsedS = {};\n    for (const attributeName of Object.keys(root.attributes)) {\n        const attributeVal = root.attributes[attributeName];\n        if (isNullOrUndefined(attributeVal)) {\n            continue;\n        }\n        switch (attributeName) {\n            case \"t\": {\n                const start = parseInt(attributeVal, 10);\n                if (isNaN(start)) {\n                    log.warn(`DASH: invalid t (\"${attributeVal}\")`);\n                }\n                else {\n                    parsedS.start = start;\n                }\n                break;\n            }\n            case \"d\": {\n                const duration = parseInt(attributeVal, 10);\n                if (isNaN(duration)) {\n                    log.warn(`DASH: invalid d (\"${attributeVal}\")`);\n                }\n                else {\n                    parsedS.duration = duration;\n                }\n                break;\n            }\n            case \"r\": {\n                const repeatCount = parseInt(attributeVal, 10);\n                if (isNaN(repeatCount)) {\n                    log.warn(`DASH: invalid r (\"${attributeVal}\")`);\n                }\n                else {\n                    parsedS.repeatCount = repeatCount;\n                }\n                break;\n            }\n        }\n    }\n    return parsedS;\n}\n/**\n * Parse a given <S> element in the MPD under an `Element` form into a JS\n * Object.\n * @param {Element} root\n * @returns {Object}\n */\nexport function parseSHTMLElement(root) {\n    const parsedS = {};\n    for (let j = 0; j < root.attributes.length; j++) {\n        const attribute = root.attributes[j];\n        switch (attribute.name) {\n            case \"t\": {\n                const start = parseInt(attribute.value, 10);\n                if (isNaN(start)) {\n                    log.warn(`DASH: invalid t (\"${attribute.value}\")`);\n                }\n                else {\n                    parsedS.start = start;\n                }\n                break;\n            }\n            case \"d\": {\n                const duration = parseInt(attribute.value, 10);\n                if (isNaN(duration)) {\n                    log.warn(`DASH: invalid d (\"${attribute.value}\")`);\n                }\n                else {\n                    parsedS.duration = duration;\n                }\n                break;\n            }\n            case \"r\": {\n                const repeatCount = parseInt(attribute.value, 10);\n                if (isNaN(repeatCount)) {\n                    log.warn(`DASH: invalid r (\"${attribute.value}\")`);\n                }\n                else {\n                    parsedS.repeatCount = repeatCount;\n                }\n                break;\n            }\n        }\n    }\n    return parsedS;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport config from \"../../../../../../config\";\nimport { NetworkError } from \"../../../../../../errors\";\nimport log from \"../../../../../../log\";\nimport assert from \"../../../../../../utils/assert\";\nimport isNullOrUndefined from \"../../../../../../utils/is_null_or_undefined\";\nimport getMonotonicTimeStamp from \"../../../../../../utils/monotonic_timestamp\";\nimport clearTimelineFromPosition from \"../../../../utils/clear_timeline_from_position\";\nimport { checkDiscontinuity, fromIndexTime, getIndexSegmentEnd, toIndexTime, } from \"../../../../utils/index_helpers\";\nimport updateSegmentTimeline from \"../../../../utils/update_segment_timeline\";\nimport getInitSegment from \"../get_init_segment\";\nimport getSegmentsFromTimeline from \"../get_segments_from_timeline\";\nimport { constructRepresentationUrl } from \"../tokens\";\nimport { getSegmentTimeRoundingError } from \"../utils\";\nimport constructTimelineFromElements from \"./construct_timeline_from_elements\";\nimport constructTimelineFromPreviousTimeline from \"./construct_timeline_from_previous_timeline\";\n/**\n * `IRepresentationIndex` implementation for a DASH `SegmentTimeline` segment\n * indexing scheme.\n * @class TimelineRepresentationIndex\n */\nexport default class TimelineRepresentationIndex {\n    /**\n     * @param {Object} index\n     * @param {Object} context\n     */\n    constructor(index, context) {\n        var _a, _b, _c, _d, _e;\n        if (!TimelineRepresentationIndex.isTimelineIndexArgument(index)) {\n            throw new Error(\"The given index is not compatible with a \" + \"TimelineRepresentationIndex.\");\n        }\n        const { availabilityTimeComplete, availabilityTimeOffset, manifestBoundsCalculator, isDynamic, isLastPeriod, representationId, representationBitrate, periodStart, periodEnd, isEMSGWhitelisted, } = context;\n        const timescale = (_a = index.timescale) !== null && _a !== void 0 ? _a : 1;\n        const presentationTimeOffset = (_b = index.presentationTimeOffset) !== null && _b !== void 0 ? _b : 0;\n        const scaledStart = periodStart * timescale;\n        const indexTimeOffset = presentationTimeOffset - scaledStart;\n        this._manifestBoundsCalculator = manifestBoundsCalculator;\n        this._isEMSGWhitelisted = isEMSGWhitelisted;\n        this._isLastPeriod = isLastPeriod;\n        this._lastUpdate = (_c = context.receivedTime) !== null && _c !== void 0 ? _c : getMonotonicTimeStamp();\n        this._unsafelyBaseOnPreviousIndex = null;\n        if (context.unsafelyBaseOnPreviousRepresentation !== null &&\n            context.unsafelyBaseOnPreviousRepresentation.index instanceof\n                TimelineRepresentationIndex) {\n            // avoid too much nested references, to keep memory down\n            context.unsafelyBaseOnPreviousRepresentation.index._unsafelyBaseOnPreviousIndex =\n                null;\n            this._unsafelyBaseOnPreviousIndex =\n                context.unsafelyBaseOnPreviousRepresentation.index;\n        }\n        this._isDynamic = isDynamic;\n        this._parseTimeline = (_d = index.timelineParser) !== null && _d !== void 0 ? _d : null;\n        const initializationUrl = ((_e = index.initialization) === null || _e === void 0 ? void 0 : _e.media) === undefined\n            ? null\n            : constructRepresentationUrl(index.initialization.media, representationId, representationBitrate);\n        const segmentUrlTemplate = index.media === undefined\n            ? null\n            : constructRepresentationUrl(index.media, representationId, representationBitrate);\n        let actualAvailabilityTimeOffset;\n        // Technically, it seems (although it is not clear) that an MPD may contain\n        // future segments and it's the job of a player to not request segments later\n        // than the time at which they should be available.\n        // In practice, we don't do that for various reasons: precision issues,\n        // various DASH spec interpretations by packagers and players...\n        //\n        // So as a compromise, if nothing in the MPD indicates that future segments\n        // may be announced (see code below), we will act as if ALL segments in this\n        // TimelineRepresentationIndex are requestable\n        if (availabilityTimeOffset === undefined && availabilityTimeComplete === undefined) {\n            actualAvailabilityTimeOffset = Infinity; // Meaning: we can request\n            // everything in the index\n        }\n        else {\n            actualAvailabilityTimeOffset = availabilityTimeOffset !== null && availabilityTimeOffset !== void 0 ? availabilityTimeOffset : 0;\n        }\n        this._index = {\n            availabilityTimeComplete: availabilityTimeComplete !== null && availabilityTimeComplete !== void 0 ? availabilityTimeComplete : true,\n            availabilityTimeOffset: actualAvailabilityTimeOffset,\n            indexRange: index.indexRange,\n            indexTimeOffset,\n            initialization: isNullOrUndefined(index.initialization)\n                ? undefined\n                : {\n                    url: initializationUrl,\n                    range: index.initialization.range,\n                },\n            segmentUrlTemplate,\n            startNumber: index.startNumber,\n            endNumber: index.endNumber,\n            timeline: index.timeline === undefined\n                ? null\n                : updateTimelineFromEndNumber(index.timeline, index.startNumber, index.endNumber),\n            timescale,\n        };\n        this._scaledPeriodStart = toIndexTime(periodStart, this._index);\n        this._scaledPeriodEnd =\n            periodEnd === undefined ? undefined : toIndexTime(periodEnd, this._index);\n    }\n    /**\n     * Construct init Segment.\n     * @returns {Object}\n     */\n    getInitSegment() {\n        return getInitSegment(this._index, this._isEMSGWhitelisted);\n    }\n    /**\n     * Asks for segments to download for a given time range.\n     * @param {Number} from - Beginning of the time wanted, in seconds\n     * @param {Number} duration - duration wanted, in seconds\n     * @returns {Array.<Object>}\n     */\n    getSegments(from, duration) {\n        this._refreshTimeline(); // clear timeline if needed\n        if (this._index.timeline === null) {\n            this._index.timeline = this._getTimeline();\n        }\n        return getSegmentsFromTimeline(this._index, from, duration, this._manifestBoundsCalculator, this._scaledPeriodEnd, this._isEMSGWhitelisted);\n    }\n    /**\n     * Returns true if the index should be refreshed.\n     * @returns {Boolean}\n     */\n    shouldRefresh() {\n        // DASH Manifest based on a SegmentTimeline should have minimumUpdatePeriod\n        // attribute which should be sufficient to know when to refresh it.\n        return false;\n    }\n    /**\n     * Returns the starting time, in seconds, of the earliest segment currently\n     * available.\n     * Returns null if nothing is in the index\n     * @returns {Number|null}\n     */\n    getFirstAvailablePosition() {\n        this._refreshTimeline();\n        if (this._index.timeline === null) {\n            this._index.timeline = this._getTimeline();\n        }\n        const timeline = this._index.timeline;\n        return timeline.length === 0\n            ? null\n            : fromIndexTime(Math.max(this._scaledPeriodStart, timeline[0].start), this._index);\n    }\n    /**\n     * Returns the ending time, in seconds, of the last segment currently\n     * available.\n     * Returns null if nothing is in the index\n     * @returns {Number|null}\n     */\n    getLastAvailablePosition() {\n        var _a;\n        this._refreshTimeline();\n        if (this._index.timeline === null) {\n            this._index.timeline = this._getTimeline();\n        }\n        const lastReqSegInfo = getLastRequestableSegmentInfo(\n        // Needed typecast for TypeScript\n        this._index, this._manifestBoundsCalculator, this._scaledPeriodEnd);\n        if (lastReqSegInfo === null) {\n            return null;\n        }\n        const lastScaledPosition = Math.min(lastReqSegInfo.end, (_a = this._scaledPeriodEnd) !== null && _a !== void 0 ? _a : Infinity);\n        return fromIndexTime(lastScaledPosition, this._index);\n    }\n    /**\n     * Returns the absolute end in seconds this RepresentationIndex can reach once\n     * all segments are available.\n     * @returns {number|null|undefined}\n     */\n    getEnd() {\n        var _a;\n        if (this._isDynamic && !this._isLastPeriod) {\n            return undefined;\n        }\n        this._refreshTimeline();\n        if (this._index.timeline === null) {\n            this._index.timeline = this._getTimeline();\n        }\n        if (this._index.timeline.length <= 0) {\n            return null;\n        }\n        const lastSegment = this._index.timeline[this._index.timeline.length - 1];\n        const lastTime = Math.min(getIndexSegmentEnd(lastSegment, null, this._scaledPeriodEnd), (_a = this._scaledPeriodEnd) !== null && _a !== void 0 ? _a : Infinity);\n        return fromIndexTime(lastTime, this._index);\n    }\n    /**\n     * Returns:\n     *   - `true` if in the given time interval, at least one new segment is\n     *     expected to be available in the future.\n     *   - `false` either if all segments in that time interval are already\n     *     available for download or if none will ever be available for it.\n     *   - `undefined` when it is not possible to tell.\n     * @param {number} start\n     * @param {number} end\n     * @returns {boolean|undefined}\n     */\n    awaitSegmentBetween(start, end) {\n        var _a, _b;\n        assert(start <= end);\n        if (!this._isDynamic) {\n            return false; // No segment will be newly available in the future\n        }\n        this._refreshTimeline();\n        if (this._index.timeline === null) {\n            this._index.timeline = this._getTimeline();\n        }\n        const { timescale, timeline } = this._index;\n        const segmentTimeRounding = getSegmentTimeRoundingError(timescale);\n        const scaledWantedEnd = toIndexTime(end, this._index);\n        const lastReqSegInfo = getLastRequestableSegmentInfo(\n        // Needed typecast for TypeScript\n        this._index, this._manifestBoundsCalculator, this._scaledPeriodEnd);\n        if (lastReqSegInfo !== null) {\n            const lastReqSegmentEnd = Math.min(lastReqSegInfo.end, (_a = this._scaledPeriodEnd) !== null && _a !== void 0 ? _a : Infinity);\n            const roundedReqSegmentEnd = lastReqSegmentEnd + segmentTimeRounding;\n            if (roundedReqSegmentEnd >=\n                Math.min(scaledWantedEnd, (_b = this._scaledPeriodEnd) !== null && _b !== void 0 ? _b : Infinity)) {\n                return false; // everything up to that point is already requestable\n            }\n        }\n        const scaledWantedStart = toIndexTime(start, this._index);\n        if (timeline.length > 0 &&\n            lastReqSegInfo !== null &&\n            !lastReqSegInfo.isLastOfTimeline) {\n            // There are some future segments already anounced in the MPD\n            const lastSegment = timeline[timeline.length - 1];\n            const lastSegmentEnd = getIndexSegmentEnd(lastSegment, null, this._scaledPeriodEnd);\n            const roundedLastSegEnd = lastSegmentEnd + segmentTimeRounding;\n            if (scaledWantedStart < roundedLastSegEnd + segmentTimeRounding) {\n                return true; // The MPD's timeline already contains one such element,\n                // It is just not requestable yet\n            }\n        }\n        if (!this._isLastPeriod) {\n            // Let's consider - perhaps wrongly, that Periods which aren't the last\n            // one have all of their segments announced.\n            return false;\n        }\n        if (this._scaledPeriodEnd === undefined) {\n            return scaledWantedEnd + segmentTimeRounding > this._scaledPeriodStart\n                ? undefined // There may be future segments at this point\n                : false; // Before the current Period\n        }\n        // `true` if within the boundaries of this Period. `false` otherwise.\n        return (scaledWantedStart - segmentTimeRounding < this._scaledPeriodEnd &&\n            scaledWantedEnd + segmentTimeRounding > this._scaledPeriodStart);\n    }\n    /**\n     * Returns true if a Segment returned by this index is still considered\n     * available.\n     * Returns false if it is not available anymore.\n     * Returns undefined if we cannot know whether it is still available or not.\n     * @param {Object} segment\n     * @returns {Boolean|undefined}\n     */\n    isSegmentStillAvailable(segment) {\n        if (segment.isInit) {\n            return true;\n        }\n        this._refreshTimeline();\n        if (this._index.timeline === null) {\n            this._index.timeline = this._getTimeline();\n        }\n        return isSegmentStillAvailable(segment, \n        // Needed typecast for TypeScript\n        this._index, this._manifestBoundsCalculator, this._scaledPeriodEnd);\n    }\n    /**\n     * Checks if the time given is in a discontinuity. That is:\n     *   - We're on the upper bound of the current range (end of the range - time\n     *     is inferior to the timescale)\n     *   - The next range starts after the end of the current range.\n     * @param {Number} time\n     * @returns {Number|null}\n     */\n    checkDiscontinuity(time) {\n        this._refreshTimeline();\n        let timeline = this._index.timeline;\n        if (timeline === null) {\n            timeline = this._getTimeline();\n            this._index.timeline = timeline;\n        }\n        return checkDiscontinuity({\n            timeline,\n            timescale: this._index.timescale,\n            indexTimeOffset: this._index.indexTimeOffset,\n        }, time, this._scaledPeriodEnd);\n    }\n    /**\n     * @param {Error} error\n     * @returns {Boolean}\n     */\n    canBeOutOfSyncError(error) {\n        if (!this._isDynamic) {\n            return false;\n        }\n        return error instanceof NetworkError && error.isHttpError(404);\n    }\n    /**\n     * Replace this RepresentationIndex with one from a new version of the\n     * Manifest.\n     * @param {Object} newIndex\n     */\n    _replace(newIndex) {\n        this._parseTimeline = newIndex._parseTimeline;\n        this._index = newIndex._index;\n        this._isDynamic = newIndex._isDynamic;\n        this._scaledPeriodStart = newIndex._scaledPeriodStart;\n        this._scaledPeriodEnd = newIndex._scaledPeriodEnd;\n        this._lastUpdate = newIndex._lastUpdate;\n        this._manifestBoundsCalculator = newIndex._manifestBoundsCalculator;\n        this._isLastPeriod = newIndex._isLastPeriod;\n    }\n    /**\n     * Update this RepresentationIndex with a shorter version of it coming from a\n     * new version of the MPD.\n     * @param {Object} newIndex\n     */\n    _update(newIndex) {\n        if (this._index.timeline === null) {\n            this._index.timeline = this._getTimeline();\n        }\n        if (newIndex._index.timeline === null) {\n            newIndex._index.timeline = newIndex._getTimeline();\n        }\n        const hasReplaced = updateSegmentTimeline(this._index.timeline, newIndex._index.timeline);\n        if (hasReplaced) {\n            this._index.startNumber = newIndex._index.startNumber;\n        }\n        this._index.availabilityTimeOffset = newIndex._index.availabilityTimeOffset;\n        this._index.availabilityTimeComplete = newIndex._index.availabilityTimeComplete;\n        this._index.endNumber = newIndex._index.endNumber;\n        this._isDynamic = newIndex._isDynamic;\n        this._scaledPeriodStart = newIndex._scaledPeriodStart;\n        this._scaledPeriodEnd = newIndex._scaledPeriodEnd;\n        this._lastUpdate = newIndex._lastUpdate;\n        this._isLastPeriod = newIndex._isLastPeriod;\n    }\n    /**\n     * Returns `false` if this RepresentationIndex currently contains its last\n     * segment.\n     * Returns `true` if it's still pending.\n     * @returns {Boolean}\n     */\n    isStillAwaitingFutureSegments() {\n        var _a;\n        if (!this._isDynamic) {\n            return false;\n        }\n        this._refreshTimeline();\n        if (this._index.timeline === null) {\n            this._index.timeline = this._getTimeline();\n        }\n        const { timeline } = this._index;\n        if (timeline.length === 0) {\n            // No segment announced in this Period\n            if (this._scaledPeriodEnd !== undefined) {\n                const liveEdge = this._manifestBoundsCalculator.getEstimatedLiveEdge();\n                if (liveEdge !== undefined &&\n                    toIndexTime(liveEdge, this._index) > this._scaledPeriodEnd) {\n                    // This Period is over, we're not awaiting anything\n                    return false;\n                }\n            }\n            // Let's just consider that we're awaiting only for when this is the last Period.\n            return this._isLastPeriod;\n        }\n        const segmentTimeRounding = getSegmentTimeRoundingError(this._index.timescale);\n        const lastReqSegInfo = getLastRequestableSegmentInfo(\n        // Needed typecast for TypeScript\n        this._index, this._manifestBoundsCalculator, this._scaledPeriodEnd);\n        if (lastReqSegInfo !== null && !lastReqSegInfo.isLastOfTimeline) {\n            // There might be non-yet requestable segments in the manifest\n            const lastReqSegmentEnd = Math.min(lastReqSegInfo.end, (_a = this._scaledPeriodEnd) !== null && _a !== void 0 ? _a : Infinity);\n            if (this._scaledPeriodEnd !== undefined &&\n                lastReqSegmentEnd + segmentTimeRounding >= this._scaledPeriodEnd) {\n                // The last requestable segment ends after the end of the Period anyway\n                return false;\n            }\n            return true; // There are not-yet requestable segments\n        }\n        if (!this._isLastPeriod) {\n            // This index is not linked to the current last Period in the MPD, in\n            // which case it is inferred that all segments have been announced.\n            //\n            // Note that this condition might break very very rare use cases where old\n            // Periods are still being generated, yet it should fix more cases than it\n            // breaks.\n            return false;\n        }\n        if (this._scaledPeriodEnd === undefined) {\n            // This is the last Period of a dynamic content whose end is unknown.\n            // Just return true.\n            return true;\n        }\n        const lastSegment = timeline[timeline.length - 1];\n        const lastSegmentEnd = getIndexSegmentEnd(lastSegment, null, this._scaledPeriodEnd);\n        // We're awaiting future segments only if the current end is before the end\n        // of the Period\n        return lastSegmentEnd + segmentTimeRounding < this._scaledPeriodEnd;\n    }\n    /**\n     * @returns {Boolean}\n     */\n    isInitialized() {\n        return true;\n    }\n    initialize() {\n        log.error(\"A `TimelineRepresentationIndex` does not need to be initialized\");\n    }\n    addPredictedSegments() {\n        log.warn(\"Cannot add predicted segments to a `TimelineRepresentationIndex`\");\n    }\n    /**\n     * Returns the `duration` of each segment in the context of its Manifest (i.e.\n     * as the Manifest anounces them, actual segment duration may be different due\n     * to approximations), in seconds.\n     *\n     * NOTE: we could here do a median or a mean but I chose to be lazy (and\n     * more performant) by returning the duration of the first element instead.\n     * As `isPrecize` is `false`, the rest of the code should be notified that\n     * this is only an approximation.\n     * @returns {number}\n     */\n    getTargetSegmentDuration() {\n        this._refreshTimeline();\n        const { timeline, timescale } = this._index;\n        if (timeline === null) {\n            return undefined;\n        }\n        const firstElementInTimeline = timeline[0];\n        if (firstElementInTimeline === undefined) {\n            return undefined;\n        }\n        return {\n            duration: firstElementInTimeline.duration / timescale,\n            isPrecize: false,\n        };\n    }\n    /**\n     * Returns `true` if the given object can be used as an \"index\" argument to\n     * create a new `TimelineRepresentationIndex`.\n     * @param {Object} index\n     * @returns {boolean}\n     */\n    static isTimelineIndexArgument(index) {\n        return typeof index.timelineParser === \"function\" || Array.isArray(index.timeline);\n    }\n    /**\n     * Clean-up timeline to remove segment information which should not be\n     * available due to timeshifting.\n     */\n    _refreshTimeline() {\n        var _a, _b;\n        if (this._index.timeline === null) {\n            this._index.timeline = this._getTimeline();\n        }\n        if (!this._isDynamic) {\n            return;\n        }\n        const firstPosition = this._manifestBoundsCalculator.getEstimatedMinimumSegmentTime(((_b = (_a = this._index.timeline[0]) === null || _a === void 0 ? void 0 : _a.duration) !== null && _b !== void 0 ? _b : 0) / this._index.timescale);\n        if (isNullOrUndefined(firstPosition)) {\n            return; // we don't know yet\n        }\n        const scaledFirstPosition = toIndexTime(firstPosition, this._index);\n        const nbEltsRemoved = clearTimelineFromPosition(this._index.timeline, scaledFirstPosition);\n        if (this._index.startNumber !== undefined) {\n            this._index.startNumber += nbEltsRemoved;\n        }\n        else if (this._index.endNumber !== undefined) {\n            this._index.startNumber = nbEltsRemoved + 1;\n        }\n    }\n    /**\n     * Allows to generate the \"timeline\" for this RepresentationIndex.\n     * Call this function when the timeline is unknown.\n     * This function was added to only perform that task lazily, i.e. only when\n     * first needed.\n     * After calling it, every now unneeded variable will be freed from memory.\n     * This means that calling _getTimeline more than once will just return an\n     * empty array.\n     *\n     * /!\\ Please note that this structure should follow the exact same structure\n     * than a SegmentTimeline element in the corresponding MPD.\n     * This means:\n     *   - It should have the same amount of elements in its array than there was\n     *     `<S>` elements in the SegmentTimeline.\n     *   - Each of those same elements should have the same start time, the same\n     *     duration and the same repeat counter than what could be deduced from\n     *     the SegmentTimeline.\n     * This is needed to be able to run parsing optimization when refreshing the\n     * MPD. Not doing so could lead to the RxPlayer not being able to play the\n     * stream anymore.\n     * @returns {Array.<Object>}\n     */\n    _getTimeline() {\n        if (this._parseTimeline === null) {\n            if (this._index.timeline !== null) {\n                return this._index.timeline;\n            }\n            log.error(\"DASH: Timeline already lazily parsed.\");\n            return [];\n        }\n        const newElements = this._parseTimeline();\n        this._parseTimeline = null; // Free memory\n        const { MIN_DASH_S_ELEMENTS_TO_PARSE_UNSAFELY } = config.getCurrent();\n        if (this._unsafelyBaseOnPreviousIndex === null ||\n            newElements.length < MIN_DASH_S_ELEMENTS_TO_PARSE_UNSAFELY) {\n            // Just completely parse the current timeline\n            return updateTimelineFromEndNumber(constructTimelineFromElements(newElements), this._index.startNumber, this._index.endNumber);\n        }\n        // Construct previously parsed timeline if not already done\n        let prevTimeline;\n        if (this._unsafelyBaseOnPreviousIndex._index.timeline === null) {\n            prevTimeline = this._unsafelyBaseOnPreviousIndex._getTimeline();\n            this._unsafelyBaseOnPreviousIndex._index.timeline = prevTimeline;\n        }\n        else {\n            prevTimeline = this._unsafelyBaseOnPreviousIndex._index.timeline;\n        }\n        this._unsafelyBaseOnPreviousIndex = null; // Free memory\n        return updateTimelineFromEndNumber(constructTimelineFromPreviousTimeline(newElements, prevTimeline), this._index.startNumber, this._index.endNumber);\n    }\n}\n/**\n * Take the original SegmentTimeline's parsed timeline and, if an `endNumber` is\n * specified, filter segments which possess a number superior to that number.\n *\n * This should only be useful in only rare and broken MPDs, but we aim to\n * respect the specification even in those cases.\n *\n * @param {Array.<Object>} timeline\n * @param {number|undefined} startNumber\n * @param {Array.<Object>} endNumber\n * @returns {number|undefined}\n */\nfunction updateTimelineFromEndNumber(timeline, startNumber, endNumber) {\n    if (endNumber === undefined) {\n        return timeline;\n    }\n    let currNumber = startNumber !== null && startNumber !== void 0 ? startNumber : 1;\n    for (let idx = 0; idx < timeline.length; idx++) {\n        const seg = timeline[idx];\n        currNumber += seg.repeatCount + 1;\n        if (currNumber > endNumber) {\n            if (currNumber === endNumber + 1) {\n                return timeline.slice(0, idx + 1);\n            }\n            else {\n                const newTimeline = timeline.slice(0, idx);\n                const lastElt = Object.assign({}, seg);\n                const beginningNumber = currNumber - seg.repeatCount - 1;\n                lastElt.repeatCount = Math.max(0, endNumber - beginningNumber);\n                newTimeline.push(lastElt);\n                return newTimeline;\n            }\n        }\n    }\n    return timeline;\n}\n/**\n * Returns true if a Segment returned by the corresponding index is still\n * considered available.\n * Returns false if it is not available anymore.\n * Returns undefined if we cannot know whether it is still available or not.\n * /!\\ We do not check the mediaURLs of the segment.\n * @param {Object} segment\n * @param {Object} index\n * @param {Object} manifestBoundsCalculator\n * @param {number|undefined} scaledPeriodEnd\n * @returns {Boolean|undefined}\n */\nexport function isSegmentStillAvailable(segment, index, manifestBoundsCalculator, scaledPeriodEnd) {\n    const lastReqSegInfo = getLastRequestableSegmentInfo(index, manifestBoundsCalculator, scaledPeriodEnd);\n    if (lastReqSegInfo === null) {\n        return false;\n    }\n    for (let i = 0; i < index.timeline.length; i++) {\n        if (lastReqSegInfo.timelineIdx < i) {\n            return false;\n        }\n        const tSegment = index.timeline[i];\n        const tSegmentTime = (tSegment.start - index.indexTimeOffset) / index.timescale;\n        if (tSegmentTime > segment.time) {\n            return false; // We went over it without finding it\n        }\n        else if (tSegmentTime === segment.time) {\n            if (tSegment.range === undefined) {\n                return segment.range === undefined;\n            }\n            return (!isNullOrUndefined(segment.range) &&\n                tSegment.range[0] === segment.range[0] &&\n                tSegment.range[1] === segment.range[1]);\n        }\n        else {\n            // tSegment.start < segment.time\n            if (tSegment.repeatCount >= 0 && tSegment.duration !== undefined) {\n                const timeDiff = tSegmentTime - tSegment.start;\n                const repeat = timeDiff / tSegment.duration - 1;\n                return repeat % 1 === 0 && repeat <= lastReqSegInfo.newRepeatCount;\n            }\n        }\n    }\n    return false;\n}\n/**\n * Returns from the given RepresentationIndex information on the last segment\n * that may be requested currently.\n *\n * Returns `null` if there's no such segment.\n * @param {Object} index\n * @param {Object} manifestBoundsCalculator\n * @param {number|undefined} scaledPeriodEnd\n * @returns {number|null}\n */\nexport function getLastRequestableSegmentInfo(index, manifestBoundsCalculator, scaledPeriodEnd) {\n    if (index.timeline.length <= 0) {\n        return null;\n    }\n    if (index.availabilityTimeOffset === Infinity) {\n        // availabilityTimeOffset to Infinity == Everything is requestable in the timeline.\n        const lastIndex = index.timeline.length - 1;\n        const lastElem = index.timeline[lastIndex];\n        return {\n            isLastOfTimeline: true,\n            timelineIdx: lastIndex,\n            newRepeatCount: lastElem.repeatCount,\n            end: getIndexSegmentEnd(lastElem, null, scaledPeriodEnd),\n        };\n    }\n    const adjustedMaxSeconds = manifestBoundsCalculator.getEstimatedMaximumPosition(index.availabilityTimeOffset);\n    if (adjustedMaxSeconds === undefined) {\n        const lastIndex = index.timeline.length - 1;\n        const lastElem = index.timeline[lastIndex];\n        return {\n            isLastOfTimeline: true,\n            timelineIdx: lastIndex,\n            newRepeatCount: lastElem.repeatCount,\n            end: getIndexSegmentEnd(lastElem, null, scaledPeriodEnd),\n        };\n    }\n    for (let i = index.timeline.length - 1; i >= index.timeline.length; i--) {\n        const element = index.timeline[i];\n        const endOfFirstOccurence = element.start + element.duration;\n        if (fromIndexTime(endOfFirstOccurence, index) <= adjustedMaxSeconds) {\n            const endTime = getIndexSegmentEnd(element, index.timeline[i + 1], scaledPeriodEnd);\n            if (fromIndexTime(endTime, index) <= adjustedMaxSeconds) {\n                return {\n                    isLastOfTimeline: i === index.timeline.length - 1,\n                    timelineIdx: i,\n                    newRepeatCount: element.repeatCount,\n                    end: endOfFirstOccurence,\n                };\n            }\n            else {\n                // We have to find the right repeatCount\n                const maxIndexTime = toIndexTime(adjustedMaxSeconds, index);\n                const diffToSegStart = maxIndexTime - element.start;\n                const nbOfSegs = Math.floor(diffToSegStart / element.duration);\n                assert(nbOfSegs >= 1);\n                return {\n                    isLastOfTimeline: false,\n                    timelineIdx: i,\n                    newRepeatCount: nbOfSegs - 1,\n                    end: element.start + nbOfSegs * element.duration,\n                };\n            }\n        }\n    }\n    return null;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport isNonEmptyString from \"../../../../../utils/is_non_empty_string\";\n/**\n * Pad with 0 in the left of the given n argument to reach l length\n * @param {Number|string} n\n * @param {Number} l\n * @returns {string}\n */\nfunction padLeftWithZeros(n, l) {\n    const nToString = n.toString();\n    if (nToString.length >= l) {\n        return nToString;\n    }\n    const arr = new Array(l + 1).join(\"0\") + nToString;\n    return arr.slice(-l);\n}\n/**\n * @param {string|number} replacer\n * @returns {Function}\n */\nfunction processFormatedToken(replacer) {\n    return (_match, _format, widthStr) => {\n        const width = isNonEmptyString(widthStr) ? parseInt(widthStr, 10) : 1;\n        return padLeftWithZeros(String(replacer), width);\n    };\n}\n/**\n * @param {string} urlTemplate\n * @param {string|undefined} representationId\n * @param {number|undefined} bitrate\n * @returns {string}\n */\nexport function constructRepresentationUrl(urlTemplate, representationId, bitrate) {\n    return replaceRepresentationDASHTokens(urlTemplate, representationId, bitrate);\n}\n/**\n * Replace \"tokens\" written in a given path (e.g. $RepresentationID$) by the corresponding\n * infos, taken from the given segment.\n * @param {string} path\n * @param {string|undefined} id\n * @param {number|undefined} bitrate\n * @returns {string}\n */\nexport function replaceRepresentationDASHTokens(path, id, bitrate) {\n    if (path.indexOf(\"$\") === -1) {\n        return path;\n    }\n    else {\n        return path\n            .replace(/\\$\\$/g, \"$\")\n            .replace(/\\$RepresentationID\\$/g, String(id))\n            .replace(/\\$Bandwidth(%0(\\d+)d)?\\$/g, processFormatedToken(bitrate === undefined ? 0 : bitrate));\n    }\n}\n/**\n * Create function allowing to replace \"tokens\" in a given DASH segment URL\n * (e.g. $Time$, which has to be replaced by the segment's start time) by the\n * right information.\n * @param {number|undefined} time\n * @param {number|undefined} nb\n * @returns {Function}\n */\nexport function createDashUrlDetokenizer(time, nb) {\n    /**\n     * Replace the tokens in the given `url` by the segment information defined\n     * by the outer function.\n     * @param {string} url\n     * @returns {string}\n     *\n     * @throws Error - Throws if we do not have enough data to construct the URL\n     */\n    return function replaceTokensInUrl(url) {\n        if (url.indexOf(\"$\") === -1) {\n            return url;\n        }\n        else {\n            return url\n                .replace(/\\$\\$/g, \"$\")\n                .replace(/\\$Number(%0(\\d+)d)?\\$/g, (_x, _y, widthStr) => {\n                if (nb === undefined) {\n                    throw new Error(\"Segment number not defined in a $Number$ scheme\");\n                }\n                return processFormatedToken(nb)(_x, _y, widthStr);\n            })\n                .replace(/\\$Time(%0(\\d+)d)?\\$/g, (_x, _y, widthStr) => {\n                if (time === undefined) {\n                    throw new Error(\"Segment time not defined in a $Time$ scheme\");\n                }\n                return processFormatedToken(time)(_x, _y, widthStr);\n            });\n        }\n    };\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport config from \"../../../../../config\";\n/**\n * In Javascript, numbers are encoded in a way that a floating number may be\n * represented internally with a rounding error.\n *\n * This function returns a small number allowing to accound for rounding many\n * rounding errors.\n * @param {number} timescale\n * @returns {boolean}\n */\nexport function getSegmentTimeRoundingError(timescale) {\n    return config.getCurrent().DEFAULT_MAXIMUM_TIME_ROUNDING_ERROR * timescale;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../../../log\";\nimport { SUPPORTED_ADAPTATIONS_TYPE } from \"../../../../manifest\";\nimport arrayFind from \"../../../../utils/array_find\";\nimport arrayIncludes from \"../../../../utils/array_includes\";\nimport isNonEmptyString from \"../../../../utils/is_non_empty_string\";\nimport isNullOrUndefined from \"../../../../utils/is_null_or_undefined\";\n/** Different `role`s a text Adaptation can be. */\nconst SUPPORTED_TEXT_TYPES = [\"subtitle\", \"caption\"];\n/**\n * From a thumbnail AdaptationSet, returns core information such as the number\n * of tiles vertically and horizontally per image.\n *\n * Returns `null` if the information could not be parsed.\n * @param {Object} adaptation\n * @returns {Object|null}\n */\nexport function getThumbnailAdaptationSetInfo(adaptation, representation) {\n    var _a, _b, _c, _d;\n    const thumbnailProp = (_b = arrayFind((_a = adaptation.children.essentialProperties) !== null && _a !== void 0 ? _a : [], (p) => p.schemeIdUri === \"http://dashif.org/guidelines/thumbnail_tile\" ||\n        p.schemeIdUri === \"http://dashif.org/thumbnail_tile\")) !== null && _b !== void 0 ? _b : arrayFind((_d = (_c = (representation !== null && representation !== void 0 ? representation : adaptation.children.representations[0])) === null || _c === void 0 ? void 0 : _c.children.essentialProperties) !== null && _d !== void 0 ? _d : [], (p) => p.schemeIdUri === \"http://dashif.org/guidelines/thumbnail_tile\" ||\n        p.schemeIdUri === \"http://dashif.org/thumbnail_tile\");\n    if (thumbnailProp === undefined) {\n        return null;\n    }\n    const tilesRegex = /(\\d+)x(\\d+)/;\n    if (thumbnailProp === undefined ||\n        thumbnailProp.value === undefined ||\n        !tilesRegex.test(thumbnailProp.value)) {\n        log.warn(\"DASH: Invalid thumbnails Representation, no tile-related information\");\n        return null;\n    }\n    const match = thumbnailProp.value.match(tilesRegex);\n    const horizontalTiles = parseInt(match[1], 10);\n    const verticalTiles = parseInt(match[2], 10);\n    return {\n        horizontalTiles,\n        verticalTiles,\n    };\n}\n/**\n * Infers the type of adaptation from codec and mimetypes found in it.\n *\n * This follows the guidelines defined by the DASH-IF IOP:\n *   - one adaptation set contains a single media type\n *   - The order of verifications are:\n *       1. mimeType\n *       2. Role\n *       3. codec\n *\n * Note: This is based on DASH-IF-IOP-v4.0 with some more freedom.\n * @param {Object} adaptation\n * @param {Array.<Object>} representations\n * @returns {string} - \"audio\"|\"video\"|\"text\"|\"metadata\"|\"unknown\"\n */\nexport default function inferAdaptationType(adaptation, representations) {\n    if (adaptation.attributes.contentType === \"image\") {\n        if (getThumbnailAdaptationSetInfo(adaptation) !== null) {\n            return \"thumbnails\";\n        }\n        return undefined;\n    }\n    const adaptationMimeType = isNonEmptyString(adaptation.attributes.mimeType)\n        ? adaptation.attributes.mimeType\n        : null;\n    const adaptationCodecs = isNonEmptyString(adaptation.attributes.codecs)\n        ? adaptation.attributes.codecs\n        : null;\n    const adaptationRoles = !isNullOrUndefined(adaptation.children.roles)\n        ? adaptation.children.roles\n        : null;\n    function fromMimeType(mimeType, roles) {\n        const topLevel = mimeType.split(\"/\")[0];\n        if (arrayIncludes(SUPPORTED_ADAPTATIONS_TYPE, topLevel)) {\n            return topLevel;\n        }\n        if (mimeType === \"application/ttml+xml\") {\n            return \"text\";\n        }\n        // manage DASH-IF mp4-embedded subtitles and metadata\n        if (mimeType === \"application/mp4\") {\n            if (roles !== null) {\n                if (arrayFind(roles, (role) => role.schemeIdUri === \"urn:mpeg:dash:role:2011\" &&\n                    arrayIncludes(SUPPORTED_TEXT_TYPES, role.value)) !== undefined) {\n                    return \"text\";\n                }\n            }\n            return undefined;\n        }\n    }\n    function fromCodecs(codecs) {\n        switch (codecs.substring(0, 3)) {\n            case \"avc\":\n            case \"hev\":\n            case \"hvc\":\n            case \"vp8\":\n            case \"vp9\":\n            case \"av1\":\n                return \"video\";\n            case \"vtt\":\n                return \"text\";\n        }\n        switch (codecs.substring(0, 4)) {\n            case \"mp4a\":\n                return \"audio\";\n            case \"wvtt\":\n            case \"stpp\":\n                return \"text\";\n        }\n    }\n    if (adaptationMimeType !== null) {\n        const typeFromMimeType = fromMimeType(adaptationMimeType, adaptationRoles);\n        if (typeFromMimeType !== undefined) {\n            return typeFromMimeType;\n        }\n    }\n    if (adaptationCodecs !== null) {\n        const typeFromCodecs = fromCodecs(adaptationCodecs);\n        if (typeFromCodecs !== undefined) {\n            return typeFromCodecs;\n        }\n    }\n    for (let i = 0; i < representations.length; i++) {\n        const representation = representations[i];\n        const { mimeType, codecs } = representation.attributes;\n        if (mimeType !== undefined) {\n            const typeFromMimeType = fromMimeType(mimeType, adaptationRoles);\n            if (typeFromMimeType !== undefined) {\n                return typeFromMimeType;\n            }\n        }\n        if (codecs !== undefined) {\n            const typeFromCodecs = fromCodecs(codecs);\n            if (typeFromCodecs !== undefined) {\n                return typeFromCodecs;\n            }\n        }\n    }\n    return undefined;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport getMonotonicTimeStamp from \"../../../../utils/monotonic_timestamp\";\n/**\n * This class allows to easily calculate the first and last available positions\n * in a content at any time.\n *\n * By centralizing the manifest bounds calculation in this class and by giving\n * an instance of it to each parsed elements which might depend on it, we\n * ensure that we can provide it once it is known to every one of those\n * elements without needing to parse a second time the MPD.\n * @class ManifestBoundsCalculator\n */\nexport default class ManifestBoundsCalculator {\n    /**\n     * @param {Object} args\n     */\n    constructor(args) {\n        this._isDynamic = args.isDynamic;\n        this._timeShiftBufferDepth =\n            !args.isDynamic || args.timeShiftBufferDepth === undefined\n                ? null\n                : args.timeShiftBufferDepth;\n        this._serverTimestampOffset = args.serverTimestampOffset;\n        this._availabilityStartTime = args.availabilityStartTime;\n    }\n    /**\n     * Set the last position and the position time (the value of the RxPlayer's\n     * monotonically-raising timestamp at the time that position was true\n     * converted into seconds).\n     *\n     * @example\n     * Example if you trust `Date.now()` to give you a reliable offset:\n     * ```js\n     * const lastPosition = Date.now();\n     * const positionTime = getMonotonicTimeStamp() / 1000;\n     * manifestBoundsCalculator.setLastPosition(lastPosition, positionTime);\n     * ```\n     *\n     * @param {number} lastPosition\n     * @param {number|undefined} positionTime\n     */\n    setLastPosition(lastPosition, positionTime) {\n        this._lastPosition = lastPosition;\n        this._positionTime = positionTime;\n    }\n    /**\n     * Returns `true` if the last position and the position time\n     * (for dynamic content only) have been comunicated.\n     * `false` otherwise.\n     * @returns {boolean}\n     */\n    lastPositionIsKnown() {\n        if (this._isDynamic) {\n            return this._positionTime !== undefined && this._lastPosition !== undefined;\n        }\n        return this._lastPosition !== undefined;\n    }\n    /**\n     * Estimate a minimum bound for the content from the last set segment time\n     * and buffer depth.\n     * Consider that it is only an estimate, not the real value.\n     * @param {number} segmentDuration - In DASH, the buffer depth actually also\n     * depend on a corresponding's segment duration (e.g. a segment become\n     * unavailable once the `timeShiftBufferDepth` + its duration has elapsed).\n     * This argument can thus be set the approximate duration of a segment.\n     * @return {number|undefined}\n     */\n    getEstimatedMinimumSegmentTime(segmentDuration) {\n        var _a;\n        if (!this._isDynamic || this._timeShiftBufferDepth === null) {\n            return 0;\n        }\n        const maximumBound = (_a = this.getEstimatedLiveEdge()) !== null && _a !== void 0 ? _a : this.getEstimatedMaximumPosition(0);\n        if (maximumBound === undefined) {\n            return undefined;\n        }\n        const minimumBound = maximumBound - (this._timeShiftBufferDepth + segmentDuration);\n        return minimumBound;\n    }\n    /**\n     * Estimate the segment time in seconds that corresponds to what could be\n     * considered the live edge (or `undefined` for non-live contents).\n     *\n     * Note that for some contents which just anounce segments in advance, this\n     * value might be very different than the maximum position that is\n     * requestable.\n     * @return {number|undefined}\n     */\n    getEstimatedLiveEdge() {\n        if (!this._isDynamic || this._serverTimestampOffset === undefined) {\n            return undefined;\n        }\n        return ((getMonotonicTimeStamp() + this._serverTimestampOffset) / 1000 -\n            this._availabilityStartTime);\n    }\n    /**\n     * Produce a rough estimate of the ending time of the last requestable segment\n     * in that content.\n     *\n     * This value is only an estimate and may be far from reality.\n     *\n     * The `availabilityTimeOffset` in argument is the corresponding\n     * `availabilityTimeOffset` that applies to the current wanted segment, or `0`\n     * if none exist. It will be applied on live content to deduce the maximum\n     * segment time available.\n     */\n    getEstimatedMaximumPosition(availabilityTimeOffset) {\n        if (!this._isDynamic) {\n            return this._lastPosition;\n        }\n        const liveEdge = this.getEstimatedLiveEdge();\n        if (liveEdge !== undefined && availabilityTimeOffset !== Infinity) {\n            return liveEdge + availabilityTimeOffset;\n        }\n        else if (this._positionTime !== undefined && this._lastPosition !== undefined) {\n            return Math.max(this._lastPosition - this._positionTime + getMonotonicTimeStamp() / 1000, 0);\n        }\n        return this._lastPosition;\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../../../log\";\nimport { SUPPORTED_ADAPTATIONS_TYPE } from \"../../../../manifest\";\nimport arrayFind from \"../../../../utils/array_find\";\nimport arrayFindIndex from \"../../../../utils/array_find_index\";\nimport arrayIncludes from \"../../../../utils/array_includes\";\nimport isNonEmptyString from \"../../../../utils/is_non_empty_string\";\nimport isNullOrUndefined from \"../../../../utils/is_null_or_undefined\";\nimport attachTrickModeTrack from \"./attach_trickmode_track\";\nimport inferAdaptationType, { getThumbnailAdaptationSetInfo, } from \"./infer_adaptation_type\";\nimport parseRepresentations from \"./parse_representations\";\nimport resolveBaseURLs from \"./resolve_base_urls\";\n/**\n * Detect if the accessibility given defines an adaptation for the visually\n * impaired.\n * Based on DVB Document A168 (DVB-DASH) and DASH-IF 4.3.\n * @param {Object} accessibility\n * @returns {Boolean}\n */\nfunction isVisuallyImpaired(accessibility) {\n    if (accessibility === undefined) {\n        return false;\n    }\n    const isVisuallyImpairedAudioDvbDash = accessibility.schemeIdUri === \"urn:tva:metadata:cs:AudioPurposeCS:2007\" &&\n        accessibility.value === \"1\";\n    const isVisuallyImpairedDashIf = accessibility.schemeIdUri === \"urn:mpeg:dash:role:2011\" &&\n        accessibility.value === \"description\";\n    return isVisuallyImpairedAudioDvbDash || isVisuallyImpairedDashIf;\n}\n/**\n * Detect if the accessibility given defines an adaptation for the hard of\n * hearing.\n * Based on DVB Document A168 (DVB-DASH) and DASH specification.\n * @param {Array.<Object>} accessibilities\n * @param {Array.<Object>} roles\n * @returns {Boolean}\n */\nfunction isCaptionning(accessibilities, roles) {\n    if (accessibilities !== undefined) {\n        const hasDvbClosedCaptionSignaling = accessibilities.some((accessibility) => accessibility.schemeIdUri === \"urn:tva:metadata:cs:AudioPurposeCS:2007\" &&\n            accessibility.value === \"2\");\n        if (hasDvbClosedCaptionSignaling) {\n            return true;\n        }\n    }\n    if (roles !== undefined) {\n        const hasDashCaptionSinaling = roles.some((role) => role.schemeIdUri === \"urn:mpeg:dash:role:2011\" && role.value === \"caption\");\n        if (hasDashCaptionSinaling) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Detect if the accessibility given defines an AdaptationSet containing a sign\n * language interpretation.\n * Based on DASH-IF 4.3.\n * @param {Object} accessibility\n * @returns {Boolean}\n */\nfunction hasSignLanguageInterpretation(accessibility) {\n    if (accessibility === undefined) {\n        return false;\n    }\n    return (accessibility.schemeIdUri === \"urn:mpeg:dash:role:2011\" &&\n        accessibility.value === \"sign\");\n}\n/**\n * Contruct Adaptation ID from the information we have.\n * @param {Object} adaptation\n * @param {Object} infos\n * @returns {string}\n */\nfunction getAdaptationID(adaptation, infos) {\n    if (isNonEmptyString(adaptation.attributes.id)) {\n        return adaptation.attributes.id;\n    }\n    const { isClosedCaption, isForcedSubtitle, isAudioDescription, isSignInterpreted, isTrickModeTrack, type, } = infos;\n    let idString = type;\n    if (isNonEmptyString(adaptation.attributes.language)) {\n        idString += `-${adaptation.attributes.language}`;\n    }\n    if (isClosedCaption === true) {\n        idString += \"-cc\";\n    }\n    if (isForcedSubtitle === true) {\n        idString += \"-cc\";\n    }\n    if (isAudioDescription === true) {\n        idString += \"-ad\";\n    }\n    if (isSignInterpreted === true) {\n        idString += \"-si\";\n    }\n    if (isTrickModeTrack) {\n        idString += \"-trickMode\";\n    }\n    if (isNonEmptyString(adaptation.attributes.contentType)) {\n        idString += `-${adaptation.attributes.contentType}`;\n    }\n    if (isNonEmptyString(adaptation.attributes.codecs)) {\n        idString += `-${adaptation.attributes.codecs}`;\n    }\n    if (isNonEmptyString(adaptation.attributes.mimeType)) {\n        idString += `-${adaptation.attributes.mimeType}`;\n    }\n    if (adaptation.attributes.frameRate !== undefined) {\n        idString += `-${String(adaptation.attributes.frameRate)}`;\n    }\n    return idString;\n}\n/**\n * Returns a list of ID this adaptation can be seamlessly switched to\n * @param {Object} adaptation\n * @returns {Array.<string>}\n */\nfunction getAdaptationSetSwitchingIDs(adaptation) {\n    if (!isNullOrUndefined(adaptation.children.supplementalProperties)) {\n        const { supplementalProperties } = adaptation.children;\n        for (const supplementalProperty of supplementalProperties) {\n            if (supplementalProperty.schemeIdUri ===\n                \"urn:mpeg:dash:adaptation-set-switching:2016\" &&\n                !isNullOrUndefined(supplementalProperty.value)) {\n                return supplementalProperty.value\n                    .split(\",\")\n                    .map((id) => id.trim())\n                    .filter((id) => isNonEmptyString(id));\n            }\n        }\n    }\n    return [];\n}\n/**\n * Process AdaptationSets intermediate representations to return under its final\n * form.\n * Note that the AdaptationSets returned are sorted by priority (from the most\n * priority to the least one).\n * @param {Array.<Object>} adaptationsIR\n * @param {Object} context\n * @returns {Array.<Object>}\n */\nexport default function parseAdaptationSets(adaptationsIR, context) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const parsedAdaptations = { video: [], audio: [], text: [] };\n    const parsedThumbnailTracks = [];\n    const trickModeAdaptations = [];\n    const adaptationSwitchingInfos = {};\n    const parsedAdaptationsIDs = [];\n    for (let adaptationIdx = 0; adaptationIdx < adaptationsIR.length; adaptationIdx++) {\n        const adaptation = adaptationsIR[adaptationIdx];\n        const adaptationChildren = adaptation.children;\n        const { essentialProperties, roles, label } = adaptationChildren;\n        const isMainAdaptation = Array.isArray(roles) &&\n            roles.some((role) => role.value === \"main\") &&\n            roles.some((role) => role.schemeIdUri === \"urn:mpeg:dash:role:2011\");\n        const representationsIR = adaptation.children.representations;\n        const availabilityTimeComplete = (_a = adaptation.attributes.availabilityTimeComplete) !== null && _a !== void 0 ? _a : context.availabilityTimeComplete;\n        let availabilityTimeOffset;\n        if (adaptation.attributes.availabilityTimeOffset !== undefined ||\n            context.availabilityTimeOffset !== undefined) {\n            availabilityTimeOffset =\n                ((_b = adaptation.attributes.availabilityTimeOffset) !== null && _b !== void 0 ? _b : 0) +\n                    ((_c = context.availabilityTimeOffset) !== null && _c !== void 0 ? _c : 0);\n        }\n        const type = inferAdaptationType(adaptation, representationsIR);\n        if (type === undefined) {\n            continue;\n        }\n        const priority = (_d = adaptation.attributes.selectionPriority) !== null && _d !== void 0 ? _d : 1;\n        const originalID = adaptation.attributes.id;\n        const adaptationSetSwitchingIDs = getAdaptationSetSwitchingIDs(adaptation);\n        const parentSegmentTemplates = [];\n        if (context.segmentTemplate !== undefined) {\n            parentSegmentTemplates.push(context.segmentTemplate);\n        }\n        if (adaptation.children.segmentTemplate !== undefined) {\n            parentSegmentTemplates.push(adaptation.children.segmentTemplate);\n        }\n        const reprCtxt = {\n            availabilityTimeComplete,\n            availabilityTimeOffset,\n            baseURLs: resolveBaseURLs(context.baseURLs, adaptationChildren.baseURLs),\n            contentProtectionParser: context.contentProtectionParser,\n            manifestBoundsCalculator: context.manifestBoundsCalculator,\n            end: context.end,\n            isDynamic: context.isDynamic,\n            isLastPeriod: context.isLastPeriod,\n            manifestProfiles: context.manifestProfiles,\n            parentSegmentTemplates,\n            receivedTime: context.receivedTime,\n            start: context.start,\n            unsafelyBaseOnPreviousAdaptation: null,\n        };\n        const trickModeProperty = Array.isArray(essentialProperties)\n            ? arrayFind(essentialProperties, (scheme) => {\n                return scheme.schemeIdUri === \"http://dashif.org/guidelines/trickmode\";\n            })\n            : undefined;\n        const trickModeAttachedAdaptationIds = (_e = trickModeProperty === null || trickModeProperty === void 0 ? void 0 : trickModeProperty.value) === null || _e === void 0 ? void 0 : _e.split(\" \");\n        const isTrickModeTrack = trickModeAttachedAdaptationIds !== undefined;\n        const { accessibilities } = adaptationChildren;\n        let isDub;\n        if (roles !== undefined && roles.some((role) => role.value === \"dub\")) {\n            isDub = true;\n        }\n        let isClosedCaption;\n        if (type !== \"text\") {\n            isClosedCaption = false;\n        }\n        else {\n            isClosedCaption = isCaptionning(accessibilities, roles);\n        }\n        let isForcedSubtitle;\n        if (type === \"text\" &&\n            roles !== undefined &&\n            roles.some((role) => role.value === \"forced-subtitle\" || role.value === \"forced_subtitle\")) {\n            isForcedSubtitle = true;\n        }\n        let isAudioDescription;\n        if (type !== \"audio\") {\n            isAudioDescription = false;\n        }\n        else if (accessibilities !== undefined) {\n            isAudioDescription = accessibilities.some(isVisuallyImpaired);\n        }\n        let isSignInterpreted;\n        if (type !== \"video\") {\n            isSignInterpreted = false;\n        }\n        else if (accessibilities !== undefined) {\n            isSignInterpreted = accessibilities.some(hasSignLanguageInterpretation);\n        }\n        let adaptationID = getAdaptationID(adaptation, {\n            isAudioDescription,\n            isForcedSubtitle,\n            isClosedCaption,\n            isSignInterpreted,\n            isTrickModeTrack,\n            type,\n        });\n        // Avoid duplicate IDs\n        while (arrayIncludes(parsedAdaptationsIDs, adaptationID)) {\n            adaptationID += \"-dup\";\n        }\n        const newID = adaptationID;\n        parsedAdaptationsIDs.push(adaptationID);\n        reprCtxt.unsafelyBaseOnPreviousAdaptation =\n            (_g = (_f = context.unsafelyBaseOnPreviousPeriod) === null || _f === void 0 ? void 0 : _f.getAdaptation(adaptationID)) !== null && _g !== void 0 ? _g : null;\n        const representations = parseRepresentations(representationsIR, adaptation, reprCtxt);\n        if (type === \"thumbnails\") {\n            const track = createThumbnailTracks(adaptation, representations);\n            if (track !== null) {\n                parsedThumbnailTracks.push(...track);\n            }\n            continue;\n        }\n        const parsedAdaptationSet = {\n            id: adaptationID,\n            representations,\n            type,\n            isTrickModeTrack,\n        };\n        if (!isNullOrUndefined(adaptation.attributes.language)) {\n            parsedAdaptationSet.language = adaptation.attributes.language;\n        }\n        if (!isNullOrUndefined(isClosedCaption)) {\n            parsedAdaptationSet.closedCaption = isClosedCaption;\n        }\n        if (!isNullOrUndefined(isAudioDescription)) {\n            parsedAdaptationSet.audioDescription = isAudioDescription;\n        }\n        if (isDub === true) {\n            parsedAdaptationSet.isDub = true;\n        }\n        if (isForcedSubtitle !== undefined) {\n            parsedAdaptationSet.forcedSubtitles = isForcedSubtitle;\n        }\n        if (isSignInterpreted === true) {\n            parsedAdaptationSet.isSignInterpreted = true;\n        }\n        if (label !== undefined) {\n            parsedAdaptationSet.label = label;\n        }\n        if (trickModeAttachedAdaptationIds !== undefined) {\n            trickModeAdaptations.push({\n                adaptation: parsedAdaptationSet,\n                trickModeAttachedAdaptationIds,\n            });\n        }\n        else {\n            // look if we have to merge this into another Adaptation\n            let mergedIntoIdx = -1;\n            for (const id of adaptationSetSwitchingIDs) {\n                const switchingInfos = adaptationSwitchingInfos[id];\n                if (switchingInfos !== undefined &&\n                    switchingInfos.newID !== newID &&\n                    arrayIncludes(switchingInfos.adaptationSetSwitchingIDs, originalID)) {\n                    mergedIntoIdx = arrayFindIndex(parsedAdaptations[type], (a) => a[0].id === id);\n                    const mergedInto = parsedAdaptations[type][mergedIntoIdx];\n                    if (mergedInto !== undefined &&\n                        mergedInto[0].audioDescription === parsedAdaptationSet.audioDescription &&\n                        mergedInto[0].closedCaption === parsedAdaptationSet.closedCaption &&\n                        mergedInto[0].language === parsedAdaptationSet.language) {\n                        log.info('DASH Parser: merging \"switchable\" AdaptationSets', originalID, id);\n                        mergedInto[0].representations.push(...parsedAdaptationSet.representations);\n                        mergedInto[1] = {\n                            priority: Math.max(priority, mergedInto[1].priority),\n                            isMainAdaptation: isMainAdaptation || mergedInto[1].isMainAdaptation,\n                            indexInMpd: Math.min(adaptationIdx, mergedInto[1].indexInMpd),\n                        };\n                        break;\n                    }\n                }\n            }\n            if (mergedIntoIdx < 0) {\n                parsedAdaptations[type].push([\n                    parsedAdaptationSet,\n                    { priority, isMainAdaptation, indexInMpd: adaptationIdx },\n                ]);\n            }\n        }\n        if (!isNullOrUndefined(originalID) &&\n            isNullOrUndefined(adaptationSwitchingInfos[originalID])) {\n            adaptationSwitchingInfos[originalID] = {\n                newID,\n                adaptationSetSwitchingIDs,\n            };\n        }\n    }\n    const adaptationsPerType = SUPPORTED_ADAPTATIONS_TYPE.reduce((acc, adaptationType) => {\n        const adaptationsParsedForType = parsedAdaptations[adaptationType];\n        if (adaptationsParsedForType.length > 0) {\n            adaptationsParsedForType.sort(compareAdaptations);\n            acc[adaptationType] = adaptationsParsedForType.map(([parsedAdaptation]) => parsedAdaptation);\n        }\n        return acc;\n    }, {});\n    parsedAdaptations.video.sort(compareAdaptations);\n    attachTrickModeTrack(adaptationsPerType, trickModeAdaptations);\n    return {\n        adaptations: adaptationsPerType,\n        thumbnailTracks: parsedThumbnailTracks,\n    };\n}\n/**\n * From the given attributes, returns a parsed thumbnail track, or null if it\n * fails to do so.\n * @param {Object} adaptation\n * @param {Array.<Object>} representations\n * @returns {Object|null}\n */\nfunction createThumbnailTracks(adaptation, representations) {\n    var _a, _b;\n    const tracks = [];\n    for (let i = 0; i < representations.length; i++) {\n        const representation = representations[i];\n        if (representation !== undefined) {\n            if (representation.mimeType === undefined) {\n                log.warn(\"DASH: Invalid thumbnails Representation, no mime-type\");\n                continue;\n            }\n            const tileInfo = getThumbnailAdaptationSetInfo(adaptation, adaptation.children.representations[i]);\n            if (tileInfo === null) {\n                continue;\n            }\n            if (representation.height === undefined) {\n                log.warn(\"DASH: Invalid thumbnails Representation, no height information\");\n                continue;\n            }\n            if (representation.width === undefined) {\n                log.warn(\"DASH: Invalid thumbnails Representation, no width information\");\n                continue;\n            }\n            const start = (_a = representation.index.getFirstAvailablePosition()) !== null && _a !== void 0 ? _a : undefined;\n            const end = (_b = representation.index.getEnd()) !== null && _b !== void 0 ? _b : undefined;\n            let segmentDuration;\n            const targetDuration = representation.index.getTargetSegmentDuration();\n            if (targetDuration !== undefined && targetDuration.isPrecize) {\n                segmentDuration = targetDuration.duration;\n            }\n            else {\n                log.warn(\"DASH: Cannot produce duration estimate for thumbnail track\");\n            }\n            tracks.push({\n                id: representation.id,\n                cdnMetadata: representation.cdnMetadata,\n                index: representation.index,\n                mimeType: representation.mimeType,\n                height: representation.height,\n                width: representation.width,\n                horizontalTiles: tileInfo.horizontalTiles,\n                verticalTiles: tileInfo.verticalTiles,\n                start,\n                end,\n                tileDuration: segmentDuration === undefined\n                    ? undefined\n                    : segmentDuration / (tileInfo.horizontalTiles * tileInfo.verticalTiles),\n            });\n        }\n    }\n    return tracks;\n}\n/**\n * Compare groups of parsed AdaptationSet, alongside some ordering metadata,\n * allowing to easily sort them through JavaScript's `Array.prototype.sort`\n * method.\n * @param {Array.<Object>} a\n * @param {Array.<Object>} b\n * @returns {number}\n */\nfunction compareAdaptations(a, b) {\n    const priorityDiff = b[1].priority - a[1].priority;\n    if (priorityDiff !== 0) {\n        return priorityDiff;\n    }\n    if (a[1].isMainAdaptation !== b[1].isMainAdaptation) {\n        return a[1].isMainAdaptation ? -1 : 1;\n    }\n    return a[1].indexInMpd - b[1].indexInMpd;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport isNullOrUndefined from \"../../../../utils/is_null_or_undefined\";\n/**\n * Returns the base time of the Manifest.\n * @param {Object} rootAttributes\n * @param {number|undefined} [referenceDateTime]\n * @returns {number}\n */\nexport default function parseAvailabilityStartTime(rootAttributes, referenceDateTime) {\n    if (rootAttributes.type !== \"dynamic\") {\n        return 0;\n    }\n    if (isNullOrUndefined(rootAttributes.availabilityStartTime)) {\n        return referenceDateTime !== null && referenceDateTime !== void 0 ? referenceDateTime : 0;\n    }\n    return rootAttributes.availabilityStartTime;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport config from \"../../../../config\";\nimport log from \"../../../../log\";\nimport arrayFind from \"../../../../utils/array_find\";\nimport isNullOrUndefined from \"../../../../utils/is_null_or_undefined\";\nimport getMonotonicTimeStamp from \"../../../../utils/monotonic_timestamp\";\nimport { getFilenameIndexInUrl } from \"../../../../utils/url-utils\";\nimport ContentProtectionParser from \"./content_protection_parser\";\nimport getClockOffset from \"./get_clock_offset\";\nimport getHTTPUTCTimingURL from \"./get_http_utc-timing_url\";\nimport getMinimumAndMaximumPositions from \"./get_minimum_and_maximum_positions\";\nimport ManifestBoundsCalculator from \"./manifest_bounds_calculator\";\nimport parseAvailabilityStartTime from \"./parse_availability_start_time\";\nimport parsePeriods from \"./parse_periods\";\nimport resolveBaseURLs from \"./resolve_base_urls\";\n/**\n * Checks if xlinks needs to be loaded before actually parsing the manifest.\n * @param {Object} mpdIR\n * @param {Object} args\n * @param {boolean} hasLoadedClock\n * @param {Array.<Object>} warnings\n * @returns {Object}\n */\nexport default function parseMpdIr(mpdIR, args, warnings, hasLoadedClock, xlinkInfos = new WeakMap()) {\n    const { children: rootChildren, attributes: rootAttributes } = mpdIR;\n    if (isNullOrUndefined(args.externalClockOffset)) {\n        const isDynamic = rootAttributes.type === \"dynamic\";\n        const directTiming = arrayFind(rootChildren.utcTimings, (utcTiming) => {\n            return (utcTiming.schemeIdUri === \"urn:mpeg:dash:utc:direct:2014\" &&\n                !isNullOrUndefined(utcTiming.value));\n        });\n        const clockOffsetFromDirectUTCTiming = !isNullOrUndefined(directTiming) && !isNullOrUndefined(directTiming.value)\n            ? getClockOffset(directTiming.value)\n            : undefined;\n        const clockOffset = !isNullOrUndefined(clockOffsetFromDirectUTCTiming) &&\n            !isNaN(clockOffsetFromDirectUTCTiming)\n            ? clockOffsetFromDirectUTCTiming\n            : undefined;\n        if (!isNullOrUndefined(clockOffset) && hasLoadedClock !== true) {\n            args.externalClockOffset = clockOffset;\n        }\n        else if (isDynamic && hasLoadedClock !== true) {\n            const UTCTimingHTTPURL = getHTTPUTCTimingURL(mpdIR);\n            if (!isNullOrUndefined(UTCTimingHTTPURL) && UTCTimingHTTPURL.length > 0) {\n                // TODO fetch UTCTiming and XLinks at the same time\n                return {\n                    type: \"needs-clock\",\n                    value: {\n                        url: UTCTimingHTTPURL,\n                        continue: function continueParsingMPD(responseDataClock) {\n                            if (!responseDataClock.success) {\n                                warnings.push(responseDataClock.error);\n                                log.warn(\"DASH Parser: Error on fetching the clock ressource\", responseDataClock.error);\n                                return parseMpdIr(mpdIR, args, warnings, true);\n                            }\n                            args.externalClockOffset = getClockOffset(responseDataClock.data);\n                            return parseMpdIr(mpdIR, args, warnings, true);\n                        },\n                    },\n                };\n            }\n        }\n    }\n    const xlinksToLoad = [];\n    for (let i = 0; i < rootChildren.periods.length; i++) {\n        const { xlinkHref, xlinkActuate } = rootChildren.periods[i].attributes;\n        if (!isNullOrUndefined(xlinkHref) && xlinkActuate === \"onLoad\") {\n            xlinksToLoad.push({ index: i, ressource: xlinkHref });\n        }\n    }\n    if (xlinksToLoad.length === 0) {\n        return parseCompleteIntermediateRepresentation(mpdIR, args, warnings, xlinkInfos);\n    }\n    return {\n        type: \"needs-xlinks\",\n        value: {\n            xlinksUrls: xlinksToLoad.map(({ ressource }) => ressource),\n            continue: function continueParsingMPD(loadedRessources) {\n                if (loadedRessources.length !== xlinksToLoad.length) {\n                    throw new Error(\"DASH parser: wrong number of loaded ressources.\");\n                }\n                // Note: It is important to go from the last index to the first index in\n                // the resulting array, as we will potentially add elements to the array\n                for (let i = loadedRessources.length - 1; i >= 0; i--) {\n                    const index = xlinksToLoad[i].index;\n                    const { parsed: periodsIR, warnings: parsingWarnings, receivedTime, sendingTime, url, } = loadedRessources[i];\n                    if (parsingWarnings.length > 0) {\n                        warnings.push(...parsingWarnings);\n                    }\n                    for (const periodIR of periodsIR) {\n                        xlinkInfos.set(periodIR, { receivedTime, sendingTime, url });\n                    }\n                    // replace original \"xlinked\" periods by the real deal\n                    rootChildren.periods.splice(index, 1, ...periodsIR);\n                }\n                return parseMpdIr(mpdIR, args, warnings, hasLoadedClock, xlinkInfos);\n            },\n        },\n    };\n}\n/**\n * Parse the MPD intermediate representation into a regular Manifest.\n * @param {Object} mpdIR\n * @param {Object} args\n * @param {Array.<Object>} warnings\n * @param {Object} xlinkInfos\n * @returns {Object}\n */\nfunction parseCompleteIntermediateRepresentation(mpdIR, args, warnings, xlinkInfos) {\n    var _a, _b, _c, _d, _e;\n    const { children: rootChildren, attributes: rootAttributes } = mpdIR;\n    const isDynamic = rootAttributes.type === \"dynamic\";\n    const initialBaseUrl = args.url !== undefined\n        ? [{ url: args.url.substring(0, getFilenameIndexInUrl(args.url)) }]\n        : [];\n    const mpdBaseUrls = resolveBaseURLs(initialBaseUrl, rootChildren.baseURLs);\n    const availabilityStartTime = parseAvailabilityStartTime(rootAttributes, args.referenceDateTime);\n    const timeShiftBufferDepth = rootAttributes.timeShiftBufferDepth;\n    const maxSegmentDuration = rootAttributes.maxSegmentDuration;\n    const { externalClockOffset: clockOffset, unsafelyBaseOnPreviousManifest } = args;\n    const { externalClockOffset } = args;\n    const manifestBoundsCalculator = new ManifestBoundsCalculator({\n        availabilityStartTime,\n        isDynamic,\n        timeShiftBufferDepth,\n        serverTimestampOffset: externalClockOffset,\n    });\n    const contentProtectionParser = new ContentProtectionParser();\n    contentProtectionParser.addReferences((_a = rootChildren.contentProtections) !== null && _a !== void 0 ? _a : []);\n    const manifestInfos = {\n        availabilityStartTime,\n        baseURLs: mpdBaseUrls,\n        clockOffset,\n        contentProtectionParser,\n        duration: rootAttributes.duration,\n        isDynamic,\n        manifestBoundsCalculator,\n        manifestProfiles: mpdIR.attributes.profiles,\n        receivedTime: args.manifestReceivedTime,\n        unsafelyBaseOnPreviousManifest,\n        xlinkInfos,\n        xmlNamespaces: mpdIR.attributes.namespaces,\n    };\n    const parsedPeriods = parsePeriods(rootChildren.periods, manifestInfos);\n    contentProtectionParser.finalize();\n    const mediaPresentationDuration = rootAttributes.duration;\n    let lifetime;\n    let minimumTime;\n    let timeshiftDepth = null;\n    let maximumTimeData;\n    if (rootAttributes.minimumUpdatePeriod !== undefined &&\n        rootAttributes.minimumUpdatePeriod >= 0) {\n        lifetime =\n            rootAttributes.minimumUpdatePeriod === 0\n                ? config.getCurrent().DASH_FALLBACK_LIFETIME_WHEN_MINIMUM_UPDATE_PERIOD_EQUAL_0\n                : rootAttributes.minimumUpdatePeriod;\n    }\n    const { minimumSafePosition, maximumSafePosition, maximumUnsafePosition } = getMinimumAndMaximumPositions(parsedPeriods);\n    const now = getMonotonicTimeStamp();\n    if (!isDynamic) {\n        minimumTime = minimumSafePosition;\n        if (minimumTime === undefined) {\n            minimumTime = (_c = (_b = parsedPeriods[0]) === null || _b === void 0 ? void 0 : _b.start) !== null && _c !== void 0 ? _c : 0;\n        }\n        let finalMaximumSafePosition = mediaPresentationDuration !== null && mediaPresentationDuration !== void 0 ? mediaPresentationDuration : Infinity;\n        if (parsedPeriods[parsedPeriods.length - 1] !== undefined) {\n            const lastPeriod = parsedPeriods[parsedPeriods.length - 1];\n            const lastPeriodEnd = (_d = lastPeriod.end) !== null && _d !== void 0 ? _d : (lastPeriod.duration !== undefined\n                ? lastPeriod.start + lastPeriod.duration\n                : undefined);\n            if (lastPeriodEnd !== undefined && lastPeriodEnd < finalMaximumSafePosition) {\n                finalMaximumSafePosition = lastPeriodEnd;\n            }\n        }\n        if (maximumSafePosition !== undefined &&\n            maximumSafePosition < finalMaximumSafePosition) {\n            finalMaximumSafePosition = maximumSafePosition;\n        }\n        maximumTimeData = {\n            isLinear: false,\n            maximumSafePosition: finalMaximumSafePosition,\n            livePosition: undefined,\n            time: now,\n        };\n    }\n    else {\n        // Determine the maximum seekable position\n        let finalMaximumSafePosition;\n        if (maximumSafePosition !== undefined) {\n            finalMaximumSafePosition = maximumSafePosition;\n        }\n        else {\n            if (externalClockOffset === undefined) {\n                log.warn(\"DASH Parser: use system clock to define maximum position\");\n                finalMaximumSafePosition = Date.now() / 1000 - availabilityStartTime;\n            }\n            else {\n                const serverTime = getMonotonicTimeStamp() + externalClockOffset;\n                finalMaximumSafePosition = serverTime / 1000 - availabilityStartTime;\n            }\n        }\n        // Determine live edge (what position corresponds to live content, can be\n        // inferior or superior to the maximum anounced position in some specific\n        // scenarios). However, the `timeShiftBufferDepth` should be based on it.\n        let livePosition = manifestBoundsCalculator.getEstimatedLiveEdge();\n        if (livePosition === undefined) {\n            if (maximumUnsafePosition !== undefined) {\n                livePosition = maximumUnsafePosition;\n            }\n            else {\n                livePosition = finalMaximumSafePosition;\n            }\n            // manifestBoundsCalculator.forceLiveEdge(livePosition);\n        }\n        maximumTimeData = {\n            isLinear: true,\n            maximumSafePosition: finalMaximumSafePosition,\n            livePosition,\n            time: now,\n        };\n        // if the minimum calculated time is even below the buffer depth, perhaps we\n        // can go even lower in terms of depth\n        minimumTime = minimumSafePosition;\n        timeshiftDepth = timeShiftBufferDepth !== null && timeShiftBufferDepth !== void 0 ? timeShiftBufferDepth : null;\n        if (timeshiftDepth !== null) {\n            // The DASH spec implies that a segment is still available after a given\n            // `timeShiftBufferDepth` for a time equal to its duration\n            // (What I interpret from \"ISO/IEC 23009-1 fifth edition 2022-08\n            // A.3.4 Media Segment list restrictions).\n            //\n            // This `timeshiftDepth` property is global for the whole Manifest (and\n            // not per segment), thus we cannot do exactly that, but we can take the\n            // anounced `maxSegmentDuration` by default instead. This may be a little\n            // too optimistic, but would in reality not lead to a lot of issues as\n            // this `timeshiftDepth` property is not the one that should be relied on\n            // to know which segment can or cannot be requested anymore.\n            timeshiftDepth += maxSegmentDuration !== null && maxSegmentDuration !== void 0 ? maxSegmentDuration : 0;\n        }\n        if (timeshiftDepth !== null &&\n            minimumTime !== undefined &&\n            livePosition - minimumTime > timeshiftDepth) {\n            timeshiftDepth = livePosition - minimumTime;\n        }\n    }\n    // `isLastPeriodKnown` should be `true` in two cases for DASH contents:\n    //   1. When the content is static, because we know that no supplementary\n    //      Period will be added.\n    //   2. If the content is dynamic, only when both the duration is known and\n    //      the `minimumUpdatePeriod` is not set. This corresponds to the case\n    //      explained in \"4.6.4. Transition Phase between Live and On-Demand\" of\n    //      the DASH-IF IOP v4.3 for live contents transitionning to on-demand.\n    const isLastPeriodKnown = !isDynamic ||\n        (mpdIR.attributes.minimumUpdatePeriod === undefined &&\n            (((_e = parsedPeriods[parsedPeriods.length - 1]) === null || _e === void 0 ? void 0 : _e.end) !== undefined ||\n                mpdIR.attributes.duration !== undefined));\n    const parsedMPD = {\n        availabilityStartTime,\n        clockOffset: args.externalClockOffset,\n        isDynamic,\n        isLive: isDynamic,\n        isLastPeriodKnown,\n        periods: parsedPeriods,\n        publishTime: rootAttributes.publishTime,\n        suggestedPresentationDelay: rootAttributes.suggestedPresentationDelay,\n        transportType: \"dash\",\n        timeBounds: {\n            minimumSafePosition: minimumTime,\n            timeshiftDepth,\n            maximumTimeData,\n        },\n        lifetime,\n        uris: isNullOrUndefined(args.url)\n            ? rootChildren.locations\n            : [args.url, ...rootChildren.locations],\n    };\n    return { type: \"done\", value: { parsed: parsedMPD, warnings } };\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../../../log\";\nimport flatMap from \"../../../../utils/flat_map\";\nimport idGenerator from \"../../../../utils/id_generator\";\nimport isNullOrUndefined from \"../../../../utils/is_null_or_undefined\";\nimport isWorker from \"../../../../utils/is_worker\";\nimport getMonotonicTimeStamp from \"../../../../utils/monotonic_timestamp\";\nimport objectValues from \"../../../../utils/object_values\";\nimport { utf8ToStr } from \"../../../../utils/string_parsing\";\nimport flattenOverlappingPeriods from \"./flatten_overlapping_periods\";\nimport getPeriodsTimeInformation from \"./get_periods_time_infos\";\nimport parseAdaptationSets from \"./parse_adaptation_sets\";\nimport resolveBaseURLs from \"./resolve_base_urls\";\nconst generatePeriodID = idGenerator();\n/**\n * Process intermediate periods to create final parsed periods.\n * @param {Array.<Object>} periodsIR\n * @param {Object} context\n * @returns {Array.<Object>}\n */\nexport default function parsePeriods(periodsIR, context) {\n    var _a, _b, _c, _d, _e;\n    const parsedPeriods = [];\n    const periodsTimeInformation = getPeriodsTimeInformation(periodsIR, context);\n    if (periodsTimeInformation.length !== periodsIR.length) {\n        throw new Error(\"MPD parsing error: the time information are incoherent.\");\n    }\n    const { isDynamic, manifestBoundsCalculator } = context;\n    if (!isDynamic && !isNullOrUndefined(context.duration)) {\n        manifestBoundsCalculator.setLastPosition(context.duration);\n    }\n    // We parse it in reverse because we might need to deduce the buffer depth from\n    // the last Periods' indexes\n    for (let i = periodsIR.length - 1; i >= 0; i--) {\n        const isLastPeriod = i === periodsIR.length - 1;\n        const periodIR = periodsIR[i];\n        const xlinkInfos = context.xlinkInfos.get(periodIR);\n        const periodBaseURLs = resolveBaseURLs(context.baseURLs, periodIR.children.baseURLs);\n        const { periodStart, periodDuration, periodEnd } = periodsTimeInformation[i];\n        let periodID;\n        if (isNullOrUndefined(periodIR.attributes.id)) {\n            log.warn(\"DASH: No usable id found in the Period. Generating one.\");\n            periodID = \"gen-dash-period-\" + generatePeriodID();\n        }\n        else {\n            periodID = periodIR.attributes.id;\n        }\n        // Avoid duplicate IDs\n        while (parsedPeriods.some((p) => p.id === periodID)) {\n            periodID += \"-dup\";\n        }\n        const receivedTime = xlinkInfos !== undefined ? xlinkInfos.receivedTime : context.receivedTime;\n        const unsafelyBaseOnPreviousPeriod = (_b = (_a = context.unsafelyBaseOnPreviousManifest) === null || _a === void 0 ? void 0 : _a.getPeriod(periodID)) !== null && _b !== void 0 ? _b : null;\n        const availabilityTimeComplete = periodIR.attributes.availabilityTimeComplete;\n        const availabilityTimeOffset = periodIR.attributes.availabilityTimeOffset;\n        const { manifestProfiles, contentProtectionParser } = context;\n        const { segmentTemplate } = periodIR.children;\n        contentProtectionParser.addReferences((_c = periodIR.children.contentProtections) !== null && _c !== void 0 ? _c : []);\n        const adapCtxt = {\n            availabilityTimeComplete,\n            availabilityTimeOffset,\n            baseURLs: periodBaseURLs,\n            contentProtectionParser,\n            manifestBoundsCalculator,\n            end: periodEnd,\n            isDynamic,\n            isLastPeriod,\n            manifestProfiles,\n            receivedTime,\n            segmentTemplate,\n            start: periodStart,\n            unsafelyBaseOnPreviousPeriod,\n        };\n        const { adaptations, thumbnailTracks } = parseAdaptationSets(periodIR.children.adaptations, adapCtxt);\n        const namespaces = ((_d = context.xmlNamespaces) !== null && _d !== void 0 ? _d : []).concat((_e = periodIR.attributes.namespaces) !== null && _e !== void 0 ? _e : []);\n        const streamEvents = generateStreamEvents(periodIR.children.eventStreams, periodStart, namespaces);\n        const parsedPeriod = {\n            id: periodID,\n            start: periodStart,\n            end: periodEnd,\n            duration: periodDuration,\n            thumbnailTracks,\n            adaptations,\n            streamEvents,\n        };\n        parsedPeriods.unshift(parsedPeriod);\n        if (!manifestBoundsCalculator.lastPositionIsKnown()) {\n            const lastPosition = getMaximumLastPosition(adaptations);\n            if (!isDynamic) {\n                if (typeof lastPosition === \"number\") {\n                    manifestBoundsCalculator.setLastPosition(lastPosition);\n                }\n            }\n            else {\n                if (typeof lastPosition === \"number\") {\n                    const positionTime = getMonotonicTimeStamp() / 1000;\n                    manifestBoundsCalculator.setLastPosition(lastPosition, positionTime);\n                }\n                else {\n                    const guessedLastPositionFromClock = guessLastPositionFromClock(context, periodStart);\n                    if (guessedLastPositionFromClock !== undefined) {\n                        const [guessedLastPosition, guessedPositionTime] = guessedLastPositionFromClock;\n                        manifestBoundsCalculator.setLastPosition(guessedLastPosition, guessedPositionTime);\n                    }\n                }\n            }\n        }\n    }\n    if (context.isDynamic && !manifestBoundsCalculator.lastPositionIsKnown()) {\n        // Guess a last time the last position\n        const guessedLastPositionFromClock = guessLastPositionFromClock(context, 0);\n        if (guessedLastPositionFromClock !== undefined) {\n            const [lastPosition, positionTime] = guessedLastPositionFromClock;\n            manifestBoundsCalculator.setLastPosition(lastPosition, positionTime);\n        }\n    }\n    return flattenOverlappingPeriods(parsedPeriods);\n}\n/**\n * Try to guess the \"last position\", which is the last position\n * available in the manifest in seconds, and the \"position time\", the\n * monotonically-raising timestamp used by the RxPlayer, at which the\n * last position was collected.\n *\n * These values allows to retrieve at any time in the future the new last\n * position, by substracting the position time to the last position, and\n * adding to it the new monotonically-raising timestamp.\n *\n * The last position and position time are returned by this function if and only if\n * it would indicate a last position superior to the `minimumTime` given.\n *\n * This last part allows for example to detect which Period is likely to be the\n * \"current\" one in multi-periods contents. By giving the Period's start as a\n * `minimumTime`, you ensure that you will get a value only if the current time\n * is in that period.\n *\n * This is useful as guessing the live time from the clock can be seen as a last\n * resort. By detecting that the current time is before the currently considered\n * Period, we can just parse and look at the previous Period. If we can guess\n * the live time more directly from that previous one, we might be better off\n * than just using the clock.\n *\n * @param {Object} context\n * @param {number} minimumTime\n * @returns {Array.<number|undefined>}\n */\nfunction guessLastPositionFromClock(context, minimumTime) {\n    if (!isNullOrUndefined(context.clockOffset)) {\n        const lastPosition = context.clockOffset / 1000 - context.availabilityStartTime;\n        const positionTime = getMonotonicTimeStamp() / 1000;\n        const timeInSec = positionTime + lastPosition;\n        if (timeInSec >= minimumTime) {\n            return [timeInSec, positionTime];\n        }\n    }\n    else {\n        const now = Date.now() / 1000;\n        if (now >= minimumTime) {\n            log.warn(\"DASH Parser: no clock synchronization mechanism found.\" +\n                \" Using the system clock instead.\");\n            const lastPosition = now - context.availabilityStartTime;\n            const positionTime = getMonotonicTimeStamp() / 1000;\n            return [lastPosition, positionTime];\n        }\n    }\n    return undefined;\n}\n/**\n * Try to extract the last position declared for any segments in a Period:\n *   - If at least a single index' last position is defined, take the maximum\n *     among them.\n *   - If segments are available but we cannot define the last position\n *     return undefined.\n *   - If no segment are available in that period, return null\n * @param {Object} adaptationsPerType\n * @returns {number|null|undefined}\n */\nfunction getMaximumLastPosition(adaptationsPerType) {\n    let maxEncounteredPosition = null;\n    let allIndexAreEmpty = true;\n    const adaptationsVal = objectValues(adaptationsPerType).filter((ada) => !isNullOrUndefined(ada));\n    const allAdaptations = flatMap(adaptationsVal, (adaptationsForType) => adaptationsForType);\n    for (const adaptation of allAdaptations) {\n        const representations = adaptation.representations;\n        for (const representation of representations) {\n            const position = representation.index.getLastAvailablePosition();\n            if (position !== null) {\n                allIndexAreEmpty = false;\n                if (typeof position === \"number\") {\n                    maxEncounteredPosition = isNullOrUndefined(maxEncounteredPosition)\n                        ? position\n                        : Math.max(maxEncounteredPosition, position);\n                }\n            }\n        }\n    }\n    if (!isNullOrUndefined(maxEncounteredPosition)) {\n        return maxEncounteredPosition;\n    }\n    else if (allIndexAreEmpty) {\n        return null;\n    }\n    return undefined;\n}\n/**\n * Generate parsed \"eventStream\" objects from a `StreamEvent` node's\n * intermediate Representation.\n * @param {Array.<Object>} baseIr - The array of every encountered StreamEvent's\n * intermediate representations for a given Period.\n * @param {number} periodStart - The time in seconds at which this corresponding\n * Period starts.\n * @returns {Array.<Object>} - The parsed objects.\n */\nfunction generateStreamEvents(baseIr, periodStart, xmlNamespaces) {\n    var _a, _b;\n    const res = [];\n    for (const eventStreamIr of baseIr) {\n        const { schemeIdUri = \"\", timescale = 1 } = eventStreamIr.attributes;\n        const allNamespaces = xmlNamespaces.concat((_a = eventStreamIr.attributes.namespaces) !== null && _a !== void 0 ? _a : []);\n        for (const eventIr of eventStreamIr.children.events) {\n            if (eventIr.eventStreamData !== undefined) {\n                const start = ((_b = eventIr.presentationTime) !== null && _b !== void 0 ? _b : 0) / timescale + periodStart;\n                const end = eventIr.duration === undefined\n                    ? undefined\n                    : start + eventIr.duration / timescale;\n                let element;\n                let xmlData;\n                if (!isWorker && eventIr.eventStreamData instanceof Element) {\n                    element = eventIr.eventStreamData;\n                }\n                else {\n                    try {\n                        xmlData = {\n                            namespaces: allNamespaces,\n                            data: typeof eventIr.eventStreamData === \"string\"\n                                ? eventIr.eventStreamData\n                                : utf8ToStr(new Uint8Array(eventIr.eventStreamData)),\n                        };\n                    }\n                    catch (err) {\n                        log.error(\"DASH: Error while parsing event-stream:\", err instanceof Error ? err.message : \"Unknown error\");\n                    }\n                }\n                res.push({\n                    start,\n                    end,\n                    id: eventIr.id,\n                    data: {\n                        type: \"dash-event-stream\",\n                        value: { schemeIdUri, timescale, element, xmlData },\n                    },\n                });\n            }\n        }\n    }\n    return res;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport objectAssign from \"../../../../utils/object_assign\";\nimport { BaseRepresentationIndex, ListRepresentationIndex, TemplateRepresentationIndex, TimelineRepresentationIndex, } from \"./indexes\";\n/**\n * Parse the specific segment indexing information found in a representation\n * into a IRepresentationIndex implementation.\n * @param {Array.<Object>} representation\n * @param {Object} context\n * @returns {Array.<Object>}\n */\nexport default function parseRepresentationIndex(representation, context) {\n    var _a, _b, _c;\n    const { availabilityTimeOffset, manifestBoundsCalculator, isDynamic, end: periodEnd, start: periodStart, receivedTime, unsafelyBaseOnPreviousRepresentation, inbandEventStreams, isLastPeriod, } = context;\n    const isEMSGWhitelisted = (inbandEvent) => {\n        if (inbandEventStreams === undefined) {\n            return false;\n        }\n        return inbandEventStreams.some(({ schemeIdUri }) => schemeIdUri === inbandEvent.schemeIdUri);\n    };\n    const reprIndexCtxt = {\n        availabilityTimeComplete: undefined,\n        availabilityTimeOffset,\n        unsafelyBaseOnPreviousRepresentation,\n        isEMSGWhitelisted,\n        isLastPeriod,\n        manifestBoundsCalculator,\n        isDynamic,\n        periodEnd,\n        periodStart,\n        receivedTime,\n        representationBitrate: representation.attributes.bitrate,\n        representationId: representation.attributes.id,\n    };\n    let representationIndex;\n    if (representation.children.segmentBase !== undefined) {\n        const { segmentBase } = representation.children;\n        representationIndex = new BaseRepresentationIndex(segmentBase, reprIndexCtxt);\n    }\n    else if (representation.children.segmentList !== undefined) {\n        const { segmentList } = representation.children;\n        representationIndex = new ListRepresentationIndex(segmentList, reprIndexCtxt);\n    }\n    else if (representation.children.segmentTemplate !== undefined ||\n        context.parentSegmentTemplates.length > 0) {\n        const segmentTemplates = context.parentSegmentTemplates.slice();\n        const childSegmentTemplate = representation.children.segmentTemplate;\n        if (childSegmentTemplate !== undefined) {\n            segmentTemplates.push(childSegmentTemplate);\n        }\n        const segmentTemplate = objectAssign({}, ...segmentTemplates /* Ugly TS Hack */);\n        if (segmentTemplate.availabilityTimeOffset !== undefined ||\n            context.availabilityTimeOffset !== undefined) {\n            reprIndexCtxt.availabilityTimeOffset =\n                ((_a = segmentTemplate.availabilityTimeOffset) !== null && _a !== void 0 ? _a : 0) +\n                    ((_b = context.availabilityTimeOffset) !== null && _b !== void 0 ? _b : 0);\n        }\n        if (segmentTemplate.availabilityTimeComplete !== undefined ||\n            context.availabilityTimeComplete !== undefined) {\n            reprIndexCtxt.availabilityTimeComplete =\n                (_c = segmentTemplate.availabilityTimeComplete) !== null && _c !== void 0 ? _c : context.availabilityTimeComplete;\n        }\n        representationIndex = TimelineRepresentationIndex.isTimelineIndexArgument(segmentTemplate)\n            ? new TimelineRepresentationIndex(segmentTemplate, reprIndexCtxt)\n            : new TemplateRepresentationIndex(segmentTemplate, reprIndexCtxt);\n    }\n    else {\n        const adaptationChildren = context.adaptation.children;\n        if (adaptationChildren.segmentBase !== undefined) {\n            const { segmentBase } = adaptationChildren;\n            representationIndex = new BaseRepresentationIndex(segmentBase, reprIndexCtxt);\n        }\n        else if (adaptationChildren.segmentList !== undefined) {\n            const { segmentList } = adaptationChildren;\n            representationIndex = new ListRepresentationIndex(segmentList, reprIndexCtxt);\n        }\n        else {\n            representationIndex = new TemplateRepresentationIndex({\n                duration: Number.MAX_VALUE,\n                timescale: 1,\n                startNumber: 0,\n                media: \"\",\n            }, reprIndexCtxt);\n        }\n    }\n    return representationIndex;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../../../log\";\nimport arrayFind from \"../../../../utils/array_find\";\nimport objectAssign from \"../../../../utils/object_assign\";\nimport { convertSupplementalCodecsToRFC6381 } from \"./convert_supplemental_codecs\";\nimport { getWEBMHDRInformation } from \"./get_hdr_information\";\nimport parseRepresentationIndex from \"./parse_representation_index\";\nimport resolveBaseURLs from \"./resolve_base_urls\";\n/**\n * Combine inband event streams from representation and\n * adaptation data.\n * @param {Object} representation\n * @param {Object} adaptation\n * @returns {undefined | Array.<Object>}\n */\nfunction combineInbandEventStreams(representation, adaptation) {\n    const newSchemeId = [];\n    if (representation.children.inbandEventStreams !== undefined) {\n        newSchemeId.push(...representation.children.inbandEventStreams);\n    }\n    if (adaptation.children.inbandEventStreams !== undefined) {\n        newSchemeId.push(...adaptation.children.inbandEventStreams);\n    }\n    if (newSchemeId.length === 0) {\n        return undefined;\n    }\n    return newSchemeId;\n}\n/**\n * Extract HDR information from manifest and codecs.\n * @param {Object}\n * @returns {Object | undefined}\n */\nfunction getHDRInformation({ adaptationProfiles, essentialProperties, supplementalProperties, manifestProfiles, codecs, }) {\n    const profiles = (adaptationProfiles !== null && adaptationProfiles !== void 0 ? adaptationProfiles : \"\") + (manifestProfiles !== null && manifestProfiles !== void 0 ? manifestProfiles : \"\");\n    if (profiles.indexOf(\"http://dashif.org/guidelines/dash-if-uhd#hevc-hdr-pq10\") !== -1) {\n        if (codecs === \"hvc1.2.4.L153.B0\" || codecs === \"hev1.2.4.L153.B0\") {\n            return { colorDepth: 10, eotf: \"pq\", colorSpace: \"rec2020\" };\n        }\n    }\n    const transferCharacteristicScheme = arrayFind([...(essentialProperties !== null && essentialProperties !== void 0 ? essentialProperties : []), ...(supplementalProperties !== null && supplementalProperties !== void 0 ? supplementalProperties : [])], (p) => p.schemeIdUri === \"urn:mpeg:mpegB:cicp:TransferCharacteristics\");\n    if (transferCharacteristicScheme !== undefined) {\n        // 1: ITU-R BT.709\n        // 2: Unspecified\n        // 4: Gamma 2.2 curve\n        // 5: Gamma 2.8 curve\n        // 6: SMPTE 170M\n        // 7: SMPTE 240M\n        // 8: Linear\n        // 9: Logarithmic (100:1 range)\n        // 10: Logarithmic (100 * Sqrt(10) : 1 range)\n        // 11: IEC 61966-2-4\n        // 12: ITU-R BT.1361 Extended Colour Gamut\n        // 13: IEC 61966-2-1 (sRGB or sYCC)\n        // 14: ITU-R BT.2020 10-bit system\n        // 15: ITU-R BT.2020 12-bit system\n        // 16: SMPTE ST 2084, ITU-R BT.2100 PQ\n        // 17: SMPTE ST 428-1\n        // 18: ARIB STD-B67 (HLG)\n        switch (transferCharacteristicScheme.value) {\n            case \"15\":\n                return undefined; // SDR\n            case \"16\":\n                return { eotf: \"pq\" };\n            case \"18\":\n                return { eotf: \"hlg\" };\n        }\n    }\n    if (codecs !== undefined && /^vp(08|09|10)/.test(codecs)) {\n        return getWEBMHDRInformation(codecs);\n    }\n}\n/**\n * Process intermediate representations to create final parsed representations.\n * In the same order.\n * @param {Array.<Object>} representationsIR\n * @param {Object} context\n * @returns {Array.<Object>}\n */\nexport default function parseRepresentations(representationsIR, adaptation, context) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const parsedRepresentations = [];\n    for (const representation of representationsIR) {\n        // Compute Representation ID\n        let representationID = representation.attributes.id !== undefined\n            ? representation.attributes.id\n            : String(representation.attributes.bitrate) +\n                (representation.attributes.height !== undefined\n                    ? `-${representation.attributes.height}`\n                    : \"\") +\n                (representation.attributes.width !== undefined\n                    ? `-${representation.attributes.width}`\n                    : \"\") +\n                (representation.attributes.mimeType !== undefined\n                    ? `-${representation.attributes.mimeType}`\n                    : \"\") +\n                (representation.attributes.codecs !== undefined\n                    ? `-${representation.attributes.codecs}`\n                    : \"\");\n        // Avoid duplicate IDs\n        while (parsedRepresentations.some((r) => r.id === representationID)) {\n            representationID += \"-dup\";\n        }\n        // Retrieve previous version of the Representation, if one.\n        const unsafelyBaseOnPreviousRepresentation = (_b = (_a = context.unsafelyBaseOnPreviousAdaptation) === null || _a === void 0 ? void 0 : _a.getRepresentation(representationID)) !== null && _b !== void 0 ? _b : null;\n        const inbandEventStreams = combineInbandEventStreams(representation, adaptation);\n        const availabilityTimeComplete = (_c = representation.attributes.availabilityTimeComplete) !== null && _c !== void 0 ? _c : context.availabilityTimeComplete;\n        let availabilityTimeOffset;\n        if (representation.attributes.availabilityTimeOffset !== undefined ||\n            context.availabilityTimeOffset !== undefined) {\n            availabilityTimeOffset =\n                ((_d = representation.attributes.availabilityTimeOffset) !== null && _d !== void 0 ? _d : 0) +\n                    ((_e = context.availabilityTimeOffset) !== null && _e !== void 0 ? _e : 0);\n        }\n        const reprIndexCtxt = objectAssign({}, context, {\n            availabilityTimeOffset,\n            availabilityTimeComplete,\n            unsafelyBaseOnPreviousRepresentation,\n            adaptation,\n            inbandEventStreams,\n        });\n        const representationIndex = parseRepresentationIndex(representation, reprIndexCtxt);\n        // Find bitrate\n        let representationBitrate;\n        if (representation.attributes.bitrate === undefined) {\n            log.warn(\"DASH: No usable bitrate found in the Representation.\");\n            representationBitrate = 0;\n        }\n        else {\n            representationBitrate = representation.attributes.bitrate;\n        }\n        const representationBaseURLs = resolveBaseURLs(context.baseURLs, representation.children.baseURLs);\n        const cdnMetadata = representationBaseURLs.length === 0\n            ? // No BaseURL seems to be associated to this Representation, nor to the MPD,\n                // but underlying segments might have one. To indicate that segments should\n                // still be available through a CDN without giving any root CDN URL here,\n                // we just communicate about an empty `baseUrl`, as documented.\n                [{ baseUrl: \"\", id: undefined }]\n            : representationBaseURLs.map((x) => ({\n                baseUrl: x.url,\n                id: x.serviceLocation,\n            }));\n        // Construct Representation Base\n        const parsedRepresentation = {\n            bitrate: representationBitrate,\n            cdnMetadata,\n            index: representationIndex,\n            id: representationID,\n        };\n        if (representation.children.supplementalProperties !== undefined &&\n            arrayFind(representation.children.supplementalProperties, (r) => r.schemeIdUri === \"tag:dolby.com,2018:dash:EC3_ExtensionType:2018\" &&\n                r.value === \"JOC\") !== undefined) {\n            parsedRepresentation.isSpatialAudio = true;\n        }\n        // Add optional attributes\n        let codecs;\n        if (representation.attributes.codecs !== undefined) {\n            codecs = representation.attributes.codecs;\n        }\n        else if (adaptation.attributes.codecs !== undefined) {\n            codecs = adaptation.attributes.codecs;\n        }\n        if (codecs !== undefined) {\n            codecs = codecs === \"mp4a.40.02\" ? \"mp4a.40.2\" : codecs;\n            parsedRepresentation.codecs = codecs;\n        }\n        let supplementalCodecs;\n        if (representation.attributes.supplementalCodecs !== undefined) {\n            supplementalCodecs = representation.attributes.supplementalCodecs;\n        }\n        else if (adaptation.attributes.supplementalCodecs !== undefined) {\n            supplementalCodecs = adaptation.attributes.supplementalCodecs;\n        }\n        if (supplementalCodecs !== undefined) {\n            parsedRepresentation.supplementalCodecs =\n                convertSupplementalCodecsToRFC6381(supplementalCodecs);\n        }\n        if (representation.attributes.frameRate !== undefined) {\n            parsedRepresentation.frameRate = representation.attributes.frameRate;\n        }\n        else if (adaptation.attributes.frameRate !== undefined) {\n            parsedRepresentation.frameRate = adaptation.attributes.frameRate;\n        }\n        if (representation.attributes.height !== undefined) {\n            parsedRepresentation.height = representation.attributes.height;\n        }\n        else if (adaptation.attributes.height !== undefined) {\n            parsedRepresentation.height = adaptation.attributes.height;\n        }\n        if (representation.attributes.mimeType !== undefined) {\n            parsedRepresentation.mimeType = representation.attributes.mimeType;\n        }\n        else if (adaptation.attributes.mimeType !== undefined) {\n            parsedRepresentation.mimeType = adaptation.attributes.mimeType;\n        }\n        if (representation.attributes.width !== undefined) {\n            parsedRepresentation.width = representation.attributes.width;\n        }\n        else if (adaptation.attributes.width !== undefined) {\n            parsedRepresentation.width = adaptation.attributes.width;\n        }\n        // Content Protection parsing\n        {\n            const contentProtIrArr = [\n                ...((_f = adaptation.children.contentProtections) !== null && _f !== void 0 ? _f : []),\n                ...((_g = representation.children.contentProtections) !== null && _g !== void 0 ? _g : []),\n            ];\n            for (const contentProtIr of contentProtIrArr) {\n                context.contentProtectionParser.add(parsedRepresentation, contentProtIr);\n            }\n        }\n        parsedRepresentation.hdrInfo = getHDRInformation({\n            adaptationProfiles: adaptation.attributes.profiles,\n            supplementalProperties: adaptation.children.supplementalProperties,\n            essentialProperties: adaptation.children.essentialProperties,\n            manifestProfiles: context.manifestProfiles,\n            codecs,\n        });\n        parsedRepresentations.push(parsedRepresentation);\n    }\n    return parsedRepresentations;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { resolveURL } from \"../../../../utils/url-utils\";\n/**\n * @param {Array.<string>} currentBaseURLs\n * @param {Array.<Object>} newBaseUrlsIR\n * @returns {Array.<string>}\n */\nexport default function resolveBaseURLs(currentBaseURLs, newBaseUrlsIR) {\n    var _a;\n    if (newBaseUrlsIR.length === 0) {\n        return currentBaseURLs;\n    }\n    const newBaseUrls = newBaseUrlsIR.map((ir) => {\n        return { url: ir.value };\n    });\n    if (currentBaseURLs.length === 0) {\n        return newBaseUrls;\n    }\n    const result = [];\n    for (let i = 0; i < currentBaseURLs.length; i++) {\n        const curBaseUrl = currentBaseURLs[i];\n        for (let j = 0; j < newBaseUrls.length; j++) {\n            const newBaseUrl = newBaseUrls[j];\n            const newUrl = resolveURL(curBaseUrl.url, newBaseUrl.url);\n            result.push({\n                url: newUrl,\n                serviceLocation: (_a = newBaseUrl.serviceLocation) !== null && _a !== void 0 ? _a : curBaseUrl.serviceLocation,\n            });\n        }\n    }\n    return result;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport parseFromDocument from \"./parse_from_document\";\nexport default parseFromDocument;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport isNullOrUndefined from \"../../../../../utils/is_null_or_undefined\";\nimport parseBaseURL from \"./BaseURL\";\nimport parseContentComponent from \"./ContentComponent\";\nimport parseContentProtection from \"./ContentProtection\";\nimport { createRepresentationIntermediateRepresentation } from \"./Representation\";\nimport parseSegmentBase from \"./SegmentBase\";\nimport parseSegmentList from \"./SegmentList\";\nimport parseSegmentTemplate from \"./SegmentTemplate\";\nimport { parseBoolean, parseIntOrBoolean, parseMaybeDividedNumber, parseMPDFloat, parseMPDInteger, parseScheme, ValueParser, } from \"./utils\";\n/**\n * Parse child nodes from an AdaptationSet.\n * @param {NodeList} adaptationSetChildren - The AdaptationSet child nodes.\n * @returns {Array.<Object>}\n */\nfunction parseAdaptationSetChildren(adaptationSetChildren) {\n    const children = {\n        baseURLs: [],\n        representations: [],\n    };\n    const contentProtections = [];\n    let warnings = [];\n    for (let i = 0; i < adaptationSetChildren.length; i++) {\n        if (adaptationSetChildren[i].nodeType === Node.ELEMENT_NODE) {\n            const currentElement = adaptationSetChildren[i];\n            switch (currentElement.nodeName) {\n                case \"Accessibility\":\n                    if (children.accessibilities === undefined) {\n                        children.accessibilities = [parseScheme(currentElement)];\n                    }\n                    else {\n                        children.accessibilities.push(parseScheme(currentElement));\n                    }\n                    break;\n                case \"BaseURL\": {\n                    const [baseURLObj, baseURLWarnings] = parseBaseURL(currentElement);\n                    if (baseURLObj !== undefined) {\n                        children.baseURLs.push(baseURLObj);\n                    }\n                    if (baseURLWarnings.length > 0) {\n                        warnings = warnings.concat(baseURLWarnings);\n                    }\n                    break;\n                }\n                case \"ContentComponent\":\n                    children.contentComponent = parseContentComponent(currentElement);\n                    break;\n                case \"EssentialProperty\":\n                    if (isNullOrUndefined(children.essentialProperties)) {\n                        children.essentialProperties = [parseScheme(currentElement)];\n                    }\n                    else {\n                        children.essentialProperties.push(parseScheme(currentElement));\n                    }\n                    break;\n                case \"InbandEventStream\":\n                    if (children.inbandEventStreams === undefined) {\n                        children.inbandEventStreams = [];\n                    }\n                    children.inbandEventStreams.push(parseScheme(currentElement));\n                    break;\n                case \"Label\": {\n                    const label = currentElement.textContent;\n                    if (label !== null && label !== undefined) {\n                        children.label = label;\n                    }\n                    break;\n                }\n                case \"Representation\": {\n                    const [representation, representationWarnings] = createRepresentationIntermediateRepresentation(currentElement);\n                    children.representations.push(representation);\n                    if (representationWarnings.length > 0) {\n                        warnings = warnings.concat(representationWarnings);\n                    }\n                    break;\n                }\n                case \"Role\":\n                    if (isNullOrUndefined(children.roles)) {\n                        children.roles = [parseScheme(currentElement)];\n                    }\n                    else {\n                        children.roles.push(parseScheme(currentElement));\n                    }\n                    break;\n                case \"SupplementalProperty\":\n                    if (isNullOrUndefined(children.supplementalProperties)) {\n                        children.supplementalProperties = [parseScheme(currentElement)];\n                    }\n                    else {\n                        children.supplementalProperties.push(parseScheme(currentElement));\n                    }\n                    break;\n                case \"SegmentBase\": {\n                    const [segmentBase, segmentBaseWarnings] = parseSegmentBase(currentElement);\n                    children.segmentBase = segmentBase;\n                    if (segmentBaseWarnings.length > 0) {\n                        warnings = warnings.concat(segmentBaseWarnings);\n                    }\n                    break;\n                }\n                case \"SegmentList\": {\n                    const [segmentList, segmentListWarnings] = parseSegmentList(currentElement);\n                    children.segmentList = segmentList;\n                    if (segmentListWarnings.length > 0) {\n                        warnings = warnings.concat(segmentListWarnings);\n                    }\n                    break;\n                }\n                case \"SegmentTemplate\": {\n                    const [segmentTemplate, segmentTemplateWarnings] = parseSegmentTemplate(currentElement);\n                    children.segmentTemplate = segmentTemplate;\n                    if (segmentTemplateWarnings.length > 0) {\n                        warnings = warnings.concat(segmentTemplateWarnings);\n                    }\n                    break;\n                }\n                case \"ContentProtection\": {\n                    const [contentProtection, contentProtectionWarnings] = parseContentProtection(currentElement);\n                    if (contentProtectionWarnings.length > 0) {\n                        warnings = warnings.concat(contentProtectionWarnings);\n                    }\n                    if (contentProtection !== undefined) {\n                        contentProtections.push(contentProtection);\n                    }\n                    break;\n                }\n                // case \"Rating\":\n                //   children.rating = currentElement;\n                //   break;\n                // case \"Viewpoint\":\n                //   children.viewpoint = currentElement;\n                //   break;\n            }\n        }\n    }\n    if (contentProtections.length > 0) {\n        children.contentProtections = contentProtections;\n    }\n    return [children, warnings];\n}\n/**\n * Parse every attributes from an AdaptationSet root element into a simple JS\n * object.\n * @param {Element} root - The AdaptationSet root element.\n * @returns {Array.<Object>}\n */\nfunction parseAdaptationSetAttributes(root) {\n    const parsedAdaptation = {};\n    const warnings = [];\n    const parseValue = ValueParser(parsedAdaptation, warnings);\n    for (let i = 0; i < root.attributes.length; i++) {\n        const attribute = root.attributes[i];\n        switch (attribute.name) {\n            case \"id\":\n                parsedAdaptation.id = attribute.value;\n                break;\n            case \"group\":\n                parseValue(attribute.value, {\n                    asKey: \"group\",\n                    parser: parseMPDInteger,\n                    dashName: \"group\",\n                });\n                break;\n            case \"lang\":\n                parsedAdaptation.language = attribute.value;\n                break;\n            case \"contentType\":\n                parsedAdaptation.contentType = attribute.value;\n                break;\n            case \"par\":\n                parsedAdaptation.par = attribute.value;\n                break;\n            case \"minBandwidth\":\n                parseValue(attribute.value, {\n                    asKey: \"minBitrate\",\n                    parser: parseMPDInteger,\n                    dashName: \"minBandwidth\",\n                });\n                break;\n            case \"maxBandwidth\":\n                parseValue(attribute.value, {\n                    asKey: \"maxBitrate\",\n                    parser: parseMPDInteger,\n                    dashName: \"maxBandwidth\",\n                });\n                break;\n            case \"minWidth\":\n                parseValue(attribute.value, {\n                    asKey: \"minWidth\",\n                    parser: parseMPDInteger,\n                    dashName: \"minWidth\",\n                });\n                break;\n            case \"maxWidth\":\n                parseValue(attribute.value, {\n                    asKey: \"maxWidth\",\n                    parser: parseMPDInteger,\n                    dashName: \"maxWidth\",\n                });\n                break;\n            case \"minHeight\":\n                parseValue(attribute.value, {\n                    asKey: \"minHeight\",\n                    parser: parseMPDInteger,\n                    dashName: \"minHeight\",\n                });\n                break;\n            case \"maxHeight\":\n                parseValue(attribute.value, {\n                    asKey: \"maxHeight\",\n                    parser: parseMPDInteger,\n                    dashName: \"maxHeight\",\n                });\n                break;\n            case \"minFrameRate\":\n                parseValue(attribute.value, {\n                    asKey: \"minFrameRate\",\n                    parser: parseMaybeDividedNumber,\n                    dashName: \"minFrameRate\",\n                });\n                break;\n            case \"maxFrameRate\":\n                parseValue(attribute.value, {\n                    asKey: \"maxFrameRate\",\n                    parser: parseMaybeDividedNumber,\n                    dashName: \"maxFrameRate\",\n                });\n                break;\n            case \"selectionPriority\":\n                parseValue(attribute.value, {\n                    asKey: \"selectionPriority\",\n                    parser: parseMPDInteger,\n                    dashName: \"selectionPriority\",\n                });\n                break;\n            case \"segmentAlignment\":\n                parseValue(attribute.value, {\n                    asKey: \"segmentAlignment\",\n                    parser: parseIntOrBoolean,\n                    dashName: \"segmentAlignment\",\n                });\n                break;\n            case \"subsegmentAlignment\":\n                parseValue(attribute.value, {\n                    asKey: \"subsegmentAlignment\",\n                    parser: parseIntOrBoolean,\n                    dashName: \"subsegmentAlignment\",\n                });\n                break;\n            case \"bitstreamSwitching\":\n                parseValue(attribute.value, {\n                    asKey: \"bitstreamSwitching\",\n                    parser: parseBoolean,\n                    dashName: \"bitstreamSwitching\",\n                });\n                break;\n            case \"audioSamplingRate\":\n                parsedAdaptation.audioSamplingRate = attribute.value;\n                break;\n            case \"codecs\":\n                parsedAdaptation.codecs = attribute.value;\n                break;\n            case \"scte214:supplementalCodecs\":\n                parsedAdaptation.supplementalCodecs = attribute.value;\n                break;\n            case \"codingDependency\":\n                parseValue(attribute.value, {\n                    asKey: \"codingDependency\",\n                    parser: parseBoolean,\n                    dashName: \"codingDependency\",\n                });\n                break;\n            case \"frameRate\":\n                parseValue(attribute.value, {\n                    asKey: \"frameRate\",\n                    parser: parseMaybeDividedNumber,\n                    dashName: \"frameRate\",\n                });\n                break;\n            case \"height\":\n                parseValue(attribute.value, {\n                    asKey: \"height\",\n                    parser: parseMPDInteger,\n                    dashName: \"height\",\n                });\n                break;\n            case \"maxPlayoutRate\":\n                parseValue(attribute.value, {\n                    asKey: \"maxPlayoutRate\",\n                    parser: parseMPDFloat,\n                    dashName: \"maxPlayoutRate\",\n                });\n                break;\n            case \"maximumSAPPeriod\":\n                parseValue(attribute.value, {\n                    asKey: \"maximumSAPPeriod\",\n                    parser: parseMPDFloat,\n                    dashName: \"maximumSAPPeriod\",\n                });\n                break;\n            case \"mimeType\":\n                parsedAdaptation.mimeType = attribute.value;\n                break;\n            case \"profiles\":\n                parsedAdaptation.profiles = attribute.value;\n                break;\n            case \"segmentProfiles\":\n                parsedAdaptation.segmentProfiles = attribute.value;\n                break;\n            case \"width\":\n                parseValue(attribute.value, {\n                    asKey: \"width\",\n                    parser: parseMPDInteger,\n                    dashName: \"width\",\n                });\n                break;\n            case \"availabilityTimeOffset\":\n                parseValue(attribute.value, {\n                    asKey: \"availabilityTimeOffset\",\n                    parser: parseMPDFloat,\n                    dashName: \"availabilityTimeOffset\",\n                });\n                break;\n            case \"availabilityTimeComplete\":\n                parseValue(attribute.value, {\n                    asKey: \"availabilityTimeComplete\",\n                    parser: parseBoolean,\n                    dashName: \"availabilityTimeComplete\",\n                });\n                break;\n        }\n    }\n    return [parsedAdaptation, warnings];\n}\n/**\n * Parse an AdaptationSet element into an AdaptationSet intermediate\n * representation.\n * @param {Element} adaptationSetElement - The AdaptationSet root element.\n * @returns {Array.<Object>}\n */\nexport function createAdaptationSetIntermediateRepresentation(adaptationSetElement) {\n    const childNodes = adaptationSetElement.childNodes;\n    const [children, childrenWarnings] = parseAdaptationSetChildren(childNodes);\n    const [attributes, attrsWarnings] = parseAdaptationSetAttributes(adaptationSetElement);\n    const warnings = childrenWarnings.concat(attrsWarnings);\n    return [{ children, attributes }, warnings];\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Parse an BaseURL element into an BaseURL intermediate\n * representation.\n * @param {Element} root - The BaseURL root element.\n * @returns {Array.<Object|undefined>}\n */\nexport default function parseBaseURL(root) {\n    const value = root.textContent;\n    const warnings = [];\n    if (value === null || value.length === 0) {\n        return [undefined, warnings];\n    }\n    return [{ value }, warnings];\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Parse a \"ContentComponent\" Element in a DASH MPD.\n * @param {Element} root\n * @returns {Object}\n */\nexport default function parseContentComponent(root) {\n    const ret = {};\n    for (let i = 0; i < root.attributes.length; i++) {\n        const attribute = root.attributes[i];\n        switch (attribute.name) {\n            case \"id\":\n                ret.id = attribute.value;\n                break;\n            case \"lang\":\n                ret.language = attribute.value;\n                break;\n            case \"contentType\":\n                ret.contentType = attribute.value;\n                break;\n            case \"par\":\n                ret.par = attribute.value;\n                break;\n        }\n    }\n    return ret;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../../../../log\";\nimport { hexToBytes } from \"../../../../../utils/string_parsing\";\nimport { parseBase64 } from \"./utils\";\n/**\n * @param {NodeList} contentProtectionChildren\n * @Returns {Object}\n */\nfunction parseContentProtectionChildren(contentProtectionChildren) {\n    const warnings = [];\n    const cencPssh = [];\n    for (let i = 0; i < contentProtectionChildren.length; i++) {\n        if (contentProtectionChildren[i].nodeType === Node.ELEMENT_NODE) {\n            const currentElement = contentProtectionChildren[i];\n            if (currentElement.nodeName === \"cenc:pssh\") {\n                const content = currentElement.textContent;\n                if (content !== null && content.length > 0) {\n                    const [toUint8Array, error] = parseBase64(content, \"cenc:pssh\");\n                    if (error !== null) {\n                        log.warn(error.message);\n                        warnings.push(error);\n                    }\n                    if (toUint8Array !== null) {\n                        cencPssh.push(toUint8Array);\n                    }\n                }\n            }\n        }\n    }\n    return [{ cencPssh }, warnings];\n}\n/**\n * @param {Element} root\n * @returns {Object}\n */\nfunction parseContentProtectionAttributes(root) {\n    const ret = {};\n    for (let i = 0; i < root.attributes.length; i++) {\n        const attribute = root.attributes[i];\n        switch (attribute.name) {\n            case \"schemeIdUri\":\n                ret.schemeIdUri = attribute.value;\n                break;\n            case \"value\":\n                ret.value = attribute.value;\n                break;\n            case \"cenc:default_KID\":\n                ret.keyId = hexToBytes(attribute.value.replace(/-/g, \"\"));\n                break;\n            case \"ref\":\n                ret.ref = attribute.value;\n                break;\n            case \"refId\":\n                ret.refId = attribute.value;\n                break;\n        }\n    }\n    return ret;\n}\n/**\n * @param {Element} contentProtectionElement\n * @returns {Object}\n */\nexport default function parseContentProtection(contentProtectionElement) {\n    const [children, childrenWarnings] = parseContentProtectionChildren(contentProtectionElement.childNodes);\n    const attributes = parseContentProtectionAttributes(contentProtectionElement);\n    return [{ children, attributes }, childrenWarnings];\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { parseMPDInteger, ValueParser } from \"./utils\";\n/**\n * Parse the EventStream node to extract Event nodes and their\n * content.\n * @param {Element} element\n * @returns {Array}\n */\nexport default function parseEventStream(element) {\n    const eventStreamIR = {\n        children: { events: [] },\n        attributes: {},\n    };\n    let warnings = [];\n    // 1 - Parse attributes\n    const parseValue = ValueParser(eventStreamIR.attributes, warnings);\n    for (let i = 0; i < element.attributes.length; i++) {\n        const attr = element.attributes[i];\n        switch (attr.name) {\n            case \"schemeIdUri\":\n                eventStreamIR.attributes.schemeIdUri = attr.value;\n                break;\n            case \"timescale\":\n                parseValue(attr.value, {\n                    asKey: \"timescale\",\n                    parser: parseMPDInteger,\n                    dashName: \"timescale\",\n                });\n                break;\n            case \"value\":\n                eventStreamIR.attributes.value = attr.value;\n                break;\n        }\n    }\n    for (let i = 0; i < element.childNodes.length; i++) {\n        if (element.childNodes[i].nodeType === Node.ELEMENT_NODE) {\n            const currentElement = element.childNodes[i];\n            switch (currentElement.nodeName) {\n                case \"Event\": {\n                    const [event, eventWarnings] = parseEvent(currentElement);\n                    eventStreamIR.children.events.push(event);\n                    if (eventWarnings.length > 0) {\n                        warnings = warnings.concat(eventWarnings);\n                    }\n                    break;\n                }\n            }\n        }\n    }\n    return [eventStreamIR, warnings];\n}\n/**\n * Parse `Event` Element, as found in EventStream nodes.\n * @param {Element} element\n * @returns {Array}\n */\nfunction parseEvent(element) {\n    const eventIR = {\n        eventStreamData: element,\n    };\n    const warnings = [];\n    // 1 - Parse attributes\n    const parseValue = ValueParser(eventIR, warnings);\n    for (let i = 0; i < element.attributes.length; i++) {\n        const attr = element.attributes[i];\n        switch (attr.name) {\n            case \"presentationTime\":\n                parseValue(attr.value, {\n                    asKey: \"presentationTime\",\n                    parser: parseMPDInteger,\n                    dashName: \"presentationTime\",\n                });\n                break;\n            case \"duration\":\n                parseValue(attr.value, {\n                    asKey: \"duration\",\n                    parser: parseMPDInteger,\n                    dashName: \"duration\",\n                });\n                break;\n            case \"id\":\n                eventIR.id = attr.value;\n                break;\n        }\n    }\n    return [eventIR, warnings];\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { parseByteRange, ValueParser } from \"./utils\";\n/**\n * @param {Element} root\n * @returns {Array.<Object>}\n */\nexport default function parseInitialization(root) {\n    const parsedInitialization = {};\n    const warnings = [];\n    const parseValue = ValueParser(parsedInitialization, warnings);\n    for (let i = 0; i < root.attributes.length; i++) {\n        const attribute = root.attributes[i];\n        switch (attribute.name) {\n            case \"range\":\n                parseValue(attribute.value, {\n                    asKey: \"range\",\n                    parser: parseByteRange,\n                    dashName: \"range\",\n                });\n                break;\n            case \"sourceURL\":\n                parsedInitialization.media = attribute.value;\n                break;\n        }\n    }\n    return [parsedInitialization, warnings];\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport parseBaseURL from \"./BaseURL\";\nimport parseContentProtection from \"./ContentProtection\";\nimport { createPeriodIntermediateRepresentation } from \"./Period\";\nimport { parseDateTime, parseDuration, parseScheme, ValueParser } from \"./utils\";\n/**\n * Parse children of the MPD's root into a simple object.\n * @param {NodeList} mpdChildren\n * @returns {Array.<Object>}\n */\nfunction parseMPDChildren(mpdChildren) {\n    const baseURLs = [];\n    const locations = [];\n    const periods = [];\n    const utcTimings = [];\n    const contentProtections = [];\n    let warnings = [];\n    for (let i = 0; i < mpdChildren.length; i++) {\n        if (mpdChildren[i].nodeType === Node.ELEMENT_NODE) {\n            const currentNode = mpdChildren[i];\n            switch (currentNode.nodeName) {\n                case \"BaseURL\": {\n                    const [baseURLObj, baseURLWarnings] = parseBaseURL(currentNode);\n                    if (baseURLObj !== undefined) {\n                        baseURLs.push(baseURLObj);\n                    }\n                    warnings = warnings.concat(baseURLWarnings);\n                    break;\n                }\n                case \"Location\":\n                    locations.push(currentNode.textContent === null ? \"\" : currentNode.textContent);\n                    break;\n                case \"Period\": {\n                    const [period, periodWarnings] = createPeriodIntermediateRepresentation(currentNode);\n                    periods.push(period);\n                    warnings = warnings.concat(periodWarnings);\n                    break;\n                }\n                case \"UTCTiming\": {\n                    const utcTiming = parseScheme(currentNode);\n                    utcTimings.push(utcTiming);\n                    break;\n                }\n                case \"ContentProtection\": {\n                    const [contentProtection, contentProtectionWarnings] = parseContentProtection(currentNode);\n                    if (contentProtectionWarnings.length > 0) {\n                        warnings = warnings.concat(contentProtectionWarnings);\n                    }\n                    if (contentProtection !== undefined) {\n                        contentProtections.push(contentProtection);\n                    }\n                    break;\n                }\n            }\n        }\n    }\n    return [{ baseURLs, locations, periods, utcTimings, contentProtections }, warnings];\n}\n/**\n * @param {Element} root\n * @returns {Array.<Object>}\n */\nfunction parseMPDAttributes(root) {\n    const res = {};\n    const warnings = [];\n    const parseValue = ValueParser(res, warnings);\n    for (let i = 0; i < root.attributes.length; i++) {\n        const attribute = root.attributes[i];\n        switch (attribute.name) {\n            case \"id\":\n                res.id = attribute.value;\n                break;\n            case \"profiles\":\n                res.profiles = attribute.value;\n                break;\n            case \"type\":\n                res.type = attribute.value;\n                break;\n            case \"availabilityStartTime\":\n                parseValue(attribute.value, {\n                    asKey: \"availabilityStartTime\",\n                    parser: parseDateTime,\n                    dashName: \"availabilityStartTime\",\n                });\n                break;\n            case \"availabilityEndTime\":\n                parseValue(attribute.value, {\n                    asKey: \"availabilityEndTime\",\n                    parser: parseDateTime,\n                    dashName: \"availabilityEndTime\",\n                });\n                break;\n            case \"publishTime\":\n                parseValue(attribute.value, {\n                    asKey: \"publishTime\",\n                    parser: parseDateTime,\n                    dashName: \"publishTime\",\n                });\n                break;\n            case \"mediaPresentationDuration\":\n                parseValue(attribute.value, {\n                    asKey: \"duration\",\n                    parser: parseDuration,\n                    dashName: \"mediaPresentationDuration\",\n                });\n                break;\n            case \"minimumUpdatePeriod\":\n                parseValue(attribute.value, {\n                    asKey: \"minimumUpdatePeriod\",\n                    parser: parseDuration,\n                    dashName: \"minimumUpdatePeriod\",\n                });\n                break;\n            case \"minBufferTime\":\n                parseValue(attribute.value, {\n                    asKey: \"minBufferTime\",\n                    parser: parseDuration,\n                    dashName: \"minBufferTime\",\n                });\n                break;\n            case \"timeShiftBufferDepth\":\n                parseValue(attribute.value, {\n                    asKey: \"timeShiftBufferDepth\",\n                    parser: parseDuration,\n                    dashName: \"timeShiftBufferDepth\",\n                });\n                break;\n            case \"suggestedPresentationDelay\":\n                parseValue(attribute.value, {\n                    asKey: \"suggestedPresentationDelay\",\n                    parser: parseDuration,\n                    dashName: \"suggestedPresentationDelay\",\n                });\n                break;\n            case \"maxSegmentDuration\":\n                parseValue(attribute.value, {\n                    asKey: \"maxSegmentDuration\",\n                    parser: parseDuration,\n                    dashName: \"maxSegmentDuration\",\n                });\n                break;\n            case \"maxSubsegmentDuration\":\n                parseValue(attribute.value, {\n                    asKey: \"maxSubsegmentDuration\",\n                    parser: parseDuration,\n                    dashName: \"maxSubsegmentDuration\",\n                });\n                break;\n        }\n    }\n    return [res, warnings];\n}\n/**\n * @param {Element} root\n * @returns {Array.<Object>}\n */\nexport function createMPDIntermediateRepresentation(root) {\n    const [children, childrenWarnings] = parseMPDChildren(root.childNodes);\n    const [attributes, attrsWarnings] = parseMPDAttributes(root);\n    const warnings = childrenWarnings.concat(attrsWarnings);\n    return [{ children, attributes }, warnings];\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { createAdaptationSetIntermediateRepresentation } from \"./AdaptationSet\";\nimport parseBaseURL from \"./BaseURL\";\nimport parseContentProtection from \"./ContentProtection\";\nimport parseEventStream from \"./EventStream\";\nimport parseSegmentTemplate from \"./SegmentTemplate\";\nimport { parseBoolean, parseDuration, ValueParser } from \"./utils\";\n/**\n * @param {NodeList} periodChildren\n * @returns {Array}\n */\nfunction parsePeriodChildren(periodChildren) {\n    const baseURLs = [];\n    const adaptations = [];\n    let segmentTemplate;\n    const contentProtections = [];\n    let warnings = [];\n    const eventStreams = [];\n    for (let i = 0; i < periodChildren.length; i++) {\n        if (periodChildren[i].nodeType === Node.ELEMENT_NODE) {\n            const currentElement = periodChildren[i];\n            switch (currentElement.nodeName) {\n                case \"BaseURL\": {\n                    const [baseURLObj, baseURLWarnings] = parseBaseURL(currentElement);\n                    if (baseURLObj !== undefined) {\n                        baseURLs.push(baseURLObj);\n                    }\n                    warnings = warnings.concat(baseURLWarnings);\n                    break;\n                }\n                case \"AdaptationSet\": {\n                    const [adaptation, adaptationWarnings] = createAdaptationSetIntermediateRepresentation(currentElement);\n                    adaptations.push(adaptation);\n                    warnings = warnings.concat(adaptationWarnings);\n                    break;\n                }\n                case \"EventStream\": {\n                    const [eventStream, eventStreamWarnings] = parseEventStream(currentElement);\n                    eventStreams.push(eventStream);\n                    warnings = warnings.concat(eventStreamWarnings);\n                    break;\n                }\n                case \"SegmentTemplate\": {\n                    const [parsedSegmentTemplate, segmentTemplateWarnings] = parseSegmentTemplate(currentElement);\n                    segmentTemplate = parsedSegmentTemplate;\n                    if (segmentTemplateWarnings.length > 0) {\n                        warnings = warnings.concat(segmentTemplateWarnings);\n                    }\n                    break;\n                }\n                case \"ContentProtection\": {\n                    const [contentProtection, contentProtectionWarnings] = parseContentProtection(currentElement);\n                    if (contentProtectionWarnings.length > 0) {\n                        warnings = warnings.concat(contentProtectionWarnings);\n                    }\n                    if (contentProtection !== undefined) {\n                        contentProtections.push(contentProtection);\n                    }\n                    break;\n                }\n            }\n        }\n    }\n    return [\n        { baseURLs, adaptations, eventStreams, segmentTemplate, contentProtections },\n        warnings,\n    ];\n}\n/**\n * @param {Element} periodElement\n * @returns {Array}\n */\nfunction parsePeriodAttributes(periodElement) {\n    const res = {};\n    const warnings = [];\n    const parseValue = ValueParser(res, warnings);\n    for (let i = 0; i < periodElement.attributes.length; i++) {\n        const attr = periodElement.attributes[i];\n        switch (attr.name) {\n            case \"id\":\n                res.id = attr.value;\n                break;\n            case \"start\":\n                parseValue(attr.value, {\n                    asKey: \"start\",\n                    parser: parseDuration,\n                    dashName: \"start\",\n                });\n                break;\n            case \"duration\":\n                parseValue(attr.value, {\n                    asKey: \"duration\",\n                    parser: parseDuration,\n                    dashName: \"duration\",\n                });\n                break;\n            case \"bitstreamSwitching\":\n                parseValue(attr.value, {\n                    asKey: \"bitstreamSwitching\",\n                    parser: parseBoolean,\n                    dashName: \"bitstreamSwitching\",\n                });\n                break;\n            case \"xlink:href\":\n                res.xlinkHref = attr.value;\n                break;\n            case \"xlink:actuate\":\n                res.xlinkActuate = attr.value;\n                break;\n        }\n    }\n    return [res, warnings];\n}\n/**\n * @param {Element} periodElement\n * @returns {Array}\n */\nexport function createPeriodIntermediateRepresentation(periodElement) {\n    const [children, childrenWarnings] = parsePeriodChildren(periodElement.childNodes);\n    const [attributes, attrsWarnings] = parsePeriodAttributes(periodElement);\n    const warnings = childrenWarnings.concat(attrsWarnings);\n    return [{ children, attributes }, warnings];\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport isNullOrUndefined from \"../../../../../utils/is_null_or_undefined\";\nimport parseBaseURL from \"./BaseURL\";\nimport parseContentProtection from \"./ContentProtection\";\nimport parseSegmentBase from \"./SegmentBase\";\nimport parseSegmentList from \"./SegmentList\";\nimport parseSegmentTemplate from \"./SegmentTemplate\";\nimport { MPDError, parseBoolean, parseMaybeDividedNumber, parseMPDFloat, parseMPDInteger, parseScheme, ValueParser, } from \"./utils\";\n/**\n * @param {NodeList} representationChildren\n * @returns {Object}\n */\nfunction parseRepresentationChildren(representationChildren) {\n    const children = {\n        baseURLs: [],\n    };\n    const contentProtections = [];\n    let warnings = [];\n    for (let i = 0; i < representationChildren.length; i++) {\n        if (representationChildren[i].nodeType === Node.ELEMENT_NODE) {\n            const currentElement = representationChildren[i];\n            switch (currentElement.nodeName) {\n                case \"BaseURL\": {\n                    const [baseURLObj, baseURLWarnings] = parseBaseURL(currentElement);\n                    if (baseURLObj !== undefined) {\n                        children.baseURLs.push(baseURLObj);\n                    }\n                    warnings = warnings.concat(baseURLWarnings);\n                    break;\n                }\n                case \"InbandEventStream\":\n                    if (children.inbandEventStreams === undefined) {\n                        children.inbandEventStreams = [];\n                    }\n                    children.inbandEventStreams.push(parseScheme(currentElement));\n                    break;\n                case \"SegmentBase\": {\n                    const [segmentBase, segmentBaseWarnings] = parseSegmentBase(currentElement);\n                    children.segmentBase = segmentBase;\n                    if (segmentBaseWarnings.length > 0) {\n                        warnings = warnings.concat(segmentBaseWarnings);\n                    }\n                    break;\n                }\n                case \"SegmentList\": {\n                    const [segmentList, segmentListWarnings] = parseSegmentList(currentElement);\n                    warnings = warnings.concat(segmentListWarnings);\n                    children.segmentList = segmentList;\n                    break;\n                }\n                case \"SegmentTemplate\": {\n                    const [segmentTemplate, segmentTemplateWarnings] = parseSegmentTemplate(currentElement);\n                    warnings = warnings.concat(segmentTemplateWarnings);\n                    children.segmentTemplate = segmentTemplate;\n                    break;\n                }\n                case \"ContentProtection\": {\n                    const [contentProtection, contentProtectionWarnings] = parseContentProtection(currentElement);\n                    if (contentProtectionWarnings.length > 0) {\n                        warnings = warnings.concat(contentProtectionWarnings);\n                    }\n                    if (contentProtection !== undefined) {\n                        contentProtections.push(contentProtection);\n                    }\n                    break;\n                }\n                case \"EssentialProperty\":\n                    if (isNullOrUndefined(children.essentialProperties)) {\n                        children.essentialProperties = [parseScheme(currentElement)];\n                    }\n                    else {\n                        children.essentialProperties.push(parseScheme(currentElement));\n                    }\n                    break;\n                case \"SupplementalProperty\":\n                    if (isNullOrUndefined(children.supplementalProperties)) {\n                        children.supplementalProperties = [parseScheme(currentElement)];\n                    }\n                    else {\n                        children.supplementalProperties.push(parseScheme(currentElement));\n                    }\n                    break;\n            }\n        }\n    }\n    if (contentProtections.length > 0) {\n        children.contentProtections = contentProtections;\n    }\n    return [children, warnings];\n}\n/**\n * @param {Element} representationElement\n * @returns {Array}\n */\nfunction parseRepresentationAttributes(representationElement) {\n    const attributes = {};\n    const warnings = [];\n    const parseValue = ValueParser(attributes, warnings);\n    for (let i = 0; i < representationElement.attributes.length; i++) {\n        const attr = representationElement.attributes[i];\n        switch (attr.name) {\n            case \"audioSamplingRate\":\n                attributes.audioSamplingRate = attr.value;\n                break;\n            case \"bandwidth\":\n                parseValue(attr.value, {\n                    asKey: \"bitrate\",\n                    parser: parseMPDInteger,\n                    dashName: \"bandwidth\",\n                });\n                break;\n            case \"codecs\":\n                attributes.codecs = attr.value;\n                break;\n            case \"codingDependency\":\n                parseValue(attr.value, {\n                    asKey: \"codingDependency\",\n                    parser: parseBoolean,\n                    dashName: \"codingDependency\",\n                });\n                break;\n            case \"frameRate\":\n                parseValue(attr.value, {\n                    asKey: \"frameRate\",\n                    parser: parseMaybeDividedNumber,\n                    dashName: \"frameRate\",\n                });\n                break;\n            case \"height\":\n                parseValue(attr.value, {\n                    asKey: \"height\",\n                    parser: parseMPDInteger,\n                    dashName: \"height\",\n                });\n                break;\n            case \"id\":\n                attributes.id = attr.value;\n                break;\n            case \"maxPlayoutRate\":\n                parseValue(attr.value, {\n                    asKey: \"maxPlayoutRate\",\n                    parser: parseMPDFloat,\n                    dashName: \"maxPlayoutRate\",\n                });\n                break;\n            case \"maximumSAPPeriod\":\n                parseValue(attr.value, {\n                    asKey: \"maximumSAPPeriod\",\n                    parser: parseMPDFloat,\n                    dashName: \"maximumSAPPeriod\",\n                });\n                break;\n            case \"mimeType\":\n                attributes.mimeType = attr.value;\n                break;\n            case \"profiles\":\n                attributes.profiles = attr.value;\n                break;\n            case \"qualityRanking\":\n                parseValue(attr.value, {\n                    asKey: \"qualityRanking\",\n                    parser: parseMPDInteger,\n                    dashName: \"qualityRanking\",\n                });\n                break;\n            case \"scte214:supplementalCodecs\":\n                attributes.supplementalCodecs = attr.value;\n                break;\n            case \"segmentProfiles\":\n                attributes.segmentProfiles = attr.value;\n                break;\n            case \"width\":\n                parseValue(attr.value, {\n                    asKey: \"width\",\n                    parser: parseMPDInteger,\n                    dashName: \"width\",\n                });\n                break;\n            case \"availabilityTimeOffset\":\n                parseValue(attr.value, {\n                    asKey: \"availabilityTimeOffset\",\n                    parser: parseMPDFloat,\n                    dashName: \"availabilityTimeOffset\",\n                });\n                break;\n            case \"availabilityTimeComplete\":\n                parseValue(attr.value, {\n                    asKey: \"availabilityTimeComplete\",\n                    parser: parseBoolean,\n                    dashName: \"availabilityTimeComplete\",\n                });\n                break;\n        }\n    }\n    if (attributes.bitrate === undefined) {\n        warnings.push(new MPDError(\"No bitrate found on a Representation\"));\n    }\n    return [attributes, warnings];\n}\n/**\n * @param {Element} representationElement\n * @returns {Array}\n */\nexport function createRepresentationIntermediateRepresentation(representationElement) {\n    const [children, childrenWarnings] = parseRepresentationChildren(representationElement.childNodes);\n    const [attributes, attrsWarnings] = parseRepresentationAttributes(representationElement);\n    const warnings = childrenWarnings.concat(attrsWarnings);\n    return [{ children, attributes }, warnings];\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport parseInitialization from \"./Initialization\";\nimport { parseBoolean, parseByteRange, parseMPDFloat, parseMPDInteger, ValueParser, } from \"./utils\";\n/**\n * Parse a SegmentBase element into a SegmentBase intermediate representation.\n * @param {Element} root - The SegmentBase root element.\n * @returns {Array}\n */\nexport default function parseSegmentBase(root) {\n    const attributes = {};\n    let warnings = [];\n    const parseValue = ValueParser(attributes, warnings);\n    const segmentBaseChildren = root.childNodes;\n    for (let i = 0; i < segmentBaseChildren.length; i++) {\n        if (segmentBaseChildren[i].nodeType === Node.ELEMENT_NODE) {\n            const currentNode = segmentBaseChildren[i];\n            if (currentNode.nodeName === \"Initialization\") {\n                const [initialization, initializationWarnings] = parseInitialization(currentNode);\n                attributes.initialization = initialization;\n                warnings = warnings.concat(initializationWarnings);\n            }\n        }\n    }\n    for (let i = 0; i < root.attributes.length; i++) {\n        const attr = root.attributes[i];\n        switch (attr.name) {\n            case \"timescale\":\n                parseValue(attr.value, {\n                    asKey: \"timescale\",\n                    parser: parseMPDInteger,\n                    dashName: \"timescale\",\n                });\n                break;\n            case \"presentationTimeOffset\":\n                parseValue(attr.value, {\n                    asKey: \"presentationTimeOffset\",\n                    parser: parseMPDFloat,\n                    dashName: \"presentationTimeOffset\",\n                });\n                break;\n            case \"indexRange\":\n                parseValue(attr.value, {\n                    asKey: \"indexRange\",\n                    parser: parseByteRange,\n                    dashName: \"indexRange\",\n                });\n                break;\n            case \"indexRangeExact\":\n                parseValue(attr.value, {\n                    asKey: \"indexRangeExact\",\n                    parser: parseBoolean,\n                    dashName: \"indexRangeExact\",\n                });\n                break;\n            case \"availabilityTimeOffset\":\n                parseValue(attr.value, {\n                    asKey: \"availabilityTimeOffset\",\n                    parser: parseMPDFloat,\n                    dashName: \"availabilityTimeOffset\",\n                });\n                break;\n            case \"availabilityTimeComplete\":\n                parseValue(attr.value, {\n                    asKey: \"availabilityTimeComplete\",\n                    parser: parseBoolean,\n                    dashName: \"availabilityTimeComplete\",\n                });\n                break;\n            case \"duration\":\n                parseValue(attr.value, {\n                    asKey: \"duration\",\n                    parser: parseMPDInteger,\n                    dashName: \"duration\",\n                });\n                break;\n            case \"startNumber\":\n                parseValue(attr.value, {\n                    asKey: \"startNumber\",\n                    parser: parseMPDInteger,\n                    dashName: \"startNumber\",\n                });\n                break;\n            case \"endNumber\":\n                parseValue(attr.value, {\n                    asKey: \"endNumber\",\n                    parser: parseMPDInteger,\n                    dashName: \"endNumber\",\n                });\n                break;\n        }\n    }\n    return [attributes, warnings];\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport objectAssign from \"../../../../../utils/object_assign\";\nimport parseSegmentBase from \"./SegmentBase\";\nimport parseSegmentURL from \"./SegmentURL\";\n/**\n * @param {Element} root\n * @returns {Array}\n */\nexport default function parseSegmentList(root) {\n    const [base, baseWarnings] = parseSegmentBase(root);\n    let warnings = baseWarnings;\n    const list = [];\n    const segmentListChildren = root.childNodes;\n    for (let i = 0; i < segmentListChildren.length; i++) {\n        if (segmentListChildren[i].nodeType === Node.ELEMENT_NODE) {\n            const currentNode = segmentListChildren[i];\n            if (currentNode.nodeName === \"SegmentURL\") {\n                const [segmentURL, segmentURLWarnings] = parseSegmentURL(currentNode);\n                list.push(segmentURL);\n                warnings = warnings.concat(segmentURLWarnings);\n            }\n        }\n    }\n    const ret = objectAssign(base, { list });\n    return [ret, warnings];\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport isNullOrUndefined from \"../../../../../utils/is_null_or_undefined\";\nimport objectAssign from \"../../../../../utils/object_assign\";\nimport parseSegmentBase from \"./SegmentBase\";\nimport createSegmentTimelineParser from \"./SegmentTimeline\";\nimport { parseBoolean, parseMPDFloat, ValueParser } from \"./utils\";\n/**\n * Parse a SegmentTemplate element into a SegmentTemplate intermediate\n * representation.\n * @param {Element} root - The SegmentTemplate root element.\n * @returns {Array}\n */\nexport default function parseSegmentTemplate(root) {\n    const [base, segmentBaseWarnings] = parseSegmentBase(root);\n    const warnings = segmentBaseWarnings;\n    let timelineParser;\n    // First look for a possible SegmentTimeline\n    for (let i = 0; i < root.childNodes.length; i++) {\n        if (root.childNodes[i].nodeType === Node.ELEMENT_NODE) {\n            const currentNode = root.childNodes[i];\n            if (currentNode.nodeName === \"SegmentTimeline\") {\n                timelineParser = createSegmentTimelineParser(currentNode);\n            }\n        }\n    }\n    const ret = objectAssign({}, base, {\n        duration: base.duration,\n        timelineParser,\n    });\n    const parseValue = ValueParser(ret, warnings);\n    for (let i = 0; i < root.attributes.length; i++) {\n        const attribute = root.attributes[i];\n        switch (attribute.nodeName) {\n            case \"initialization\":\n                if (isNullOrUndefined(ret.initialization)) {\n                    ret.initialization = { media: attribute.value };\n                }\n                break;\n            case \"index\":\n                ret.index = attribute.value;\n                break;\n            case \"availabilityTimeOffset\":\n                parseValue(attribute.value, {\n                    asKey: \"availabilityTimeOffset\",\n                    parser: parseMPDFloat,\n                    dashName: \"availabilityTimeOffset\",\n                });\n                break;\n            case \"availabilityTimeComplete\":\n                parseValue(attribute.value, {\n                    asKey: \"availabilityTimeComplete\",\n                    parser: parseBoolean,\n                    dashName: \"availabilityTimeComplete\",\n                });\n                break;\n            case \"media\":\n                ret.media = attribute.value;\n                break;\n            case \"bitstreamSwitching\":\n                parseValue(attribute.value, {\n                    asKey: \"bitstreamSwitching\",\n                    parser: parseBoolean,\n                    dashName: \"bitstreamSwitching\",\n                });\n                break;\n        }\n    }\n    return [ret, warnings];\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @param {Element} root\n * @returns {Function}\n */\nexport default function createSegmentTimelineParser(root) {\n    let result = null;\n    return function () {\n        if (result === null) {\n            const elements = root.getElementsByTagName(\"S\");\n            result = elements;\n            return elements;\n        }\n        return result;\n    };\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { parseByteRange, ValueParser } from \"./utils\";\n/**\n * Parse a SegmentURL element into a SegmentURL intermediate\n * representation.\n * @param {Element} root - The SegmentURL root element.\n * @returns {Array}\n */\nexport default function parseSegmentURL(root) {\n    const parsedSegmentURL = {};\n    const warnings = [];\n    const parseValue = ValueParser(parsedSegmentURL, warnings);\n    for (let i = 0; i < root.attributes.length; i++) {\n        const attribute = root.attributes[i];\n        switch (attribute.name) {\n            case \"media\":\n                parsedSegmentURL.media = attribute.value;\n                break;\n            case \"indexRange\":\n                parseValue(attribute.value, {\n                    asKey: \"indexRange\",\n                    parser: parseByteRange,\n                    dashName: \"indexRange\",\n                });\n                break;\n            case \"index\":\n                parsedSegmentURL.index = attribute.value;\n                break;\n            case \"mediaRange\":\n                parseValue(attribute.value, {\n                    asKey: \"mediaRange\",\n                    parser: parseByteRange,\n                    dashName: \"mediaRange\",\n                });\n                break;\n        }\n    }\n    return [parsedSegmentURL, warnings];\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// XML-Schema\n// <http://standards.iso.org/ittf/PubliclyAvailableStandards/MPEG-DASH_schema_files/DASH-MPD.xsd>\nimport log from \"../../../../../log\";\nimport { base64ToBytes } from \"../../../../../utils/base64\";\nimport isNonEmptyString from \"../../../../../utils/is_non_empty_string\";\nconst iso8601Duration = /^P(([\\d.]*)Y)?(([\\d.]*)M)?(([\\d.]*)D)?T?(([\\d.]*)H)?(([\\d.]*)M)?(([\\d.]*)S)?/;\nconst rangeRe = /([0-9]+)-([0-9]+)/;\n/**\n * Parse MPD boolean attributes.\n *\n * The returned value is a tuple of two elements where:\n *   1. the first value is the parsed boolean - or `null` if we could not parse\n *      it\n *   2. the second value is a possible error encountered while parsing this\n *      value - set to `null` if no error was encountered.\n * @param {string} val - The value to parse\n * @param {string} displayName - The name of the property. Used for error\n * formatting.\n * @returns {Array.<Boolean | Error | null>}\n */\nfunction parseBoolean(val, displayName) {\n    if (val === \"true\") {\n        return [true, null];\n    }\n    if (val === \"false\") {\n        return [false, null];\n    }\n    const error = new MPDError(`\\`${displayName}\\` property is not a boolean value but \"${val}\"`);\n    return [false, error];\n}\n/**\n * Parse MPD integer attributes.\n *\n * The returned value is a tuple of two elements where:\n *   1. the first value is the parsed boolean - or `null` if we could not parse\n *      it\n *   2. the second value is a possible error encountered while parsing this\n *      value - set to `null` if no error was encountered.\n * @param {string} val - The value to parse\n * @param {string} displayName - The name of the property. Used for error\n * formatting.\n * @returns {Array.<number | Error | null>}\n */\nfunction parseMPDInteger(val, displayName) {\n    const toInt = parseInt(val, 10);\n    if (isNaN(toInt)) {\n        const error = new MPDError(`\\`${displayName}\\` property is not an integer value but \"${val}\"`);\n        return [null, error];\n    }\n    return [toInt, null];\n}\n/**\n * Parse MPD float attributes.\n *\n * The returned value is a tuple of two elements where:\n *   1. the first value is the parsed boolean - or `null` if we could not parse\n *      it\n *   2. the second value is a possible error encountered while parsing this\n *      value - set to `null` if no error was encountered.\n * @param {string} val - The value to parse\n * @param {string} displayName - The name of the property. Used for error\n * formatting.\n * @returns {Array.<number | Error | null>}\n */\nfunction parseMPDFloat(val, displayName) {\n    if (val === \"INF\") {\n        return [Infinity, null];\n    }\n    const toInt = parseFloat(val);\n    if (isNaN(toInt)) {\n        const error = new MPDError(`\\`${displayName}\\` property is invalid: \"${val}\"`);\n        return [null, error];\n    }\n    return [toInt, null];\n}\n/**\n * Parse MPD attributes which are either integer or boolean values.\n *\n * The returned value is a tuple of two elements where:\n *   1. the first value is the parsed value - or `null` if we could not parse\n *      it\n *   2. the second value is a possible error encountered while parsing this\n *      value - set to `null` if no error was encountered.\n * @param {string} val - The value to parse\n * @param {string} displayName - The name of the property. Used for error\n * formatting.\n * @returns {Array.<Boolean | number | Error | null>}\n */\nfunction parseIntOrBoolean(val, displayName) {\n    if (val === \"true\") {\n        return [true, null];\n    }\n    if (val === \"false\") {\n        return [false, null];\n    }\n    const toInt = parseInt(val, 10);\n    if (isNaN(toInt)) {\n        const error = new MPDError(`\\`${displayName}\\` property is not a boolean nor an integer but \"${val}\"`);\n        return [null, error];\n    }\n    return [toInt, null];\n}\n/**\n * Parse MPD date attributes.\n *\n * The returned value is a tuple of two elements where:\n *   1. the first value is the parsed value - or `null` if we could not parse\n *      it\n *   2. the second value is a possible error encountered while parsing this\n *      value - set to `null` if no error was encountered.\n * @param {string} val - The value to parse\n * @param {string} displayName - The name of the property. Used for error\n * formatting.\n * @returns {Array.<Date | null | Error>}\n */\nfunction parseDateTime(val, displayName) {\n    const parsed = Date.parse(val);\n    if (isNaN(parsed)) {\n        const error = new MPDError(`\\`${displayName}\\` is in an invalid date format: \"${val}\"`);\n        return [null, error];\n    }\n    return [new Date(Date.parse(val)).getTime() / 1000, null];\n}\n/**\n * Parse MPD ISO8601 duration attributes into seconds.\n *\n * The returned value is a tuple of two elements where:\n *   1. the first value is the parsed value - or `null` if we could not parse\n *      it\n *   2. the second value is a possible error encountered while parsing this\n *      value - set to `null` if no error was encountered.\n * @param {string} val - The value to parse\n * @param {string} displayName - The name of the property. Used for error\n * formatting.\n * @returns {Array.<number | Error | null>}\n */\nfunction parseDuration(val, displayName) {\n    if (!isNonEmptyString(val)) {\n        const error = new MPDError(`\\`${displayName}\\` property is empty`);\n        return [0, error];\n    }\n    const match = iso8601Duration.exec(val);\n    if (match === null) {\n        const error = new MPDError(`\\`${displayName}\\` property has an unrecognized format \"${val}\"`);\n        return [null, error];\n    }\n    const duration = parseFloat(isNonEmptyString(match[2]) ? match[2] : \"0\") * 365 * 24 * 60 * 60 +\n        parseFloat(isNonEmptyString(match[4]) ? match[4] : \"0\") * 30 * 24 * 60 * 60 +\n        parseFloat(isNonEmptyString(match[6]) ? match[6] : \"0\") * 24 * 60 * 60 +\n        parseFloat(isNonEmptyString(match[8]) ? match[8] : \"0\") * 60 * 60 +\n        parseFloat(isNonEmptyString(match[10]) ? match[10] : \"0\") * 60 +\n        parseFloat(isNonEmptyString(match[12]) ? match[12] : \"0\");\n    return [duration, null];\n}\n/**\n * Parse MPD byterange attributes into arrays of two elements: the start and\n * the end.\n *\n * The returned value is a tuple of two elements where:\n *   1. the first value is the parsed value - or `null` if we could not parse\n *      it\n *   2. the second value is a possible error encountered while parsing this\n *      value - set to `null` if no error was encountered.\n * @param {string} val\n * @param {string} displayName\n * @returns {Array.<Array.<number> | Error | null>}\n */\nfunction parseByteRange(val, displayName) {\n    const match = rangeRe.exec(val);\n    if (match === null) {\n        const error = new MPDError(`\\`${displayName}\\` property has an unrecognized format \"${val}\"`);\n        return [null, error];\n    }\n    else {\n        return [[+match[1], +match[2]], null];\n    }\n}\n/**\n * Parse MPD base64 attribute into an Uint8Array.\n * the end.\n *\n * The returned value is a tuple of two elements where:\n *   1. the first value is the parsed value - or `null` if we could not parse\n *      it\n *   2. the second value is a possible error encountered while parsing this\n *      value - set to `null` if no error was encountered.\n * @param {string} val\n * @param {string} displayName\n * @returns {Uint8Array | Error | null>}\n */\nfunction parseBase64(val, displayName) {\n    try {\n        return [base64ToBytes(val), null];\n    }\n    catch (_) {\n        const error = new MPDError(`\\`${displayName}\\` is not a valid base64 string: \"${val}\"`);\n        return [null, error];\n    }\n}\n/**\n * Some values in the MPD can be expressed as divisions of integers (e.g. frame\n * rates).\n * This function tries to convert it to a floating point value.\n * @param {string} val\n * @param {string} displayName\n * @returns {Array.<number | Error | null>}\n */\nfunction parseMaybeDividedNumber(val, displayName) {\n    const matches = /^(\\d+)\\/(\\d+)$/.exec(val);\n    if (matches !== null) {\n        // No need to check, we know both are numbers\n        return [+matches[1] / +matches[2], null];\n    }\n    return parseMPDFloat(val, displayName);\n}\n/**\n * @param {Element} root\n * @returns {Object}\n */\nfunction parseScheme(root) {\n    let schemeIdUri;\n    let value;\n    for (let i = 0; i < root.attributes.length; i++) {\n        const attribute = root.attributes[i];\n        switch (attribute.name) {\n            case \"schemeIdUri\":\n                schemeIdUri = attribute.value;\n                break;\n            case \"value\":\n                value = attribute.value;\n                break;\n        }\n    }\n    return { schemeIdUri, value };\n}\n/**\n * Create a function to factorize the MPD parsing logic.\n * @param {Object} dest - The destination object which will contain the parsed\n * values.\n * @param {Array.<Error>} warnings - An array which will contain every parsing\n * error encountered.\n * @return {Function}\n */\nfunction ValueParser(dest, warnings) {\n    /**\n     * Parse a single value and add it to the `dest` objects.\n     * If an error arised while parsing, add it at the end of the `warnings` array.\n     * @param {string} objKey - The key which will be added to the `dest` object.\n     * @param {string} val - The value found in the MPD which we should parse.\n     * @param {Function} parsingFn - The parsing function adapted for this value.\n     * @param {string} displayName - The name of the key as it appears in the MPD.\n     * This is used only in error formatting,\n     */\n    return function (val, { asKey, parser, dashName, }) {\n        const [parsingResult, parsingError] = parser(val, dashName);\n        if (parsingError !== null) {\n            log.warn(parsingError.message);\n            warnings.push(parsingError);\n        }\n        if (parsingResult !== null) {\n            dest[asKey] = parsingResult;\n        }\n    };\n}\n/**\n * Error arising when parsing the MPD.\n * @class MPDError\n * @extends Error\n */\nclass MPDError extends Error {\n    /**\n     * @param {string} message\n     */\n    constructor(message) {\n        super(message);\n        // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class\n        Object.setPrototypeOf(this, MPDError.prototype);\n        this.name = \"MPDError\";\n    }\n}\nexport { MPDError, ValueParser, parseBase64, parseBoolean, parseByteRange, parseDateTime, parseDuration, parseIntOrBoolean, parseMaybeDividedNumber, parseMPDFloat, parseMPDInteger, parseScheme, };\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assertUnreachable } from \"../../../../utils/assert\";\nimport isNullOrUndefined from \"../../../../utils/is_null_or_undefined\";\nimport parseMpdIr from \"../common\";\nimport { createMPDIntermediateRepresentation } from \"./node_parsers/MPD\";\nimport { createPeriodIntermediateRepresentation } from \"./node_parsers/Period\";\n/**\n * Parse MPD through the JS parser, on a `Document` instance.\n * @param {Document} document - Original manifest as returned by the server\n * @param {Object} args - Various parsing options and information.\n * @returns {Object} - Response returned by the DASH-JS parser.\n */\nexport default function parseFromDocument(document, args) {\n    const root = document.documentElement;\n    if (isNullOrUndefined(root) || root.nodeName !== \"MPD\") {\n        throw new Error(\"DASH Parser: document root should be MPD\");\n    }\n    const [mpdIR, warnings] = createMPDIntermediateRepresentation(root);\n    const ret = parseMpdIr(mpdIR, args, warnings);\n    return processReturn(ret);\n    /**\n     * Handle `parseMpdIr` return values, asking for resources if they are needed\n     * and pre-processing them before continuing parsing.\n     *\n     * @param {Object} initialRes\n     * @returns {Object}\n     */\n    function processReturn(initialRes) {\n        if (initialRes.type === \"done\") {\n            return initialRes;\n        }\n        else if (initialRes.type === \"needs-clock\") {\n            return {\n                type: \"needs-resources\",\n                value: {\n                    urls: [initialRes.value.url],\n                    format: \"string\",\n                    continue(loadedClock) {\n                        if (loadedClock.length !== 1) {\n                            throw new Error(\"DASH parser: wrong number of loaded ressources.\");\n                        }\n                        const newRet = initialRes.value.continue(loadedClock[0].responseData);\n                        return processReturn(newRet);\n                    },\n                },\n            };\n        }\n        else if (initialRes.type === \"needs-xlinks\") {\n            return {\n                type: \"needs-resources\",\n                value: {\n                    urls: initialRes.value.xlinksUrls,\n                    format: \"string\",\n                    continue(loadedXlinks) {\n                        const resourceInfos = [];\n                        for (let i = 0; i < loadedXlinks.length; i++) {\n                            const { responseData: xlinkResp, receivedTime, sendingTime, url, } = loadedXlinks[i];\n                            if (!xlinkResp.success) {\n                                throw xlinkResp.error;\n                            }\n                            const wrappedData = \"<root>\" + xlinkResp.data + \"</root>\";\n                            const dataAsXML = new DOMParser().parseFromString(wrappedData, \"text/xml\");\n                            if (isNullOrUndefined(dataAsXML) || dataAsXML.children.length === 0) {\n                                throw new Error(\"DASH parser: Invalid external ressources\");\n                            }\n                            const periods = dataAsXML.children[0].children;\n                            const periodsIR = [];\n                            const periodsIRWarnings = [];\n                            for (let j = 0; j < periods.length; j++) {\n                                if (periods[j].nodeType === Node.ELEMENT_NODE) {\n                                    const [periodIR, periodWarnings] = createPeriodIntermediateRepresentation(periods[j]);\n                                    periodsIRWarnings.push(...periodWarnings);\n                                    periodsIR.push(periodIR);\n                                }\n                            }\n                            resourceInfos.push({\n                                url,\n                                receivedTime,\n                                sendingTime,\n                                parsed: periodsIR,\n                                warnings: periodsIRWarnings,\n                            });\n                        }\n                        const newRet = initialRes.value.continue(resourceInfos);\n                        return processReturn(newRet);\n                    },\n                },\n            };\n        }\n        else {\n            assertUnreachable(initialRes);\n        }\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../../log\";\nimport { SUPPORTED_ADAPTATIONS_TYPE } from \"../../../manifest\";\nimport arrayIncludes from \"../../../utils/array_includes\";\nimport assert from \"../../../utils/assert\";\nimport { concat, itobe4 } from \"../../../utils/byte_parsing\";\nimport isNonEmptyString from \"../../../utils/is_non_empty_string\";\nimport isNullOrUndefined from \"../../../utils/is_null_or_undefined\";\nimport getMonotonicTimeStamp from \"../../../utils/monotonic_timestamp\";\nimport objectAssign from \"../../../utils/object_assign\";\nimport { hexToBytes } from \"../../../utils/string_parsing\";\nimport { getFilenameIndexInUrl } from \"../../../utils/url-utils\";\nimport { createBox } from \"../../containers/isobmff\";\nimport checkManifestIDs from \"../utils/check_manifest_ids\";\nimport { getAudioCodecs, getVideoCodecs } from \"./get_codecs\";\nimport parseCNodes from \"./parse_C_nodes\";\nimport parseProtectionNode from \"./parse_protection_node\";\nimport RepresentationIndex from \"./representation_index\";\nimport SharedSmoothSegmentTimeline from \"./shared_smooth_segment_timeline\";\nimport parseBoolean from \"./utils/parseBoolean\";\nimport reduceChildren from \"./utils/reduceChildren\";\nimport { replaceRepresentationSmoothTokens } from \"./utils/tokens\";\nconst DEFAULT_MIME_TYPES = {\n    audio: \"audio/mp4\",\n    video: \"video/mp4\",\n    text: \"application/ttml+xml\",\n};\nconst MIME_TYPES = {\n    AACL: \"audio/mp4\",\n    AVC1: \"video/mp4\",\n    H264: \"video/mp4\",\n    TTML: \"application/ttml+xml+mp4\",\n    DFXP: \"application/ttml+xml+mp4\",\n};\n/**\n * @param {Object|undefined} parserOptions\n * @returns {Function}\n */\nfunction createSmoothStreamingParser(parserOptions = {}) {\n    const referenceDateTime = parserOptions.referenceDateTime === undefined\n        ? Date.UTC(1970, 0, 1, 0, 0, 0, 0) / 1000\n        : parserOptions.referenceDateTime;\n    const minRepresentationBitrate = parserOptions.minRepresentationBitrate === undefined\n        ? 0\n        : parserOptions.minRepresentationBitrate;\n    const { serverSyncInfos } = parserOptions;\n    const serverTimeOffset = serverSyncInfos !== undefined\n        ? serverSyncInfos.serverTimestamp - serverSyncInfos.clientTime\n        : undefined;\n    /**\n     * @param {Element} q\n     * @param {string} streamType\n     * @return {Object}\n     */\n    function parseQualityLevel(q, streamType) {\n        const customAttributes = reduceChildren(q, (acc, qName, qNode) => {\n            if (qName === \"CustomAttributes\") {\n                acc.push(...reduceChildren(qNode, (cAttrs, cName, cNode) => {\n                    if (cName === \"Attribute\") {\n                        const name = cNode.getAttribute(\"Name\");\n                        const value = cNode.getAttribute(\"Value\");\n                        if (name !== null && value !== null) {\n                            cAttrs.push(name + \"=\" + value);\n                        }\n                    }\n                    return cAttrs;\n                }, []));\n            }\n            return acc;\n        }, []);\n        /**\n         * @param {string} name\n         * @returns {string|undefined}\n         */\n        function getAttribute(name) {\n            const attr = q.getAttribute(name);\n            return attr === null ? undefined : attr;\n        }\n        switch (streamType) {\n            case \"audio\": {\n                const audiotag = getAttribute(\"AudioTag\");\n                const bitsPerSample = getAttribute(\"BitsPerSample\");\n                const channels = getAttribute(\"Channels\");\n                const codecPrivateData = getAttribute(\"CodecPrivateData\");\n                const fourCC = getAttribute(\"FourCC\");\n                const packetSize = getAttribute(\"PacketSize\");\n                const samplingRate = getAttribute(\"SamplingRate\");\n                const bitrateAttr = getAttribute(\"Bitrate\");\n                let bitrate = bitrateAttr === undefined ? 0 : parseInt(bitrateAttr, 10);\n                bitrate = isNaN(bitrate) ? 0 : bitrate;\n                if ((fourCC !== undefined && MIME_TYPES[fourCC] === undefined) ||\n                    codecPrivateData === undefined) {\n                    log.warn(\"Smooth parser: Unsupported audio codec. Ignoring quality level.\");\n                    return null;\n                }\n                const codecs = getAudioCodecs(codecPrivateData, fourCC);\n                return {\n                    audiotag: audiotag !== undefined ? parseInt(audiotag, 10) : audiotag,\n                    bitrate,\n                    bitsPerSample: bitsPerSample !== undefined ? parseInt(bitsPerSample, 10) : bitsPerSample,\n                    channels: channels !== undefined ? parseInt(channels, 10) : channels,\n                    codecPrivateData,\n                    codecs,\n                    customAttributes,\n                    mimeType: fourCC !== undefined ? MIME_TYPES[fourCC] : fourCC,\n                    packetSize: packetSize !== undefined ? parseInt(packetSize, 10) : packetSize,\n                    samplingRate: samplingRate !== undefined ? parseInt(samplingRate, 10) : samplingRate,\n                };\n            }\n            case \"video\": {\n                const codecPrivateData = getAttribute(\"CodecPrivateData\");\n                const fourCC = getAttribute(\"FourCC\");\n                const width = getAttribute(\"MaxWidth\");\n                const height = getAttribute(\"MaxHeight\");\n                const bitrateAttr = getAttribute(\"Bitrate\");\n                let bitrate = bitrateAttr === undefined ? 0 : parseInt(bitrateAttr, 10);\n                bitrate = isNaN(bitrate) ? 0 : bitrate;\n                if ((fourCC !== undefined && MIME_TYPES[fourCC] === undefined) ||\n                    codecPrivateData === undefined) {\n                    log.warn(\"Smooth parser: Unsupported video codec. Ignoring quality level.\");\n                    return null;\n                }\n                const codecs = getVideoCodecs(codecPrivateData);\n                return {\n                    bitrate,\n                    customAttributes,\n                    mimeType: fourCC !== undefined ? MIME_TYPES[fourCC] : fourCC,\n                    codecPrivateData,\n                    codecs,\n                    width: width !== undefined ? parseInt(width, 10) : undefined,\n                    height: height !== undefined ? parseInt(height, 10) : undefined,\n                };\n            }\n            case \"text\": {\n                const codecPrivateData = getAttribute(\"CodecPrivateData\");\n                const fourCC = getAttribute(\"FourCC\");\n                const bitrateAttr = getAttribute(\"Bitrate\");\n                let bitrate = bitrateAttr === undefined ? 0 : parseInt(bitrateAttr, 10);\n                bitrate = isNaN(bitrate) ? 0 : bitrate;\n                return {\n                    bitrate,\n                    customAttributes,\n                    mimeType: fourCC !== undefined ? MIME_TYPES[fourCC] : fourCC,\n                    codecPrivateData: codecPrivateData !== null && codecPrivateData !== void 0 ? codecPrivateData : \"\",\n                };\n            }\n            default:\n                log.error(\"Smooth Parser: Unrecognized StreamIndex type: \" + streamType);\n                return null;\n        }\n    }\n    /**\n     * Parse the adaptations (<StreamIndex>) tree containing\n     * representations (<QualityLevels>) and timestamp indexes (<c>).\n     * Indexes can be quite huge, and this function needs to\n     * to be optimized.\n     * @param {Object} args\n     * @returns {Object}\n     */\n    function parseAdaptation(args) {\n        const { root, timescale, baseUrl, protections, timeShiftBufferDepth, manifestReceivedTime, isLive, } = args;\n        const timescaleAttr = root.getAttribute(\"Timescale\");\n        let _timescale = timescaleAttr === null ? timescale : +timescaleAttr;\n        if (isNaN(_timescale)) {\n            _timescale = timescale;\n        }\n        const typeAttribute = root.getAttribute(\"Type\");\n        if (typeAttribute === null) {\n            throw new Error(\"StreamIndex without type.\");\n        }\n        if (!arrayIncludes(SUPPORTED_ADAPTATIONS_TYPE, typeAttribute)) {\n            log.warn(\"Smooth Parser: Unrecognized adaptation type:\", typeAttribute);\n        }\n        const adaptationType = typeAttribute;\n        const subType = root.getAttribute(\"Subtype\");\n        const language = root.getAttribute(\"Language\");\n        const UrlAttr = root.getAttribute(\"Url\");\n        const UrlPathWithTokens = UrlAttr === null ? \"\" : UrlAttr;\n        if (0 /* __ENVIRONMENT__.CURRENT_ENV */ === 1 /* __ENVIRONMENT__.DEV */) {\n            assert(UrlPathWithTokens !== \"\");\n        }\n        const { qualityLevels, cNodes } = reduceChildren(root, (res, _name, node) => {\n            switch (_name) {\n                case \"QualityLevel\": {\n                    const qualityLevel = parseQualityLevel(node, adaptationType);\n                    if (qualityLevel === null) {\n                        return res;\n                    }\n                    // filter out video qualityLevels with small bitrates\n                    if (adaptationType !== \"video\" ||\n                        qualityLevel.bitrate > minRepresentationBitrate) {\n                        res.qualityLevels.push(qualityLevel);\n                    }\n                    break;\n                }\n                case \"c\":\n                    res.cNodes.push(node);\n                    break;\n            }\n            return res;\n        }, { qualityLevels: [], cNodes: [] });\n        const sharedSmoothTimeline = new SharedSmoothSegmentTimeline({\n            timeline: parseCNodes(cNodes),\n            timescale: _timescale,\n            timeShiftBufferDepth,\n            manifestReceivedTime,\n        });\n        // we assume that all qualityLevels have the same\n        // codec and mimeType\n        assert(qualityLevels.length !== 0, \"Adaptation should have at least one playable representation.\");\n        const adaptationID = adaptationType + (isNonEmptyString(language) ? \"_\" + language : \"\");\n        const representations = qualityLevels.map((qualityLevel) => {\n            const media = replaceRepresentationSmoothTokens(UrlPathWithTokens, qualityLevel.bitrate, qualityLevel.customAttributes);\n            const mimeType = isNonEmptyString(qualityLevel.mimeType)\n                ? qualityLevel.mimeType\n                : DEFAULT_MIME_TYPES[adaptationType];\n            const codecs = qualityLevel.codecs;\n            const id = adaptationID +\n                \"_\" +\n                (!isNullOrUndefined(adaptationType) ? adaptationType + \"-\" : \"\") +\n                (!isNullOrUndefined(mimeType) ? mimeType + \"-\" : \"\") +\n                (!isNullOrUndefined(codecs) ? codecs + \"-\" : \"\") +\n                String(qualityLevel.bitrate);\n            const keyIDs = [];\n            let firstProtection;\n            if (protections.length > 0) {\n                firstProtection = protections[0];\n                protections.forEach((protection) => {\n                    keyIDs.push(protection.keyId);\n                });\n            }\n            const segmentPrivateInfos = {\n                bitsPerSample: qualityLevel.bitsPerSample,\n                channels: qualityLevel.channels,\n                codecPrivateData: qualityLevel.codecPrivateData,\n                packetSize: qualityLevel.packetSize,\n                samplingRate: qualityLevel.samplingRate,\n                height: qualityLevel.height,\n                width: qualityLevel.width,\n                // TODO set multiple protections here\n                // instead of the first one\n                protection: !isNullOrUndefined(firstProtection)\n                    ? {\n                        keyId: firstProtection.keyId,\n                    }\n                    : undefined,\n            };\n            const reprIndex = new RepresentationIndex({\n                isLive,\n                sharedSmoothTimeline,\n                media,\n                segmentPrivateInfos,\n            });\n            const representation = objectAssign({}, qualityLevel, {\n                index: reprIndex,\n                cdnMetadata: [{ baseUrl }],\n                mimeType,\n                codecs,\n                id,\n            });\n            if (keyIDs.length > 0 || firstProtection !== undefined) {\n                const initDataValues = firstProtection === undefined\n                    ? []\n                    : firstProtection.keySystems.map((keySystemData) => {\n                        const { systemId, privateData } = keySystemData;\n                        const cleanedSystemId = systemId.replace(/-/g, \"\");\n                        const pssh = createPSSHBox(cleanedSystemId, privateData);\n                        return { systemId: cleanedSystemId, data: pssh };\n                    });\n                if (initDataValues.length > 0) {\n                    const initData = [{ type: \"cenc\", values: initDataValues }];\n                    representation.contentProtections = { keyIds: keyIDs, initData };\n                }\n                else {\n                    representation.contentProtections = { keyIds: keyIDs, initData: [] };\n                }\n            }\n            return representation;\n        });\n        // TODO(pierre): real ad-insert support\n        if (subType === \"ADVT\") {\n            return null;\n        }\n        const parsedAdaptation = {\n            id: adaptationID,\n            type: adaptationType,\n            representations,\n            language: language === null ? undefined : language,\n        };\n        if (adaptationType === \"text\" && subType === \"DESC\") {\n            parsedAdaptation.closedCaption = true;\n        }\n        return parsedAdaptation;\n    }\n    function parseFromDocument(doc, url, manifestReceivedTime) {\n        let baseUrl = \"\";\n        if (url !== undefined) {\n            const filenameIdx = getFilenameIndexInUrl(url);\n            baseUrl = url.substring(0, filenameIdx);\n        }\n        const root = doc.documentElement;\n        if (isNullOrUndefined(root) || root.nodeName !== \"SmoothStreamingMedia\") {\n            throw new Error(\"document root should be SmoothStreamingMedia\");\n        }\n        const majorVersionAttr = root.getAttribute(\"MajorVersion\");\n        const minorVersionAttr = root.getAttribute(\"MinorVersion\");\n        if (majorVersionAttr === null ||\n            minorVersionAttr === null ||\n            !/^[2]-[0-2]$/.test(majorVersionAttr + \"-\" + minorVersionAttr)) {\n            throw new Error(\"Version should be 2.0, 2.1 or 2.2\");\n        }\n        const timescaleAttr = root.getAttribute(\"Timescale\");\n        let timescale = !isNonEmptyString(timescaleAttr) ? 10000000 : +timescaleAttr;\n        if (isNaN(timescale)) {\n            timescale = 10000000;\n        }\n        const { protections, adaptationNodes } = reduceChildren(root, (res, name, node) => {\n            switch (name) {\n                case \"Protection\": {\n                    res.protections.push(parseProtectionNode(node, parserOptions.keySystems));\n                    break;\n                }\n                case \"StreamIndex\":\n                    res.adaptationNodes.push(node);\n                    break;\n            }\n            return res;\n        }, {\n            adaptationNodes: [],\n            protections: [],\n        });\n        const initialAdaptations = {};\n        const isLive = parseBoolean(root.getAttribute(\"IsLive\"));\n        let timeShiftBufferDepth;\n        if (isLive) {\n            const dvrWindowLength = root.getAttribute(\"DVRWindowLength\");\n            if (dvrWindowLength !== null &&\n                !isNaN(+dvrWindowLength) &&\n                +dvrWindowLength !== 0) {\n                timeShiftBufferDepth = +dvrWindowLength / timescale;\n            }\n        }\n        const adaptations = adaptationNodes.reduce((acc, node) => {\n            const adaptation = parseAdaptation({\n                root: node,\n                baseUrl,\n                timescale,\n                protections,\n                isLive,\n                timeShiftBufferDepth,\n                manifestReceivedTime,\n            });\n            if (adaptation === null) {\n                return acc;\n            }\n            const type = adaptation.type;\n            const adaps = acc[type];\n            if (adaps === undefined) {\n                acc[type] = [adaptation];\n            }\n            else {\n                adaps.push(adaptation);\n            }\n            return acc;\n        }, initialAdaptations);\n        let suggestedPresentationDelay;\n        let availabilityStartTime;\n        let minimumTime;\n        let timeshiftDepth = null;\n        let maximumTimeData;\n        const firstVideoAdaptation = adaptations.video !== undefined ? adaptations.video[0] : undefined;\n        const firstAudioAdaptation = adaptations.audio !== undefined ? adaptations.audio[0] : undefined;\n        /** Minimum time that can be reached regardless of the StreamIndex chosen. */\n        let safeMinimumTime;\n        /** Maximum time that can be reached regardless of the StreamIndex chosen. */\n        let safeMaximumTime;\n        /** Maximum time that can be reached in absolute on the content. */\n        let unsafeMaximumTime;\n        if (firstVideoAdaptation !== undefined || firstAudioAdaptation !== undefined) {\n            const firstTimeReferences = [];\n            const lastTimeReferences = [];\n            if (firstVideoAdaptation !== undefined) {\n                const firstVideoRepresentation = firstVideoAdaptation.representations[0];\n                if (firstVideoRepresentation !== undefined) {\n                    const firstVideoTimeReference = firstVideoRepresentation.index.getFirstAvailablePosition();\n                    const lastVideoTimeReference = firstVideoRepresentation.index.getLastAvailablePosition();\n                    if (!isNullOrUndefined(firstVideoTimeReference)) {\n                        firstTimeReferences.push(firstVideoTimeReference);\n                    }\n                    if (!isNullOrUndefined(lastVideoTimeReference)) {\n                        lastTimeReferences.push(lastVideoTimeReference);\n                    }\n                }\n            }\n            if (firstAudioAdaptation !== undefined) {\n                const firstAudioRepresentation = firstAudioAdaptation.representations[0];\n                if (firstAudioRepresentation !== undefined) {\n                    const firstAudioTimeReference = firstAudioRepresentation.index.getFirstAvailablePosition();\n                    const lastAudioTimeReference = firstAudioRepresentation.index.getLastAvailablePosition();\n                    if (!isNullOrUndefined(firstAudioTimeReference)) {\n                        firstTimeReferences.push(firstAudioTimeReference);\n                    }\n                    if (!isNullOrUndefined(lastAudioTimeReference)) {\n                        lastTimeReferences.push(lastAudioTimeReference);\n                    }\n                }\n            }\n            if (firstTimeReferences.length > 0) {\n                safeMinimumTime = Math.max(...firstTimeReferences);\n            }\n            if (lastTimeReferences.length > 0) {\n                safeMaximumTime = Math.min(...lastTimeReferences);\n                unsafeMaximumTime = Math.max(...lastTimeReferences);\n            }\n        }\n        const manifestDuration = root.getAttribute(\"Duration\");\n        const duration = manifestDuration !== null && +manifestDuration !== 0\n            ? +manifestDuration / timescale\n            : undefined;\n        if (isLive) {\n            suggestedPresentationDelay = parserOptions.suggestedPresentationDelay;\n            availabilityStartTime = referenceDateTime;\n            minimumTime = safeMinimumTime !== null && safeMinimumTime !== void 0 ? safeMinimumTime : availabilityStartTime;\n            let livePosition = unsafeMaximumTime;\n            if (livePosition === undefined) {\n                livePosition = Date.now() / 1000 - availabilityStartTime;\n            }\n            let maximumSafePosition = safeMaximumTime;\n            if (maximumSafePosition === undefined) {\n                maximumSafePosition = livePosition;\n            }\n            maximumTimeData = {\n                isLinear: true,\n                maximumSafePosition,\n                livePosition,\n                time: getMonotonicTimeStamp(),\n            };\n            timeshiftDepth = timeShiftBufferDepth !== null && timeShiftBufferDepth !== void 0 ? timeShiftBufferDepth : null;\n        }\n        else {\n            minimumTime = safeMinimumTime !== null && safeMinimumTime !== void 0 ? safeMinimumTime : 0;\n            let maximumTime = safeMaximumTime;\n            if (maximumTime === undefined) {\n                maximumTime = duration !== undefined ? minimumTime + duration : Infinity;\n            }\n            maximumTimeData = {\n                isLinear: false,\n                maximumSafePosition: maximumTime,\n                livePosition: undefined,\n                time: getMonotonicTimeStamp(),\n            };\n        }\n        const periodStart = isLive ? 0 : minimumTime;\n        const periodEnd = isLive ? undefined : maximumTimeData.maximumSafePosition;\n        const manifest = {\n            availabilityStartTime: availabilityStartTime === undefined ? 0 : availabilityStartTime,\n            clockOffset: serverTimeOffset,\n            isLive,\n            isDynamic: isLive,\n            isLastPeriodKnown: true,\n            timeBounds: {\n                minimumSafePosition: minimumTime,\n                timeshiftDepth,\n                maximumTimeData,\n            },\n            periods: [\n                {\n                    adaptations,\n                    duration: periodEnd !== undefined ? periodEnd - periodStart : duration,\n                    end: periodEnd,\n                    id: \"gen-smooth-period-0\",\n                    start: periodStart,\n                    thumbnailTracks: [],\n                },\n            ],\n            suggestedPresentationDelay,\n            transportType: \"smooth\",\n            uris: isNullOrUndefined(url) ? [] : [url],\n        };\n        checkManifestIDs(manifest);\n        return manifest;\n    }\n    return parseFromDocument;\n}\n/**\n * @param {string} systemId - Hex string representing the CDM, 16 bytes.\n * @param {Uint8Array|undefined} privateData - Data associated to protection\n * specific system.\n * @returns {Uint8Array}\n */\nfunction createPSSHBox(systemId, privateData) {\n    if (systemId.length !== 32) {\n        throw new Error(\"HSS: wrong system id length\");\n    }\n    const version = 0;\n    return createBox(\"pssh\", concat([version, 0, 0, 0], hexToBytes(systemId), \n    /** To put there KIDs if it exists (necessitate PSSH v1) */\n    itobe4(privateData.length), privateData));\n}\nexport default createSmoothStreamingParser;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport isNonEmptyString from \"../../../utils/is_non_empty_string\";\n/**\n * @param {string} codecPrivateData\n * @param {string|undefined} fourCC\n * @returns {string}\n */\nexport function getAudioCodecs(codecPrivateData, fourCC) {\n    let mpProfile;\n    if (fourCC === \"AACH\") {\n        mpProfile = 5; // High Efficiency AAC Profile\n    }\n    else {\n        mpProfile = isNonEmptyString(codecPrivateData)\n            ? (parseInt(codecPrivateData.substring(0, 2), 16) & 0xf8) >> 3\n            : 2;\n    }\n    if (mpProfile === 0) {\n        // Return default audio codec\n        return \"mp4a.40.2\";\n    }\n    return `mp4a.40.${mpProfile}`;\n}\n/**\n * @param {string} codecPrivateData\n * @returns {string}\n */\nexport function getVideoCodecs(codecPrivateData) {\n    // we can extract codes only if fourCC is on of \"H264\", \"X264\", \"DAVC\", \"AVC1\"\n    const arr = /00000001\\d7([0-9a-fA-F]{6})/.exec(codecPrivateData);\n    if (arr === null || !isNonEmptyString(arr[1])) {\n        // Return default video codec\n        return \"avc1.4D401E\";\n    }\n    return \"avc1.\" + arr[1];\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport createSmoothStreamingParser from \"./create_parser\";\nimport SmoothRepresentationIndex from \"./representation_index\";\nexport default createSmoothStreamingParser;\nexport { SmoothRepresentationIndex };\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport isNonEmptyString from \"../../../utils/is_non_empty_string\";\n/**\n * Parse C nodes to build index timeline.\n * @param {Element} nodes\n */\nexport default function parseCNodes(nodes) {\n    return nodes.reduce((timeline, node, i) => {\n        const dAttr = node.getAttribute(\"d\");\n        const tAttr = node.getAttribute(\"t\");\n        const rAttr = node.getAttribute(\"r\");\n        const repeatCount = rAttr !== null ? +rAttr - 1 : 0;\n        let start = tAttr !== null ? +tAttr : undefined;\n        let duration = dAttr !== null ? +dAttr : undefined;\n        if (i === 0) {\n            // first node\n            start = start === undefined || isNaN(start) ? 0 : start;\n        }\n        else {\n            // from second node to the end\n            const prev = timeline[i - 1];\n            if (start === undefined || isNaN(start)) {\n                if (prev.duration === undefined || isNaN(prev.duration)) {\n                    throw new Error(\"Smooth: Invalid CNodes. Missing timestamp.\");\n                }\n                start = prev.start + prev.duration * (prev.repeatCount + 1);\n            }\n        }\n        if (duration === undefined || isNaN(duration)) {\n            const nextNode = nodes[i + 1];\n            if (nextNode !== undefined) {\n                const nextTAttr = nextNode.getAttribute(\"t\");\n                const nextStart = isNonEmptyString(nextTAttr) ? +nextTAttr : null;\n                if (nextStart === null) {\n                    throw new Error(\"Can't build index timeline from Smooth Manifest.\");\n                }\n                duration = nextStart - start;\n            }\n            else {\n                return timeline;\n            }\n        }\n        timeline.push({ duration, start, repeatCount });\n        return timeline;\n    }, []);\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { base64ToBytes } from \"../../../utils/base64\";\nimport { concat } from \"../../../utils/byte_parsing\";\nimport { hexToBytes } from \"../../../utils/string_parsing\";\nimport { getPlayReadyKIDFromPrivateData } from \"../../containers/isobmff\";\n/**\n * @param {Uint8Array} keyIdBytes\n * @returns {Array.<Object>}\n */\nfunction createWidevineKeySystem(keyIdBytes) {\n    return [\n        {\n            systemId: \"edef8ba9-79d6-4ace-a3c8-27dcd51d21ed\", // Widevine\n            privateData: concat([0x08, 0x01, 0x12, 0x10], keyIdBytes),\n        },\n    ];\n}\n/**\n * Parse \"Protection\" Node, which contains DRM information\n * @param {Element} protectionNode\n * @returns {Object}\n */\nexport default function parseProtectionNode(protectionNode, keySystemCreator = createWidevineKeySystem) {\n    if (protectionNode.firstElementChild === null ||\n        protectionNode.firstElementChild.nodeName !== \"ProtectionHeader\") {\n        throw new Error(\"Protection should have ProtectionHeader child\");\n    }\n    const header = protectionNode.firstElementChild;\n    const privateData = base64ToBytes(header.textContent === null ? \"\" : header.textContent);\n    const keyIdHex = getPlayReadyKIDFromPrivateData(privateData);\n    const keyIdBytes = hexToBytes(keyIdHex);\n    // remove possible braces\n    const systemIdAttr = header.getAttribute(\"SystemID\");\n    const systemId = (systemIdAttr !== null ? systemIdAttr : \"\")\n        .toLowerCase()\n        .replace(/\\{|\\}/g, \"\");\n    return {\n        keyId: keyIdBytes,\n        keySystems: [\n            {\n                systemId,\n                privateData,\n                /* keyIds: [keyIdBytes], */\n            },\n        ].concat(keySystemCreator(keyIdBytes)),\n    };\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { NetworkError } from \"../../../errors\";\nimport log from \"../../../log\";\nimport assert from \"../../../utils/assert\";\nimport getMonotonicTimeStamp from \"../../../utils/monotonic_timestamp\";\nimport { checkDiscontinuity, getIndexSegmentEnd } from \"../utils/index_helpers\";\nimport { replaceSegmentSmoothTokens } from \"./utils/tokens\";\n/**\n * @param {Number} start\n * @param {Number} up\n * @param {Number} duration\n * @returns {Number}\n */\nfunction getSegmentNumber(start, up, duration) {\n    const diff = up - start;\n    return diff > 0 ? Math.floor(diff / duration) : 0;\n}\n/**\n * Convert second-based start time and duration to the timescale of the\n * manifest's index.\n * @param {Object} index\n * @param {Number} start\n * @param {Number} duration\n * @returns {Object} - Object with two properties:\n *   - up {Number}: timescaled timestamp of the beginning time\n *   - to {Number}: timescaled timestamp of the end time (start time + duration)\n */\nfunction normalizeRange(timescale, start, duration) {\n    const ts = timescale === undefined || timescale === 0 ? 1 : timescale;\n    return { up: start * ts, to: (start + duration) * ts };\n}\n/**\n * Calculate the number of times a segment repeat based on the next segment.\n * @param {Object} segment\n * @param {Object} nextSegment\n * @returns {Number}\n */\nfunction calculateRepeat(segment, nextSegment) {\n    let repeatCount = segment.repeatCount;\n    // A negative value of the @r attribute of the S element indicates\n    // that the duration indicated in @d attribute repeats until the\n    // start of the next S element, the end of the Period or until the\n    // next MPD update.\n    // TODO Also for SMOOTH????\n    if (segment.duration !== undefined && repeatCount < 0) {\n        const repeatEnd = nextSegment !== undefined ? nextSegment.start : Infinity;\n        repeatCount = Math.ceil((repeatEnd - segment.start) / segment.duration) - 1;\n    }\n    return repeatCount;\n}\n/**\n * RepresentationIndex implementation for Smooth Manifests.\n *\n * Allows to interact with the index to create new Segments.\n *\n * @class SmoothRepresentationIndex\n */\nexport default class SmoothRepresentationIndex {\n    /**\n     * Creates a new `SmoothRepresentationIndex`.\n     * @param {Object} index\n     * @param {Object} options\n     */\n    constructor(options) {\n        const { isLive, segmentPrivateInfos, media, sharedSmoothTimeline } = options;\n        this._sharedSmoothTimeline = sharedSmoothTimeline;\n        this._initSegmentInfos = {\n            bitsPerSample: segmentPrivateInfos.bitsPerSample,\n            channels: segmentPrivateInfos.channels,\n            codecPrivateData: segmentPrivateInfos.codecPrivateData,\n            packetSize: segmentPrivateInfos.packetSize,\n            samplingRate: segmentPrivateInfos.samplingRate,\n            timescale: sharedSmoothTimeline.timescale,\n            height: segmentPrivateInfos.height,\n            width: segmentPrivateInfos.width,\n            protection: segmentPrivateInfos.protection,\n        };\n        this._isLive = isLive;\n        this._media = media;\n        if (sharedSmoothTimeline.timeline.length !== 0 && isLive) {\n            const { timeline, validityTime } = sharedSmoothTimeline;\n            const lastItem = timeline[timeline.length - 1];\n            const scaledEnd = getIndexSegmentEnd(lastItem, null);\n            const scaledTimelineValidityTime = (validityTime / 1000) * sharedSmoothTimeline.timescale;\n            this._scaledLiveGap = scaledTimelineValidityTime - scaledEnd;\n        }\n    }\n    /**\n     * Construct init Segment compatible with a Smooth Manifest.\n     * @returns {Object}\n     */\n    getInitSegment() {\n        return {\n            id: \"init\",\n            isInit: true,\n            privateInfos: { smoothInitSegment: this._initSegmentInfos },\n            url: null,\n            time: 0,\n            end: 0,\n            duration: 0,\n            timescale: 1,\n            complete: true,\n        };\n    }\n    /**\n     * Generate a list of Segments for a particular period of time.\n     *\n     * @param {Number} from\n     * @param {Number} dur\n     * @returns {Array.<Object>}\n     */\n    getSegments(from, dur) {\n        this._refreshTimeline();\n        const { timescale, timeline } = this._sharedSmoothTimeline;\n        const { up, to } = normalizeRange(timescale, from, dur);\n        const media = this._media;\n        let currentNumber;\n        const segments = [];\n        const timelineLength = timeline.length;\n        const maxPosition = this._scaledLiveGap === undefined\n            ? undefined\n            : (getMonotonicTimeStamp() / 1000) * timescale - this._scaledLiveGap;\n        for (let i = 0; i < timelineLength; i++) {\n            const segmentRange = timeline[i];\n            const { duration, start } = segmentRange;\n            const repeat = calculateRepeat(segmentRange, timeline[i + 1]);\n            let segmentNumberInCurrentRange = getSegmentNumber(start, up, duration);\n            let segmentTime = start + segmentNumberInCurrentRange * duration;\n            const timeToAddToCheckMaxPosition = duration;\n            while (segmentTime < to &&\n                segmentNumberInCurrentRange <= repeat &&\n                (maxPosition === undefined ||\n                    segmentTime + timeToAddToCheckMaxPosition <= maxPosition)) {\n                const time = segmentTime;\n                const number = currentNumber !== undefined\n                    ? currentNumber + segmentNumberInCurrentRange\n                    : undefined;\n                const segment = {\n                    id: String(segmentTime),\n                    isInit: false,\n                    time: time / timescale,\n                    end: (time + duration) / timescale,\n                    duration: duration / timescale,\n                    timescale: 1,\n                    number,\n                    url: replaceSegmentSmoothTokens(media, time),\n                    complete: true,\n                    privateInfos: { smoothMediaSegment: { time, duration } },\n                };\n                segments.push(segment);\n                // update segment number and segment time for the next segment\n                segmentNumberInCurrentRange++;\n                segmentTime = start + segmentNumberInCurrentRange * duration;\n            }\n            if (segmentTime >= to) {\n                // we reached ``to``, we're done\n                return segments;\n            }\n            if (currentNumber !== undefined) {\n                currentNumber += repeat + 1;\n            }\n        }\n        return segments;\n    }\n    /**\n     * Returns true if, based on the arguments, the index should be refreshed.\n     * (If we should re-fetch the manifest)\n     * @param {Number} up\n     * @param {Number} to\n     * @returns {Boolean}\n     */\n    shouldRefresh(up, to) {\n        this._refreshTimeline();\n        if (!this._isLive) {\n            return false;\n        }\n        const { timeline, timescale } = this._sharedSmoothTimeline;\n        const lastSegmentInCurrentTimeline = timeline[timeline.length - 1];\n        if (lastSegmentInCurrentTimeline === undefined) {\n            return false;\n        }\n        const repeat = lastSegmentInCurrentTimeline.repeatCount;\n        const endOfLastSegmentInCurrentTimeline = lastSegmentInCurrentTimeline.start +\n            (repeat + 1) * lastSegmentInCurrentTimeline.duration;\n        if (to * timescale < endOfLastSegmentInCurrentTimeline) {\n            return false;\n        }\n        if (up * timescale >= endOfLastSegmentInCurrentTimeline) {\n            return true;\n        }\n        // ----\n        const startOfLastSegmentInCurrentTimeline = lastSegmentInCurrentTimeline.start + repeat * lastSegmentInCurrentTimeline.duration;\n        return up * timescale > startOfLastSegmentInCurrentTimeline;\n    }\n    /**\n     * Returns first position available in the index.\n     * @returns {Number|null}\n     */\n    getFirstAvailablePosition() {\n        this._refreshTimeline();\n        const { timeline, timescale } = this._sharedSmoothTimeline;\n        if (timeline.length === 0) {\n            return null;\n        }\n        return timeline[0].start / timescale;\n    }\n    /**\n     * Returns last position available in the index.\n     * @returns {Number}\n     */\n    getLastAvailablePosition() {\n        this._refreshTimeline();\n        const { timeline, timescale } = this._sharedSmoothTimeline;\n        if (this._scaledLiveGap === undefined) {\n            const lastTimelineElement = timeline[timeline.length - 1];\n            return getIndexSegmentEnd(lastTimelineElement, null) / timescale;\n        }\n        for (let i = timeline.length - 1; i >= 0; i--) {\n            const timelineElt = timeline[i];\n            const timescaledNow = (getMonotonicTimeStamp() / 1000) * timescale;\n            const { start, duration, repeatCount } = timelineElt;\n            for (let j = repeatCount; j >= 0; j--) {\n                const end = start + duration * (j + 1);\n                const positionToReach = end;\n                if (positionToReach <= timescaledNow - this._scaledLiveGap) {\n                    return end / timescale;\n                }\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Returns the absolute end in seconds this RepresentationIndex can reach once\n     * all segments are available.\n     * @returns {number|null|undefined}\n     */\n    getEnd() {\n        if (!this._isLive) {\n            return this.getLastAvailablePosition();\n        }\n        return undefined;\n    }\n    /**\n     * Returns:\n     *   - `true` if in the given time interval, at least one new segment is\n     *     expected to be available in the future.\n     *   - `false` either if all segments in that time interval are already\n     *     available for download or if none will ever be available for it.\n     *   - `undefined` when it is not possible to tell.\n     * @param {number} start\n     * @param {number} end\n     * @returns {boolean|undefined}\n     */\n    awaitSegmentBetween(start, end) {\n        var _a;\n        assert(start <= end);\n        if (this.isStillAwaitingFutureSegments()) {\n            return false;\n        }\n        const lastAvailablePosition = this.getLastAvailablePosition();\n        if (lastAvailablePosition !== undefined && end < lastAvailablePosition) {\n            return false;\n        }\n        return end > ((_a = this.getFirstAvailablePosition()) !== null && _a !== void 0 ? _a : 0) ? undefined : false;\n    }\n    /**\n     * Checks if `timeSec` is in a discontinuity.\n     * That is, if there's no segment available for the `timeSec` position.\n     * @param {number} timeSec - The time to check if it's in a discontinuity, in\n     * seconds.\n     * @returns {number | null} - If `null`, no discontinuity is encountered at\n     * `time`. If this is a number instead, there is one and that number is the\n     * position for which a segment is available in seconds.\n     */\n    checkDiscontinuity(timeSec) {\n        this._refreshTimeline();\n        return checkDiscontinuity(this._sharedSmoothTimeline, timeSec, undefined);\n    }\n    /**\n     * Returns `true` if a Segment returned by this index is still considered\n     * available.\n     * Returns `false` if it is not available anymore.\n     * Returns `undefined` if we cannot know whether it is still available or not.\n     * @param {Object} segment\n     * @returns {Boolean|undefined}\n     */\n    isSegmentStillAvailable(segment) {\n        if (segment.isInit) {\n            return true;\n        }\n        this._refreshTimeline();\n        const { timeline, timescale } = this._sharedSmoothTimeline;\n        for (let i = 0; i < timeline.length; i++) {\n            const tSegment = timeline[i];\n            const tSegmentTime = tSegment.start / timescale;\n            if (tSegmentTime > segment.time) {\n                return false; // We went over it without finding it\n            }\n            else if (tSegmentTime === segment.time) {\n                return true;\n            }\n            else {\n                // tSegment.start < segment.time\n                if (tSegment.repeatCount >= 0 && tSegment.duration !== undefined) {\n                    const timeDiff = tSegmentTime - tSegment.start;\n                    const repeat = timeDiff / tSegment.duration - 1;\n                    return repeat % 1 === 0 && repeat <= tSegment.repeatCount;\n                }\n            }\n        }\n        return false;\n    }\n    /**\n     * @param {Error} error\n     * @returns {Boolean}\n     */\n    canBeOutOfSyncError(error) {\n        if (!this._isLive) {\n            return false;\n        }\n        return (error instanceof NetworkError && (error.isHttpError(404) || error.isHttpError(412)));\n    }\n    /**\n     * Returns the `duration` of each segment in the context of its Manifest (i.e.\n     * as the Manifest anounces them, actual segment duration may be different due\n     * to approximations), in seconds.\n     *\n     * NOTE: we could here do a median or a mean but I chose to be lazy (and\n     * more performant) by returning the duration of the first element instead.\n     * As `isPrecize` is `false`, the rest of the code should be notified that\n     * this is only an approximation.\n     * @returns {number}\n     */\n    getTargetSegmentDuration() {\n        this._refreshTimeline();\n        const { timeline, timescale } = this._sharedSmoothTimeline;\n        const firstElementInTimeline = timeline[0];\n        if (firstElementInTimeline === undefined) {\n            return undefined;\n        }\n        return {\n            duration: firstElementInTimeline.duration / timescale,\n            isPrecize: false,\n        };\n    }\n    /**\n     * Replace this RepresentationIndex by a newly downloaded one.\n     * Check if the old index had more information about new segments and re-add\n     * them if that's the case.\n     * @param {Object} newIndex\n     */\n    _replace(newIndex) {\n        this._initialScaledLastPosition = newIndex._initialScaledLastPosition;\n        this._scaledLiveGap = newIndex._scaledLiveGap;\n        this._sharedSmoothTimeline.replace(newIndex._sharedSmoothTimeline);\n    }\n    /**\n     * Update the current index with a new, partial, version.\n     * This method might be use to only add information about new segments.\n     * @param {Object} newIndex\n     */\n    _update(newIndex) {\n        this._scaledLiveGap = newIndex._scaledLiveGap;\n        this._sharedSmoothTimeline.update(newIndex._sharedSmoothTimeline);\n    }\n    /**\n     * Returns `false` if the last segments in this index have already been\n     * generated.\n     * Returns `true` if the index is still waiting on future segments to be\n     * generated.\n     *\n     * For Smooth, it should only depend on whether the content is a live content\n     * or not.\n     * TODO What about Smooth live content that finishes at some point?\n     * @returns {boolean}\n     */\n    isStillAwaitingFutureSegments() {\n        return this._isLive;\n    }\n    /**\n     * @returns {Boolean}\n     */\n    isInitialized() {\n        return true;\n    }\n    initialize() {\n        log.error(\"A `SmoothRepresentationIndex` does not need to be initialized\");\n    }\n    /**\n     * Add segments to a `SharedSmoothSegmentTimeline` that were predicted to come\n     * after `currentSegment`.\n     * @param {Array.<Object>} nextSegments - The segment information parsed.\n     * @param {Object} currentSegment - Information on the segment which contained\n     * that new segment information.\n     */\n    addPredictedSegments(nextSegments, currentSegment) {\n        this._sharedSmoothTimeline.addPredictedSegments(nextSegments, currentSegment);\n    }\n    /**\n     * Clean-up timeline to remove segment information which should not be\n     * available due to the timeshift window\n     */\n    _refreshTimeline() {\n        this._sharedSmoothTimeline.refresh();\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../../log\";\nimport getMonotonicTimeStamp from \"../../../utils/monotonic_timestamp\";\nimport clearTimelineFromPosition from \"../utils/clear_timeline_from_position\";\nimport { getIndexSegmentEnd } from \"../utils/index_helpers\";\nimport updateSegmentTimeline from \"../utils/update_segment_timeline\";\nimport addSegmentInfos from \"./utils/add_segment_infos\";\n/**\n * Smooth contents provide the index of segments under a \"StreamIndex\", the\n * smooth equivalent of an AdaptationSet.\n *\n * This means that multiple \"QualityLevel\" (smooth's Representation) are going\n * to rely on the exact same list of segments. This also means that all\n * mutations on that timeline (whether it is to evict old segments or to add\n * new ones) should presumably happen for all of them at the same time.\n *\n * The `SharedSmoothSegmentTimeline` is an abstraction over that index of\n * segments whose goal is to explicitely provide a data structure that can be\n * shared to every `RepresentationIndex` linked to Representations being part\n * of the same smooth Adaptation, thus allowing to mutualize any side-effect\n * done to it automatically.\n *\n * @class SharedSmoothSegmentTimeline\n */\nexport default class SharedSmoothSegmentTimeline {\n    constructor(args) {\n        const { timeline, timescale, timeShiftBufferDepth, manifestReceivedTime } = args;\n        this.timeline = timeline;\n        this.timescale = timescale;\n        const estimatedReceivedTime = manifestReceivedTime !== null && manifestReceivedTime !== void 0 ? manifestReceivedTime : getMonotonicTimeStamp();\n        this.validityTime = estimatedReceivedTime;\n        this._timeShiftBufferDepth = timeShiftBufferDepth;\n        if (timeline.length !== 0) {\n            const lastItem = timeline[timeline.length - 1];\n            const scaledEnd = getIndexSegmentEnd(lastItem, null);\n            this._initialScaledLastPosition = scaledEnd;\n        }\n    }\n    /**\n     * Clean-up timeline to remove segment information which should not be\n     * available due to the timeshift window\n     */\n    refresh() {\n        // clean segments before time shift buffer depth\n        if (this._initialScaledLastPosition === undefined) {\n            return;\n        }\n        const timeShiftBufferDepth = this._timeShiftBufferDepth;\n        const timeSinceLastRealUpdate = (getMonotonicTimeStamp() - this.validityTime) / 1000;\n        const lastPositionEstimate = timeSinceLastRealUpdate + this._initialScaledLastPosition / this.timescale;\n        if (timeShiftBufferDepth !== undefined) {\n            const minimumPosition = (lastPositionEstimate - timeShiftBufferDepth) * this.timescale;\n            clearTimelineFromPosition(this.timeline, minimumPosition);\n        }\n    }\n    /**\n     * Replace this SharedSmoothSegmentTimeline by a newly downloaded one.\n     * Check if the old timeline had more information about new segments and re-add\n     * them if that's the case.\n     * @param {Object} newSmoothTimeline\n     */\n    replace(newSmoothTimeline) {\n        const oldTimeline = this.timeline;\n        const newTimeline = newSmoothTimeline.timeline;\n        const oldTimescale = this.timescale;\n        const newTimescale = newSmoothTimeline.timescale;\n        this._initialScaledLastPosition = newSmoothTimeline._initialScaledLastPosition;\n        this.validityTime = newSmoothTimeline.validityTime;\n        if (oldTimeline.length === 0 ||\n            newTimeline.length === 0 ||\n            oldTimescale !== newTimescale) {\n            return; // don't take risk, if something is off, take the new one\n        }\n        const lastOldTimelineElement = oldTimeline[oldTimeline.length - 1];\n        const lastNewTimelineElement = newTimeline[newTimeline.length - 1];\n        const newEnd = getIndexSegmentEnd(lastNewTimelineElement, null);\n        if (getIndexSegmentEnd(lastOldTimelineElement, null) <= newEnd) {\n            return;\n        }\n        for (let i = 0; i < oldTimeline.length; i++) {\n            const oldTimelineRange = oldTimeline[i];\n            const oldEnd = getIndexSegmentEnd(oldTimelineRange, null);\n            if (oldEnd === newEnd) {\n                // just add the supplementary segments\n                this.timeline = this.timeline.concat(oldTimeline.slice(i + 1));\n                return;\n            }\n            if (oldEnd > newEnd) {\n                // adjust repeatCount + add supplementary segments\n                if (oldTimelineRange.duration !== lastNewTimelineElement.duration) {\n                    return;\n                }\n                const rangeDuration = newEnd - oldTimelineRange.start;\n                if (rangeDuration === 0) {\n                    log.warn(\"Smooth Parser: a discontinuity detected in the previous manifest\" +\n                        \" has been resolved.\");\n                    this.timeline = this.timeline.concat(oldTimeline.slice(i));\n                    return;\n                }\n                if (rangeDuration < 0 || rangeDuration % oldTimelineRange.duration !== 0) {\n                    return;\n                }\n                const repeatWithOld = rangeDuration / oldTimelineRange.duration - 1;\n                const relativeRepeat = oldTimelineRange.repeatCount - repeatWithOld;\n                if (relativeRepeat < 0) {\n                    return;\n                }\n                lastNewTimelineElement.repeatCount += relativeRepeat;\n                const supplementarySegments = oldTimeline.slice(i + 1);\n                this.timeline = this.timeline.concat(supplementarySegments);\n                return;\n            }\n        }\n    }\n    /**\n     * Update the current SharedSmoothSegmentTimeline with a new, partial, version.\n     * This method might be use to only add information about new segments.\n     * @param {Object} newSmoothTimeline\n     */\n    update(newSmoothTimeline) {\n        updateSegmentTimeline(this.timeline, newSmoothTimeline.timeline);\n        this._initialScaledLastPosition = newSmoothTimeline._initialScaledLastPosition;\n        this.validityTime = newSmoothTimeline.validityTime;\n    }\n    /**\n     * Add segments to a `SharedSmoothSegmentTimeline` that were predicted to come\n     * after `currentSegment`.\n     * @param {Array.<Object>} nextSegments - The segment information parsed.\n     * @param {Object} segment - Information on the segment which contained that\n     * new segment information.\n     */\n    addPredictedSegments(nextSegments, currentSegment) {\n        var _a;\n        if (((_a = currentSegment.privateInfos) === null || _a === void 0 ? void 0 : _a.smoothMediaSegment) === undefined) {\n            log.warn(\"Smooth Parser: should only encounter SmoothRepresentationIndex\");\n            return;\n        }\n        this.refresh();\n        for (const nextSeg of nextSegments) {\n            addSegmentInfos(this.timeline, this.timescale, nextSeg, currentSegment.privateInfos.smoothMediaSegment);\n        }\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { getIndexSegmentEnd } from \"../../utils/index_helpers\";\n/**\n * Add a new segment to the index.\n *\n * /!\\ Mutate the given index\n * @param {Array.<Object>} timeline\n * @param {number} timescale\n * @param {Object} newSegment\n * @param {Object} currentSegment\n * @returns {Boolean} - true if the segment has been added\n */\nexport default function _addSegmentInfos(timeline, timescale, newSegment, currentSegment) {\n    const timelineLength = timeline.length;\n    const last = timeline[timelineLength - 1];\n    const scaledNewSegment = newSegment.timescale === timescale\n        ? { time: newSegment.time, duration: newSegment.duration }\n        : {\n            time: (newSegment.time / newSegment.timescale) * timescale,\n            duration: (newSegment.duration / newSegment.timescale) * timescale,\n        };\n    // in some circumstances, the new segment information are only duration\n    // information that we could use to deduct the start of the next segment.\n    // This is the case where the new segment are associated to a current\n    // segment and have the same start.\n    // However, we prefer to be sure of the duration of the new segments\n    // before adding such segments.\n    const shouldDeductNextSegment = currentSegment.time === scaledNewSegment.time;\n    if (shouldDeductNextSegment) {\n        return false;\n    }\n    else if (scaledNewSegment.time >= getIndexSegmentEnd(last, null)) {\n        // if the given timing has a timestamp after the timeline end we\n        // just need to push a new element in the timeline, or increase\n        // the @r attribute of the last element.\n        if (last.duration === scaledNewSegment.duration) {\n            last.repeatCount++;\n        }\n        else {\n            timeline.push({\n                duration: scaledNewSegment.duration,\n                start: scaledNewSegment.time,\n                repeatCount: 0,\n            });\n        }\n        return true;\n    }\n    return false;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @param {*} val\n * @returns {Boolean}\n */\nexport default function parseBoolean(val) {\n    if (typeof val === \"boolean\") {\n        return val;\n    }\n    else if (typeof val === \"string\") {\n        return val.toUpperCase() === \"TRUE\";\n    }\n    else {\n        return false;\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Reduce implementation for the children of the given element.\n * @param {Element} root\n * @param {Function} fn\n * @param {*} init\n * @returns {*}\n */\nexport default function reduceChildren(root, fn, init) {\n    let node = root.firstElementChild;\n    let accumulator = init;\n    while (node !== null) {\n        accumulator = fn(accumulator, node.nodeName, node);\n        node = node.nextElementSibling;\n    }\n    return accumulator;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @param {string} url\n * @param {string|number} bitrate\n * @returns {string}\n */\nfunction replaceRepresentationSmoothTokens(url, bitrate, customAttributes) {\n    return url\n        .replace(/\\{bitrate\\}/g, String(bitrate))\n        .replace(/{CustomAttributes}/g, customAttributes.length > 0 ? customAttributes[0] : \"\");\n}\n/**\n * @param {string} url\n * @param {number} time\n * @returns {string}\n */\nfunction replaceSegmentSmoothTokens(url, time) {\n    return url.replace(/\\{start time\\}/g, String(time));\n}\nexport { replaceRepresentationSmoothTokens, replaceSegmentSmoothTokens };\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../../log\";\nimport arrayIncludes from \"../../../utils/array_includes\";\n/**\n * Ensure that no two periods, adaptations from the same period and\n * representations from the same adaptation, have the same ID.\n *\n * Log and mutate their ID if not until this is verified.\n *\n * @param {Object} manifest\n */\nexport default function checkManifestIDs(manifest) {\n    const periodIDS = [];\n    manifest.periods.forEach((period) => {\n        const periodID = period.id;\n        if (arrayIncludes(periodIDS, periodID)) {\n            log.warn(\"Two periods with the same ID found. Updating.\");\n            const newID = periodID + \"-dup\";\n            period.id = newID;\n            checkManifestIDs(manifest);\n            periodIDS.push(newID);\n        }\n        else {\n            periodIDS.push(periodID);\n        }\n        const { adaptations } = period;\n        const adaptationIDs = [];\n        Object.keys(adaptations).forEach((type) => {\n            const adaptationsForType = adaptations[type];\n            if (adaptationsForType === undefined) {\n                return;\n            }\n            adaptationsForType.forEach((adaptation) => {\n                const adaptationID = adaptation.id;\n                if (arrayIncludes(adaptationIDs, adaptationID)) {\n                    log.warn(\"Two adaptations with the same ID found. Updating.\", adaptationID);\n                    const newID = adaptationID + \"-dup\";\n                    adaptation.id = newID;\n                    checkManifestIDs(manifest);\n                    adaptationIDs.push(newID);\n                }\n                else {\n                    adaptationIDs.push(adaptationID);\n                }\n                const representationIDs = [];\n                adaptation.representations.forEach((representation) => {\n                    const representationID = representation.id;\n                    if (arrayIncludes(representationIDs, representationID)) {\n                        log.warn(\"Two representations with the same ID found. Updating.\", representationID);\n                        const newID = `${representationID}-dup`;\n                        representation.id = newID;\n                        checkManifestIDs(manifest);\n                        representationIDs.push(newID);\n                    }\n                    else {\n                        representationIDs.push(representationID);\n                    }\n                });\n            });\n        });\n    });\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Remove segments which starts before the given `firstAvailablePosition` from\n * the timeline. `firstAvailablePosition` has to be time scaled.\n * @param {Array.<Object>} timeline\n * @param {number} firstAvailablePosition\n * @returns {number} - Returns the number of removed segments. This includes\n * potential implicit segment from decremented `repeatCount` attributes.\n */\nexport default function clearTimelineFromPosition(timeline, firstAvailablePosition) {\n    let nbEltsRemoved = 0;\n    while (timeline.length > 0) {\n        const firstElt = timeline[0];\n        if (firstElt.start >= firstAvailablePosition) {\n            return nbEltsRemoved; // all clear\n        }\n        if (firstElt.repeatCount === -1) {\n            return nbEltsRemoved;\n        }\n        else if (firstElt.repeatCount === 0) {\n            timeline.shift();\n            nbEltsRemoved += 1;\n        }\n        else {\n            // we have a segment repetition\n            const nextElt = timeline[1];\n            if (nextElt !== undefined && nextElt.start <= firstAvailablePosition) {\n                timeline.shift();\n                nbEltsRemoved += 1;\n            }\n            else {\n                // no next segment or next segment is available\n                if (firstElt.duration <= 0) {\n                    return nbEltsRemoved;\n                }\n                let nextStart = firstElt.start + firstElt.duration;\n                let nextRepeat = 1;\n                while (nextStart < firstAvailablePosition && nextRepeat <= firstElt.repeatCount) {\n                    nextStart += firstElt.duration;\n                    nextRepeat++;\n                }\n                if (nextRepeat > firstElt.repeatCount) {\n                    // every start is before\n                    timeline.shift();\n                    nbEltsRemoved = firstElt.repeatCount + 1;\n                }\n                else {\n                    // some repetitions start after and some before\n                    const newRepeat = firstElt.repeatCount - nextRepeat;\n                    firstElt.start = nextStart;\n                    firstElt.repeatCount = newRepeat;\n                    nbEltsRemoved += nextRepeat;\n                    return nbEltsRemoved;\n                }\n            }\n        }\n    }\n    return nbEltsRemoved;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Returns \"first time of reference\" from the adaptation given, considering a\n * dynamic content.\n * Undefined if a time could not be found.\n *\n * We consider the latest first time from every representations in the given\n * adaptation.\n * @param {Object} adaptation\n * @returns {Number|undefined}\n */\nexport default function getFirstPositionFromAdaptation(adaptation) {\n    const { representations } = adaptation;\n    let max = null;\n    for (const representation of representations) {\n        const firstPosition = representation.index.getFirstAvailablePosition();\n        if (firstPosition === undefined) {\n            // we cannot tell\n            return undefined;\n        }\n        if (firstPosition !== null) {\n            max = max === null ? firstPosition : Math.max(max, firstPosition);\n        }\n    }\n    if (max === null) {\n        // It means that all positions were null === no segments (yet?)\n        return null;\n    }\n    return max;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Returns \"last time of reference\" from the adaptation given, considering a\n * dynamic content.\n * Undefined if a time could not be found.\n * Null if the Adaptation has no segments (it could be that it didn't started or\n * that it already finished for example).\n *\n * We consider the earliest last time from every representations in the given\n * adaptation.\n * @param {Object} adaptation\n * @returns {Number|undefined|null}\n */\nexport default function getLastPositionFromAdaptation(adaptation) {\n    const { representations } = adaptation;\n    let min = null;\n    for (const representation of representations) {\n        const lastPosition = representation.index.getLastAvailablePosition();\n        if (lastPosition === undefined) {\n            // we cannot tell\n            return undefined;\n        }\n        if (lastPosition !== null) {\n            min = min === null ? lastPosition : Math.min(min, lastPosition);\n        }\n    }\n    if (min === null) {\n        // It means that all positions were null === no segments (yet?)\n        return null;\n    }\n    return min;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../../log\";\nimport getLastPositionFromAdaptation from \"./get_last_time_from_adaptation\";\n/**\n * @param {Array.<Object>} periods\n * @returns {number | undefined}\n */\nexport default function getMaximumPosition(periods) {\n    for (let i = periods.length - 1; i >= 0; i--) {\n        const periodAdaptations = periods[i].adaptations;\n        const firstAudioAdaptationFromPeriod = periodAdaptations.audio === undefined ? undefined : periodAdaptations.audio[0];\n        const firstVideoAdaptationFromPeriod = periodAdaptations.video === undefined ? undefined : periodAdaptations.video[0];\n        if (firstAudioAdaptationFromPeriod !== undefined ||\n            firstVideoAdaptationFromPeriod !== undefined) {\n            // null == no segment\n            let maximumAudioPosition = null;\n            let maximumVideoPosition = null;\n            if (firstAudioAdaptationFromPeriod !== undefined) {\n                const lastPosition = getLastPositionFromAdaptation(firstAudioAdaptationFromPeriod);\n                if (lastPosition === undefined) {\n                    return { safe: undefined, unsafe: undefined };\n                }\n                maximumAudioPosition = lastPosition;\n            }\n            if (firstVideoAdaptationFromPeriod !== undefined) {\n                const lastPosition = getLastPositionFromAdaptation(firstVideoAdaptationFromPeriod);\n                if (lastPosition === undefined) {\n                    return { safe: undefined, unsafe: undefined };\n                }\n                maximumVideoPosition = lastPosition;\n            }\n            if ((firstAudioAdaptationFromPeriod !== undefined && maximumAudioPosition === null) ||\n                (firstVideoAdaptationFromPeriod !== undefined && maximumVideoPosition === null)) {\n                log.info(\"Parser utils: found Period with no segment. \", \"Going to previous one to calculate last position\");\n                return { safe: undefined, unsafe: undefined };\n            }\n            if (maximumVideoPosition !== null) {\n                if (maximumAudioPosition !== null) {\n                    return {\n                        safe: Math.min(maximumAudioPosition, maximumVideoPosition),\n                        unsafe: Math.max(maximumAudioPosition, maximumVideoPosition),\n                    };\n                }\n                return { safe: maximumVideoPosition, unsafe: maximumVideoPosition };\n            }\n            if (maximumAudioPosition !== null) {\n                return { safe: maximumAudioPosition, unsafe: maximumAudioPosition };\n            }\n        }\n    }\n    return { safe: undefined, unsafe: undefined };\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../../log\";\nimport getFirstPositionFromAdaptation from \"./get_first_time_from_adaptation\";\n/**\n * @param {Array.<Object>} periods\n * @returns {number | undefined}\n */\nexport default function getMinimumPosition(periods) {\n    for (let i = 0; i <= periods.length - 1; i++) {\n        const periodAdaptations = periods[i].adaptations;\n        const firstAudioAdaptationFromPeriod = periodAdaptations.audio === undefined ? undefined : periodAdaptations.audio[0];\n        const firstVideoAdaptationFromPeriod = periodAdaptations.video === undefined ? undefined : periodAdaptations.video[0];\n        if (firstAudioAdaptationFromPeriod !== undefined ||\n            firstVideoAdaptationFromPeriod !== undefined) {\n            // null == no segment\n            let minimumAudioPosition = null;\n            let minimumVideoPosition = null;\n            if (firstAudioAdaptationFromPeriod !== undefined) {\n                const firstPosition = getFirstPositionFromAdaptation(firstAudioAdaptationFromPeriod);\n                if (firstPosition === undefined) {\n                    return undefined;\n                }\n                minimumAudioPosition = firstPosition;\n            }\n            if (firstVideoAdaptationFromPeriod !== undefined) {\n                const firstPosition = getFirstPositionFromAdaptation(firstVideoAdaptationFromPeriod);\n                if (firstPosition === undefined) {\n                    return undefined;\n                }\n                minimumVideoPosition = firstPosition;\n            }\n            if ((firstAudioAdaptationFromPeriod !== undefined && minimumAudioPosition === null) ||\n                (firstVideoAdaptationFromPeriod !== undefined && minimumVideoPosition === null)) {\n                log.info(\"Parser utils: found Period with no segment. \", \"Going to next one to calculate first position\");\n                return undefined;\n            }\n            if (minimumVideoPosition !== null) {\n                if (minimumAudioPosition !== null) {\n                    return Math.max(minimumAudioPosition, minimumVideoPosition);\n                }\n                return minimumVideoPosition;\n            }\n            if (minimumAudioPosition !== null) {\n                return minimumAudioPosition;\n            }\n        }\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport isNullOrUndefined from \"../../../utils/is_null_or_undefined\";\n/**\n * Calculate the number of times a timeline element repeats based on the next\n * element.\n * @param {Object} element\n * @param {Object|null|undefined} nextElement\n * @param {number|undefined} maxPosition\n * @returns {Number}\n */\nexport function calculateRepeat(element, nextElement, maxPosition) {\n    const { repeatCount } = element;\n    if (repeatCount >= 0) {\n        return repeatCount;\n    }\n    // A negative value of the @r attribute of the S element indicates\n    // that the duration indicated in @d attribute repeats until the\n    // start of the next S element, the end of the Period or until the\n    // next MPD update.\n    let segmentEnd;\n    if (!isNullOrUndefined(nextElement)) {\n        segmentEnd = nextElement.start;\n    }\n    else if (maxPosition !== undefined) {\n        segmentEnd = maxPosition;\n    }\n    else {\n        segmentEnd = Number.MAX_VALUE;\n    }\n    return Math.ceil((segmentEnd - element.start) / element.duration) - 1;\n}\n/**\n * Returns end of the segment given, in index time.\n * @param {Object} segment\n * @param {Object|null} [nextSegment]\n * @param {number} maxPosition\n * @returns {Number}\n */\nexport function getIndexSegmentEnd(segment, nextSegment, maxPosition) {\n    const { start, duration } = segment;\n    if (duration <= 0) {\n        return start;\n    }\n    const repeat = calculateRepeat(segment, nextSegment, maxPosition);\n    return start + (repeat + 1) * duration;\n}\n/**\n * Convert from `presentationTime`, the time of the segment at the moment it\n * is decoded to `mediaTime`, the original time the segments point at.\n * @param {number} time\n * @param {Object} indexOptions\n * @returns {number}\n */\nexport function toIndexTime(time, indexOptions) {\n    var _a;\n    return time * indexOptions.timescale + ((_a = indexOptions.indexTimeOffset) !== null && _a !== void 0 ? _a : 0);\n}\n/**\n * Convert from `mediaTime`, the original time the segments point at to\n * `presentationTime`, the time of the segment at the moment it is decoded.\n * @param {number} time\n * @param {Object} indexOptions\n * @returns {number}\n */\nexport function fromIndexTime(time, indexOptions) {\n    var _a;\n    return (time - ((_a = indexOptions.indexTimeOffset) !== null && _a !== void 0 ? _a : 0)) / indexOptions.timescale;\n}\n/**\n * @param {Number} start\n * @param {Number} duration\n * @param {Number} timescale\n * @returns {Object} - Object with two properties:\n *   - up {Number}: timescaled timestamp of the beginning time\n *   - to {Number}: timescaled timestamp of the end time (start time + duration)\n */\nexport function getTimescaledRange(start, duration, timescale) {\n    return [start * timescale, (start + duration) * timescale];\n}\n/**\n * Get index of the last segment in the timeline starting before/at the given\n * timescaled time.\n * Returns -1 if the given time is lower than the start of the first available\n * segment.\n * @param {Object} timeline\n * @param {Number} timeTScaled\n * @returns {Number}\n */\nfunction getIndexOfLastObjectBefore(timeline, timeTScaled) {\n    let low = 0;\n    let high = timeline.length;\n    while (low < high) {\n        const mid = (low + high) >>> 1; // Divide by two + floor\n        if (timeline[mid].start <= timeTScaled) {\n            low = mid + 1;\n        }\n        else {\n            high = mid;\n        }\n    }\n    return low - 1;\n}\n/**\n * @param {Object} index\n * @param {number} timeSec\n * @param {number} [maxPosition]\n * @returns {number|null}\n */\nexport function checkDiscontinuity(index, timeSec, maxPosition) {\n    const { timeline } = index;\n    const scaledTime = toIndexTime(timeSec, index);\n    if (scaledTime < 0) {\n        return null;\n    }\n    const segmentIndex = getIndexOfLastObjectBefore(timeline, scaledTime);\n    if (segmentIndex < 0 || segmentIndex >= timeline.length - 1) {\n        return null;\n    }\n    const timelineItem = timeline[segmentIndex];\n    if (timelineItem.duration <= 0) {\n        return null;\n    }\n    const nextTimelineItem = timeline[segmentIndex + 1];\n    if (nextTimelineItem === undefined) {\n        return null;\n    }\n    const nextStart = nextTimelineItem.start;\n    const segmentEnd = getIndexSegmentEnd(timelineItem, nextTimelineItem, maxPosition);\n    return scaledTime >= segmentEnd && scaledTime < nextStart\n        ? fromIndexTime(nextStart, index)\n        : null;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { MediaError } from \"../../../errors\";\nimport log from \"../../../log\";\nimport { getIndexSegmentEnd } from \"./index_helpers\";\n/**\n * Update a complete array of segments in a given timeline with a [generally]\n * smaller but [generally] newer set of segments.\n *\n * Returns a boolean:\n *   - If set to `true`, the old timeline was emptied and completely replaced by\n *     the content of the newer timeline.\n *     This could happen either if a problem happened while trying to update or\n *     when the update is actually bigger than what it is updating.\n *   - If set to `false`, the older timeline was either updated to add the newer\n *     segments, or untouched.\n *\n * @param {Array.<Object>} oldTimeline\n * @param {Array.<Object>} newTimeline\n * @returns {boolean}\n */\nexport default function updateSegmentTimeline(oldTimeline, newTimeline) {\n    if (oldTimeline.length === 0) {\n        oldTimeline.push(...newTimeline);\n        return true;\n    }\n    else if (newTimeline.length === 0) {\n        return false;\n    }\n    const prevTimelineLength = oldTimeline.length;\n    const newIndexStart = newTimeline[0].start;\n    const oldLastElt = oldTimeline[prevTimelineLength - 1];\n    const oldIndexEnd = getIndexSegmentEnd(oldLastElt, newTimeline[0]);\n    if (oldIndexEnd < newIndexStart) {\n        throw new MediaError(\"MANIFEST_UPDATE_ERROR\", \"Cannot perform partial update: not enough data\");\n    }\n    for (let i = prevTimelineLength - 1; i >= 0; i--) {\n        const currStart = oldTimeline[i].start;\n        if (currStart === newIndexStart) {\n            // replace that one and those after it\n            const nbEltsToRemove = prevTimelineLength - i;\n            oldTimeline.splice(i, nbEltsToRemove, ...newTimeline);\n            return false;\n        }\n        else if (currStart < newIndexStart) {\n            // first to be before\n            const currElt = oldTimeline[i];\n            if (currElt.start + currElt.duration > newIndexStart) {\n                // The new Manifest overlaps a previous segment (weird)\n                // In that improbable case, we'll just completely replace segments\n                log.warn(\"RepresentationIndex: Manifest update removed all previous segments\");\n                oldTimeline.splice(0, prevTimelineLength, ...newTimeline);\n                return true;\n            }\n            else if (currElt.repeatCount === undefined || currElt.repeatCount <= 0) {\n                if (currElt.repeatCount < 0) {\n                    currElt.repeatCount =\n                        Math.floor((newIndexStart - currElt.start) / currElt.duration) - 1;\n                }\n                oldTimeline.splice(i + 1, prevTimelineLength - (i + 1), ...newTimeline);\n                return false;\n            }\n            // else, there is a positive repeat we might want to update\n            const eltLastTime = currElt.start + currElt.duration * (currElt.repeatCount + 1);\n            if (eltLastTime <= newIndexStart) {\n                // our new index comes directly after\n                // put it after this one\n                oldTimeline.splice(i + 1, prevTimelineLength - (i + 1), ...newTimeline);\n                return false;\n            }\n            const newCurrRepeat = (newIndexStart - currElt.start) / currElt.duration - 1;\n            if (newCurrRepeat % 1 === 0 && currElt.duration === newTimeline[0].duration) {\n                const newRepeatCount = newTimeline[0].repeatCount < 0\n                    ? -1 // === maximum possible repeat\n                    : newTimeline[0].repeatCount + newCurrRepeat + 1;\n                // replace that one and those after it\n                oldTimeline.splice(i, prevTimelineLength - i, ...newTimeline);\n                oldTimeline[i].start = currElt.start;\n                oldTimeline[i].repeatCount = newRepeatCount;\n                return false;\n            }\n            log.warn(\"RepresentationIndex: Manifest update removed previous segments\");\n            oldTimeline[i].repeatCount = Math.floor(newCurrRepeat);\n            // put it after this one\n            oldTimeline.splice(i + 1, prevTimelineLength - (i + 1), ...newTimeline);\n            return false;\n        }\n    }\n    // if we got here, it means that every segments in the previous manifest are\n    // after the new one. This is unusual.\n    // Either the new one has more depth or it's an older one.\n    const prevLastElt = oldTimeline[oldTimeline.length - 1];\n    const newLastElt = newTimeline[newTimeline.length - 1];\n    if (prevLastElt.repeatCount !== undefined && prevLastElt.repeatCount < 0) {\n        if (prevLastElt.start > newLastElt.start) {\n            log.warn(\"RepresentationIndex: The new index is older than the previous one\");\n            return false;\n        }\n        else {\n            // the new has more depth\n            log.warn('RepresentationIndex: The new index is \"bigger\" than the previous one');\n            oldTimeline.splice(0, prevTimelineLength, ...newTimeline);\n            return true;\n        }\n    }\n    const prevLastTime = prevLastElt.start + prevLastElt.duration * (prevLastElt.repeatCount + 1);\n    const newLastTime = newLastElt.start + newLastElt.duration * (newLastElt.repeatCount + 1);\n    if (prevLastTime >= newLastTime) {\n        log.warn(\"RepresentationIndex: The new index is older than the previous one\");\n        return false;\n    }\n    // the new one has more depth. full update\n    log.warn('RepresentationIndex: The new index is \"bigger\" than the previous one');\n    oldTimeline.splice(0, prevTimelineLength, ...newTimeline);\n    return true;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// __VERY__ simple SAMI parser, based on ugly-but-working REGEXP:\n//   - the text, start and end times are correctly parsed.\n//   - only text for the given language is parsed.\n//   - only the CSS style associated to the P element is set.\n//   - we should be safe for any XSS.\n// The language indicated to the parser should be present in the CSS and the\n// corresponding Class should be on the P elements. If we fail to find the\n// language in a \"lang\" property of a CSS class, the parser will throw.\n/**\n * /!\\ This file is feature-switchable.\n * It always should be imported through the `features` object.\n */\nimport isNonEmptyString from \"../../../utils/is_non_empty_string\";\nimport isNullOrUndefined from \"../../../utils/is_null_or_undefined\";\nconst HTML_ENTITIES = /&#([0-9]+);/g;\nconst BR = /<br>/gi;\nconst STYLE = /<style[^>]*>([\\s\\S]*?)<\\/style[^>]*>/i;\nconst PARAG = /\\s*<p (?:class=([^>]+))?>(.*)/i;\nconst START = /<sync[^>]+?start=\"?([0-9]*)\"?[^0-9]/i;\n/**\n * Returns classnames for every languages.\n * @param {string} str\n * @returns {Object}\n */\nfunction getClassNameByLang(str) {\n    const ruleRe = /\\.(\\S+)\\s*{([^}]*)}/gi;\n    const langs = {};\n    let m = ruleRe.exec(str);\n    while (m !== null) {\n        const name = m[1];\n        const lang = getCSSProperty(m[2], \"lang\");\n        if (!isNullOrUndefined(name) && !isNullOrUndefined(lang)) {\n            langs[lang] = name;\n        }\n        m = ruleRe.exec(str);\n    }\n    return langs;\n}\n/**\n * Returns the rules defined for the P element.\n * Empty string if not found.\n * @param {string} str - The entire styling part.\n * @returns {string}\n */\nfunction getPCSSRules(str) {\n    const pRuleRegex = /p\\s*{([^}]*)}/gi;\n    const rule = pRuleRegex.exec(str);\n    if (rule === null) {\n        return \"\";\n    }\n    return rule[1];\n}\n/**\n * @param {string} str - entire CSS rule\n * @param {string} name - name of the property\n * @returns {string|null} - value of the property. Null if not found.\n */\nfunction getCSSProperty(str, name) {\n    const matches = new RegExp(\"\\\\s*\" + name + \":\\\\s*(\\\\S+);\", \"i\").exec(str);\n    return Array.isArray(matches) ? matches[1] : null;\n}\n/**\n * @param {string} text\n * @returns {string}\n */\nfunction decodeEntities(text) {\n    return text.replace(HTML_ENTITIES, (_, $1) => String.fromCharCode(Number($1)));\n}\n/**\n * Because sami is not really html... we have to use\n * some kind of regular expressions to parse it...\n * the cthulhu way :)\n * The specification being quite clunky, this parser\n * may not work for every sami input.\n *\n * @param {string} smi\n * @param {Number} timeOffset\n * @param {string} lang\n */\nfunction parseSami(smi, timeOffset, lang) {\n    const syncOpen = /<sync[ >]/gi;\n    const syncClose = /<sync[ >]|<\\/body>/gi;\n    const subs = [];\n    const styleMatches = STYLE.exec(smi);\n    const css = Array.isArray(styleMatches) ? styleMatches[1] : \"\";\n    let up;\n    let to;\n    // FIXME Is that wanted?\n    // previously written as let to = SyncClose.exec(smi); but never used\n    syncClose.exec(smi);\n    const langs = getClassNameByLang(css);\n    const pCSS = getPCSSRules(css);\n    let klass;\n    if (isNonEmptyString(lang)) {\n        klass = langs[lang];\n        if (klass === undefined) {\n            throw new Error(`sami: could not find lang ${lang} in CSS`);\n        }\n    }\n    while (true) {\n        up = syncOpen.exec(smi);\n        to = syncClose.exec(smi);\n        if (up === null && to === null) {\n            break;\n        }\n        if (up === null || to === null || up.index >= to.index) {\n            throw new Error(\"parse error\");\n        }\n        const str = smi.slice(up.index, to.index);\n        const tim = START.exec(str);\n        if (!Array.isArray(tim)) {\n            throw new Error(\"parse error (sync time attribute)\");\n        }\n        const start = +tim[1];\n        if (isNaN(start)) {\n            throw new Error(\"parse error (sync time attribute NaN)\");\n        }\n        appendToSubs(str.split(\"\\n\"), start / 1000);\n    }\n    return subs;\n    function appendToSubs(lines, start) {\n        let i = lines.length;\n        while (--i >= 0) {\n            const paragraphInfos = PARAG.exec(lines[i]);\n            if (!Array.isArray(paragraphInfos)) {\n                continue;\n            }\n            const [, className, txt] = paragraphInfos;\n            if (klass !== className) {\n                continue;\n            }\n            if (txt === \"&nbsp;\") {\n                subs[subs.length - 1].end = start;\n            }\n            else {\n                const wrapperEl = document.createElement(\"DIV\");\n                wrapperEl.className = \"rxp-texttrack-region\";\n                const divEl = document.createElement(\"DIV\");\n                divEl.className = \"rxp-texttrack-div\";\n                divEl.style.position = \"absolute\";\n                divEl.style.bottom = \"0\";\n                divEl.style.width = \"100%\";\n                divEl.style.color = \"#fff\";\n                divEl.style.textShadow =\n                    \"-1px -1px 0 #000,\" +\n                        \"1px -1px 0 #000,\" +\n                        \"-1px 1px 0 #000,\" +\n                        \"1px 1px 0 #000\";\n                const pEl = document.createElement(\"div\");\n                pEl.className = \"rxp-texttrack-p\";\n                if (isNonEmptyString(pCSS)) {\n                    pEl.style.cssText = pCSS;\n                }\n                const textEls = txt.split(BR);\n                for (let j = 0; j < textEls.length; j++) {\n                    if (j !== 0) {\n                        pEl.appendChild(document.createElement(\"BR\"));\n                    }\n                    const spanEl = document.createElement(\"SPAN\");\n                    spanEl.className = \"rxp-texttrack-span\";\n                    spanEl.textContent = decodeEntities(textEls[j]);\n                    pEl.appendChild(spanEl);\n                }\n                divEl.appendChild(pEl);\n                wrapperEl.appendChild(divEl);\n                subs.push({\n                    element: wrapperEl,\n                    start: start + timeOffset,\n                    end: -1 /* Will be updated on a following iteration */,\n                });\n            }\n        }\n    }\n}\nexport default parseSami;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport makeVTTCue from \"../../../compat/make_vtt_cue\";\nimport isNonEmptyString from \"../../../utils/is_non_empty_string\";\nimport isNullOrUndefined from \"../../../utils/is_null_or_undefined\";\nconst HTML_ENTITIES = /&#([0-9]+);/g;\nconst BR = /<br>/gi;\nconst STYLE = /<style[^>]*>([\\s\\S]*?)<\\/style[^>]*>/i;\nconst PARAG = /\\s*<p (?:class=([^>]+))?>(.*)/i;\nconst START = /<sync[^>]+?start=\"?([0-9]*)\"?[^0-9]/i;\n/**\n * Creates an array of VTTCue/TextTrackCue from a given array of cue objects.\n * @param {Array.<Object>} cuesArray - Objects containing the start, end and\n * text.\n * @returns {Array.<VTTCue>}\n */\nfunction createCuesFromArray(cuesArray) {\n    const nativeCues = [];\n    for (let i = 0; i < cuesArray.length; i++) {\n        const { start, end, text } = cuesArray[i];\n        if (isNonEmptyString(text) && !isNullOrUndefined(end)) {\n            const cue = makeVTTCue(start, end, text);\n            if (cue !== null) {\n                nativeCues.push(cue);\n            }\n        }\n    }\n    return nativeCues;\n}\n/**\n * Returns classnames for every languages.\n * @param {string} str\n * @returns {Object}\n */\nfunction getClassNameByLang(str) {\n    const ruleRe = /\\.(\\S+)\\s*{([^}]*)}/gi;\n    const langs = {};\n    let m = ruleRe.exec(str);\n    while (Array.isArray(m)) {\n        const name = m[1];\n        const lang = getCSSProperty(m[2], \"lang\");\n        if (!isNullOrUndefined(name) && !isNullOrUndefined(lang)) {\n            langs[lang] = name;\n        }\n        m = ruleRe.exec(str);\n    }\n    return langs;\n}\n/**\n * @param {string} str - entire CSS rule\n * @param {string} name - name of the property\n * @returns {string|null} - value of the property. Null if not found.\n */\nfunction getCSSProperty(str, name) {\n    const matches = new RegExp(\"\\\\s*\" + name + \":\\\\s*(\\\\S+);\", \"i\").exec(str);\n    return Array.isArray(matches) ? matches[1] : null;\n}\n/**\n * Decode HMTL formatting into a string.\n * @param {string} text\n * @returns {string}\n */\nfunction decodeEntities(text) {\n    return text\n        .replace(BR, \"\\n\")\n        .replace(HTML_ENTITIES, (_, $1) => String.fromCharCode(Number($1)));\n}\n/**\n * Because sami is not really html... we have to use\n * some kind of regular expressions to parse it...\n * the cthulhu way :)\n * The specification being quite clunky, this parser\n * may not work for every sami input.\n *\n * @param {string} smi\n * @param {Number} timeOffset\n * @param {string} lang\n * @returns {Array.<VTTCue|TextTrackCue>}\n */\nfunction parseSami(smi, timeOffset, lang) {\n    const syncOpen = /<sync[ >]/gi;\n    const syncClose = /<sync[ >]|<\\/body>/gi;\n    const subs = [];\n    const styleMatches = STYLE.exec(smi);\n    const css = styleMatches !== null ? styleMatches[1] : \"\";\n    let up;\n    let to;\n    // FIXME Is that wanted?\n    // previously written as let to = SyncClose.exec(smi); but never used\n    syncClose.exec(smi);\n    const langs = getClassNameByLang(css);\n    let klass;\n    if (isNonEmptyString(lang)) {\n        klass = langs[lang];\n        if (klass === undefined) {\n            throw new Error(`sami: could not find lang ${lang} in CSS`);\n        }\n    }\n    while (true) {\n        up = syncOpen.exec(smi);\n        to = syncClose.exec(smi);\n        if (up === null && to === null) {\n            break;\n        }\n        if (up === null || to === null || up.index >= to.index) {\n            throw new Error(\"parse error\");\n        }\n        const str = smi.slice(up.index, to.index);\n        const tim = START.exec(str);\n        if (tim === null) {\n            throw new Error(\"parse error (sync time attribute)\");\n        }\n        const start = +tim[1];\n        if (isNaN(start)) {\n            throw new Error(\"parse error (sync time attribute NaN)\");\n        }\n        appendToSubs(str.split(\"\\n\"), start / 1000);\n    }\n    return createCuesFromArray(subs);\n    function appendToSubs(lines, start) {\n        let i = lines.length;\n        let m;\n        while (--i >= 0) {\n            m = PARAG.exec(lines[i]);\n            if (m === null) {\n                continue;\n            }\n            const [, kl, txt] = m;\n            if (klass !== kl) {\n                continue;\n            }\n            if (txt === \"&nbsp;\") {\n                subs[subs.length - 1].end = start;\n            }\n            else {\n                subs.push({ text: decodeEntities(txt), start: start + timeOffset });\n            }\n        }\n    }\n}\nexport default parseSami;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport isNonEmptyString from \"../../../utils/is_non_empty_string\";\n/**\n * Returns the first line that is not apart of the given cue block.\n * The index given can be anywhere in a known cue block.\n *\n * This function is extra-resilient due to observed real-life malformed\n * subtitles.\n * Basically, it allows some deviation from the specification as long as the\n * intent is pretty clear.\n * @param {Array<string>} linified - Whole srt. Line by line.\n * @param {number} startIndex - Index in `linified` of the first line within the\n * block.\n * @returns {number}\n */\nexport default function findEndOfCueBlock(linified, startIndex) {\n    let firstEmptyLineIndex = startIndex + 1;\n    // continue incrementing i until either:\n    //   - an empty line\n    //   - the end\n    while (isNonEmptyString(linified[firstEmptyLineIndex])) {\n        firstEmptyLineIndex++;\n    }\n    return firstEmptyLineIndex;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport isNonEmptyString from \"../../../utils/is_non_empty_string\";\nimport findEndOfCueBlock from \"./find_end_of_cue_block\";\n/**\n * Get cue blocks from a srt file.\n * @param {Array.<string>} linified - Whole srt file. Each new element in this\n * array is a new line.\n * @returns {Array.<Array.<string>>}\n */\nexport default function getCueBlocks(linified) {\n    const cueBlocks = [];\n    for (let i = 0; i < linified.length; i++) {\n        if (isNonEmptyString(linified[i])) {\n            const endOfCue = findEndOfCueBlock(linified, i);\n            const cueBlockCandidate = linified.slice(i, endOfCue);\n            if (cueBlockCandidate.length > 0) {\n                if (cueBlockCandidate.length === 1) {\n                    if (cueBlockCandidate[0].indexOf(\"-->\") >= 0) {\n                        cueBlocks.push(cueBlockCandidate);\n                    }\n                }\n                else {\n                    if (cueBlockCandidate[1].indexOf(\"-->\") >= 0 ||\n                        cueBlockCandidate[0].indexOf(\"-->\") >= 0) {\n                        cueBlocks.push(cueBlockCandidate);\n                    }\n                }\n            }\n            i = endOfCue;\n        }\n    }\n    return cueBlocks;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * /!\\ This file is feature-switchable.\n * It always should be imported through the `features` object.\n */\n// Parse SRT subtitles into HTML.\n// Done for fun. Understand <b>, <i>, <u> and <font color=\"#ff0000\" /> type\n// of tags.\nimport getCueBlocks from \"./get_cue_blocks\";\nimport parseCueBlock from \"./parse_cue\";\n/**\n * @param {string} srtStr\n * @param {Number} timeOffset\n * @returns {Array.<Object>}\n */\nexport default function parseSRTStringToHTML(srtStr, timeOffset) {\n    // Even if srt only authorize CRLF, we will also take LF or CR as line\n    // terminators for resilience\n    const lines = srtStr.split(/\\r\\n|\\n|\\r/);\n    const cueBlocks = getCueBlocks(lines);\n    const cues = [];\n    for (const cueBlock of cueBlocks) {\n        const cueObject = parseCueBlock(cueBlock, timeOffset);\n        if (cueObject !== null) {\n            const htmlCue = toHTML(cueObject);\n            if (htmlCue !== null) {\n                cues.push(htmlCue);\n            }\n        }\n    }\n    return cues;\n}\n/**\n * @param {Object} cueObj\n * @param {number} cueObj.start\n * @param {number} cueObj.end\n * @param {Array.<string>} cueObj.payload\n * @returns {Object|null}\n */\nfunction toHTML(cueObj) {\n    const { start, end, payload } = cueObj;\n    const pEl = document.createElement(\"div\");\n    pEl.className = \"rxp-texttrack-p\";\n    pEl.style.fontSize = \"28px\";\n    pEl.style.position = \"absolute\";\n    pEl.style.bottom = \"5%\";\n    pEl.style.width = \"100%\";\n    pEl.style.textAlign = \"center\";\n    pEl.style.color = \"#fff\";\n    pEl.style.textShadow =\n        \"-1px -1px 2px #000,\" +\n            \"1px -1px 2px #000,\" +\n            \"-1px 1px 2px #000,\" +\n            \"1px 1px 2px #000\";\n    for (let i = 0; i < payload.length; i++) {\n        if (i !== 0) {\n            pEl.appendChild(document.createElement(\"br\"));\n        }\n        const span = generateSpansFromSRTText(payload[i]);\n        pEl.appendChild(span);\n    }\n    return {\n        start,\n        end,\n        element: pEl,\n    };\n}\n/**\n * Take a single srt line and convert it into a span with the right style while\n * avoiding XSS.\n * What we do is set a whitelist of authorized tags, and recreate the\n * corresponding tag from scratch.\n * Supported tags:\n *   - <b>: make content bold\n *   - <i>: make content italic\n *   - <u>: draw underline on content\n *   - <font color=\"x\">: add color x to the content\n * @param {string} text\n * @returns {HTMLElement}\n */\nfunction generateSpansFromSRTText(text) {\n    const secureDiv = document.createElement(\"div\");\n    secureDiv.innerHTML = text;\n    const _loop = function (node) {\n        const childNodes = node.childNodes;\n        const span = document.createElement(\"span\");\n        span.className = \"rxp-texttrack-span\";\n        for (let i = 0; i < childNodes.length; i++) {\n            const currentNode = childNodes[i];\n            if (currentNode.nodeName === \"#text\") {\n                const linifiedText = currentNode.wholeText.split(\"\\n\");\n                for (let line = 0; line < linifiedText.length; line++) {\n                    if (line !== 0) {\n                        span.appendChild(document.createElement(\"br\"));\n                    }\n                    if (linifiedText[line].length > 0) {\n                        const textNode = document.createTextNode(linifiedText[line]);\n                        span.appendChild(textNode);\n                    }\n                }\n            }\n            else if (currentNode.nodeName === \"B\") {\n                const spanChild = _loop(currentNode);\n                spanChild.style.fontWeight = \"bold\";\n                span.appendChild(spanChild);\n            }\n            else if (currentNode.nodeName === \"I\") {\n                const spanChild = _loop(currentNode);\n                spanChild.style.fontStyle = \"italic\";\n                span.appendChild(spanChild);\n            }\n            else if (currentNode.nodeName === \"U\") {\n                const spanChild = _loop(currentNode);\n                spanChild.style.textDecoration = \"underline\";\n                span.appendChild(spanChild);\n            }\n            else if (isNodeFontWithColorProp(currentNode) &&\n                typeof currentNode.color === \"string\") {\n                // TODO loop through attributes to find color?\n                const spanChild = _loop(currentNode);\n                spanChild.style.color = currentNode.color;\n                span.appendChild(spanChild);\n            }\n            else {\n                const spanChild = _loop(currentNode);\n                span.appendChild(spanChild);\n            }\n        }\n        return span;\n    };\n    return _loop(secureDiv);\n}\n/**\n * Returns `true` if the given node is a `<font>` element which contains a\n * `color` attribute.\n * @param {Node} node\n * @returns {boolean}\n */\nfunction isNodeFontWithColorProp(node) {\n    return node.nodeName === \"FONT\" && \"color\" in node;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport makeVTTCue from \"../../../compat/make_vtt_cue\";\nimport getCueBlocks from \"./get_cue_blocks\";\nimport parseCueBlock from \"./parse_cue\";\n/**\n * Parse whole srt file into an array of cues, to be inserted in a video's\n * TrackElement.\n * @param {string} srtStr\n * @param {Number} timeOffset\n * @returns {Array.<VTTCue|TextTrackCue>}\n */\nexport default function parseSRTStringToVTTCues(srtStr, timeOffset) {\n    // Even if srt only authorize CRLF, we will also take LF or CR as line\n    // terminators for resilience\n    const lines = srtStr.split(/\\r\\n|\\n|\\r/);\n    const cueBlocks = getCueBlocks(lines);\n    const cues = [];\n    for (let i = 0; i < cueBlocks.length; i++) {\n        const cueObject = parseCueBlock(cueBlocks[i], timeOffset);\n        if (cueObject !== null) {\n            const nativeCue = toNativeCue(cueObject);\n            if (nativeCue !== null) {\n                cues.push(nativeCue);\n            }\n        }\n    }\n    return cues;\n}\n/**\n * @param {Object} cue Object\n * @returns {TextTrackCue|VTTCue|null}\n */\nfunction toNativeCue(cueObj) {\n    const { start, end, payload } = cueObj;\n    const text = payload.join(\"\\n\");\n    return makeVTTCue(start, end, text);\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport isNonEmptyString from \"../../../utils/is_non_empty_string\";\nimport parseTimestamp from \"./parse_timestamp\";\n/**\n * Parse cue block into a cue object which contains:\n *   - start {number}: the start of the cue as a timestamp in seconds\n *   - end {number}: the end of the cue as a timestamp in seconds\n *   - payload {Array.<string>}: the payload of the cue\n * @param {Array.<string>} cueLines\n * @param {Number} timeOffset\n * @returns {Object}\n */\nexport default function parseCueBlock(cueLines, timeOffset) {\n    if (cueLines.length === 0) {\n        return null;\n    }\n    let startTimeString;\n    let endTimeString;\n    let payload = [];\n    // normally in srt, the timing is at second position.\n    // We still authorize to put it in the first position for resilience\n    if (isNonEmptyString(cueLines[1]) && cueLines[1].indexOf(\"-->\") !== -1) {\n        [startTimeString, endTimeString] = cueLines[1].split(\"-->\").map((s) => s.trim());\n        payload = cueLines.slice(2, cueLines.length);\n    }\n    if (!isNonEmptyString(startTimeString) || !isNonEmptyString(endTimeString)) {\n        // Try to see if we find them in the first position\n        [startTimeString, endTimeString] = cueLines[0].split(\"-->\").map((s) => s.trim());\n        payload = cueLines.slice(1, cueLines.length);\n    }\n    if (!isNonEmptyString(startTimeString) || !isNonEmptyString(endTimeString)) {\n        // if the time is still not found, exit\n        return null;\n    }\n    const start = parseTimestamp(startTimeString);\n    const end = parseTimestamp(endTimeString);\n    if (start === undefined || end === undefined) {\n        return null;\n    }\n    return { start: start + timeOffset, end: end + timeOffset, payload };\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport isNonEmptyString from \"../../../utils/is_non_empty_string\";\n/**\n * Parse a single srt timestamp into seconds\n * @param {string} timestampString\n * @returns {Number|undefined}\n */\nexport default function parseTimestamp(timestampString) {\n    const splittedTS = timestampString.split(\":\");\n    if (isNonEmptyString(splittedTS[2])) {\n        const hours = parseInt(splittedTS[0], 10);\n        const minutes = parseInt(splittedTS[1], 10);\n        const seconds = parseFloat(splittedTS[2].replace(\",\", \".\"));\n        if (isNaN(hours) || isNaN(minutes) || isNaN(seconds)) {\n            return undefined;\n        }\n        return hours * 60 * 60 + minutes * 60 + seconds;\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../../log\";\nimport isNonEmptyString from \"../../../utils/is_non_empty_string\";\nconst CELL_RESOLUTION_REGEXP = /(\\d+) (\\d+)/;\n/**\n * Returns global parameters from a TTML Document\n * @param {Element} tt - <tt> node\n * @throws Error - Throws if the spacing style is invalid.\n * @returns {Object}\n */\nexport default function getParameters(tt) {\n    const parsedFrameRate = tt.getAttribute(\"ttp:frameRate\");\n    const parsedSubFrameRate = tt.getAttribute(\"ttp:subFramRate\");\n    const parsedTickRate = tt.getAttribute(\"ttp:tickRate\");\n    const parsedFrameRateMultiplier = tt.getAttribute(\"ttp:frameRateMultiplier\");\n    const parsedSpaceStyle = tt.getAttribute(\"xml:space\");\n    const parsedCellResolution = tt.getAttribute(\"ttp:cellResolution\");\n    let cellResolution = {\n        columns: 32,\n        rows: 15,\n    };\n    if (parsedCellResolution !== null) {\n        const extractedData = CELL_RESOLUTION_REGEXP.exec(parsedCellResolution);\n        if (extractedData === null || extractedData.length < 3) {\n            log.warn(\"TTML Parser: Invalid cellResolution\");\n        }\n        else {\n            const columns = parseInt(extractedData[1], 10);\n            const rows = parseInt(extractedData[2], 10);\n            if (isNaN(columns) || isNaN(rows)) {\n                log.warn(\"TTML Parser: Invalid cellResolution\");\n            }\n            else {\n                cellResolution = { columns, rows };\n            }\n        }\n    }\n    if (isNonEmptyString(parsedSpaceStyle) &&\n        parsedSpaceStyle !== \"default\" &&\n        parsedSpaceStyle !== \"preserve\") {\n        throw new Error(\"Invalid spacing style\");\n    }\n    let nbFrameRate = Number(parsedFrameRate);\n    if (isNaN(nbFrameRate) || nbFrameRate <= 0) {\n        nbFrameRate = 30;\n    }\n    let nbSubFrameRate = Number(parsedSubFrameRate);\n    if (isNaN(nbSubFrameRate) || nbSubFrameRate <= 0) {\n        nbSubFrameRate = 1;\n    }\n    let nbTickRate = Number(parsedTickRate);\n    if (isNaN(nbTickRate) || nbTickRate <= 0) {\n        nbTickRate = undefined;\n    }\n    let frameRate = nbFrameRate;\n    const subFrameRate = nbSubFrameRate !== null && nbSubFrameRate !== void 0 ? nbSubFrameRate : 1;\n    const spaceStyle = parsedSpaceStyle !== null && parsedSpaceStyle !== void 0 ? parsedSpaceStyle : \"default\";\n    const tickRate = nbTickRate !== null && nbTickRate !== void 0 ? nbTickRate : nbFrameRate * nbSubFrameRate;\n    if (parsedFrameRateMultiplier !== null) {\n        const multiplierResults = /^(\\d+) (\\d+)$/g.exec(parsedFrameRateMultiplier);\n        if (multiplierResults !== null) {\n            const numerator = Number(multiplierResults[1]);\n            const denominator = Number(multiplierResults[2]);\n            const multiplierNum = numerator / denominator;\n            frameRate = nbFrameRate * multiplierNum;\n        }\n    }\n    return { cellResolution, tickRate, frameRate, subFrameRate, spaceStyle };\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport arrayFind from \"../../../utils/array_find\";\nimport arrayIncludes from \"../../../utils/array_includes\";\nimport isNonEmptyString from \"../../../utils/is_non_empty_string\";\nimport startsWith from \"../../../utils/starts_with\";\n/**\n * Retrieve the attributes given in arguments in the given nodes and their\n * associated style(s)/region.\n * The first notion of the attribute encountered will be taken (by looping\n * through the given nodes in order).\n *\n * TODO manage IDREFS (plural) for styles and regions, that is, multiple one\n * @param {Array.<string>} attributes\n * @param {Array.<Node>} nodes\n * @param {Array.<Object>} styles\n * @param {Array.<Object>} regions\n * @returns {Object}\n */\nexport function getStylingAttributes(attributes, nodes, styles, regions) {\n    const currentStyle = {};\n    const leftAttributes = attributes.slice();\n    for (let i = 0; i <= nodes.length - 1; i++) {\n        const node = nodes[i];\n        if (node !== undefined) {\n            let styleID;\n            let regionID;\n            // 1. the style is directly set on a \"tts:\" attribute\n            if (node.nodeType === Node.ELEMENT_NODE) {\n                const element = node;\n                for (let j = 0; j <= element.attributes.length - 1; j++) {\n                    const attribute = element.attributes[j];\n                    const name = attribute.name;\n                    if (name === \"style\") {\n                        styleID = attribute.value;\n                    }\n                    else if (name === \"region\") {\n                        regionID = attribute.value;\n                    }\n                    else {\n                        const nameWithoutTTS = name.substring(4);\n                        if (arrayIncludes(leftAttributes, nameWithoutTTS)) {\n                            currentStyle[nameWithoutTTS] = attribute.value;\n                            leftAttributes.splice(j, 1);\n                            if (leftAttributes.length === 0) {\n                                return currentStyle;\n                            }\n                        }\n                    }\n                }\n            }\n            // 2. the style is referenced on a \"style\" attribute\n            if (isNonEmptyString(styleID)) {\n                const style = arrayFind(styles, (x) => x.id === styleID);\n                if (style !== undefined) {\n                    for (let j = 0; j <= leftAttributes.length - 1; j++) {\n                        const attribute = leftAttributes[j];\n                        if (!isNonEmptyString(currentStyle[attribute])) {\n                            if (isNonEmptyString(style.style[attribute])) {\n                                currentStyle[attribute] = style.style[attribute];\n                                leftAttributes.splice(j, 1);\n                                if (leftAttributes.length === 0) {\n                                    return currentStyle;\n                                }\n                                j--;\n                            }\n                        }\n                    }\n                }\n            }\n            // 3. the node reference a region (which can have a value for the\n            //    corresponding style)\n            if (isNonEmptyString(regionID)) {\n                const region = arrayFind(regions, (x) => x.id === regionID);\n                if (region !== undefined) {\n                    for (let j = 0; j <= leftAttributes.length - 1; j++) {\n                        const attribute = leftAttributes[j];\n                        if (!isNonEmptyString(currentStyle[attribute])) {\n                            if (isNonEmptyString(region.style[attribute])) {\n                                currentStyle[attribute] = region.style[attribute];\n                                leftAttributes.splice(j, 1);\n                                if (leftAttributes.length === 0) {\n                                    return currentStyle;\n                                }\n                                j--;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return currentStyle;\n}\n/**\n * Returns the styling directly linked to an element.\n * @param {Node} node\n * @returns {Object}\n */\nexport function getStylingFromElement(node) {\n    if (node.nodeType !== Node.ELEMENT_NODE) {\n        return {};\n    }\n    const element = node;\n    const currentStyle = {};\n    for (let i = 0; i <= element.attributes.length - 1; i++) {\n        const styleAttribute = element.attributes[i];\n        if (startsWith(styleAttribute.name, \"tts\")) {\n            const nameWithoutTTS = styleAttribute.name.substring(4);\n            currentStyle[nameWithoutTTS] = styleAttribute.value;\n        }\n    }\n    return currentStyle;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport isNonEmptyString from \"../../../utils/is_non_empty_string\";\nimport isNullOrUndefined from \"../../../utils/is_null_or_undefined\";\nimport parseTime from \"./time_parsing\";\n/**\n * Get start and end time of an element.\n * @param {Element} element\n * @param {Object} ttParams\n * @returns {Object}\n */\nexport default function getTimeDelimiters(element, ttParams) {\n    const beginAttr = element.getAttribute(\"begin\");\n    const durationAttr = element.getAttribute(\"dur\");\n    const endAttr = element.getAttribute(\"end\");\n    const start = isNonEmptyString(beginAttr) ? parseTime(beginAttr, ttParams) : null;\n    const duration = isNonEmptyString(durationAttr)\n        ? parseTime(durationAttr, ttParams)\n        : null;\n    const parsedEnd = isNonEmptyString(endAttr) ? parseTime(endAttr, ttParams) : null;\n    if (isNullOrUndefined(start) ||\n        (isNullOrUndefined(parsedEnd) && isNullOrUndefined(duration))) {\n        throw new Error(\"Invalid text cue\");\n    }\n    const end = isNullOrUndefined(parsedEnd) ? start + duration : parsedEnd;\n    return { start, end };\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Return true if no style has been already declared and no conflict is\n * detected with current cue style.\n *\n * No position, orientation and dimension style should have been set to\n * avoid any conflict.\n * @param {object} paragraphStyle\n * @returns {boolean}\n */\nexport function shouldApplyDefaultTTMLStyle(paragraphStyle) {\n    return (paragraphStyle.extent === undefined &&\n        paragraphStyle.origin === undefined &&\n        paragraphStyle.displayAlign === undefined &&\n        paragraphStyle.display === undefined &&\n        paragraphStyle.textAlign === undefined &&\n        paragraphStyle.fontSize === undefined);\n}\n/**\n * Apply a default style to TTML cue.\n *\n * The default style propose to set the cue at the bottom, centered\n * and lightly spaced apart from the edges :\n *\n *        -----------------------------------------------\n *        |                                             |\n *        |                                             |\n *        |                                             |\n *        |                                             |\n *        |                                             |\n *        |                                             |\n *        |            subtitle is displayed            |\n *        |                    here                     |\n *        -----------------------------------------------\n *\n * @param {Object} cue\n * TODO This code can be seen as risky because we might not predict every\n * possible styles that can enter in conflict.\n * A better solution should be found in the future\n */\nexport function applyDefaultTTMLStyle(paragraphStyle) {\n    paragraphStyle.extent = \"70% 20%\";\n    paragraphStyle.fontSize = \"1c\";\n    paragraphStyle.origin = \"15% 80%\";\n    paragraphStyle.displayAlign = \"before\";\n    paragraphStyle.textAlign = \"center\";\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport addClassName from \"../../../../compat/add_class_name\";\nimport log from \"../../../../log\";\nimport { REGXP_LENGTH } from \"../regexps\";\n/**\n * Apply `tts:extent` styling to an HTML element.\n * @param {HTMLElement} element\n * @param {string} extent\n */\nexport default function applyExtent(element, extent) {\n    const trimmedExtent = extent.trim();\n    if (trimmedExtent === \"auto\") {\n        return;\n    }\n    const splittedExtent = trimmedExtent.split(\" \");\n    if (splittedExtent.length !== 2) {\n        return;\n    }\n    const firstExtent = REGXP_LENGTH.exec(splittedExtent[0]);\n    const secondExtent = REGXP_LENGTH.exec(splittedExtent[1]);\n    if (firstExtent !== null && secondExtent !== null) {\n        if (firstExtent[2] === \"px\" || firstExtent[2] === \"%\" || firstExtent[2] === \"em\") {\n            element.style.width = firstExtent[1] + firstExtent[2];\n        }\n        else if (firstExtent[2] === \"c\") {\n            addClassName(element, \"proportional-style\");\n            element.setAttribute(\"data-proportional-width\", firstExtent[1]);\n        }\n        else {\n            log.warn(\"TTML Parser: unhandled extent unit:\", firstExtent[2]);\n        }\n        if (secondExtent[2] === \"px\" || secondExtent[2] === \"%\" || secondExtent[2] === \"em\") {\n            element.style.height = secondExtent[1] + secondExtent[2];\n        }\n        else if (secondExtent[2] === \"c\") {\n            addClassName(element, \"proportional-style\");\n            element.setAttribute(\"data-proportional-height\", secondExtent[1]);\n        }\n        else {\n            log.warn(\"TTML Parser: unhandled extent unit:\", secondExtent[2]);\n        }\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport addClassName from \"../../../../compat/add_class_name\";\nimport log from \"../../../../log\";\nimport { REGXP_LENGTH } from \"../regexps\";\n/**\n * Apply `tts:fontSize` styling to an HTML element.\n * @param {HTMLElement} element\n * @param {string} fontSize\n */\nexport default function applyFontSize(element, fontSize) {\n    const trimmedFontSize = fontSize.trim();\n    const splittedFontSize = trimmedFontSize.split(\" \");\n    if (splittedFontSize.length === 0) {\n        return;\n    }\n    const firstFontSize = REGXP_LENGTH.exec(splittedFontSize[0]);\n    if (firstFontSize === null) {\n        return;\n    }\n    if (firstFontSize[2] === \"px\" || firstFontSize[2] === \"em\") {\n        element.style.fontSize = firstFontSize[1] + firstFontSize[2];\n    }\n    else if (firstFontSize[2] === \"c\") {\n        element.style.position = \"relative\";\n        addClassName(element, \"proportional-style\");\n        element.setAttribute(\"data-proportional-font-size\", firstFontSize[1]);\n    }\n    else if (firstFontSize[2] === \"%\") {\n        const toNum = Number(firstFontSize[1]);\n        if (isNaN(toNum)) {\n            log.warn('TTML Parser: could not parse fontSize value \"' +\n                firstFontSize[1] +\n                '\" into a number');\n        }\n        else {\n            element.style.position = \"relative\";\n            addClassName(element, \"proportional-style\");\n            element.setAttribute(\"data-proportional-font-size\", String(toNum / 100));\n        }\n    }\n    else {\n        log.warn(\"TTML Parser: unhandled fontSize unit:\", firstFontSize[2]);\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport addClassName from \"../../../../compat/add_class_name\";\nimport log from \"../../../../log\";\nimport { REGXP_LENGTH } from \"../regexps\";\n/**\n * @param {HTMLElement} element\n * @param {string} lineHeight\n */\nexport default function applyLineHeight(element, lineHeight) {\n    const trimmedLineHeight = lineHeight.trim();\n    const splittedLineHeight = trimmedLineHeight.split(\" \");\n    if (trimmedLineHeight === \"auto\") {\n        return;\n    }\n    const firstLineHeight = REGXP_LENGTH.exec(splittedLineHeight[0]);\n    if (firstLineHeight === null) {\n        return;\n    }\n    if (firstLineHeight[2] === \"px\" ||\n        firstLineHeight[2] === \"%\" ||\n        firstLineHeight[2] === \"em\") {\n        element.style.lineHeight = firstLineHeight[1] + firstLineHeight[2];\n    }\n    else if (firstLineHeight[2] === \"c\") {\n        addClassName(element, \"proportional-style\");\n        element.setAttribute(\"data-proportional-line-height\", firstLineHeight[1]);\n    }\n    else {\n        log.warn(\"TTML Parser: unhandled lineHeight unit:\", firstLineHeight[2]);\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport addClassName from \"../../../../compat/add_class_name\";\nimport log from \"../../../../log\";\nimport { REGXP_LENGTH } from \"../regexps\";\n/**\n * @param {HTMLElement} element\n * @param {string} origin\n */\nexport default function applyOrigin(element, origin) {\n    const trimmedOrigin = origin.trim();\n    if (trimmedOrigin === \"auto\") {\n        return;\n    }\n    const splittedOrigin = trimmedOrigin.split(\" \");\n    if (splittedOrigin.length !== 2) {\n        return;\n    }\n    const firstOrigin = REGXP_LENGTH.exec(splittedOrigin[0]);\n    const secondOrigin = REGXP_LENGTH.exec(splittedOrigin[1]);\n    if (firstOrigin !== null && secondOrigin !== null) {\n        if (firstOrigin[2] === \"px\" || firstOrigin[2] === \"%\" || firstOrigin[2] === \"em\") {\n            element.style.left = firstOrigin[1] + firstOrigin[2];\n        }\n        else if (firstOrigin[2] === \"c\") {\n            addClassName(element, \"proportional-style\");\n            element.setAttribute(\"data-proportional-left\", firstOrigin[1]);\n        }\n        else {\n            log.warn(\"TTML Parser: unhandled origin unit:\", firstOrigin[2]);\n        }\n        if (secondOrigin[2] === \"px\" || secondOrigin[2] === \"%\" || secondOrigin[2] === \"em\") {\n            element.style.top = secondOrigin[1] + secondOrigin[2];\n        }\n        else if (secondOrigin[2] === \"c\") {\n            addClassName(element, \"proportional-style\");\n            element.setAttribute(\"data-proportional-top\", secondOrigin[1]);\n        }\n        else {\n            log.warn(\"TTML Parser: unhandled origin unit:\", secondOrigin[2]);\n        }\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport addClassName from \"../../../../compat/add_class_name\";\nimport log from \"../../../../log\";\nimport { REGXP_LENGTH } from \"../regexps\";\n/**\n * @param {HTMLElement} element\n * @param {string} padding\n */\nexport default function applyPadding(element, padding) {\n    const trimmedPadding = padding.trim();\n    const splittedPadding = trimmedPadding.split(\" \");\n    if (splittedPadding.length < 1) {\n        return;\n    }\n    const firstPadding = REGXP_LENGTH.exec(splittedPadding[0]);\n    if (firstPadding === null) {\n        return;\n    }\n    if (firstPadding[2] === \"px\" || firstPadding[2] === \"%\" || firstPadding[2] === \"em\") {\n        const firstPaddingValue = firstPadding[1] + firstPadding[2];\n        if (splittedPadding.length === 1) {\n            element.style.padding = firstPaddingValue;\n        }\n        else if (splittedPadding.length === 2) {\n            element.style.paddingTop = firstPaddingValue;\n            element.style.paddingBottom = firstPaddingValue;\n        }\n        else {\n            element.style.paddingTop = firstPaddingValue;\n        }\n    }\n    else if (firstPadding[2] === \"c\") {\n        addClassName(element, \"proportional-style\");\n        if (splittedPadding.length === 1) {\n            element.setAttribute(\"data-proportional-padding-top\", firstPadding[1]);\n            element.setAttribute(\"data-proportional-padding-bottom\", firstPadding[1]);\n            element.setAttribute(\"data-proportional-padding-left\", firstPadding[1]);\n            element.setAttribute(\"data-proportional-padding-right\", firstPadding[1]);\n        }\n        else if (splittedPadding.length === 2) {\n            element.setAttribute(\"data-proportional-padding-top\", firstPadding[1]);\n            element.setAttribute(\"data-proportional-padding-bottom\", firstPadding[1]);\n        }\n        else {\n            element.setAttribute(\"data-proportional-padding-top\", firstPadding[1]);\n        }\n    }\n    else {\n        log.warn(\"TTML Parser: unhandled padding unit:\", firstPadding[2]);\n    }\n    if (splittedPadding.length === 1) {\n        return;\n    }\n    const secondPadding = REGXP_LENGTH.exec(splittedPadding[1]);\n    if (secondPadding === null) {\n        return;\n    }\n    if (secondPadding[2] === \"px\" ||\n        secondPadding[2] === \"%\" ||\n        secondPadding[2] === \"em\") {\n        const secondPaddingValue = secondPadding[1] + secondPadding[2];\n        if (splittedPadding.length < 4) {\n            element.style.paddingLeft = secondPaddingValue;\n            element.style.paddingRight = secondPaddingValue;\n        }\n        else {\n            element.style.paddingRight = secondPaddingValue;\n        }\n    }\n    else if (secondPadding[2] === \"c\") {\n        addClassName(element, \"proportional-style\");\n        if (splittedPadding.length < 4) {\n            element.setAttribute(\"data-proportional-padding-left\", secondPadding[1]);\n            element.setAttribute(\"data-proportional-padding-right\", secondPadding[1]);\n        }\n        else {\n            element.setAttribute(\"data-proportional-padding-right\", secondPadding[1]);\n        }\n    }\n    else {\n        log.warn(\"TTML Parser: unhandled padding unit:\", secondPadding[2]);\n    }\n    if (splittedPadding.length === 2) {\n        return;\n    }\n    const thirdPadding = REGXP_LENGTH.exec(splittedPadding[2]);\n    if (thirdPadding === null) {\n        return;\n    }\n    if (thirdPadding[2] === \"px\" || thirdPadding[2] === \"%\" || thirdPadding[2] === \"em\") {\n        const thirdPaddingValue = thirdPadding[1] + thirdPadding[2];\n        element.style.paddingBottom = thirdPaddingValue;\n    }\n    else if (thirdPadding[2] === \"c\") {\n        addClassName(element, \"proportional-style\");\n        element.setAttribute(\"data-proportional-padding-bottom\", thirdPadding[1]);\n    }\n    else {\n        log.warn(\"TTML Parser: unhandled padding unit:\", thirdPadding[2]);\n    }\n    if (splittedPadding.length === 3) {\n        return;\n    }\n    const fourthPadding = REGXP_LENGTH.exec(splittedPadding[3]);\n    if (fourthPadding === null) {\n        return;\n    }\n    if (fourthPadding[2] === \"px\" ||\n        fourthPadding[2] === \"%\" ||\n        fourthPadding[2] === \"em\") {\n        const fourthPaddingValue = fourthPadding[1] + fourthPadding[2];\n        element.style.paddingLeft = fourthPaddingValue;\n    }\n    else if (fourthPadding[2] === \"c\") {\n        addClassName(element, \"proportional-style\");\n        element.setAttribute(\"data-proportional-padding-left\", fourthPadding[1]);\n    }\n    else {\n        log.warn(\"TTML Parser: unhandled padding unit:\", fourthPadding[2]);\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport addClassName from \"../../../../compat/add_class_name\";\nimport isNonEmptyString from \"../../../../utils/is_non_empty_string\";\nimport objectAssign from \"../../../../utils/object_assign\";\nimport { getStylingAttributes } from \"../get_styling\";\nimport { getParentDivElements, isLineBreakElement, isSpanElement } from \"../xml_utils\";\nimport applyExtent from \"./apply_extent\";\nimport applyFontSize from \"./apply_font_size\";\nimport applyLineHeight from \"./apply_line_height\";\nimport applyOrigin from \"./apply_origin\";\nimport applyPadding from \"./apply_padding\";\nimport generateCSSTextOutline from \"./generate_css_test_outline\";\nimport ttmlColorToCSSColor from \"./ttml_color_to_css_color\";\n// Styling which can be applied to <span> from any level upper.\n// Added here as an optimization\nconst SPAN_LEVEL_ATTRIBUTES = [\n    \"color\",\n    \"direction\",\n    \"display\",\n    \"fontFamily\",\n    \"fontSize\",\n    \"fontStyle\",\n    \"fontWeight\",\n    \"textDecoration\",\n    \"textOutline\",\n    \"unicodeBidi\",\n    \"visibility\",\n    \"wrapOption\",\n];\n// TODO\n// tts:showBackground (applies to region)\n// tts:zIndex (applies to region)\n/**\n * Apply style set for a singular text span of the current cue.\n * @param {HTMLElement} element - The text span\n * @param {Object} style - The style to apply\n */\nfunction applyTextStyle(element, style, shouldTrimWhiteSpace) {\n    // applies to span\n    const color = style.color;\n    if (isNonEmptyString(color)) {\n        element.style.color = ttmlColorToCSSColor(color);\n    }\n    // applies to body, div, p, region, span\n    const backgroundColor = style.backgroundColor;\n    if (isNonEmptyString(backgroundColor)) {\n        element.style.backgroundColor = ttmlColorToCSSColor(backgroundColor);\n    }\n    // applies to span\n    const textOutline = style.textOutline;\n    if (isNonEmptyString(textOutline)) {\n        const outlineData = textOutline.trim().replace(/\\s+/g, \" \").split(\" \");\n        const len = outlineData.length;\n        if (len === 3) {\n            const outlineColor = ttmlColorToCSSColor(outlineData[0]);\n            const thickness = outlineData[1];\n            element.style.textShadow = generateCSSTextOutline(outlineColor, thickness);\n        }\n        else if (isNonEmptyString(color) && len === 1) {\n            const thickness = outlineData[0];\n            element.style.textShadow = generateCSSTextOutline(color, thickness);\n        }\n        else if (len === 2) {\n            const isFirstArgAColor = /^[#A-Z]/i.test(outlineData[0]);\n            const isFirstArgANumber = /^[0-9]/.test(outlineData[0]);\n            // XOR-ing to be sure we get what we have\n            if (isFirstArgAColor !== isFirstArgANumber) {\n                if (isFirstArgAColor) {\n                    const outlineColor = ttmlColorToCSSColor(outlineData[0]);\n                    const thickness = outlineData[1];\n                    element.style.textShadow = generateCSSTextOutline(outlineColor, thickness);\n                }\n                else if (isNonEmptyString(color)) {\n                    const thickness = outlineData[0];\n                    element.style.textShadow = generateCSSTextOutline(color, thickness);\n                }\n            }\n        }\n    }\n    // applies to span\n    const textDecoration = style.textDecoration;\n    if (isNonEmptyString(textDecoration)) {\n        switch (textDecoration) {\n            case \"noUnderline\":\n            case \"noLineThrough\":\n            case \"noOverline\":\n                element.style.textDecoration = \"none\";\n                break;\n            case \"lineThrough\":\n                element.style.textDecoration = \"line-through\";\n                break;\n            default:\n                element.style.textDecoration = textDecoration;\n                break;\n        }\n    }\n    // applies to span\n    const fontFamily = style.fontFamily;\n    if (isNonEmptyString(fontFamily)) {\n        switch (fontFamily) {\n            case \"proportionalSansSerif\":\n                element.style.fontFamily = \"Arial, Helvetica, Liberation Sans, sans-serif\";\n                break;\n            // TODO monospace or sans-serif or font with both?\n            case \"monospaceSansSerif\":\n            case \"sansSerif\":\n                element.style.fontFamily = \"sans-serif\";\n                break;\n            case \"monospaceSerif\":\n            case \"default\":\n                element.style.fontFamily = \"Courier New, Liberation Mono, monospace\";\n                break;\n            // TODO font with both?\n            case \"proportionalSerif\":\n                element.style.fontFamily = \"serif\";\n                break;\n            default:\n                element.style.fontFamily = fontFamily;\n        }\n    }\n    // applies to span\n    const fontStyle = style.fontStyle;\n    if (isNonEmptyString(fontStyle)) {\n        element.style.fontStyle = fontStyle;\n    }\n    // applies to span\n    const fontWeight = style.fontWeight;\n    if (isNonEmptyString(fontWeight)) {\n        element.style.fontWeight = fontWeight;\n    }\n    // applies to span\n    const fontSize = style.fontSize;\n    if (isNonEmptyString(fontSize)) {\n        applyFontSize(element, fontSize);\n    }\n    else {\n        addClassName(element, \"proportional-style\");\n        element.setAttribute(\"data-proportional-font-size\", \"1\");\n    }\n    // applies to p, span\n    const direction = style.direction;\n    if (isNonEmptyString(direction)) {\n        element.style.direction = direction;\n    }\n    // applies to p, span\n    const unicodeBidi = style.unicodeBidi;\n    if (isNonEmptyString(unicodeBidi)) {\n        switch (unicodeBidi) {\n            case \"bidiOverride\":\n                element.style.unicodeBidi = \"bidi-override\";\n                break;\n            case \"embed\":\n                element.style.unicodeBidi = \"embed\";\n                break;\n            default:\n                element.style.unicodeBidi = \"normal\";\n        }\n    }\n    // applies to body, div, p, region, span\n    const visibility = style.visibility;\n    if (isNonEmptyString(visibility)) {\n        element.style.visibility = visibility;\n    }\n    // applies to body, div, p, region, span\n    const display = style.display;\n    if (display === \"none\") {\n        element.style.display = \"none\";\n    }\n    // applies to body, div, p, region, span\n    const wrapOption = style.wrapOption;\n    if (wrapOption === \"noWrap\") {\n        if (shouldTrimWhiteSpace) {\n            element.style.whiteSpace = \"nowrap\";\n        }\n        else {\n            element.style.whiteSpace = \"pre\";\n        }\n    }\n    else if (shouldTrimWhiteSpace) {\n        element.style.whiteSpace = \"normal\";\n    }\n    else {\n        element.style.whiteSpace = \"pre-wrap\";\n    }\n}\n/**\n * Apply style for the general text track div.\n * @param {HTMLElement} element - The <div> the style will be applied on.\n * @param {Object} style - The general style object of the paragraph.\n */\nfunction applyGeneralStyle(element, style) {\n    // Set default text color. It can be overrided by text element color.\n    element.style.color = \"white\";\n    element.style.position = \"absolute\";\n    // applies to tt, region\n    const extent = style.extent;\n    if (isNonEmptyString(extent)) {\n        applyExtent(element, extent);\n    }\n    // applies to region\n    const writingMode = style.writingMode;\n    if (isNonEmptyString(writingMode)) {\n        // TODO\n    }\n    // applies to region\n    const overflow = style.overflow;\n    element.style.overflow = isNonEmptyString(overflow) ? overflow : \"hidden\";\n    // applies to region\n    const padding = style.padding;\n    if (isNonEmptyString(padding)) {\n        applyPadding(element, padding);\n    }\n    // applies to region\n    const origin = style.origin;\n    if (isNonEmptyString(origin)) {\n        applyOrigin(element, origin);\n    }\n    // applies to region\n    const displayAlign = style.displayAlign;\n    if (isNonEmptyString(displayAlign)) {\n        element.style.display = \"flex\";\n        element.style.flexDirection = \"column\";\n        switch (displayAlign) {\n            case \"before\":\n                element.style.justifyContent = \"flex-start\";\n                break;\n            case \"center\":\n                element.style.justifyContent = \"center\";\n                break;\n            case \"after\":\n                element.style.justifyContent = \"flex-end\";\n                break;\n        }\n    }\n    // applies to region\n    const opacity = style.opacity;\n    if (isNonEmptyString(opacity)) {\n        element.style.opacity = opacity;\n    }\n    // applies to body, div, p, region, span\n    const visibility = style.visibility;\n    if (isNonEmptyString(visibility)) {\n        element.style.visibility = visibility;\n    }\n    // applies to body, div, p, region, span\n    const display = style.display;\n    if (display === \"none\") {\n        element.style.display = \"none\";\n    }\n}\n/**\n * Apply style set for a <p> element\n * @param {HTMLElement} element - The <p> element\n * @param {Object} style - The general style object of the paragraph.\n */\nfunction applyPStyle(element, style) {\n    element.style.margin = \"0px\";\n    // Set on it the default font-size, more specific font sizes may then be set\n    // on children elements.\n    // Doing this on the parent <p> elements seems to fix some CSS issues we had\n    // with too large inner line breaks spacing when the text track element was\n    // too small, for some reasons.\n    addClassName(element, \"proportional-style\");\n    element.setAttribute(\"data-proportional-font-size\", \"1\");\n    // applies to body, div, p, region, span\n    const paragraphBackgroundColor = style.backgroundColor;\n    if (isNonEmptyString(paragraphBackgroundColor)) {\n        element.style.backgroundColor = ttmlColorToCSSColor(paragraphBackgroundColor);\n    }\n    // applies to p\n    const lineHeight = style.lineHeight;\n    if (isNonEmptyString(lineHeight)) {\n        applyLineHeight(element, lineHeight);\n    }\n    // applies to p\n    const textAlign = style.textAlign;\n    if (isNonEmptyString(textAlign)) {\n        switch (textAlign) {\n            case \"center\":\n                element.style.textAlign = \"center\";\n                break;\n            case \"left\":\n            case \"start\":\n                // TODO check what start means (difference with left, writing direction?)\n                element.style.textAlign = \"left\";\n                break;\n            case \"right\":\n            case \"end\":\n                // TODO check what end means (difference with right, writing direction?)\n                element.style.textAlign = \"right\";\n                break;\n        }\n    }\n}\n/**\n * Creates span of text for the given #text element, with the right style.\n *\n * TODO create text elements as string? Might help performances.\n * @param {Element} el - the #text element, which text content should be\n * displayed\n * @param {Object} style - the style object for the given text\n * @param {Boolean} shouldTrimWhiteSpace - True if the space should be\n * trimmed.\n * @returns {HTMLElement}\n */\nfunction createTextElement(el, style, shouldTrimWhiteSpace) {\n    const textElement = document.createElement(\"span\");\n    let textContent = el.textContent === null ? \"\" : el.textContent;\n    if (shouldTrimWhiteSpace) {\n        // 1. Trim leading and trailing whitespace.\n        // 2. Collapse multiple spaces into one.\n        let trimmed = textContent.trim();\n        trimmed = trimmed.replace(/\\s+/g, \" \");\n        textContent = trimmed;\n    }\n    const textNode = document.createTextNode(textContent);\n    textElement.appendChild(textNode);\n    textElement.className = \"rxp-texttrack-span\";\n    applyTextStyle(textElement, style, shouldTrimWhiteSpace);\n    return textElement;\n}\n/**\n * Generate every text elements to display in a given paragraph.\n * @param {Element} paragraph - The <p> tag.\n * @param {Array.<Object>} regions\n * @param {Array.<Object>} styles\n * @param {Object} paragraphStyle - The general style object of the paragraph.\n * @param {Boolean} shouldTrimWhiteSpace\n * @returns {Array.<HTMLElement>}\n */\nfunction generateTextContent(paragraph, regions, styles, paragraphStyle, shouldTrimWhiteSpace) {\n    /**\n     * Recursive function, taking a node in argument and returning the\n     * corresponding array of HTMLElement in order.\n     * @param {Node} node - the node in question\n     * @param {Object} style - the current state of the style for the node.\n     * /!\\ The style object can be mutated, provide a copy of it.\n     * @param {Array.<Element>} spans - The spans parent of this node.\n     * @param {Boolean} shouldTrimWhiteSpaceFromParent - True if the space should be\n     * trimmed by default. From the parent xml:space parameter.\n     * @returns {Array.<HTMLElement>}\n     */\n    function loop(node, style, spans, shouldTrimWhiteSpaceFromParent) {\n        const childNodes = node.childNodes;\n        const elements = [];\n        for (let i = 0; i < childNodes.length; i++) {\n            const currentNode = childNodes[i];\n            if (currentNode.nodeName === \"#text\") {\n                const { backgroundColor } = getStylingAttributes([\"backgroundColor\"], spans, styles, regions);\n                if (isNonEmptyString(backgroundColor)) {\n                    style.backgroundColor = backgroundColor;\n                }\n                else {\n                    style.backgroundColor = \"\";\n                }\n                const el = createTextElement(currentNode, style, shouldTrimWhiteSpaceFromParent);\n                elements.push(el);\n            }\n            else if (isLineBreakElement(currentNode)) {\n                const br = document.createElement(\"BR\");\n                elements.push(br);\n            }\n            else if (isSpanElement(currentNode) &&\n                currentNode.nodeType === Node.ELEMENT_NODE &&\n                currentNode.childNodes.length > 0) {\n                const spaceAttribute = currentNode.getAttribute(\"xml:space\");\n                const shouldTrimWhiteSpaceOnSpan = isNonEmptyString(spaceAttribute)\n                    ? spaceAttribute === \"default\"\n                    : shouldTrimWhiteSpaceFromParent;\n                // compute the new applyable style\n                const newStyle = objectAssign({}, style, getStylingAttributes(SPAN_LEVEL_ATTRIBUTES, [currentNode], styles, regions));\n                elements.push(...loop(currentNode, newStyle, [currentNode, ...spans], shouldTrimWhiteSpaceOnSpan));\n            }\n        }\n        return elements;\n    }\n    return loop(paragraph, objectAssign({}, paragraphStyle), [], shouldTrimWhiteSpace);\n}\n/**\n * @param {Element} paragraph\n * @param {Element} body\n * @param {Array.<Object>} regions\n * @param {Array.<Object>} styles\n * @param {Object} paragraphStyle\n * @param {Object}\n * @returns {HTMLElement}\n */\nexport default function createElement(paragraph, body, regions, styles, paragraphStyle, { cellResolution, shouldTrimWhiteSpace, }) {\n    const divs = getParentDivElements(paragraph);\n    const parentElement = document.createElement(\"DIV\");\n    parentElement.className = \"rxp-texttrack-region\";\n    parentElement.setAttribute(\"data-resolution-columns\", String(cellResolution.columns));\n    parentElement.setAttribute(\"data-resolution-rows\", String(cellResolution.rows));\n    applyGeneralStyle(parentElement, paragraphStyle);\n    if (body !== null) {\n        // applies to body, div, p, region, span\n        const { bodyBackgroundColor } = getStylingAttributes([\"backgroundColor\"], [...divs, body], styles, regions);\n        if (isNonEmptyString(bodyBackgroundColor)) {\n            parentElement.style.backgroundColor = ttmlColorToCSSColor(bodyBackgroundColor);\n        }\n    }\n    const pElement = document.createElement(\"p\");\n    pElement.className = \"rxp-texttrack-p\";\n    applyPStyle(pElement, paragraphStyle);\n    const textContent = generateTextContent(paragraph, regions, styles, paragraphStyle, shouldTrimWhiteSpace);\n    for (let i = 0; i < textContent.length; i++) {\n        pElement.appendChild(textContent[i]);\n    }\n    // NOTE:\n    // The following code is for the inclusion of div elements. This has no\n    // advantage for now, and might only with future evolutions.\n    // (This is only an indication of what the base of the code could look like).\n    // if (divs.length) {\n    //   let container = parentElement;\n    //   for (let i = divs.length - 1; i >= 0; i--) {\n    //     // TODO manage style at div level?\n    //     // They are: visibility, display and backgroundColor\n    //     // All these do not have any difference if applied to the <p> element\n    //     // instead of the div.\n    //     // The advantage might only be for multiple <p> elements dispatched\n    //     // in multiple div Which we do not manage anyway for now.\n    //     const divEl = document.createElement(\"DIV\");\n    //     divEl.className = \"rxp-texttrack-div\";\n    //     container.appendChild(divEl);\n    //     container = divEl;\n    //   }\n    //   container.appendChild(pElement);\n    //   parentElement.appendChild(container);\n    // } else {\n    //   parentElement.appendChild(pElement);\n    // }\n    parentElement.appendChild(pElement);\n    return parentElement;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport isNonEmptyString from \"../../../../utils/is_non_empty_string\";\n/**\n * Try to replicate the textOutline TTML style property into CSS.\n *\n * We mock it throught the text-shadow property, translating the TTML thickness\n * into blur radius and the blur-radius into... nothing.\n *\n * @param {string} color\n * @param {string|number} thickness\n * @returns {string}\n */\nexport default function generateCSSTextOutline(color, thickness) {\n    let thick = thickness;\n    if (isNonEmptyString(thickness) && thickness.trim().endsWith(\"%\")) {\n        // As em and % are basically equivalent in CSS\n        // (they both are relative to the font-size\n        // of the current element)\n        // We convert the non supported % into the supported em\n        thick = thickness.trim().slice(0, -1);\n        thick = (parseInt(thick, 10) / 100).toString() + \"em\";\n    }\n    return (`-1px -1px ${thick} ${color},` +\n        `1px -1px ${thick} ${color},` +\n        `-1px 1px ${thick} ${color},` +\n        `1px 1px ${thick} ${color}`);\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * /!\\ This file is feature-switchable.\n * It always should be imported through the `features` object.\n */\nimport parseTTMLStringToDIV from \"./parse_ttml_to_div\";\nexport default parseTTMLStringToDIV;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport getTimeDelimiters from \"../get_time_delimiters\";\nimport createElement from \"./create_element\";\n/**\n * @param {Object} parsedCue\n * @returns {Object|null}\n */\nexport default function parseCue(parsedCue) {\n    const { paragraph, ttParams, body, regionStyles, idStyles, paragraphStyle, timeOffset, shouldTrimWhiteSpace, } = parsedCue;\n    // Disregard empty elements:\n    // TTML allows for empty elements like <div></div>.\n    // If paragraph has neither time attributes, nor\n    // non-whitespace text, don't try to make a cue out of it.\n    if (!paragraph.hasAttribute(\"begin\") &&\n        !paragraph.hasAttribute(\"end\") &&\n        /^\\s*$/.test(paragraph.textContent === null ? \"\" : paragraph.textContent)) {\n        return null;\n    }\n    const { cellResolution } = ttParams;\n    const { start, end } = getTimeDelimiters(paragraph, ttParams);\n    const element = createElement(paragraph, body, regionStyles, idStyles, paragraphStyle, {\n        cellResolution,\n        shouldTrimWhiteSpace,\n    });\n    return { start: start + timeOffset, end: end + timeOffset, element };\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport parseTtml from \"../parse_ttml\";\nimport { applyDefaultTTMLStyle, shouldApplyDefaultTTMLStyle, } from \"./apply_default_ttml_paragraph_style\";\nimport parseCue from \"./parse_cue\";\n/**\n * Create array of objects which should represent the given TTML text track.\n * These objects have the following structure\n *   - start {Number}: start time, in seconds, at which the cue should\n *     be displayed\n *   - end {Number}: end time, in seconds, at which the cue should\n *     be displayed\n *   - element {HTMLElement}: <div> element representing the cue, with the\n *     right style. This div should then be appended to an element having\n *     the exact size of the wanted region the text track provide cues for.\n *\n * TODO TTML parsing is still pretty heavy on the CPU.\n * Optimizations have been done, principally to avoid using too much XML APIs,\n * but we can still do better.\n * @param {string} str\n * @param {number} timeOffset\n */\nexport default function parseTTMLToDiv(str, timeOffset) {\n    const parsedCues = parseTtml(str, timeOffset);\n    const cues = [];\n    for (const parsedCue of parsedCues) {\n        const { paragraphStyle } = parsedCue;\n        if (shouldApplyDefaultTTMLStyle(paragraphStyle)) {\n            applyDefaultTTMLStyle(paragraphStyle);\n        }\n        const cue = parseCue(parsedCue);\n        if (cue !== null) {\n            cues.push(cue);\n        }\n    }\n    return cues;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport isNullOrUndefined from \"../../../../utils/is_null_or_undefined\";\nimport { REGXP_4_HEX_COLOR, REGXP_8_HEX_COLOR, REGXP_RGBA_COLOR, REGXP_RGB_COLOR, } from \"../regexps\";\n/**\n * Translate a color indicated in TTML-style to a CSS-style color.\n * @param {string} color\n * @returns {string} color\n */\nexport default function ttmlColorToCSSColor(color) {\n    // TODO check all possible color fomats\n    let regRes;\n    regRes = REGXP_8_HEX_COLOR.exec(color);\n    if (!isNullOrUndefined(regRes)) {\n        return (\"rgba(\" +\n            String(parseInt(regRes[1], 16)) +\n            \",\" +\n            String(parseInt(regRes[2], 16)) +\n            \",\" +\n            String(parseInt(regRes[3], 16)) +\n            \",\" +\n            String(parseInt(regRes[4], 16) / 255) +\n            \")\");\n    }\n    regRes = REGXP_4_HEX_COLOR.exec(color);\n    if (!isNullOrUndefined(regRes)) {\n        return (\"rgba(\" +\n            String(parseInt(regRes[1] + regRes[1], 16)) +\n            \",\" +\n            String(parseInt(regRes[2] + regRes[2], 16)) +\n            \",\" +\n            String(parseInt(regRes[3] + regRes[3], 16)) +\n            \",\" +\n            String(parseInt(regRes[4] + regRes[4], 16) / 255) +\n            \")\");\n    }\n    regRes = REGXP_RGB_COLOR.exec(color);\n    if (!isNullOrUndefined(regRes)) {\n        return (\"rgb(\" +\n            String(+regRes[1]) +\n            \",\" +\n            String(+regRes[2]) +\n            \",\" +\n            String(+regRes[3]) +\n            \")\");\n    }\n    regRes = REGXP_RGBA_COLOR.exec(color);\n    if (!isNullOrUndefined(regRes)) {\n        return (\"rgba(\" +\n            String(+regRes[1]) +\n            \",\" +\n            String(+regRes[2]) +\n            \",\" +\n            String(+regRes[3]) +\n            \",\" +\n            String(+regRes[4] / 255) +\n            \")\");\n    }\n    return color;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * /!\\ This file is feature-switchable.\n * It always should be imported through the `features` object.\n */\nimport parseTTMLStringToVTT from \"./parse_ttml_to_vtt\";\nexport default parseTTMLStringToVTT;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport isVTTCue from \"../../../../compat/is_vtt_cue\";\nimport makeVTTCue from \"../../../../compat/make_vtt_cue\";\nimport isNonEmptyString from \"../../../../utils/is_non_empty_string\";\nimport isNullOrUndefined from \"../../../../utils/is_null_or_undefined\";\nimport getTimeDelimiters from \"../get_time_delimiters\";\nimport { REGXP_PERCENT_VALUES } from \"../regexps\";\nimport { isLineBreakElement, isSpanElement } from \"../xml_utils\";\nconst TEXT_ALIGN_TO_LIGN_ALIGN = {\n    left: \"start\",\n    center: \"center\",\n    right: \"end\",\n    start: \"start\",\n    end: \"end\",\n};\n/**\n * @type {Object}\n */\nconst TEXT_ALIGN_TO_POSITION_ALIGN = {\n    left: \"line-left\",\n    center: \"center\",\n    right: \"line-right\",\n};\n/**\n * Parses an Element into a TextTrackCue or VTTCue.\n * /!\\ Mutates the given cueElement Element\n * @param {Element} paragraph\n * @param {Number} offset\n * @param {Array.<Object>} styles\n * @param {Array.<Object>} regions\n * @param {Object} paragraphStyle\n * @param {Object} ttParams\n * @param {Boolean} shouldTrimWhiteSpace\n * @returns {TextTrackCue|null}\n */\nexport default function parseCue(parsedCue) {\n    const { paragraph, timeOffset, paragraphStyle, ttParams, shouldTrimWhiteSpace } = parsedCue;\n    // Disregard empty elements:\n    // TTML allows for empty elements like <div></div>.\n    // If paragraph has neither time attributes, nor\n    // non-whitespace text, don't try to make a cue out of it.\n    if (!paragraph.hasAttribute(\"begin\") &&\n        !paragraph.hasAttribute(\"end\") &&\n        /^\\s*$/.test(paragraph.textContent === null ? \"\" : paragraph.textContent)) {\n        return null;\n    }\n    const { start, end } = getTimeDelimiters(paragraph, ttParams);\n    const text = generateTextContent(paragraph, shouldTrimWhiteSpace);\n    const cue = makeVTTCue(start + timeOffset, end + timeOffset, text);\n    if (cue === null) {\n        return null;\n    }\n    if (isVTTCue(cue)) {\n        addStyle(cue, paragraphStyle);\n    }\n    return cue;\n}\n/**\n * Generate text to display for a given paragraph.\n * @param {Element} paragraph - The <p> tag.\n * @param {Boolean} shouldTrimWhiteSpaceForParagraph\n * @returns {string}\n */\nfunction generateTextContent(paragraph, shouldTrimWhiteSpaceForParagraph) {\n    /**\n     * Recursive function, taking a node in argument and returning the\n     * corresponding string.\n     * @param {Node} node - the node in question\n     * @returns {string}\n     */\n    function loop(node, shouldTrimWhiteSpaceFromParent) {\n        const childNodes = node.childNodes;\n        let text = \"\";\n        for (let i = 0; i < childNodes.length; i++) {\n            const currentNode = childNodes[i];\n            if (currentNode.nodeName === \"#text\") {\n                let textContent = currentNode.textContent;\n                if (textContent === null) {\n                    textContent = \"\";\n                }\n                if (shouldTrimWhiteSpaceFromParent) {\n                    // 1. Trim leading and trailing whitespace.\n                    // 2. Collapse multiple spaces into one.\n                    let trimmed = textContent.trim();\n                    trimmed = trimmed.replace(/\\s+/g, \" \");\n                    textContent = trimmed;\n                }\n                // DOM Parser turns HTML escape caracters into caracters,\n                // that may be misinterpreted by VTTCue API (typically, less-than sign\n                // and greater-than sign can be interpreted as HTML tags signs).\n                // Original escaped caracters must be conserved.\n                const escapedTextContent = textContent\n                    .replace(/&|\\u0026/g, \"&amp;\")\n                    .replace(/<|\\u003C/g, \"&lt;\")\n                    .replace(/>|\\u2265/g, \"&gt;\")\n                    .replace(/\\u200E/g, \"&lrm;\")\n                    .replace(/\\u200F/g, \"&rlm;\")\n                    .replace(/\\u00A0/g, \"&nbsp;\");\n                text += escapedTextContent;\n            }\n            else if (isLineBreakElement(currentNode)) {\n                text += \"\\n\";\n            }\n            else if (isSpanElement(currentNode) &&\n                currentNode.nodeType === Node.ELEMENT_NODE &&\n                currentNode.childNodes.length > 0) {\n                const spaceAttribute = currentNode.getAttribute(\"xml:space\");\n                const shouldTrimWhiteSpaceForSpan = isNonEmptyString(spaceAttribute)\n                    ? spaceAttribute === \"default\"\n                    : shouldTrimWhiteSpaceFromParent;\n                text += loop(currentNode, shouldTrimWhiteSpaceForSpan);\n            }\n        }\n        return text;\n    }\n    return loop(paragraph, shouldTrimWhiteSpaceForParagraph);\n}\n/**\n * Adds applicable style properties to a cue.\n * /!\\ Mutates cue argument.\n * @param {VTTCue} cue\n * @param {Object} style\n */\nfunction addStyle(cue, style) {\n    const extent = style.extent;\n    if (isNonEmptyString(extent)) {\n        const results = REGXP_PERCENT_VALUES.exec(extent);\n        if (!isNullOrUndefined(results)) {\n            // Use width value of the extent attribute for size.\n            // Height value is ignored.\n            cue.size = Number(results[1]);\n        }\n    }\n    const writingMode = style.writingMode;\n    // let isVerticalText = true;\n    switch (writingMode) {\n        case \"tb\":\n        case \"tblr\":\n            cue.vertical = \"lr\";\n            break;\n        case \"tbrl\":\n            cue.vertical = \"rl\";\n            break;\n        default:\n            // isVerticalText = false;\n            break;\n    }\n    const origin = style.origin;\n    if (isNonEmptyString(origin)) {\n        const results = REGXP_PERCENT_VALUES.exec(origin);\n        if (!isNullOrUndefined(results)) {\n            // for vertical text use first coordinate of tts:origin\n            // to represent line of the cue and second - for position.\n            // Otherwise (horizontal), use them the other way around.\n            // if (isVerticalText) {\n            // TODO check and uncomment\n            // cue.position = Number(results[2]);\n            // cue.line = Number(results[1]);\n            // } else {\n            // TODO check and uncomment\n            // cue.position = Number(results[1]);\n            // cue.line = Number(results[2]);\n            // }\n            // A boolean indicating whether the line is an integer\n            // number of lines (using the line dimensions of the first\n            // line of the cue), or whether it is a percentage of the\n            // dimension of the video. The flag is set to true when lines\n            // are counted, and false otherwise.\n            // TODO check and uncomment\n            // cue.snapToLines = false;\n        }\n    }\n    const align = style.align;\n    if (isNonEmptyString(align)) {\n        cue.align = align;\n        if (align === \"center\") {\n            if (cue.align !== \"center\") {\n                // Workaround for a Chrome bug http://crbug.com/663797\n                // Chrome does not support align = \"center\"\n                cue.align = \"middle\";\n            }\n            cue.position = \"auto\";\n        }\n        const positionAlign = TEXT_ALIGN_TO_POSITION_ALIGN[align];\n        cue.positionAlign = positionAlign === undefined ? \"\" : positionAlign;\n        const lineAlign = TEXT_ALIGN_TO_LIGN_ALIGN[align];\n        cue.lineAlign = lineAlign === undefined ? \"\" : lineAlign;\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport parseTtml from \"../parse_ttml\";\nimport parseCue from \"./parse_cue\";\n/**\n * @param str\n * @param timeOffset\n */\nexport default function parseTtmlToNative(str, timeOffset) {\n    const parsedCues = parseTtml(str, timeOffset);\n    const cues = [];\n    for (const parsedCue of parsedCues) {\n        const cue = parseCue(parsedCue);\n        if (cue !== null) {\n            cues.push(cue);\n        }\n    }\n    return cues;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport arrayFind from \"../../../utils/array_find\";\nimport isNonEmptyString from \"../../../utils/is_non_empty_string\";\nimport objectAssign from \"../../../utils/object_assign\";\nimport getParameters from \"./get_parameters\";\nimport { getStylingAttributes, getStylingFromElement } from \"./get_styling\";\nimport resolveStylesInheritance from \"./resolve_styles_inheritance\";\nimport { getParentDivElements, getBodyNode, getRegionNodes, getStyleNodes, getTextNodes, } from \"./xml_utils\";\nconst STYLE_ATTRIBUTES = [\n    \"align\",\n    \"backgroundColor\",\n    \"color\",\n    \"direction\",\n    \"display\",\n    \"displayAlign\",\n    \"extent\",\n    \"fontFamily\",\n    \"fontSize\",\n    \"fontStyle\",\n    \"fontWeight\",\n    \"lineHeight\",\n    \"opacity\",\n    \"origin\",\n    \"overflow\",\n    \"padding\",\n    \"textAlign\",\n    \"textDecoration\",\n    \"textOutline\",\n    \"unicodeBidi\",\n    \"visibility\",\n    \"wrapOption\",\n    \"writingMode\",\n    // Not managed anywhere for now\n    // \"showBackground\",\n    // \"zIndex\",\n];\n/**\n * Create array of objects which should represent the given TTML text track.\n * TODO TTML parsing is still pretty heavy on the CPU.\n * Optimizations have been done, principally to avoid using too much XML APIs,\n * but we can still do better.\n * @param {string} str\n * @param {Number} timeOffset\n * @returns {Array.<Object>}\n */\nexport default function parseTTMLString(str, timeOffset) {\n    const cues = [];\n    const xml = new DOMParser().parseFromString(str, \"text/xml\");\n    if (xml !== null && xml !== undefined) {\n        const tts = xml.getElementsByTagName(\"tt\");\n        let tt = tts[0];\n        if (tt === undefined) {\n            // EBU-TT sometimes namespaces tt, by \"tt:\"\n            // Just catch all namespaces to play it safe\n            const namespacedTT = xml.getElementsByTagNameNS(\"*\", \"tt\");\n            tt = namespacedTT[0];\n            if (tt === undefined) {\n                throw new Error(\"invalid XML\");\n            }\n        }\n        const body = getBodyNode(tt);\n        const styleNodes = getStyleNodes(tt);\n        const regionNodes = getRegionNodes(tt);\n        const paragraphNodes = getTextNodes(tt);\n        const ttParams = getParameters(tt);\n        // construct idStyles array based on the xml as an optimization\n        const idStyles = [];\n        for (let i = 0; i <= styleNodes.length - 1; i++) {\n            const styleNode = styleNodes[i];\n            if (styleNode instanceof Element) {\n                const styleID = styleNode.getAttribute(\"xml:id\");\n                if (styleID !== null) {\n                    const subStyles = styleNode.getAttribute(\"style\");\n                    const extendsStyles = subStyles === null ? [] : subStyles.split(\" \");\n                    idStyles.push({\n                        id: styleID,\n                        style: getStylingFromElement(styleNode),\n                        extendsStyles,\n                    });\n                }\n            }\n        }\n        resolveStylesInheritance(idStyles);\n        // construct regionStyles array based on the xml as an optimization\n        const regionStyles = [];\n        for (let i = 0; i <= regionNodes.length - 1; i++) {\n            const regionNode = regionNodes[i];\n            if (regionNode instanceof Element) {\n                const regionID = regionNode.getAttribute(\"xml:id\");\n                if (regionID !== null) {\n                    let regionStyle = getStylingFromElement(regionNode);\n                    const associatedStyleID = regionNode.getAttribute(\"style\");\n                    if (isNonEmptyString(associatedStyleID)) {\n                        const style = arrayFind(idStyles, (x) => x.id === associatedStyleID);\n                        if (style !== undefined) {\n                            regionStyle = objectAssign({}, style.style, regionStyle);\n                        }\n                    }\n                    regionStyles.push({\n                        id: regionID,\n                        style: regionStyle,\n                        // already handled\n                        extendsStyles: [],\n                    });\n                }\n            }\n        }\n        // Computing the style takes a lot of ressources.\n        // To avoid too much re-computation, let's compute the body style right\n        // now and do the rest progressively.\n        // TODO Compute corresponding CSS style here (as soon as we now the TTML\n        // style) to speed up the process even more.\n        const bodyStyle = getStylingAttributes(STYLE_ATTRIBUTES, body !== null ? [body] : [], idStyles, regionStyles);\n        const bodySpaceAttribute = body !== null ? body.getAttribute(\"xml:space\") : undefined;\n        const shouldTrimWhiteSpaceOnBody = bodySpaceAttribute === \"default\" || ttParams.spaceStyle === \"default\";\n        for (let i = 0; i < paragraphNodes.length; i++) {\n            const paragraph = paragraphNodes[i];\n            if (paragraph instanceof Element) {\n                const divs = getParentDivElements(paragraph);\n                const paragraphStyle = objectAssign({}, bodyStyle, getStylingAttributes(STYLE_ATTRIBUTES, [paragraph, ...divs], idStyles, regionStyles));\n                const paragraphSpaceAttribute = paragraph.getAttribute(\"xml:space\");\n                const shouldTrimWhiteSpace = isNonEmptyString(paragraphSpaceAttribute)\n                    ? paragraphSpaceAttribute === \"default\"\n                    : shouldTrimWhiteSpaceOnBody;\n                const cue = {\n                    paragraph,\n                    timeOffset,\n                    idStyles,\n                    regionStyles,\n                    body,\n                    paragraphStyle,\n                    ttParams,\n                    shouldTrimWhiteSpace,\n                };\n                if (cue !== null) {\n                    cues.push(cue);\n                }\n            }\n        }\n    }\n    return cues;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// examples: 00:00:40:07 (7 frames) or 00:00:40:07.1 (7 frames, 1 subframe)\nconst REGXP_TIME_COLON_FRAMES = /^(\\d{2,}):(\\d{2}):(\\d{2}):(\\d{2})\\.?(\\d+)?$/;\n// examples: 00:00:40:07 (7 frames) or 00:00:40:07.1 (7 frames, 1 subframe)\nconst REGXP_TIME_COLON = /^(?:(\\d{2,}):)?(\\d{2}):(\\d{2})$/;\n// examples: 01:02:43.0345555 or 02:43.03\nconst REGXP_TIME_COLON_MS = /^(?:(\\d{2,}):)?(\\d{2}):(\\d{2}\\.\\d{2,})$/;\n// examples: 75f or 75.5f\nconst REGXP_TIME_FRAMES = /^(\\d*\\.?\\d*)f$/;\n// examples: 50t or 50.5t\nconst REGXP_TIME_TICK = /^(\\d*\\.?\\d*)t$/;\n// examples: 3.45h, 3m or 4.20s\nconst REGXP_TIME_HMS = /^(?:(\\d*\\.?\\d*)h)?(?:(\\d*\\.?\\d*)m)?(?:(\\d*\\.?\\d*)s)?(?:(\\d*\\.?\\d*)ms)?$/;\n// examples: 50% 10%\nconst REGXP_PERCENT_VALUES = /^(\\d{1,2}|100)% (\\d{1,2}|100)%$/;\nconst REGXP_LENGTH = /^((?:\\+|-)?\\d*(?:\\.\\d+)?)(px|em|c|%|rh|rw)$/;\nconst REGXP_8_HEX_COLOR = /^#([0-9A-f]{2})([0-9A-f]{2})([0-9A-f]{2})([0-9A-f]{2})$/;\nconst REGXP_4_HEX_COLOR = /^#([0-9A-f])([0-9A-f])([0-9A-f])([0-9A-f])$/;\nconst REGXP_RGB_COLOR = /^rgb\\( *(\\d+) *, *(\\d+) *, *(\\d+) *\\)/;\nconst REGXP_RGBA_COLOR = /^rgba\\( *(\\d+) *, *(\\d+) *, *(\\d+) *, *(\\d+) *\\)/;\nexport { REGXP_4_HEX_COLOR, REGXP_8_HEX_COLOR, REGXP_RGB_COLOR, REGXP_RGBA_COLOR, REGXP_LENGTH, REGXP_PERCENT_VALUES, REGXP_TIME_COLON, REGXP_TIME_COLON_FRAMES, REGXP_TIME_COLON_MS, REGXP_TIME_FRAMES, REGXP_TIME_HMS, REGXP_TIME_TICK, };\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../../log\";\nimport arrayFindIndex from \"../../../utils/array_find_index\";\nimport arrayIncludes from \"../../../utils/array_includes\";\nimport objectAssign from \"../../../utils/object_assign\";\n/**\n * Transform all styles inheriting from other styles to the same styles but with\n * the inheritance removed (by resolving those inheritance here).\n *\n * Note that the original style object is directly mutated with every\n * inheritance they had resolved and removed.\n *\n * To make a pseudo-code analogy this would be equivalent to transform those\n * two classes:\n * ```\n * class A {\n *   methodA() {}\n * }\n *\n * class B extends A {\n *   method B() {}\n * }\n * ```\n * into the same two classes without inheritance:\n * ```\n * class A {\n *   methodA() {}\n * }\n * class B {\n *   methodA() {} // inherited from class A\n *   methodB() {}\n * }\n * ```\n *\n * Doing this here allows to simplify further treatment of those styles.\n * @param {Array.<Object>} styles\n */\nexport default function resolveStylesInheritance(styles) {\n    // keep track of all the indexes parsed to avoid infinite loops\n    const recursivelyBrowsedIndexes = [];\n    function resolveStyleInheritance(styleElt, index) {\n        recursivelyBrowsedIndexes.push(index);\n        for (const extendedStyleID of styleElt.extendsStyles) {\n            const extendedStyleIndex = arrayFindIndex(styles, (x) => x.id === extendedStyleID);\n            if (extendedStyleIndex < 0) {\n                log.warn(\"TTML Parser: unknown style inheritance: \" + extendedStyleID);\n            }\n            else {\n                const extendedStyle = styles[extendedStyleIndex];\n                if (arrayIncludes(recursivelyBrowsedIndexes, extendedStyleIndex)) {\n                    log.warn(\"TTML Parser: infinite style inheritance loop avoided\");\n                }\n                else {\n                    resolveStyleInheritance(extendedStyle, extendedStyleIndex);\n                }\n                styleElt.style = objectAssign({}, extendedStyle.style, styleElt.style);\n            }\n        }\n        styleElt.extendsStyles.length = 0;\n    }\n    for (let i = 0; i < styles.length; i++) {\n        resolveStyleInheritance(styles[i], i);\n        recursivelyBrowsedIndexes.length = 0; // reset\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { REGXP_TIME_COLON, REGXP_TIME_COLON_FRAMES, REGXP_TIME_COLON_MS, REGXP_TIME_FRAMES, REGXP_TIME_HMS, REGXP_TIME_TICK, } from \"./regexps\";\n/**\n * Parses a TTML time into seconds.\n * @param {string} text\n * @param {Object} ttParams\n * @returns {Number|undefined}\n */\nfunction parseTime(text, ttParams) {\n    if (REGXP_TIME_COLON_FRAMES.test(text)) {\n        return parseColonTimeWithFrames(ttParams, text);\n    }\n    else if (REGXP_TIME_COLON.test(text)) {\n        return parseTimeFromRegExp(REGXP_TIME_COLON, text);\n    }\n    else if (REGXP_TIME_COLON_MS.test(text)) {\n        return parseTimeFromRegExp(REGXP_TIME_COLON_MS, text);\n    }\n    else if (REGXP_TIME_FRAMES.test(text)) {\n        return parseFramesTime(ttParams, text);\n    }\n    else if (REGXP_TIME_TICK.test(text)) {\n        return parseTickTime(ttParams, text);\n    }\n    else if (REGXP_TIME_HMS.test(text)) {\n        return parseTimeFromRegExp(REGXP_TIME_HMS, text);\n    }\n}\n/**\n * Parses a TTML time in frame format\n * @param {Object} ttParams\n * @param {string} text\n * @returns {Number}\n */\nfunction parseFramesTime(ttParams, text) {\n    // 75f or 75.5f\n    // (We cast as we're sure the regexp is respected here)\n    const results = REGXP_TIME_FRAMES.exec(text);\n    const frames = Number(results[1]);\n    return frames / ttParams.frameRate;\n}\n/**\n * Parses a TTML time in tick format\n * @param {Object} ttParams\n * @param {string} text\n * @returns {Number}\n */\nfunction parseTickTime(ttParams, text) {\n    // 50t or 50.5t\n    // (We cast as we're sure the regexp is respected here)\n    const results = REGXP_TIME_TICK.exec(text);\n    const ticks = Number(results[1]);\n    return ticks / ttParams.tickRate;\n}\n/**\n * Parses a TTML colon formatted time containing frames\n * @param {Object} ttParams\n * @param {string} text\n * @returns {Number}\n */\nfunction parseColonTimeWithFrames(ttParams, text) {\n    // 01:02:43:07 (\"07\" is frames) or 01:02:43:07.1 (subframes)\n    // (We cast as we're sure the regexp is respected here)\n    const results = REGXP_TIME_COLON_FRAMES.exec(text);\n    const hours = Number(results[1]);\n    const minutes = Number(results[2]);\n    let seconds = Number(results[3]);\n    let frames = Number(results[4]);\n    let subframes = Number(results[5]);\n    if (isNaN(subframes)) {\n        subframes = 0;\n    }\n    frames += subframes / ttParams.subFrameRate;\n    seconds += frames / ttParams.frameRate;\n    return seconds + minutes * 60 + hours * 3600;\n}\n/**\n * Parses a TTML time with a given regex. Expects regex to be some\n * sort of a time-matcher to match hours, minutes, seconds and milliseconds\n *\n * @param {RegExp} regex\n * @param {string} text\n * @returns {number|null}\n */\nfunction parseTimeFromRegExp(regex, text) {\n    const results = regex.exec(text);\n    if (results === null || results[0] === \"\") {\n        return null;\n    }\n    // This capture is optional, but will still be in the array as undefined,\n    // default to 0.\n    let hours = Number(results[1]);\n    if (isNaN(hours)) {\n        hours = 0;\n    }\n    let minutes = Number(results[2]);\n    if (isNaN(minutes)) {\n        minutes = 0;\n    }\n    let seconds = Number(results[3]);\n    if (isNaN(seconds)) {\n        seconds = 0;\n    }\n    let milliseconds = Number(results[4]);\n    if (isNaN(milliseconds)) {\n        milliseconds = 0;\n    }\n    return milliseconds / 1000 + seconds + minutes * 60 + hours * 3600;\n}\nexport default parseTime;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport isNullOrUndefined from \"../../../utils/is_null_or_undefined\";\n/**\n * Returns the parent elements which have the given tagName, by order of\n * closeness relative to our element.\n * @param {Element|Node} element\n * @param {string} tagName\n * @returns {Array.<Element>}\n */\nexport function getParentElementsByTagName(element, tagName) {\n    if (!(element.parentNode instanceof Element)) {\n        return [];\n    }\n    function constructArray(_element) {\n        const elements = [];\n        if (_element.tagName.toLowerCase() === tagName.toLowerCase()) {\n            elements.push(_element);\n        }\n        const parentNode = _element.parentNode;\n        if (parentNode instanceof Element) {\n            elements.push(...constructArray(parentNode));\n        }\n        return elements;\n    }\n    return constructArray(element.parentNode);\n}\n/**\n * Returns the parent elements which have the given tagName, by order of\n * closeness relative to our element.\n * @param {Element|Node} element\n * @returns {Array.<Element>}\n */\nexport function getParentDivElements(element) {\n    let divs = getParentElementsByTagName(element, \"div\");\n    if (divs.length === 0) {\n        const ttDivs = getParentElementsByTagName(element, \"tt:div\");\n        if (ttDivs.length > 0) {\n            divs = ttDivs;\n        }\n    }\n    return divs;\n}\n/**\n * Returns the first notion of the attribute encountered in the list of elemnts\n * given.\n * @param {string} attribute\n * @param {Array.<Element>} elements\n * @returns {string|undefined}\n */\nexport function getAttributeInElements(attribute, elements) {\n    for (let i = 0; i <= elements.length - 1; i++) {\n        const element = elements[i];\n        if (element !== undefined) {\n            const directAttrValue = element.getAttribute(attribute);\n            if (!isNullOrUndefined(directAttrValue)) {\n                return directAttrValue;\n            }\n        }\n    }\n}\n/**\n * @param {Element} tt\n * @returns {Element}\n */\nexport function getBodyNode(tt) {\n    const bodyNodes = tt.getElementsByTagName(\"body\");\n    if (bodyNodes.length > 0) {\n        return bodyNodes[0];\n    }\n    const namespacedBodyNodes = tt.getElementsByTagName(\"tt:body\");\n    if (namespacedBodyNodes.length > 0) {\n        return namespacedBodyNodes[0];\n    }\n    return null;\n}\n/**\n * @param {Element} tt - <tt> node\n * @returns {Array.<Element>}\n */\nexport function getStyleNodes(tt) {\n    const styleNodes = tt.getElementsByTagName(\"style\");\n    if (styleNodes.length > 0) {\n        return styleNodes;\n    }\n    const namespacedStyleNodes = tt.getElementsByTagName(\"tt:style\");\n    if (namespacedStyleNodes.length > 0) {\n        return namespacedStyleNodes;\n    }\n    return styleNodes;\n}\n/**\n * @param {Element} tt - <tt> node\n * @returns {Array.<Element>}\n */\nexport function getRegionNodes(tt) {\n    const regionNodes = tt.getElementsByTagName(\"region\");\n    if (regionNodes.length > 0) {\n        return regionNodes;\n    }\n    const namespacedRegionNodes = tt.getElementsByTagName(\"tt:region\");\n    if (namespacedRegionNodes.length > 0) {\n        return namespacedRegionNodes;\n    }\n    return regionNodes;\n}\n/**\n * @param {Element} tt - <tt> node\n * @returns {Array.<Element>}\n */\nexport function getTextNodes(tt) {\n    const pNodes = tt.getElementsByTagName(\"p\");\n    if (pNodes.length > 0) {\n        return pNodes;\n    }\n    const namespacedPNodes = tt.getElementsByTagName(\"tt:p\");\n    if (namespacedPNodes.length > 0) {\n        return namespacedPNodes;\n    }\n    return pNodes;\n}\n/**\n * Returns true if the given node corresponds to a TTML line break element.\n * @param {Node} node\n * @returns {boolean}\n */\nexport function isLineBreakElement(node) {\n    return node.nodeName === \"br\" || node.nodeName === \"tt:br\";\n}\n/**\n * Returns true if the given node corresponds to a TTML span element.\n * @param {Node} node\n * @returns {boolean}\n */\nexport function isSpanElement(node) {\n    return node.nodeName === \"span\" || node.nodeName === \"tt:span\";\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport isNonEmptyString from \"../../../utils/is_non_empty_string\";\nimport { findEndOfCueBlock, isStartOfCueBlock } from \"./utils\";\n/**\n * Get cue blocks from a WebVTT file.\n * @param {Array.<string>} linified - Whole WebVTT file. Each new element in\n * this array is a new line.\n * @param {number} headerOffset - index of the first line after the header.\n * Used to avoid taking the header into consideration.\n * @returns {Array.<Array.<string>>}\n */\nexport default function getCueBlocks(linified, headerOffset) {\n    const cueBlocks = [];\n    for (let i = headerOffset; i < linified.length; i++) {\n        if (isStartOfCueBlock(linified, i)) {\n            const endOfCue = findEndOfCueBlock(linified, i);\n            cueBlocks.push(linified.slice(i, endOfCue));\n            i = endOfCue;\n        }\n        else if (isNonEmptyString(linified[i])) {\n            // continue incrementing i until either:\n            //   - empty line\n            //   - end\n            while (isNonEmptyString(linified[i])) {\n                i++;\n            }\n        }\n    }\n    return cueBlocks;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport isNonEmptyString from \"../../../utils/is_non_empty_string\";\nimport { isStartOfStyleBlock } from \"./utils\";\n/**\n * Get cue blocks from a WebVTT file.\n * @param {Array.<string>} linified - Whole WebVTT file. Each new element in\n * this array is a new line.\n * @param {number} headerOffset - index of the first line after the header.\n * Used to avoid taking the header into consideration.\n * @returns {Array.<Array.<string>>}\n */\nexport default function getStyleBlocks(linified, headerOffset) {\n    const styleBlocks = [];\n    for (let i = headerOffset; i < linified.length; i++) {\n        //\n        if (isStartOfStyleBlock(linified, i)) {\n            const startOfStyleBlock = i;\n            i++;\n            // continue incrementing i until either:\n            //   - empty line\n            //   - end of file\n            while (isNonEmptyString(linified[i])) {\n                i++;\n            }\n            const styleBlock = linified.slice(startOfStyleBlock, i);\n            styleBlocks.push(styleBlock);\n        }\n        else if (isNonEmptyString(linified[i])) {\n            // continue incrementing i until either:\n            //   - empty line\n            //   - end\n            while (isNonEmptyString(linified[i])) {\n                i++;\n            }\n        }\n    }\n    return styleBlocks;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport createStyledElement from \"./create_styled_element\";\n/**\n * @param {string} text\n * @param {Array.<Object>} styleElements\n * @returns {Array.<HTMLElement>}\n */\nexport default function convertPayloadToHTML(text, styleElements) {\n    const filteredText = text\n        // Remove timestamp tags\n        .replace(/<[0-9]{2}:[0-9]{2}.[0-9]{3}>/, \"\")\n        // Remove tag content or attributes (e.g. <b dfgfdg> => <b>)\n        .replace(/<([u,i,b,c])(\\..*?)?(?: .*?)?>(.*?)<\\/\\1>/g, \"<$1$2>$3</$1$2>\");\n    const parsedWebVTT = new DOMParser().parseFromString(filteredText, \"text/html\");\n    const nodes = parsedWebVTT.body.childNodes;\n    const styledElements = [];\n    for (let i = 0; i < nodes.length; i++) {\n        styledElements.push(createStyledElement(nodes[i], styleElements));\n    }\n    return styledElements;\n}\n","/**\n * Creates default classes defined in the W3 specification\n *\n * https://www.w3.org/TR/webvtt1/#default-classes\n */\nconst colorMap = {\n    white: \"#ffffff\",\n    lime: \"#00ff00\",\n    cyan: \"#00ffff\",\n    red: \"#ff0000\",\n    yellow: \"#ffff00\",\n    magenta: \"#ff00ff\",\n    blue: \"#0000ff\",\n    black: \"#000000\",\n};\nexport default function createDefaultStyleElements() {\n    return Object.keys(colorMap).reduce((result, key) => {\n        result[key] = `color: ${colorMap[key]};`;\n        result[`bg_${key}`] = `background-color: ${colorMap[key]};`;\n        return result;\n    }, {});\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport objectValues from \"../../../../utils/object_values\";\n/**\n * Construct a DOM attribute reflecting given cue settings\n * @param {Partial<Record<string, string>>} settings\n * @returns {Attr}\n */\nexport default function createStyleAttribute(settings) {\n    const pAttr = document.createAttribute(\"style\");\n    pAttr.value = getAttrValue(settings);\n    return pAttr;\n}\nconst getAttrValue = (settings) => {\n    const hasSettings = settings !== undefined && objectValues(settings).length !== 0;\n    if (!hasSettings) {\n        return \"text-align:center\";\n    }\n    const xPositioning = getPositioningX(settings);\n    const yPositioning = getPositioningY(settings);\n    return (\"position: absolute;\" +\n        \"margin: 0;\" +\n        `transform: translate(${xPositioning.offset}%,${yPositioning.offset}%);` +\n        `width: ${getSizePercentage(settings.size)}%;` +\n        `left: ${xPositioning.position}%;` +\n        `top: ${yPositioning.position !== null ? `${yPositioning.position}%` : \"auto\"};` +\n        `text-align: ${getAlignValue(settings.align)};`);\n};\nvar PositionAlignment;\n(function (PositionAlignment) {\n    PositionAlignment[\"LINE_LEFT\"] = \"line-left\";\n    PositionAlignment[\"CENTER\"] = \"center\";\n    PositionAlignment[\"LINE_RIGHT\"] = \"line-right\";\n})(PositionAlignment || (PositionAlignment = {}));\nvar Align;\n(function (Align) {\n    Align[\"LEFT\"] = \"left\";\n    Align[\"CENTER\"] = \"center\";\n    Align[\"RIGHT\"] = \"right\";\n})(Align || (Align = {}));\nvar LineAlignment;\n(function (LineAlignment) {\n    LineAlignment[\"START\"] = \"start\";\n    LineAlignment[\"CENTER\"] = \"center\";\n    LineAlignment[\"END\"] = \"end\";\n})(LineAlignment || (LineAlignment = {}));\nconst getPositioningX = (settings) => {\n    return {\n        position: getXPositionPercentage(settings),\n        offset: getXOffsetPercentage(settings),\n    };\n};\nconst getXPositionPercentage = (settings) => {\n    const positionPercentage = getPercentageValue(settings.position);\n    if (positionPercentage !== null) {\n        return positionPercentage;\n    }\n    const align = getAlignValue(settings.align);\n    const alignMap = {\n        [Align.LEFT]: 0,\n        [Align.CENTER]: 50,\n        [Align.RIGHT]: 100,\n    };\n    return alignMap[align];\n};\nconst getXOffsetPercentage = (settings) => {\n    const getPositionAlignment = (positionSetting) => {\n        const positionRegex = /,(line-left|line-right|center)/;\n        const matches = positionRegex.exec(positionSetting);\n        if (!Array.isArray(matches) || matches.length < 2) {\n            return null;\n        }\n        return matches[1];\n    };\n    const positionAlignmentMap = {\n        [PositionAlignment.LINE_LEFT]: 0,\n        [PositionAlignment.CENTER]: -50,\n        [PositionAlignment.LINE_RIGHT]: -100,\n    };\n    const positionAlignment = settings.position !== undefined ? getPositionAlignment(settings.position) : null;\n    if (positionAlignment !== null) {\n        return positionAlignmentMap[positionAlignment];\n    }\n    const alignMap = {\n        [Align.LEFT]: 0,\n        [Align.CENTER]: -50,\n        [Align.RIGHT]: -100,\n    };\n    const align = settings.align !== undefined ? getAlignValue(settings.align) : Align.CENTER;\n    return alignMap[align];\n};\nconst getPositioningY = (settings) => {\n    return {\n        position: getYPositionPercentage(settings.line),\n        offset: getYOffsetPercentage(settings.line),\n    };\n};\nconst getYPositionPercentage = (lineSetting) => {\n    return getPercentageValue(lineSetting);\n};\nconst getYOffsetPercentage = (lineSetting) => {\n    const getLineAlignment = (line) => {\n        const positionRegex = /,(start|center|end)/;\n        const matches = positionRegex.exec(line);\n        if (!Array.isArray(matches) || matches.length < 2) {\n            return null;\n        }\n        return matches[1];\n    };\n    const lineAlignmentMap = {\n        [LineAlignment.START]: 0,\n        [LineAlignment.CENTER]: -50,\n        [LineAlignment.END]: -100,\n    };\n    if (lineSetting === undefined) {\n        return lineAlignmentMap[LineAlignment.START];\n    }\n    const lineAlignment = getLineAlignment(lineSetting);\n    return lineAlignment !== null\n        ? lineAlignmentMap[lineAlignment]\n        : lineAlignmentMap[LineAlignment.START];\n};\nconst getAlignValue = (alignSetting) => {\n    switch (alignSetting) {\n        case \"left\":\n        case \"start\":\n            return \"left\";\n        case \"right\":\n        case \"end\":\n            return \"right\";\n        default:\n            return \"center\";\n    }\n};\nconst getSizePercentage = (sizeSetting) => {\n    const defaultSize = 100;\n    return getPercentageValueOrDefault(sizeSetting, defaultSize);\n};\nconst getPercentageValueOrDefault = (percentageString, defaultValue) => {\n    const value = getPercentageValue(percentageString);\n    return value !== null ? value : defaultValue;\n};\nconst getPercentageValue = (percentageString) => {\n    if (percentageString === undefined) {\n        return null;\n    }\n    const percentageValueRegex = /^([\\d.]+)%/;\n    const matches = percentageValueRegex.exec(percentageString);\n    if (!Array.isArray(matches) || matches.length < 2) {\n        return null;\n    }\n    return parseInt(matches[1], 10);\n};\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport arrayIncludes from \"../../../../utils/array_includes\";\nimport isNonEmptyString from \"../../../../utils/is_non_empty_string\";\n/**\n * Construct an HTMLElement/TextNode representing the given node and apply\n * the right styling on it.\n * @param {Node} baseNode\n * @param {Array.<Object>} styleElements\n * @param {Array.<string>} styleClasses\n * @returns {Node}\n */\nexport default function createStyledElement(baseNode, styleElements) {\n    const HTMLTags = [\"u\", \"i\", \"b\"];\n    const authorizedNodeNames = [\"u\", \"i\", \"b\", \"c\", \"#text\"];\n    const mainNodeName = baseNode.nodeName.toLowerCase().split(\".\")[0];\n    let nodeWithStyle;\n    if (arrayIncludes(authorizedNodeNames, mainNodeName)) {\n        if (mainNodeName === \"#text\") {\n            const linifiedText = baseNode.wholeText.split(\"\\n\");\n            nodeWithStyle = document.createElement(\"span\");\n            for (let i = 0; i < linifiedText.length; i++) {\n                if (i > 0) {\n                    nodeWithStyle.appendChild(document.createElement(\"br\"));\n                }\n                if (linifiedText[i].length > 0) {\n                    const textNode = document.createTextNode(linifiedText[i]);\n                    nodeWithStyle.appendChild(textNode);\n                }\n            }\n        }\n        else {\n            const nodeClasses = baseNode.nodeName.toLowerCase().split(\".\");\n            const styleContents = [];\n            nodeClasses.forEach((nodeClass) => {\n                if (isNonEmptyString(styleElements[nodeClass])) {\n                    styleContents.push(styleElements[nodeClass]);\n                }\n            });\n            if (styleContents.length !== 0) {\n                // If style must be applied\n                const attr = document.createAttribute(\"style\");\n                styleContents.forEach((styleContent) => {\n                    attr.value += styleContent;\n                });\n                const nameClass = arrayIncludes(HTMLTags, mainNodeName) ? mainNodeName : \"span\";\n                nodeWithStyle = document.createElement(nameClass);\n                nodeWithStyle.setAttributeNode(attr);\n            }\n            else {\n                // If style mustn't be applied. Rebuild element with tag name\n                const elementTag = !arrayIncludes(HTMLTags, mainNodeName) ? \"span\" : mainNodeName;\n                nodeWithStyle = document.createElement(elementTag);\n            }\n            for (let j = 0; j < baseNode.childNodes.length; j++) {\n                const child = createStyledElement(baseNode.childNodes[j], styleElements);\n                nodeWithStyle.appendChild(child);\n            }\n        }\n    }\n    else {\n        nodeWithStyle = document.createElement(\"span\");\n        for (let j = 0; j < baseNode.childNodes.length; j++) {\n            const child = createStyledElement(baseNode.childNodes[j], styleElements);\n            nodeWithStyle.appendChild(child);\n        }\n    }\n    return nodeWithStyle;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * /!\\ This file is feature-switchable.\n * It always should be imported through the `features` object.\n */\nimport parseWebVTTToDiv from \"./parse_webvtt_to_div\";\nexport default parseWebVTTToDiv;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport isNonEmptyString from \"../../../../utils/is_non_empty_string\";\nimport createDefaultStyleElements from \"./create_default_style_elements\";\n/**\n * Parse style element from WebVTT.\n * @param {Array.<Array.<string>>} styleBlocks\n * @return {Object}\n */\nexport default function parseStyleBlocks(styleBlocks) {\n    const classes = createDefaultStyleElements();\n    let global = \"\";\n    styleBlocks.forEach((styleBlock) => {\n        if (styleBlock.length >= 2) {\n            for (let index = 1; index < styleBlock.length; index++) {\n                let line = styleBlock[index];\n                if (Array.isArray(/::cue {/.exec(line))) {\n                    line = styleBlock[++index];\n                    while (isNonEmptyString(line) &&\n                        !(Array.isArray(/}/.exec(line)) || line.length === 0)) {\n                        global += line;\n                        line = styleBlock[++index];\n                    }\n                }\n                else {\n                    const classNames = [];\n                    let cueClassLine = /::cue\\(\\.?(.*?)\\)(?:,| {)/.exec(line);\n                    while (isNonEmptyString(line) && Array.isArray(cueClassLine)) {\n                        classNames.push(cueClassLine[1]);\n                        line = styleBlock[++index];\n                        cueClassLine = /::cue\\(\\.?(.*?)\\)(?:,| {)/.exec(line);\n                    }\n                    let styleContent = \"\";\n                    while (isNonEmptyString(line) &&\n                        !(Array.isArray(/}/.exec(line)) || line.length === 0)) {\n                        styleContent += line;\n                        line = styleBlock[++index];\n                    }\n                    classNames.forEach((className) => {\n                        const styleElement = classes[className];\n                        if (styleElement === undefined) {\n                            classes[className] = styleContent;\n                        }\n                        else {\n                            classes[className] += styleContent;\n                        }\n                    });\n                }\n            }\n        }\n    });\n    return { classes, global };\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport getCueBlocks from \"../get_cue_blocks\";\nimport getStyleBlocks from \"../get_style_blocks\";\nimport parseCueBlock from \"../parse_cue_block\";\nimport { getFirstLineAfterHeader } from \"../utils\";\nimport parseStyleBlocks from \"./parse_style_block\";\nimport toHTML from \"./to_html\";\n/**\n * Parse WebVTT from text. Returns an array with:\n * - start : start of current cue, in seconds\n * - end : end of current cue, in seconds\n * - content : HTML formatted cue.\n *\n * Global style is parsed and applied to div element.\n * Specific style is parsed and applied to class element.\n *\n * @throws Error - Throws if the given WebVTT string is invalid.\n * @param {string} text - The whole webvtt subtitles to parse\n * @param {Number} timeOffset - Offset to add to start and end times, in seconds\n * @return {Array.<Object>}\n */\nexport default function parseWebVTT(text, timeOffset) {\n    const newLineChar = /\\r\\n|\\n|\\r/g; // CRLF|LF|CR\n    const linified = text.split(newLineChar);\n    const cuesArray = [];\n    if (/^WEBVTT( |\\t|\\n|\\r|$)/.exec(linified[0]) === null) {\n        throw new Error(\"Can't parse WebVTT: Invalid File.\");\n    }\n    const firstLineAfterHeader = getFirstLineAfterHeader(linified);\n    const styleBlocks = getStyleBlocks(linified, firstLineAfterHeader);\n    const cueBlocks = getCueBlocks(linified, firstLineAfterHeader);\n    const styles = parseStyleBlocks(styleBlocks);\n    for (let i = 0; i < cueBlocks.length; i++) {\n        const cueObject = parseCueBlock(cueBlocks[i], timeOffset);\n        if (cueObject !== null) {\n            const htmlCue = toHTML(cueObject, styles);\n            cuesArray.push(htmlCue);\n        }\n    }\n    return cuesArray;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport isNonEmptyString from \"../../../../utils/is_non_empty_string\";\nimport convertPayloadToHTML from \"./convert_payload_to_html\";\nimport createStyleAttribute from \"./create_style_attribute\";\n/**\n * Parse cue block into an object with the following properties:\n *   - start {number}: start time at which the cue should be displayed\n *   - end {number}: end time at which the cue should be displayed\n *   - element {HTMLElement}: the cue text, translated into an HTMLElement\n *\n * Returns undefined if the cue block could not be parsed.\n * @param {Object} cueObj\n * @param {Number} cueObj.start\n * @param {Number} cueObj.end\n * @param {Object} cueObj.settings;\n * @param {string|undefined} cueObj.header\n * @param {Array.<string>} cueObj.payload\n * @param {Object} styling\n * @param {Object} styling.classes\n * @param {string|undefined} styling.global\n * @returns {Object|undefined}\n */\nexport default function toHTML(cueObj, styling) {\n    const { start, end, settings, header, payload } = cueObj;\n    const region = document.createElement(\"div\");\n    const regionAttr = document.createAttribute(\"style\");\n    regionAttr.value =\n        \"width:100%;\" +\n            \"height:100%;\" +\n            \"display:flex;\" +\n            \"flex-direction:column;\" +\n            \"justify-content:flex-end;\" +\n            \"align-items:center;\";\n    region.setAttributeNode(regionAttr);\n    // Get content, format and apply style.\n    const pElement = document.createElement(\"p\");\n    const pAttr = createStyleAttribute(settings);\n    pElement.setAttributeNode(pAttr);\n    const spanElement = document.createElement(\"span\");\n    const attr = document.createAttribute(\"style\");\n    // set color and background-color default values, as indicated in:\n    // https://www.w3.org/TR/webvtt1/#applying-css-properties\n    attr.value = \"background-color:rgba(0,0,0,0.8);\" + \"color:white;\";\n    spanElement.setAttributeNode(attr);\n    const { global, classes } = styling;\n    const localStyle = isNonEmptyString(header) ? classes[header] : undefined;\n    const styles = [global, localStyle].filter((s) => s !== undefined).join(\"\");\n    attr.value += styles;\n    spanElement.setAttributeNode(attr);\n    convertPayloadToHTML(payload.join(\"\\n\"), classes).forEach((element) => {\n        spanElement.appendChild(element);\n    });\n    region.appendChild(pElement);\n    pElement.appendChild(spanElement);\n    return { start, end, element: region };\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * /!\\ This file is feature-switchable.\n * It always should be imported through the `features` object.\n */\nimport parseVTTStringToVTTCues from \"./parse_vtt_to_cues\";\nexport default parseVTTStringToVTTCues;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport isVTTCue from \"../../../../compat/is_vtt_cue\";\nimport getCueBlocks from \"../get_cue_blocks\";\nimport parseCueBlock from \"../parse_cue_block\";\nimport { getFirstLineAfterHeader } from \"../utils\";\nimport setSettingsOnCue from \"./set_settings_on_cue\";\nimport toNativeCue from \"./to_native_cue\";\n// Simple VTT to ICompatVTTCue parser:\n// Just parse cues and associated settings.\n// Does not take into consideration STYLE and REGION blocks.\n/**\n * Parse whole WEBVTT file into an array of cues, to be inserted in a video's\n * TrackElement.\n * @param {string} vttStr\n * @param {Number} timeOffset\n * @returns {Array.<ICompatVTTCue|TextTrackCue>}\n */\nexport default function parseVTTStringToVTTCues(vttStr, timeOffset) {\n    // WEBVTT authorize CRLF, LF or CR as line terminators\n    const lines = vttStr.split(/\\r\\n|\\n|\\r/);\n    if (!/^WEBVTT($| |\\t)/.test(lines[0])) {\n        throw new Error(\"Can't parse WebVTT: Invalid file.\");\n    }\n    const firstLineAfterHeader = getFirstLineAfterHeader(lines);\n    const cueBlocks = getCueBlocks(lines, firstLineAfterHeader);\n    const cues = [];\n    for (const cueBlock of cueBlocks) {\n        const cueObject = parseCueBlock(cueBlock, timeOffset);\n        if (cueObject !== null) {\n            const nativeCue = toNativeCue(cueObject);\n            if (nativeCue !== null) {\n                if (isVTTCue(nativeCue)) {\n                    setSettingsOnCue(cueObject.settings, nativeCue);\n                }\n                cues.push(nativeCue);\n            }\n        }\n    }\n    return cues;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport arrayIncludes from \"../../../../utils/array_includes\";\nimport isNonEmptyString from \"../../../../utils/is_non_empty_string\";\n/**\n * Add the corresponding settings on the given cue.\n * /!\\ Mutates the cue given.\n * @param {Object} settings - settings for the cue, as a key-value object.\n * @param {ICompatVTTCue|TextTrackCue} cue\n */\nexport default function setSettingsOnCue(settings, cue) {\n    if (isNonEmptyString(settings.vertical) &&\n        (settings.vertical === \"rl\" || settings.vertical === \"lr\")) {\n        cue.vertical = settings.vertical;\n    }\n    if (isNonEmptyString(settings.line)) {\n        // Capture groups:\n        //   1 -> percentage position\n        //   2 -> optional decimals from percentage position\n        //   3 -> optional follow-up of the string indicating alignment value\n        //   4 -> alignment value\n        const percentagePosition = /^(\\d+(\\.\\d+)?)%(,([a-z]+))?/;\n        const percentageMatches = percentagePosition.exec(settings.line);\n        if (Array.isArray(percentageMatches)) {\n            cue.line = Number(percentageMatches[1]);\n            cue.snapToLines = false;\n            if (arrayIncludes([\"start\", \"center\", \"end\"], percentageMatches[4])) {\n                cue.lineAlign = percentageMatches[4];\n            }\n        }\n        else {\n            // Capture groups:\n            //   1 -> line number\n            //   2 -> optional follow-up of the string indicating alignment value\n            //   3 -> alignment value\n            const linePosition = /^(-?\\d+)(,([a-z]+))?/;\n            const lineMatches = linePosition.exec(settings.line);\n            if (Array.isArray(lineMatches)) {\n                cue.line = Number(lineMatches[1]);\n                cue.snapToLines = true;\n                if (arrayIncludes([\"start\", \"center\", \"end\"], lineMatches[3])) {\n                    cue.lineAlign = lineMatches[3];\n                }\n            }\n        }\n    }\n    if (isNonEmptyString(settings.position)) {\n        const positionRegex = /^([\\d.]+)%(?:,(line-left|line-right|center))?$/;\n        const positionArr = positionRegex.exec(settings.position);\n        if (Array.isArray(positionArr) && positionArr.length >= 2) {\n            const position = parseInt(positionArr[1], 10);\n            if (!isNaN(position)) {\n                cue.position = position;\n                if (positionArr[2] !== undefined) {\n                    cue.positionAlign = positionArr[2];\n                }\n            }\n        }\n    }\n    if (isNonEmptyString(settings.size)) {\n        cue.size = settings.size;\n    }\n    if (typeof settings.align === \"string\" &&\n        arrayIncludes([\"start\", \"center\", \"end\", \"left\"], settings.align)) {\n        cue.align = settings.align;\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport makeVTTCue from \"../../../../compat/make_vtt_cue\";\n/**\n * @param {Object} cueObj\n * @returns {TextTrackCue|ICompatVTTCue|null}\n */\nexport default function toNativeCue(cueObj) {\n    const { start, end, payload } = cueObj;\n    const text = payload.join(\"\\n\");\n    return makeVTTCue(start, end, text);\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport parseTimestamp from \"./parse_timestamp\";\n/**\n * Parse the settings part of a cue, into key-value object.\n * @param {string} settingsString\n * @returns {Object}\n */\nfunction parseSettings(settingsString) {\n    const splittedSettings = settingsString.split(/ |\\t/);\n    return splittedSettings.reduce((acc, setting) => {\n        const splittedSetting = setting.split(\":\");\n        if (splittedSetting.length === 2) {\n            acc[splittedSetting[0]] = splittedSetting[1];\n        }\n        return acc;\n    }, {});\n}\n/**\n * Parse the line containing the timestamp and settings in a cue.\n * The returned object has the following properties:\n *   - start {Number}: start of the cue, in seconds\n *   - end {Number}: end of the cue, in seconds\n *   - settings {Object}: settings for the cue as a key-value object.\n * @param {string} timeString\n * @returns {Object|null}\n */\nfunction parseTimeAndSettings(timeString) {\n    // RegExp for the timestamps + settings line.\n    // Capture groups:\n    //   1 -> start timestamp\n    //   2 -> end timestamp\n    //   3 - settings\n    const lineRegex = /^([\\d:.]+)[ |\\t]+-->[ |\\t]+([\\d:.]+)[ |\\t]*(.*)$/;\n    const matches = lineRegex.exec(timeString);\n    if (matches === null) {\n        return null;\n    }\n    const start = parseTimestamp(matches[1]);\n    const end = parseTimestamp(matches[2]);\n    if (start === undefined || end === undefined) {\n        return null;\n    }\n    const settings = parseSettings(matches[3]);\n    return { start, end, settings };\n}\n/**\n * Parse cue block into a cue object which contains:\n *   - start {number}: the start of the cue as a timestamp in seconds\n *   - end {number}: the end of the cue as a timestamp in seconds\n *   - header {string|undefined}: The optional cue identifier\n *   - payload {Array.<string>}: the payload of the cue\n * @param {Array.<string>} cueLines\n * @param {Number} timeOffset\n * @returns {Object}\n */\nexport default function parseCueBlock(cueLines, timeOffset) {\n    const timingRegexp = /-->/;\n    let timeString;\n    let payload;\n    let header;\n    if (!timingRegexp.test(cueLines[0])) {\n        if (!timingRegexp.test(cueLines[1])) {\n            // not a cue\n            return null;\n        }\n        header = cueLines[0];\n        timeString = cueLines[1];\n        payload = cueLines.slice(2, cueLines.length);\n    }\n    else {\n        timeString = cueLines[0];\n        payload = cueLines.slice(1, cueLines.length);\n    }\n    const timeAndSettings = parseTimeAndSettings(timeString);\n    if (timeAndSettings === null) {\n        return null;\n    }\n    const { start, end, settings } = timeAndSettings;\n    return {\n        start: start + timeOffset,\n        end: end + timeOffset,\n        settings,\n        payload,\n        header,\n    };\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport isNonEmptyString from \"../../../utils/is_non_empty_string\";\n/**\n * Parse a single webvtt timestamp into seconds\n * @param {string} timestampString\n * @returns {Number|undefined}\n */\nexport default function parseTimestamp(timestampString) {\n    const splittedTS = timestampString.split(\":\").reverse();\n    if (isNonEmptyString(splittedTS[2]) || isNonEmptyString(splittedTS[1])) {\n        const hours = isNonEmptyString(splittedTS[2]) ? parseInt(splittedTS[2], 10) : 0;\n        const minutes = parseInt(splittedTS[1], 10);\n        const seconds = parseFloat(splittedTS[0].replace(\",\", \".\"));\n        if (isNaN(hours) || isNaN(minutes) || isNaN(seconds)) {\n            return undefined;\n        }\n        return hours * 60 * 60 + minutes * 60 + seconds;\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport isNonEmptyString from \"../../../utils/is_non_empty_string\";\n/**\n * Returns first line after the WEBVTT header.\n * That is, the line after the first blank line after the first line!\n * @param {Array.<string>} linified\n * @returns {Number}\n */\nfunction getFirstLineAfterHeader(linified) {\n    let i = 0;\n    while (i < linified.length) {\n        if (linified[i] === \"\") {\n            return i + 1;\n        }\n        i++;\n    }\n    return i;\n}\n/**\n * Returns true if the given line looks like the beginning of a Style block.\n * @param {string} text\n * @returns {Boolean}\n */\nfunction isStartOfStyleBlock(lines, index) {\n    return (typeof lines[index] === \"string\" &&\n        /^STYLE( .*)?$/g.test(lines[index]) &&\n        // A cue identifer can also contain \"STYLE\". Check that we have no timings\n        // on the second line\n        (lines[index + 1] === undefined || lines[index + 1].indexOf(\"-->\") < 0));\n}\n/**\n * Returns true if the given line looks like the beginning of a comment block.\n * @param {string} text\n * @returns {Boolean}\n */\nfunction isStartOfNoteBlock(lines, index) {\n    return (typeof lines[index] === \"string\" &&\n        /^NOTE( .*)?$/g.test(lines[index]) &&\n        // A cue identifer can also contain \"NOTE\". Check that we have no timings\n        // on the second line\n        (lines[index + 1] === undefined || lines[index + 1].indexOf(\"-->\") < 0));\n}\n/**\n * Returns true if the given line looks like the beginning of a region block.\n * @param {string} text\n * @returns {Boolean}\n */\nfunction isStartOfRegionBlock(lines, index) {\n    return (typeof lines[index] === \"string\" &&\n        /^REGION( .*)?$/g.test(lines[index]) &&\n        // A cue identifer can also contain \"REGION\". Check that we have no timings\n        // on the second line\n        (lines[index + 1] === undefined || lines[index + 1].indexOf(\"-->\") < 0));\n}\n/**\n * Returns true if the line given looks like the beginning of a cue.\n * You should provide to this function only lines following \"empty\" lines.\n * @param {Array.<string>} lines\n * @param {number} index\n * @returns {Boolean}\n */\nfunction isStartOfCueBlock(lines, index) {\n    // checked cases:\n    //   - empty lines\n    //   - start of a comment\n    //   - start of a region\n    //   - start of a style\n    // Anything else whose first or second line is a timestamp line is a cue.\n    const firstLine = lines[index];\n    if (firstLine === undefined ||\n        firstLine === \"\" ||\n        isStartOfStyleBlock(lines, index) ||\n        isStartOfRegionBlock(lines, index) ||\n        isStartOfNoteBlock(lines, index)) {\n        return false;\n    }\n    if (firstLine.indexOf(\"-->\") >= 0) {\n        return true;\n    }\n    const secondLine = lines[index + 1];\n    return secondLine !== undefined && secondLine.indexOf(\"-->\") >= 0;\n}\n/**\n * Find end of current WebVTT cue block.\n * @param {Array<string>} linified\n * @param {number} startOfCueBlock\n * @returns {number}\n */\nfunction findEndOfCueBlock(linified, startOfCueBlock) {\n    let firstEmptyLineIndex = startOfCueBlock + 1;\n    // continue incrementing i until either:\n    //   - empty line\n    //   - end\n    while (isNonEmptyString(linified[firstEmptyLineIndex])) {\n        firstEmptyLineIndex++;\n    }\n    return firstEmptyLineIndex;\n}\nexport { getFirstLineAfterHeader, isStartOfCueBlock, isStartOfNoteBlock, isStartOfRegionBlock, isStartOfStyleBlock, findEndOfCueBlock, };\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport isSeekingApproximate from \"../compat/is_seeking_approximate\";\nimport config from \"../config\";\nimport log from \"../log\";\nimport getMonotonicTimeStamp from \"../utils/monotonic_timestamp\";\nimport noop from \"../utils/noop\";\nimport objectAssign from \"../utils/object_assign\";\nimport { getBufferedTimeRange } from \"../utils/ranges\";\nimport SharedReference from \"../utils/reference\";\nimport TaskCanceller from \"../utils/task_canceller\";\nimport generateReadOnlyObserver from \"./utils/generate_read_only_observer\";\nimport ObservationPosition from \"./utils/observation_position\";\n/**\n * HTMLMediaElement Events for which playback observations are calculated and\n * emitted.\n */\nconst SCANNED_MEDIA_ELEMENTS_EVENTS = [\n    \"canplay\",\n    \"ended\",\n    \"play\",\n    \"pause\",\n    \"seeking\",\n    \"seeked\",\n    \"loadedmetadata\",\n    \"ratechange\",\n];\n/**\n * Class allowing to \"observe\" current playback conditions so the RxPlayer is\n * then able to react upon them.\n *\n * This is a central class of the RxPlayer as many modules rely on the\n * `PlaybackObserver` to know the current state of the media being played.\n *\n * You can use the PlaybackObserver to either get the last observation\n * performed, get the current media state or listen to media observation sent\n * at a regular interval.\n *\n * @class {PlaybackObserver}\n */\nexport default class PlaybackObserver {\n    /**\n     * Create a new `PlaybackObserver`, which allows to produce new \"playback\n     * observations\" on various media events and intervals.\n     *\n     * Note that creating a `PlaybackObserver` lead to the usage of resources,\n     * such as event listeners which will only be freed once the `stop` method is\n     * called.\n     * @param {HTMLMediaElement} mediaElement\n     * @param {Object} options\n     */\n    constructor(mediaElement, options) {\n        this._internalSeeksIncoming = [];\n        this._mediaElement = mediaElement;\n        this._withMediaSource = options.withMediaSource;\n        this._lowLatencyMode = options.lowLatencyMode;\n        this._canceller = new TaskCanceller();\n        this._observationRef = this._createSharedReference();\n        this._expectedSeekingPosition = null;\n        this._pendingSeek = null;\n        const onLoadedMetadata = () => {\n            if (this._pendingSeek !== null) {\n                const positionToSeekTo = this._pendingSeek;\n                this._pendingSeek = null;\n                this._actuallySetCurrentTime(positionToSeekTo);\n            }\n        };\n        mediaElement.addEventListener(\"loadedmetadata\", onLoadedMetadata);\n        this._canceller.signal.register(() => {\n            mediaElement.removeEventListener(\"loadedmetadata\", onLoadedMetadata);\n        });\n    }\n    /**\n     * Stop the `PlaybackObserver` from emitting playback observations and free all\n     * resources reserved to emitting them such as event listeners and intervals.\n     *\n     * Once `stop` is called, no new playback observation will ever be emitted.\n     *\n     * Note that it is important to call stop once the `PlaybackObserver` is no\n     * more needed to avoid unnecessarily leaking resources.\n     */\n    stop() {\n        this._canceller.cancel();\n    }\n    /**\n     * Returns the current position advertised by the `HTMLMediaElement`, in\n     * seconds.\n     * @returns {number}\n     */\n    getCurrentTime() {\n        return this._mediaElement.currentTime;\n    }\n    /**\n     * Returns the current playback rate advertised by the `HTMLMediaElement`.\n     * @returns {number}\n     */\n    getPlaybackRate() {\n        return this._mediaElement.playbackRate;\n    }\n    /**\n     * Returns the current `paused` status advertised by the `HTMLMediaElement`.\n     *\n     * Use this instead of the same status emitted on an observation when you want\n     * to be sure you're using the current value.\n     * @returns {boolean}\n     */\n    getIsPaused() {\n        return this._mediaElement.paused;\n    }\n    /**\n     * Update the current position (seek) on the `HTMLMediaElement`, by giving a\n     * new position in seconds.\n     *\n     * Note that seeks performed through this method are caracherized as\n     * \"internal\" seeks. They don't result into the exact same playback\n     * observation than regular seeks (which most likely comes from the outside,\n     * e.g. the user).\n     * @param {number} time\n     */\n    setCurrentTime(time) {\n        if (this._mediaElement.readyState >= 1) {\n            this._actuallySetCurrentTime(time);\n        }\n        else {\n            this._internalSeeksIncoming = [];\n            this._pendingSeek = time;\n            this._generateObservationForEvent(\"manual\");\n        }\n    }\n    /**\n     * Update the playback rate of the `HTMLMediaElement`.\n     * @param {number} playbackRate\n     */\n    setPlaybackRate(playbackRate) {\n        this._mediaElement.playbackRate = playbackRate;\n    }\n    /**\n     * Returns the current `readyState` advertised by the `HTMLMediaElement`.\n     * @returns {number}\n     */\n    getReadyState() {\n        return this._mediaElement.readyState;\n    }\n    /**\n     * Returns an `IReadOnlySharedReference` storing the last playback observation\n     * produced by the `PlaybackObserver` and updated each time a new one is\n     * produced.\n     *\n     * This value can then be for example listened to to be notified of future\n     * playback observations.\n     *\n     * @returns {Object}\n     */\n    getReference() {\n        return this._observationRef;\n    }\n    /**\n     * Register a callback so it regularly receives playback observations.\n     * @param {Function} cb\n     * @param {Object} params - Configuration parameters:\n     *   - `includeLastObservation`: If set to `true` the last observation will\n     *     be first emitted synchronously.\n     *   - `clearSignal`: If set, the callback will be unregistered when this\n     *     CancellationSignal emits.\n     */\n    listen(cb, params) {\n        if (this._canceller.isUsed() || params.clearSignal.isCancelled()) {\n            return noop;\n        }\n        this._observationRef.onUpdate(cb, {\n            clearSignal: params.clearSignal,\n            emitCurrentValue: params.includeLastObservation,\n        });\n    }\n    /**\n     * Generate a new playback observer which can listen to other\n     * properties and which can only be accessed to read observations (e.g.\n     * it cannot ask to perform a seek).\n     *\n     * The object returned will respect the `IReadOnlyPlaybackObserver` interface\n     * and will inherit this `PlaybackObserver`'s lifecycle: it will emit when\n     * the latter emits.\n     *\n     * As argument, this method takes a function which will allow to produce\n     * the new set of properties to be present on each observation.\n     * @param {Function} transform\n     * @returns {Object}\n     */\n    deriveReadOnlyObserver(transform) {\n        return generateReadOnlyObserver(this, transform, this._canceller.signal);\n    }\n    _actuallySetCurrentTime(time) {\n        log.info(\"API: Seeking internally\", time);\n        this._internalSeeksIncoming.push(time);\n        this._mediaElement.currentTime = time;\n    }\n    /**\n     * Creates the `IReadOnlySharedReference` that will generate playback\n     * observations.\n     * @returns {Object}\n     */\n    _createSharedReference() {\n        if (this._observationRef !== undefined) {\n            return this._observationRef;\n        }\n        const { SAMPLING_INTERVAL_MEDIASOURCE, SAMPLING_INTERVAL_LOW_LATENCY, SAMPLING_INTERVAL_NO_MEDIASOURCE, } = config.getCurrent();\n        const returnedSharedReference = new SharedReference(this._getCurrentObservation(\"init\"), this._canceller.signal);\n        let interval;\n        if (this._lowLatencyMode) {\n            interval = SAMPLING_INTERVAL_LOW_LATENCY;\n        }\n        else if (this._withMediaSource) {\n            interval = SAMPLING_INTERVAL_MEDIASOURCE;\n        }\n        else {\n            interval = SAMPLING_INTERVAL_NO_MEDIASOURCE;\n        }\n        const onInterval = () => {\n            this._generateObservationForEvent(\"timeupdate\");\n        };\n        let intervalId = setInterval(onInterval, interval);\n        SCANNED_MEDIA_ELEMENTS_EVENTS.map((eventName) => {\n            const onMediaEvent = () => {\n                restartInterval();\n                this._generateObservationForEvent(eventName);\n            };\n            this._mediaElement.addEventListener(eventName, onMediaEvent);\n            this._canceller.signal.register(() => {\n                this._mediaElement.removeEventListener(eventName, onMediaEvent);\n            });\n        });\n        this._canceller.signal.register(() => {\n            clearInterval(intervalId);\n            returnedSharedReference.finish();\n        });\n        return returnedSharedReference;\n        function restartInterval() {\n            clearInterval(intervalId);\n            intervalId = setInterval(onInterval, interval);\n        }\n    }\n    _getCurrentObservation(event) {\n        var _a, _b;\n        /** Actual event emitted through an observation. */\n        let tmpEvt = event;\n        // NOTE: `this._observationRef` may be `undefined` because we might here be\n        // called in the constructor when that property is not yet set.\n        const previousObservation = this._observationRef === undefined\n            ? getInitialObservation(this._mediaElement)\n            : this._observationRef.getValue();\n        /**\n         * If `true`, there is a seek operation ongoing but it was done from the\n         * `PlaybackObserver`'s `setCurrentTime` method, not from external code.\n         */\n        let isInternalSeeking = false;\n        /** If set, the position for which we plan to seek to as soon as possible. */\n        let pendingPosition = this._pendingSeek;\n        /** Initially-polled playback observation, before adjustments. */\n        const mediaTimings = getMediaInfos(this._mediaElement);\n        const { buffered, readyState, position, seeking } = mediaTimings;\n        if (tmpEvt === \"seeking\") {\n            // We just began seeking.\n            // Let's find out if the seek is internal or external and handle approximate\n            // seeking\n            if (this._internalSeeksIncoming.length > 0) {\n                isInternalSeeking = true;\n                tmpEvt = \"internal-seeking\";\n                const startedInternalSeekTime = this._internalSeeksIncoming.shift();\n                this._expectedSeekingPosition = isSeekingApproximate\n                    ? Math.max(position, startedInternalSeekTime !== null && startedInternalSeekTime !== void 0 ? startedInternalSeekTime : 0)\n                    : position;\n            }\n            else {\n                this._expectedSeekingPosition = position;\n            }\n        }\n        else if (seeking) {\n            // we're still seeking, this time without a \"seeking\" event so it's an\n            // already handled one, keep track of the last wanted position we wanted\n            // to seek to, to work-around devices re-seeking silently.\n            this._expectedSeekingPosition = Math.max(position, (_a = this._expectedSeekingPosition) !== null && _a !== void 0 ? _a : 0);\n        }\n        else if (isSeekingApproximate &&\n            this._expectedSeekingPosition !== null &&\n            position < this._expectedSeekingPosition) {\n            // We're on a target with aproximate seeking, we're not seeking anymore, but\n            // we're not yet at the expected seeking position.\n            // Signal to the rest of the application that the intented position is not\n            // the current position but the one contained in `this._expectedSeekingPosition`\n            pendingPosition = this._expectedSeekingPosition;\n        }\n        else {\n            this._expectedSeekingPosition = null;\n        }\n        if (seeking &&\n            previousObservation.seeking === 1 /* SeekingState.Internal */ &&\n            event !== \"seeking\") {\n            isInternalSeeking = true;\n        }\n        // NOTE: Devices which decide to not exactly seek where we want to seek\n        // (e.g. to start on an intra video frame instead) bother us when it\n        // comes to defining rebuffering and freezing statuses, because we might\n        // for example believe that we're rebuffering whereas it's just that the\n        // device decided to bring us just before the buffered data.\n        //\n        // After many major issues on those devices (namely Tizen), we decided to\n        // just consider the position WE wanted to seek to as the real current\n        // position for buffer-starvation related metrics like the current range,\n        // the bufferGap, the rebuffering status, the freezing status...\n        //\n        // This specificity should only apply to those devices, other devices rely\n        // on the actual current position.\n        const basePosition = (_b = this._expectedSeekingPosition) !== null && _b !== void 0 ? _b : position;\n        let currentRange;\n        let bufferGap;\n        if (!this._withMediaSource && buffered.length === 0 && readyState >= 3) {\n            // Sometimes `buffered` stay empty for directfile contents yet we are able\n            // to play. This seems to be linked to browser-side issues but has been\n            // encountered on enough platforms (Chrome desktop and PlayStation 4's\n            // WebKit for us to do something about it in the player.\n            currentRange = undefined;\n            bufferGap = undefined;\n        }\n        else {\n            currentRange = getBufferedTimeRange(buffered, basePosition);\n            bufferGap =\n                currentRange !== null\n                    ? currentRange.end - basePosition\n                    : // TODO null/0 would probably be\n                        // more appropriate\n                        Infinity;\n        }\n        const fullyLoaded = hasLoadedUntilTheEnd(basePosition, currentRange, mediaTimings.ended, mediaTimings.duration, this._lowLatencyMode);\n        const rebufferingStatus = getRebufferingStatus({\n            previousObservation,\n            currentObservation: mediaTimings,\n            basePosition,\n            observationEvent: tmpEvt,\n            lowLatencyMode: this._lowLatencyMode,\n            withMediaSource: this._withMediaSource,\n            bufferGap,\n            fullyLoaded,\n        });\n        const freezingStatus = getFreezingStatus(previousObservation, mediaTimings, tmpEvt, bufferGap);\n        let seekingState;\n        if (isInternalSeeking) {\n            seekingState = 1 /* SeekingState.Internal */;\n        }\n        else if (seeking) {\n            seekingState = 2 /* SeekingState.External */;\n        }\n        else {\n            seekingState = 0 /* SeekingState.None */;\n        }\n        const timings = objectAssign({}, mediaTimings, {\n            position: new ObservationPosition(mediaTimings.position, pendingPosition),\n            event: tmpEvt,\n            seeking: seekingState,\n            rebuffering: rebufferingStatus,\n            freezing: freezingStatus,\n            bufferGap,\n            currentRange,\n            fullyLoaded,\n        });\n        if (log.hasLevel(\"DEBUG\")) {\n            log.debug(\"API: current media element state tick\", \"event\", timings.event, \"position\", timings.position.getPolled(), \"seeking\", timings.seeking, \"internalSeek\", isInternalSeeking, \"rebuffering\", timings.rebuffering !== null, \"freezing\", timings.freezing !== null, \"ended\", timings.ended, \"paused\", timings.paused, \"playbackRate\", timings.playbackRate, \"readyState\", timings.readyState, \"pendingPosition\", pendingPosition);\n        }\n        return timings;\n    }\n    _generateObservationForEvent(event) {\n        const newObservation = this._getCurrentObservation(event);\n        if (log.hasLevel(\"DEBUG\")) {\n            log.debug(\"API: current playback timeline:\\n\" +\n                prettyPrintBuffered(newObservation.buffered, newObservation.position.getPolled()), `\\n${event}`);\n        }\n        this._observationRef.setValue(newObservation);\n    }\n}\n/**\n * Returns the amount of time in seconds the buffer should have ahead of the\n * current position before resuming playback. Based on the infos of the\n * rebuffering status.\n *\n * Waiting time differs between a rebuffering happening after a \"seek\" or one\n * happening after a buffer starvation occured.\n * @param {Object|null} rebufferingStatus\n * @param {Boolean} lowLatencyMode\n * @returns {Number}\n */\nfunction getRebufferingEndGap(rebufferingStatus, lowLatencyMode) {\n    if (rebufferingStatus === null) {\n        return 0;\n    }\n    const suffix = lowLatencyMode ? \"LOW_LATENCY\" : \"DEFAULT\";\n    const { RESUME_GAP_AFTER_SEEKING, RESUME_GAP_AFTER_NOT_ENOUGH_DATA, RESUME_GAP_AFTER_BUFFERING, } = config.getCurrent();\n    switch (rebufferingStatus.reason) {\n        case \"seeking\":\n            return RESUME_GAP_AFTER_SEEKING[suffix];\n        case \"not-ready\":\n            return RESUME_GAP_AFTER_NOT_ENOUGH_DATA[suffix];\n        case \"buffering\":\n            return RESUME_GAP_AFTER_BUFFERING[suffix];\n    }\n}\n/**\n * @param {Object} currentRange\n * @param {Number} duration\n * @param {Boolean} lowLatencyMode\n * @returns {Boolean}\n */\nfunction hasLoadedUntilTheEnd(currentTime, currentRange, ended, duration, lowLatencyMode) {\n    const { REBUFFERING_GAP } = config.getCurrent();\n    const suffix = lowLatencyMode ? \"LOW_LATENCY\" : \"DEFAULT\";\n    if (currentRange === undefined) {\n        return ended && Math.abs(duration - currentTime) <= REBUFFERING_GAP[suffix];\n    }\n    return currentRange !== null && duration - currentRange.end <= REBUFFERING_GAP[suffix];\n}\n/**\n * Get basic playback information.\n * @param {HTMLMediaElement} mediaElement\n * @returns {Object}\n */\nfunction getMediaInfos(mediaElement) {\n    const { buffered, currentTime, duration, ended, paused, playbackRate, readyState, seeking, } = mediaElement;\n    return {\n        buffered,\n        position: currentTime,\n        duration,\n        ended,\n        paused,\n        playbackRate,\n        readyState,\n        seeking,\n    };\n}\n/**\n * Infer the rebuffering status.\n * @param {Object} options\n * @returns {Object|null}\n */\nfunction getRebufferingStatus({ previousObservation, currentObservation, basePosition, observationEvent, withMediaSource, lowLatencyMode, bufferGap, fullyLoaded, }) {\n    const { REBUFFERING_GAP } = config.getCurrent();\n    const { position: currentTime, paused, readyState, ended } = currentObservation;\n    const { rebuffering: prevRebuffering, event: prevEvt, position: prevTime, } = previousObservation;\n    const canSwitchToRebuffering = readyState >= 1 &&\n        observationEvent !== \"loadedmetadata\" &&\n        prevRebuffering === null &&\n        !(fullyLoaded || ended);\n    let rebufferEndPosition = null;\n    let shouldRebuffer;\n    let shouldStopRebuffer;\n    const rebufferGap = lowLatencyMode\n        ? REBUFFERING_GAP.LOW_LATENCY\n        : REBUFFERING_GAP.DEFAULT;\n    if (withMediaSource) {\n        if (canSwitchToRebuffering) {\n            if (bufferGap === Infinity) {\n                shouldRebuffer = true;\n                rebufferEndPosition = basePosition;\n            }\n            else if (bufferGap === undefined) {\n                if (readyState < 3) {\n                    shouldRebuffer = true;\n                    rebufferEndPosition = undefined;\n                }\n            }\n            else if (bufferGap <= rebufferGap) {\n                shouldRebuffer = true;\n                rebufferEndPosition = basePosition + bufferGap;\n            }\n        }\n        else if (prevRebuffering !== null) {\n            const resumeGap = getRebufferingEndGap(prevRebuffering, lowLatencyMode);\n            if ((shouldRebuffer !== true &&\n                prevRebuffering !== null &&\n                readyState > 1 &&\n                (fullyLoaded ||\n                    ended ||\n                    (bufferGap !== undefined && isFinite(bufferGap) && bufferGap > resumeGap))) ||\n                (bufferGap === undefined && readyState >= 3)) {\n                shouldStopRebuffer = true;\n            }\n            else if (bufferGap === undefined) {\n                rebufferEndPosition = undefined;\n            }\n            else if (bufferGap === Infinity) {\n                rebufferEndPosition = basePosition;\n            }\n            else if (bufferGap <= resumeGap) {\n                rebufferEndPosition = basePosition + bufferGap;\n            }\n        }\n    }\n    // when using a direct file, the media will stall and unstall on its\n    // own, so we only try to detect when the media timestamp has not changed\n    // between two consecutive timeupdates\n    else {\n        if (canSwitchToRebuffering && // TODO what about when paused: e.g. when loading initially the content\n            ((!paused &&\n                observationEvent === \"timeupdate\" &&\n                prevEvt === \"timeupdate\" &&\n                currentTime === prevTime.getPolled()) ||\n                (observationEvent === \"seeking\" &&\n                    (bufferGap === Infinity || (bufferGap === undefined && readyState < 3))))) {\n            shouldRebuffer = true;\n        }\n        else if (prevRebuffering !== null &&\n            ((observationEvent !== \"seeking\" && currentTime !== prevTime.getPolled()) ||\n                observationEvent === \"canplay\" ||\n                (bufferGap === undefined && readyState >= 3) ||\n                (bufferGap !== undefined &&\n                    bufferGap < Infinity &&\n                    (bufferGap > getRebufferingEndGap(prevRebuffering, lowLatencyMode) ||\n                        fullyLoaded ||\n                        ended)))) {\n            shouldStopRebuffer = true;\n        }\n    }\n    if (shouldStopRebuffer === true) {\n        return null;\n    }\n    else if (shouldRebuffer === true || prevRebuffering !== null) {\n        let reason;\n        if (observationEvent === \"seeking\" ||\n            (prevRebuffering !== null && prevRebuffering.reason === \"seeking\")) {\n            reason = \"seeking\";\n        }\n        else if (currentObservation.seeking) {\n            reason = \"seeking\";\n        }\n        else if (readyState === 1) {\n            reason = \"not-ready\";\n        }\n        else {\n            reason = \"buffering\";\n        }\n        if (prevRebuffering !== null && prevRebuffering.reason === reason) {\n            return {\n                reason: prevRebuffering.reason,\n                timestamp: prevRebuffering.timestamp,\n                position: rebufferEndPosition,\n            };\n        }\n        return {\n            reason,\n            timestamp: getMonotonicTimeStamp(),\n            position: rebufferEndPosition,\n        };\n    }\n    return null;\n}\n/**\n * Detect if the current media can be considered as \"freezing\" (i.e. not\n * advancing for unknown reasons).\n *\n * Returns a corresponding `IFreezingStatus` object if that's the case and\n * `null` if not.\n * @param {Object} prevObservation\n * @param {Object} currentInfo\n * @param {string} currentEvt\n * @param {number|undefined} bufferGap\n * @returns {Object|null}\n */\nfunction getFreezingStatus(prevObservation, currentInfo, currentEvt, bufferGap) {\n    const { MINIMUM_BUFFER_AMOUNT_BEFORE_FREEZING } = config.getCurrent();\n    if (prevObservation.freezing !== null) {\n        if (currentInfo.ended ||\n            currentInfo.paused ||\n            currentInfo.readyState === 0 ||\n            currentInfo.playbackRate === 0 ||\n            prevObservation.position.getPolled() !== currentInfo.position) {\n            return null; // Quit freezing status\n        }\n        return prevObservation.freezing; // Stay in it\n    }\n    return currentEvt === \"timeupdate\" &&\n        bufferGap !== undefined &&\n        bufferGap > MINIMUM_BUFFER_AMOUNT_BEFORE_FREEZING &&\n        !currentInfo.ended &&\n        !currentInfo.paused &&\n        currentInfo.readyState >= 1 &&\n        currentInfo.playbackRate !== 0 &&\n        currentInfo.position === prevObservation.position.getPolled()\n        ? { timestamp: getMonotonicTimeStamp() }\n        : null;\n}\n/**\n * Pretty print a TimeRanges Object, to see the current content of it in a\n * one-liner string.\n *\n * @example\n * This function is called by giving it directly the TimeRanges, such as:\n * ```js\n * prettyPrintBuffered(document.getElementsByTagName(\"video\")[0].buffered);\n * ```\n *\n * Let's consider this possible return:\n *\n * ```\n * 0.00|==29.95==|29.95 ~30.05~ 60.00|==29.86==|89.86\n *          ^14\n * ```\n * This means that our video element has 29.95 seconds of buffer between 0 and\n * 29.95 seconds.\n * Then 30.05 seconds where no buffer is found.\n * Then 29.86 seconds of buffer between 60.00 and 89.86 seconds.\n *\n * A caret on the second line indicates the current time we're at.\n * The number coming after it is the current time.\n * @param {TimeRanges} buffered\n * @param {number} currentTime\n * @returns {string}\n */\nfunction prettyPrintBuffered(buffered, currentTime) {\n    let str = \"\";\n    let currentTimeStr = \"\";\n    for (let i = 0; i < buffered.length; i++) {\n        const start = buffered.start(i);\n        const end = buffered.end(i);\n        const fixedStart = start.toFixed(2);\n        const fixedEnd = end.toFixed(2);\n        const fixedDuration = (end - start).toFixed(2);\n        const newIntervalStr = `${fixedStart}|==${fixedDuration}==|${fixedEnd}`;\n        str += newIntervalStr;\n        if (currentTimeStr.length === 0 && end > currentTime) {\n            const padBefore = str.length - Math.floor(newIntervalStr.length / 2);\n            currentTimeStr = \" \".repeat(padBefore) + `^${currentTime}`;\n        }\n        if (i < buffered.length - 1) {\n            const nextStart = buffered.start(i + 1);\n            const fixedDiff = (nextStart - end).toFixed(2);\n            const holeStr = ` ~${fixedDiff}~ `;\n            str += holeStr;\n            if (currentTimeStr.length === 0 && currentTime < nextStart) {\n                const padBefore = str.length - Math.floor(holeStr.length / 2);\n                currentTimeStr = \" \".repeat(padBefore) + `^${currentTime}`;\n            }\n        }\n    }\n    if (currentTimeStr.length === 0) {\n        currentTimeStr = \" \".repeat(str.length) + `^${currentTime}`;\n    }\n    return str + \"\\n\" + currentTimeStr;\n}\n/**\n * Generate the initial playback observation for when no event has yet been\n * emitted to lead to one.\n * @param {HTMLMediaElement} mediaElement\n * @returns {Object}\n */\nfunction getInitialObservation(mediaElement) {\n    const mediaTimings = getMediaInfos(mediaElement);\n    return objectAssign(mediaTimings, {\n        rebuffering: null,\n        event: \"init\",\n        seeking: 0 /* SeekingState.None */,\n        position: new ObservationPosition(mediaTimings.position, null),\n        freezing: null,\n        bufferGap: 0,\n        currentRange: null,\n        fullyLoaded: false,\n    });\n}\n","/**\n * Create `IReadOnlyPlaybackObserver` from a source `IReadOnlyPlaybackObserver`\n * and a mapping function.\n * @param {Object} src\n * @param {Function} transform\n * @returns {Object}\n */\nexport default function generateReadOnlyObserver(src, transform, cancellationSignal) {\n    const mappedRef = transform(src.getReference(), cancellationSignal);\n    return {\n        getCurrentTime() {\n            return src.getCurrentTime();\n        },\n        getReadyState() {\n            return src.getReadyState();\n        },\n        getPlaybackRate() {\n            return src.getPlaybackRate();\n        },\n        getIsPaused() {\n            return src.getIsPaused();\n        },\n        getReference() {\n            return mappedRef;\n        },\n        listen(cb, params) {\n            if (cancellationSignal.isCancelled() || params.clearSignal.isCancelled()) {\n                return;\n            }\n            mappedRef.onUpdate(cb, {\n                clearSignal: params.clearSignal,\n                emitCurrentValue: params.includeLastObservation,\n            });\n        },\n        deriveReadOnlyObserver(newTransformFn) {\n            return generateReadOnlyObserver(this, newTransformFn, cancellationSignal);\n        },\n    };\n}\n","/**\n * Class facilitating the exploitation of what could be called the \"playback\n * position\" (the position at which we should currently be playing).\n *\n * In appearance a simple concept, it has in reality some gotchas that we wanted\n * to make more explicit.\n * As such, this class defines multiple methods to obtain an estimate of it,\n * each having its own pros and cons.\n *\n * @class ObservationPosition\n */\nexport default class ObservationPosition {\n    constructor(last, wanted) {\n        this._last = last;\n        this._wanted = wanted;\n    }\n    /**\n     * Obtain arguments allowing to instanciate the same ObservationPosition.\n     *\n     * This can be used to create a new `ObservationPosition` across JS realms,\n     * generally to communicate its data between the main thread and a WebWorker.\n     * @returns {Array.<number>}\n     */\n    serialize() {\n        return [this._last, this._wanted];\n    }\n    /**\n     * Returns the playback position actually observed on the media element at\n     * the time the playback observation was made.\n     *\n     * Note that it may be different than the position for which media data is\n     * wanted in rare scenarios where the goal position is not yet set on the\n     * media element.\n     *\n     * You should use this value when you want to obtain the actual position set\n     * on the media element for browser compatibility purposes. Note that this\n     * position was calculated at observation time, it might thus not be\n     * up-to-date if what you want is milliseconds-accuracy.\n     *\n     * If what you want is the actual position which the player is intended to\n     * play, you should rely on `getWanted` instead`.\n     * @returns {number}\n     */\n    getPolled() {\n        return this._last;\n    }\n    /**\n     * Returns the position which the player should consider to load media data\n     * at the time the observation was made.\n     *\n     * It can be different than the value returned by `getPolled` in rare\n     * scenarios:\n     *\n     *   - When the initial position has not been set yet.\n     *\n     *   - When the current device do not let the RxPlayer peform precize seeks,\n     *     usually for perfomance reasons by seeking to a previous IDR frame\n     *     instead (for now only Tizen may be like this), in which case we\n     *     prefer to generally rely on the position wanted by the player (this\n     *     e.g. prevents issues where the RxPlayer logic and the device are\n     *     seeking back and forth in a loop).\n     *\n     *   - When a wanted position has been \"forced\" (@see forceWantedPosition).\n     * @returns {number}\n     */\n    getWanted() {\n        var _a;\n        return (_a = this._wanted) !== null && _a !== void 0 ? _a : this._last;\n    }\n    /**\n     * Method to call if you want to overwrite the currently wanted position.\n     * @param {number} pos\n     */\n    forceWantedPosition(pos) {\n        this._wanted = pos;\n    }\n    /**\n     * Returns `true` when the position wanted returned by `getWanted` and the\n     * actual position returned by `getPolled` may be different, meaning that\n     * we're currently not at the position we want to reach.\n     *\n     * This is a relatively rare situation which only happens when either the\n     * initial seek has not yet been performed. on specific targets where the\n     * seeking behavior is a little broken (@see getWanted) or when the wanted\n     * position has been forced (@see forceWantedPosition).\n     *\n     * In those situations, you might temporarily refrain from acting upon the\n     * actual current media position, as it may change soon.\n     *\n     * @returns {boolean}\n     */\n    isAwaitingFuturePosition() {\n        return this._wanted !== null;\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { resolveURL } from \"../../utils/url-utils\";\nexport default function constructSegmentUrl(wantedCdn, segment) {\n    if (wantedCdn === null) {\n        return null;\n    }\n    if (segment.url === null) {\n        return wantedCdn.baseUrl;\n    }\n    return resolveURL(wantedCdn.baseUrl, segment.url);\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { utf8ToStr } from \"../../utils/string_parsing\";\n/**\n * From an array of EMSGs with manifest validity scheme id,\n * tells if the manifest needs to be refreshed.\n * @param {Array.<Object>} emsgs\n * @param {number} manifestPublishTime\n * @returns {boolean}\n */\nfunction manifestNeedsToBeRefreshed(emsgs, manifestPublishTime) {\n    if (emsgs.length <= 0) {\n        return false;\n    }\n    const len = emsgs.length;\n    for (let i = 0; i < len; i++) {\n        const manifestRefreshEventFromEMSGs = emsgs[i];\n        const currentManifestPublishTime = manifestPublishTime;\n        const { messageData } = manifestRefreshEventFromEMSGs;\n        const strPublishTime = utf8ToStr(messageData);\n        const eventManifestPublishTime = Date.parse(strPublishTime);\n        if (currentManifestPublishTime === undefined ||\n            eventManifestPublishTime === undefined ||\n            isNaN(eventManifestPublishTime) ||\n            // DASH-if 4.3 tells (4.5.2.1) :\n            // \"The media presentation time beyond the event time (indicated\n            // time by presentation_time_delta) is correctly described only\n            // by MPDs with publish time greater than indicated value in the\n            // message_data field.\"\n            //\n            // Here, if the current manifest has its publish time inferior or\n            // identical to the event manifest publish time, then the manifest needs\n            // to be updated\n            eventManifestPublishTime >= currentManifestPublishTime) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Get wrapped inband events and manifest refresh event from\n * parsed ISOBMFF EMSG boxes.\n * @param {Array.<Object>} parsedEMSGs\n * @param {undefined | number} manifestPublishTime\n * @returns {Object}\n */\nexport default function getEventsOutOfEMSGs(parsedEMSGs, manifestPublishTime) {\n    if (parsedEMSGs.length === 0) {\n        return undefined;\n    }\n    const { manifestRefreshEventsFromEMSGs, EMSGs } = parsedEMSGs.reduce((acc, val) => {\n        // Scheme that signals manifest update\n        if (val.schemeIdUri === \"urn:mpeg:dash:event:2012\" &&\n            // TODO support value 2 and 3\n            val.value === \"1\") {\n            if (acc.manifestRefreshEventsFromEMSGs === undefined) {\n                acc.manifestRefreshEventsFromEMSGs = [];\n            }\n            acc.manifestRefreshEventsFromEMSGs.push(val);\n        }\n        else {\n            if (acc.EMSGs === undefined) {\n                acc.EMSGs = [];\n            }\n            acc.EMSGs.push(val);\n        }\n        return acc;\n    }, {\n        manifestRefreshEventsFromEMSGs: undefined,\n        EMSGs: undefined,\n    });\n    const inbandEvents = EMSGs === null || EMSGs === void 0 ? void 0 : EMSGs.map((evt) => ({\n        type: \"emsg\",\n        value: evt,\n    }));\n    const needsManifestRefresh = manifestPublishTime === undefined || manifestRefreshEventsFromEMSGs === undefined\n        ? false\n        : manifestNeedsToBeRefreshed(manifestRefreshEventsFromEMSGs, manifestPublishTime);\n    return { inbandEvents, needsManifestRefresh };\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * /!\\ This file is feature-switchable.\n * It always should be imported through the `features` object.\n */\nimport DASHPipelines from \"./pipelines\";\nexport default DASHPipelines;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { concat } from \"../../utils/byte_parsing\";\nimport request from \"../../utils/request\";\nimport addQueryString from \"../utils/add_query_string\";\nimport byteRange from \"../utils/byte_range\";\n/**\n * Perform a request for an initialization segment, agnostic to the container.\n * @param {string} initialUrl\n * @param {Object} segment\n * @param {Object} options\n * @param {CancellationSignal} cancelSignal\n * @param {Object} callbacks\n * @returns {Promise}\n */\nexport default function initSegmentLoader(initialUrl, segment, options, cancelSignal, callbacks) {\n    var _a, _b;\n    let url = initialUrl;\n    if (((_a = options.cmcdPayload) === null || _a === void 0 ? void 0 : _a.type) === \"query\") {\n        url = addQueryString(url, options.cmcdPayload.value);\n    }\n    const cmcdHeaders = ((_b = options.cmcdPayload) === null || _b === void 0 ? void 0 : _b.type) === \"headers\" ? options.cmcdPayload.value : undefined;\n    if (segment.range === undefined) {\n        return request({\n            url,\n            responseType: \"arraybuffer\",\n            headers: cmcdHeaders,\n            timeout: options.timeout,\n            connectionTimeout: options.connectionTimeout,\n            cancelSignal,\n            onProgress: callbacks.onProgress,\n        }).then((data) => ({ resultType: \"segment-loaded\", resultData: data }));\n    }\n    if (segment.indexRange === undefined) {\n        return request({\n            url,\n            headers: Object.assign(Object.assign({}, cmcdHeaders), { Range: byteRange(segment.range) }),\n            responseType: \"arraybuffer\",\n            timeout: options.timeout,\n            connectionTimeout: options.connectionTimeout,\n            cancelSignal,\n            onProgress: callbacks.onProgress,\n        }).then((data) => ({ resultType: \"segment-loaded\", resultData: data }));\n    }\n    // range and indexRange are contiguous (99% of the cases)\n    if (segment.range[1] + 1 === segment.indexRange[0]) {\n        return request({\n            url,\n            headers: Object.assign(Object.assign({}, cmcdHeaders), { Range: byteRange([segment.range[0], segment.indexRange[1]]) }),\n            responseType: \"arraybuffer\",\n            timeout: options.timeout,\n            connectionTimeout: options.connectionTimeout,\n            cancelSignal,\n            onProgress: callbacks.onProgress,\n        }).then((data) => ({ resultType: \"segment-loaded\", resultData: data }));\n    }\n    const rangeRequest$ = request({\n        url,\n        headers: Object.assign(Object.assign({}, cmcdHeaders), { Range: byteRange(segment.range) }),\n        responseType: \"arraybuffer\",\n        timeout: options.timeout,\n        connectionTimeout: options.connectionTimeout,\n        cancelSignal,\n        onProgress: callbacks.onProgress,\n    });\n    const indexRequest$ = request({\n        url,\n        headers: Object.assign(Object.assign({}, cmcdHeaders), { Range: byteRange(segment.indexRange) }),\n        responseType: \"arraybuffer\",\n        timeout: options.timeout,\n        connectionTimeout: options.connectionTimeout,\n        cancelSignal,\n        onProgress: callbacks.onProgress,\n    });\n    return Promise.all([rangeRequest$, indexRequest$]).then(([initData, indexData]) => {\n        const data = concat(new Uint8Array(initData.responseData), new Uint8Array(indexData.responseData));\n        const sendingTime = Math.min(initData.sendingTime, indexData.sendingTime);\n        const receivedTime = Math.max(initData.receivedTime, indexData.receivedTime);\n        return {\n            resultType: \"segment-loaded\",\n            resultData: {\n                url,\n                responseData: data,\n                size: initData.size + indexData.size,\n                requestDuration: receivedTime - sendingTime,\n                sendingTime,\n                receivedTime,\n            },\n        };\n    });\n}\n","import { OtherError } from \"../../errors\";\nimport globalScope from \"../../utils/global_scope\";\nimport isNullOrUndefined from \"../../utils/is_null_or_undefined\";\nimport TaskCanceller from \"../../utils/task_canceller\";\nimport checkISOBMFFIntegrity from \"../utils/check_isobmff_integrity\";\nimport inferSegmentContainer from \"../utils/infer_segment_container\";\n/**\n * Add multiple checks on the response given by the `segmentLoader` in argument.\n * If the response appear to be corrupted, the returned Promise will reject with\n * an error with an `INTEGRITY_ERROR` code.\n * @param {Function} segmentLoader\n * @returns {Function}\n */\nexport function addSegmentIntegrityChecks(segmentLoader) {\n    return (url, context, loaderOptions, initialCancelSignal, callbacks) => {\n        return new Promise((resolve, reject) => {\n            const requestCanceller = new TaskCanceller();\n            const unlinkCanceller = requestCanceller.linkToSignal(initialCancelSignal);\n            requestCanceller.signal.register(reject);\n            segmentLoader(url, context, loaderOptions, requestCanceller.signal, Object.assign(Object.assign({}, callbacks), { onNewChunk(data) {\n                    try {\n                        throwOnIntegrityError(data);\n                        callbacks.onNewChunk(data);\n                    }\n                    catch (err) {\n                        // Do not reject with a `CancellationError` after cancelling the request\n                        cleanUpCancellers();\n                        // Cancel the request\n                        requestCanceller.cancel();\n                        // Reject with thrown error\n                        reject(err);\n                    }\n                } })).then((info) => {\n                cleanUpCancellers();\n                if (requestCanceller.isUsed()) {\n                    return;\n                }\n                if (info.resultType === \"segment-loaded\") {\n                    try {\n                        throwOnIntegrityError(info.resultData.responseData);\n                    }\n                    catch (err) {\n                        reject(err);\n                        return;\n                    }\n                }\n                resolve(info);\n            }, (err) => {\n                cleanUpCancellers();\n                reject(err);\n            });\n            function cleanUpCancellers() {\n                requestCanceller.signal.deregister(reject);\n                unlinkCanceller();\n            }\n        });\n        /**\n         * If the data's seems to be corrupted, throws an `INTEGRITY_ERROR` error.\n         * @param {*} data\n         */\n        function throwOnIntegrityError(data) {\n            if ((!(data instanceof ArrayBuffer) && !(data instanceof Uint8Array)) ||\n                inferSegmentContainer(context.type, context.mimeType) !== \"mp4\") {\n                return;\n            }\n            checkISOBMFFIntegrity(new Uint8Array(data), context.segment.isInit);\n        }\n    };\n}\n/**\n * Add multiple checks on the response given by the `manifestLoader` in argument.\n * If the response appear to be corrupted, the returned Promise will reject with\n * an error with an `INTEGRITY_ERROR` code.\n * @param {Function} manifestLoader\n * @returns {Function}\n */\nexport function addManifestIntegrityChecks(manifestLoader) {\n    return async (url, options, initialCancelSignal) => {\n        const res = await manifestLoader(url, options, initialCancelSignal);\n        throwOnIntegrityError(res.responseData);\n        return res;\n        /**\n         * If the data's seems to be corrupted, throws an `INTEGRITY_ERROR` error.\n         * @param {*} data\n         */\n        function throwOnIntegrityError(data) {\n            if (typeof data === \"string\") {\n                let currOffset = data.length - 1;\n                const expectedStrings = [\"</\", \"MPD\", \">\"];\n                for (let i = expectedStrings.length - 1; i >= 0; i--) {\n                    const currentExpectedStr = expectedStrings[i];\n                    while (isCharXmlWhiteSpace(data[currOffset])) {\n                        currOffset--;\n                    }\n                    for (let j = currentExpectedStr.length - 1; j >= 0; j--) {\n                        if (data[currOffset] !== currentExpectedStr[j]) {\n                            throw new Error(\"INTEGRITY_ERROR MPD does not end with </MPD>\");\n                        }\n                        else {\n                            currOffset--;\n                        }\n                    }\n                }\n            }\n            else if (data instanceof ArrayBuffer) {\n                let currOffset = data.byteLength - 1;\n                const dv = new DataView(data);\n                const expectedCharGroups = [[0x3c, 0x2f], [0x4d, 0x50, 0x44], [0x3e]];\n                for (let i = expectedCharGroups.length - 1; i >= 0; i--) {\n                    const currentExpectedCharGroup = expectedCharGroups[i];\n                    while (isUtf8XmlWhiteSpace(dv.getUint8(currOffset))) {\n                        currOffset--;\n                    }\n                    for (let j = currentExpectedCharGroup.length - 1; j >= 0; j--) {\n                        if (dv.getUint8(currOffset) !== currentExpectedCharGroup[j]) {\n                            throw new Error(\"INTEGRITY_ERROR MPD does not end with </MPD>\");\n                        }\n                        else {\n                            currOffset--;\n                        }\n                    }\n                }\n            }\n            else if (!isNullOrUndefined(globalScope.Document) &&\n                data instanceof globalScope.Document) {\n                if (data.documentElement.nodeName !== \"MPD\") {\n                    throw new OtherError(\"INTEGRITY_ERROR\", \"MPD does not end with </MPD>\");\n                }\n            }\n        }\n    };\n}\n/**\n * Returns `true` if the character given can be considered as\n * whitespace according to the XML spec.\n * @param {string} char\n * @returns {boolean}\n */\nfunction isCharXmlWhiteSpace(char) {\n    return char === \" \" || char === \"\\t\" || char === \"\\r\" || char === \"\\n\";\n}\n/**\n * Returns `true` if the character given can be considered as an ASCII\n * whitespace according to the HTML spec.\n * @param {string} char\n * @returns {boolean}\n */\nfunction isUtf8XmlWhiteSpace(char) {\n    return char === 0x20 || char === 0x9 || char === 0xd || char === 0xa;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { extractCompleteChunks } from \"../../parsers/containers/isobmff\";\nimport { concat } from \"../../utils/byte_parsing\";\nimport fetchRequest from \"../../utils/request/fetch\";\n/**\n * Load segments through a \"chunk\" mode (decodable chunk by decodable chunk).\n *\n * This method is particularly adapted to low-latency streams.\n *\n * @param {string} url - URL of the segment to download.\n * @param {Object} requestOptions\n * @param {Object|undefined} requestOptions.headers - Headers for the\n * low-latency request\n * @param {number|undefined} requestOptions.timeout - Request timeout for the\n * low-latency request.\n * @param {number|undefined} requestOptions.connectionTimeout - HTTP connection\n * timeout for the low-latency request.\n * @param {Object} callbacks\n * @param {CancellationSignal} cancelSignal\n * @returns {Promise}\n */\nexport default async function loadChunkedSegmentData(url, requestOptions, callbacks, cancelSignal) {\n    let partialChunk = null;\n    /**\n     * Called each time `fetch` has new data available.\n     * @param {Object} info\n     */\n    function onData(info) {\n        const chunk = new Uint8Array(info.chunk);\n        const concatenated = partialChunk !== null ? concat(partialChunk, chunk) : chunk;\n        const res = extractCompleteChunks(concatenated);\n        const completeChunks = res[0];\n        partialChunk = res[1];\n        if (completeChunks !== null) {\n            completeChunks.forEach((completedChunk) => {\n                callbacks.onNewChunk(completedChunk);\n            });\n            if (cancelSignal.isCancelled()) {\n                return;\n            }\n        }\n        callbacks.onProgress({\n            duration: info.duration,\n            size: info.size,\n            totalSize: info.totalSize,\n        });\n        if (cancelSignal.isCancelled()) {\n            return;\n        }\n    }\n    const res = await fetchRequest({\n        url,\n        headers: requestOptions.headers,\n        onData,\n        timeout: requestOptions.timeout,\n        connectionTimeout: requestOptions.connectionTimeout,\n        cancelSignal,\n    });\n    return {\n        resultType: \"chunk-complete\",\n        resultData: res,\n    };\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport config from \"../../config\";\nimport { formatError } from \"../../errors\";\nimport features from \"../../features\";\nimport log from \"../../log\";\nimport Manifest from \"../../manifest/classes\";\nimport objectAssign from \"../../utils/object_assign\";\nimport request from \"../../utils/request\";\nimport { strToUtf8, utf8ToStr } from \"../../utils/string_parsing\";\nexport default function generateManifestParser(options) {\n    const { referenceDateTime } = options;\n    const serverTimeOffset = options.serverSyncInfos !== undefined\n        ? options.serverSyncInfos.serverTimestamp - options.serverSyncInfos.clientTime\n        : undefined;\n    return function manifestParser(manifestData, parserOptions, onWarnings, cancelSignal, scheduleRequest) {\n        var _a;\n        const { responseData } = manifestData;\n        const argClockOffset = parserOptions.externalClockOffset;\n        const url = (_a = manifestData.url) !== null && _a !== void 0 ? _a : parserOptions.originalUrl;\n        const externalClockOffset = serverTimeOffset !== null && serverTimeOffset !== void 0 ? serverTimeOffset : argClockOffset;\n        const unsafelyBaseOnPreviousManifest = parserOptions.unsafeMode\n            ? parserOptions.previousManifest\n            : null;\n        const dashParserOpts = {\n            unsafelyBaseOnPreviousManifest,\n            url,\n            referenceDateTime,\n            externalClockOffset,\n        };\n        const parsers = features.dashParsers;\n        if (parsers.wasm === null ||\n            parsers.wasm.status === \"uninitialized\" ||\n            parsers.wasm.status === \"failure\") {\n            log.debug(\"DASH: WASM MPD Parser not initialized. Running JS one.\");\n            return runDefaultJsParser();\n        }\n        else {\n            const manifestAB = getManifestAsArrayBuffer(responseData);\n            if (!doesXmlSeemsUtf8Encoded(manifestAB)) {\n                log.info(\"DASH: MPD doesn't seem to be UTF-8-encoded. \" +\n                    \"Running JS parser instead of the WASM one.\");\n                return runDefaultJsParser();\n            }\n            if (parsers.wasm.status === \"initialized\") {\n                log.debug(\"DASH: Running WASM MPD Parser.\");\n                const parsed = parsers.wasm.runWasmParser(manifestAB, dashParserOpts);\n                return processMpdParserResponse(parsed);\n            }\n            else {\n                log.debug(\"DASH: Awaiting WASM initialization before parsing the MPD.\");\n                const initProm = parsers.wasm.waitForInitialization().catch(() => {\n                    /* ignore errors, we will check the status later */\n                });\n                return initProm.then(() => {\n                    if (parsers.wasm === null || parsers.wasm.status !== \"initialized\") {\n                        log.warn(\"DASH: WASM MPD parser initialization failed. \" +\n                            \"Running JS parser instead\");\n                        return runDefaultJsParser();\n                    }\n                    log.debug(\"DASH: Running WASM MPD Parser.\");\n                    const parsed = parsers.wasm.runWasmParser(manifestAB, dashParserOpts);\n                    return processMpdParserResponse(parsed);\n                });\n            }\n        }\n        /**\n         * Parse the MPD through the default JS-written parser (as opposed to the\n         * WebAssembly one).\n         * If it is not defined, throws.\n         * @returns {Object|Promise.<Object>}\n         */\n        function runDefaultJsParser() {\n            if (parsers.fastJs !== null) {\n                const manifestStr = getManifestAsString(responseData);\n                const parsedManifest = parsers.fastJs(manifestStr, dashParserOpts);\n                return processMpdParserResponse(parsedManifest);\n            }\n            else if (parsers.native !== null) {\n                const manifestDocument = getManifestAsDocument(responseData);\n                const parsedManifest = parsers.native(manifestDocument, dashParserOpts);\n                return processMpdParserResponse(parsedManifest);\n            }\n            else {\n                throw new Error(\"No MPD parser is imported\");\n            }\n        }\n        /**\n         * Process return of one of the MPD parser.\n         * If it asks for a resource, load it then continue.\n         * @param {Object} parserResponse - Response returned from a MPD parser.\n         * @returns {Object|Promise.<Object>}\n         */\n        function processMpdParserResponse(parserResponse) {\n            if (parserResponse.type === \"done\") {\n                if (parserResponse.value.warnings.length > 0) {\n                    onWarnings(parserResponse.value.warnings);\n                }\n                if (cancelSignal.isCancelled()) {\n                    return Promise.reject(cancelSignal.cancellationError);\n                }\n                const warnings = [];\n                const manifest = new Manifest(parserResponse.value.parsed, options, warnings);\n                return { manifest, url, warnings };\n            }\n            const { value } = parserResponse;\n            const externalResources = value.urls.map((resourceUrl) => {\n                return scheduleRequest(() => {\n                    const defaultTimeout = config.getCurrent().DEFAULT_REQUEST_TIMEOUT;\n                    const defaultConnectionTimeout = config.getCurrent().DEFAULT_CONNECTION_TIMEOUT;\n                    return value.format === \"string\"\n                        ? request({\n                            url: resourceUrl,\n                            responseType: \"text\",\n                            timeout: defaultTimeout,\n                            connectionTimeout: defaultConnectionTimeout,\n                            cancelSignal,\n                        })\n                        : request({\n                            url: resourceUrl,\n                            responseType: \"arraybuffer\",\n                            timeout: defaultTimeout,\n                            connectionTimeout: defaultConnectionTimeout,\n                            cancelSignal,\n                        });\n                }).then((res) => {\n                    if (value.format === \"string\") {\n                        if (typeof res.responseData !== \"string\") {\n                            throw new Error(\"External DASH resources should have been a string\");\n                        }\n                        return objectAssign(res, {\n                            responseData: {\n                                success: true,\n                                data: res.responseData,\n                            },\n                        });\n                    }\n                    else {\n                        if (!(res.responseData instanceof ArrayBuffer)) {\n                            throw new Error(\"External DASH resources should have been ArrayBuffers\");\n                        }\n                        return objectAssign(res, {\n                            responseData: {\n                                success: true,\n                                data: res.responseData,\n                            },\n                        });\n                    }\n                }, (err) => {\n                    const error = formatError(err, {\n                        defaultCode: \"PIPELINE_PARSE_ERROR\",\n                        defaultReason: \"An unknown error occured when parsing ressources.\",\n                    });\n                    return objectAssign({}, {\n                        size: undefined,\n                        requestDuration: undefined,\n                        responseData: {\n                            success: false,\n                            error,\n                        },\n                    });\n                });\n            });\n            return Promise.all(externalResources).then((loadedResources) => {\n                if (value.format === \"string\") {\n                    assertLoadedResourcesFormatString(loadedResources);\n                    return processMpdParserResponse(value.continue(loadedResources));\n                }\n                else {\n                    assertLoadedResourcesFormatArrayBuffer(loadedResources);\n                    return processMpdParserResponse(value.continue(loadedResources));\n                }\n            });\n        }\n    };\n}\n/**\n * Throw if the given input is not in the expected format.\n * Allows to enforce runtime type-checking as compile-time type-checking here is\n * difficult to enforce.\n *\n * @param loadedResource\n * @returns\n */\nfunction assertLoadedResourcesFormatString(loadedResources) {\n    if (0 /* __ENVIRONMENT__.CURRENT_ENV */ === 0 /* __ENVIRONMENT__.PRODUCTION */) {\n        return;\n    }\n    loadedResources.forEach((loadedResource) => {\n        const { responseData } = loadedResource;\n        if (responseData.success && typeof responseData.data === \"string\") {\n            return;\n        }\n        else if (!responseData.success) {\n            return;\n        }\n        throw new Error(\"Invalid data given to the LoadedRessource\");\n    });\n}\n/**\n * Throw if the given input is not in the expected format.\n * Allows to enforce runtime type-checking as compile-time type-checking here is\n * difficult to enforce.\n *\n * @param loadedResource\n * @returns\n */\nfunction assertLoadedResourcesFormatArrayBuffer(loadedResources) {\n    if (0 /* __ENVIRONMENT__.CURRENT_ENV */ === 0 /* __ENVIRONMENT__.PRODUCTION */) {\n        return;\n    }\n    loadedResources.forEach((loadedResource) => {\n        const { responseData } = loadedResource;\n        if (responseData.success && responseData.data instanceof ArrayBuffer) {\n            return;\n        }\n        else if (!responseData.success) {\n            return;\n        }\n        throw new Error(\"Invalid data given to the LoadedRessource\");\n    });\n}\n/**\n * Try to convert a Manifest from an unknown format to an array of nodes as\n * parsed by our XML DOM parser.\n *\n * Throws if the format cannot be converted.\n * @param {*} manifestSrc\n * @returns {Array.<Object | string>}\n */\nfunction getManifestAsString(manifestSrc) {\n    if (manifestSrc instanceof ArrayBuffer) {\n        return utf8ToStr(new Uint8Array(manifestSrc));\n    }\n    else if (typeof manifestSrc === \"string\") {\n        return manifestSrc;\n    }\n    else if (manifestSrc instanceof Document) {\n        return manifestSrc.documentElement.outerHTML;\n    }\n    else {\n        throw new Error(\"DASH Manifest Parser: Unrecognized Manifest format\");\n    }\n}\n/**\n * Try to convert a Manifest from an unknown format to a `Document` format.\n * Useful to exploit DOM-parsing APIs to quickly parse an XML Manifest.\n *\n * Throws if the format cannot be converted.\n * @param {*} manifestSrc\n * @returns {Document}\n */\nfunction getManifestAsDocument(manifestSrc) {\n    if (manifestSrc instanceof ArrayBuffer) {\n        return new DOMParser().parseFromString(utf8ToStr(new Uint8Array(manifestSrc)), \"text/xml\");\n    }\n    else if (typeof manifestSrc === \"string\") {\n        return new DOMParser().parseFromString(manifestSrc, \"text/xml\");\n    }\n    else if (manifestSrc instanceof Document) {\n        return manifestSrc;\n    }\n    else {\n        throw new Error(\"DASH Manifest Parser: Unrecognized Manifest format\");\n    }\n}\n/**\n * Try to convert a Manifest from an unknown format to an `ArrayBuffer` format.\n * Throws if the format cannot be converted.\n * @param {*} manifestSrc\n * @returns {ArrayBuffer}\n */\nfunction getManifestAsArrayBuffer(manifestSrc) {\n    if (manifestSrc instanceof ArrayBuffer) {\n        return manifestSrc;\n    }\n    else if (typeof manifestSrc === \"string\") {\n        return strToUtf8(manifestSrc).buffer;\n    }\n    else if (manifestSrc instanceof Document) {\n        return strToUtf8(manifestSrc.documentElement.innerHTML).buffer;\n    }\n    else {\n        throw new Error(\"DASH Manifest Parser: Unrecognized Manifest format\");\n    }\n}\n/**\n * Returns true if the given XML appears to be encoded in UTF-8.\n *\n * For now, this function can return a lot of false positives, but it should\n * mostly work with real use cases.\n * @param {ArrayBuffer} xmlData\n * @returns {boolean}\n */\nfunction doesXmlSeemsUtf8Encoded(xmlData) {\n    const dv = new DataView(xmlData);\n    if (dv.getUint16(0) === 0xefbb && dv.getUint8(2) === 0xbf) {\n        // (UTF-8 BOM)\n        return true;\n    }\n    else if (dv.getUint16(0) === 0xfeff || dv.getUint16(0) === 0xfffe) {\n        // (UTF-16 BOM)\n        return false;\n    }\n    // TODO check encoding from request mimeType and text declaration?\n    // https://www.w3.org/TR/xml/#sec-TextDecl\n    return true;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport features from \"../../features\";\nimport generateManifestLoader from \"../utils/generate_manifest_loader\";\nimport { addManifestIntegrityChecks } from \"./integrity_checks\";\nimport generateManifestParser from \"./manifest_parser\";\nimport generateSegmentLoader from \"./segment_loader\";\nimport generateAudioVideoSegmentParser from \"./segment_parser\";\nimport generateTextTrackLoader from \"./text_loader\";\nimport generateTextTrackParser from \"./text_parser\";\nimport { loadThumbnail, parseThumbnail } from \"./thumbnails\";\n/**\n * Returns pipelines used for DASH streaming.\n * @param {Object} options\n * implementation. Used for each generated http request.\n * @returns {Object}\n */\nexport default function (options) {\n    const manifestLoader = generateManifestLoader({ customManifestLoader: options.manifestLoader }, mightUseDashWasmFeature() ? \"text\" : \"arraybuffer\", options.checkManifestIntegrity === true ? addManifestIntegrityChecks : null);\n    const manifestParser = generateManifestParser(options);\n    const segmentLoader = generateSegmentLoader(options);\n    const audioVideoSegmentParser = generateAudioVideoSegmentParser(options);\n    const textTrackLoader = generateTextTrackLoader(options);\n    const textTrackParser = generateTextTrackParser(options);\n    return {\n        transportName: \"dash\",\n        manifest: { loadManifest: manifestLoader, parseManifest: manifestParser },\n        audio: {\n            loadSegment: segmentLoader,\n            parseSegment: audioVideoSegmentParser,\n        },\n        video: {\n            loadSegment: segmentLoader,\n            parseSegment: audioVideoSegmentParser,\n        },\n        text: { loadSegment: textTrackLoader, parseSegment: textTrackParser },\n        thumbnails: {\n            loadThumbnail,\n            parseThumbnail,\n        },\n    };\n}\n/**\n * Returns true if the DASH-WASM parser is either initialized or being\n * initialized.\n * @returns {boolean}\n */\nfunction mightUseDashWasmFeature() {\n    return (features.dashParsers.wasm !== null &&\n        (features.dashParsers.wasm.status === \"initialized\" ||\n            features.dashParsers.wasm.status === \"initializing\"));\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { CustomLoaderError } from \"../../errors\";\nimport request, { fetchIsSupported } from \"../../utils/request\";\nimport warnOnce from \"../../utils/warn_once\";\nimport addQueryString from \"../utils/add_query_string\";\nimport byteRange from \"../utils/byte_range\";\nimport inferSegmentContainer from \"../utils/infer_segment_container\";\nimport constructSegmentUrl from \"./construct_segment_url\";\nimport initSegmentLoader from \"./init_segment_loader\";\nimport { addSegmentIntegrityChecks } from \"./integrity_checks\";\nimport loadChunkedSegmentData from \"./load_chunked_segment_data\";\n/**\n * Segment loader triggered if there was no custom-defined one in the API.\n * @param {string} initialUrl\n * @param {Object} context\n * @param {boolean} lowLatencyMode\n * @param {Object} options\n * @param {Object} callbacks\n * @param {Object} cancelSignal\n * @returns {Promise}\n */\nexport async function regularSegmentLoader(initialUrl, context, lowLatencyMode, options, callbacks, cancelSignal) {\n    var _a, _b;\n    if (context.segment.isInit) {\n        return initSegmentLoader(initialUrl, context.segment, options, cancelSignal, callbacks);\n    }\n    const url = ((_a = options.cmcdPayload) === null || _a === void 0 ? void 0 : _a.type) === \"query\"\n        ? addQueryString(initialUrl, options.cmcdPayload.value)\n        : initialUrl;\n    const cmcdHeaders = ((_b = options.cmcdPayload) === null || _b === void 0 ? void 0 : _b.type) === \"headers\" ? options.cmcdPayload.value : undefined;\n    const { segment } = context;\n    let headers;\n    if (segment.range !== undefined) {\n        headers = Object.assign(Object.assign({}, cmcdHeaders), { Range: byteRange(segment.range) });\n    }\n    else if (cmcdHeaders !== undefined) {\n        headers = cmcdHeaders;\n    }\n    const containerType = inferSegmentContainer(context.type, context.mimeType);\n    if (lowLatencyMode && (containerType === \"mp4\" || containerType === undefined)) {\n        if (fetchIsSupported()) {\n            return loadChunkedSegmentData(url, {\n                headers,\n                timeout: options.timeout,\n                connectionTimeout: options.connectionTimeout,\n            }, callbacks, cancelSignal);\n        }\n        else {\n            warnOnce(\"DASH: Your browser does not have the fetch API. You will have \" +\n                \"a higher chance of rebuffering when playing close to the live edge\");\n        }\n    }\n    const data = await request({\n        url,\n        responseType: \"arraybuffer\",\n        headers,\n        timeout: options.timeout,\n        connectionTimeout: options.connectionTimeout,\n        cancelSignal,\n        onProgress: callbacks.onProgress,\n    });\n    return { resultType: \"segment-loaded\", resultData: data };\n}\n/**\n * @param {Object} config\n * @returns {Function}\n */\nexport default function generateSegmentLoader({ lowLatencyMode, segmentLoader: customSegmentLoader, checkMediaSegmentIntegrity, }) {\n    return checkMediaSegmentIntegrity !== true\n        ? segmentLoader\n        : addSegmentIntegrityChecks(segmentLoader);\n    /**\n     * @param {Object|null} wantedCdn\n     * @param {Object} context\n     * @param {Object} options\n     * @param {Object} cancelSignal\n     * @param {Object} callbacks\n     * @returns {Promise.<Object>}\n     */\n    function segmentLoader(wantedCdn, context, options, cancelSignal, callbacks) {\n        const url = constructSegmentUrl(wantedCdn, context.segment);\n        if (url === null) {\n            return Promise.resolve({\n                resultType: \"segment-created\",\n                resultData: null,\n            });\n        }\n        if (lowLatencyMode || customSegmentLoader === undefined) {\n            return regularSegmentLoader(url, context, lowLatencyMode, options, callbacks, cancelSignal);\n        }\n        return new Promise((res, rej) => {\n            /** `true` when the custom segmentLoader should not be active anymore. */\n            let hasFinished = false;\n            /**\n             * Callback triggered when the custom segment loader has a response.\n             * @param {Object} _args\n             */\n            const resolve = (_args) => {\n                if (hasFinished || cancelSignal.isCancelled()) {\n                    return;\n                }\n                hasFinished = true;\n                cancelSignal.deregister(abortCustomLoader);\n                res({\n                    resultType: \"segment-loaded\",\n                    resultData: {\n                        responseData: _args.data,\n                        size: _args.size,\n                        requestDuration: _args.duration,\n                    },\n                });\n            };\n            /**\n             * Callback triggered when the custom segment loader fails\n             * @param {*} err - The corresponding error encountered\n             */\n            const reject = (err) => {\n                var _a, _b;\n                if (hasFinished || cancelSignal.isCancelled()) {\n                    return;\n                }\n                hasFinished = true;\n                cancelSignal.deregister(abortCustomLoader);\n                // Format error and send it\n                const castedErr = err;\n                const message = (_a = castedErr === null || castedErr === void 0 ? void 0 : castedErr.message) !== null && _a !== void 0 ? _a : \"Unknown error when fetching a DASH segment through a \" +\n                    \"custom segmentLoader.\";\n                const emittedErr = new CustomLoaderError(message, (_b = castedErr === null || castedErr === void 0 ? void 0 : castedErr.canRetry) !== null && _b !== void 0 ? _b : false, castedErr === null || castedErr === void 0 ? void 0 : castedErr.xhr);\n                rej(emittedErr);\n            };\n            const progress = (_args) => {\n                if (hasFinished || cancelSignal.isCancelled()) {\n                    return;\n                }\n                callbacks.onProgress({\n                    duration: _args.duration,\n                    size: _args.size,\n                    totalSize: _args.totalSize,\n                });\n            };\n            /**\n             * Callback triggered when the custom segment loader wants to fallback to\n             * the \"regular\" implementation\n             */\n            const fallback = () => {\n                if (hasFinished || cancelSignal.isCancelled()) {\n                    return;\n                }\n                hasFinished = true;\n                cancelSignal.deregister(abortCustomLoader);\n                regularSegmentLoader(url, context, lowLatencyMode, options, callbacks, cancelSignal).then(res, rej);\n            };\n            const customCallbacks = { reject, resolve, progress, fallback };\n            let byteRanges;\n            if (context.segment.range !== undefined) {\n                byteRanges = [context.segment.range];\n                if (context.segment.indexRange !== undefined) {\n                    byteRanges.push(context.segment.indexRange);\n                }\n            }\n            const args = {\n                isInit: context.segment.isInit,\n                timeout: options.timeout,\n                byteRanges,\n                trackType: context.type,\n                url,\n                cmcdPayload: options.cmcdPayload,\n            };\n            const abort = customSegmentLoader(args, customCallbacks);\n            cancelSignal.register(abortCustomLoader);\n            /**\n             * The logic to run when the custom loader is cancelled while pending.\n             * @param {Error} err\n             */\n            function abortCustomLoader(err) {\n                if (hasFinished) {\n                    return;\n                }\n                hasFinished = true;\n                if (typeof abort === \"function\") {\n                    abort();\n                }\n                rej(err);\n            }\n        });\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { getMDHDTimescale, getSegmentsFromSidx, takePSSHOut, } from \"../../parsers/containers/isobmff\";\nimport { getKeyIdFromInitSegment, parseEmsgBoxes, } from \"../../parsers/containers/isobmff/utils\";\nimport { getSegmentsFromCues, getTimeCodeScale } from \"../../parsers/containers/matroska\";\nimport isNullOrUndefined from \"../../utils/is_null_or_undefined\";\nimport getISOBMFFTimingInfos from \"../utils/get_isobmff_timing_infos\";\nimport inferSegmentContainer from \"../utils/infer_segment_container\";\nimport getEventsOutOfEMSGs from \"./get_events_out_of_emsgs\";\n/**\n * @param {Object} config\n * @returns {Function}\n */\nexport default function generateAudioVideoSegmentParser({ __priv_patchLastSegmentInSidx, }) {\n    return function audioVideoSegmentParser(loadedSegment, context, initTimescale) {\n        var _a, _b;\n        const { segment, periodStart, periodEnd } = context;\n        const { data, isChunked } = loadedSegment;\n        const appendWindow = [periodStart, periodEnd];\n        if (data === null) {\n            if (segment.isInit) {\n                return {\n                    segmentType: \"init\",\n                    initializationData: null,\n                    initializationDataSize: 0,\n                    protectionData: [],\n                    initTimescale: undefined,\n                };\n            }\n            return {\n                segmentType: \"media\",\n                chunkData: null,\n                chunkSize: 0,\n                chunkInfos: null,\n                chunkOffset: 0,\n                protectionData: [],\n                appendWindow,\n            };\n        }\n        const chunkData = data instanceof Uint8Array ? data : new Uint8Array(data);\n        const containerType = inferSegmentContainer(context.type, context.mimeType);\n        // TODO take a look to check if this is an ISOBMFF/webm?\n        const seemsToBeMP4 = containerType === \"mp4\" || containerType === undefined;\n        const protectionData = [];\n        if (seemsToBeMP4) {\n            const psshInfo = takePSSHOut(chunkData);\n            let keyId;\n            if (segment.isInit) {\n                keyId = (_a = getKeyIdFromInitSegment(chunkData)) !== null && _a !== void 0 ? _a : undefined;\n            }\n            if (psshInfo.length > 0 || keyId !== undefined) {\n                protectionData.push({\n                    initDataType: \"cenc\",\n                    keyId,\n                    initData: psshInfo,\n                });\n            }\n        }\n        if (!segment.isInit) {\n            const chunkInfos = seemsToBeMP4\n                ? getISOBMFFTimingInfos(chunkData, isChunked, segment, initTimescale)\n                : null; // TODO extract time info from webm\n            const chunkOffset = (_b = segment.timestampOffset) !== null && _b !== void 0 ? _b : 0;\n            if (seemsToBeMP4) {\n                const parsedEMSGs = parseEmsgBoxes(chunkData);\n                if (parsedEMSGs !== undefined) {\n                    const whitelistedEMSGs = parsedEMSGs.filter((evt) => {\n                        if (segment.privateInfos === undefined ||\n                            segment.privateInfos.isEMSGWhitelisted === undefined) {\n                            return false;\n                        }\n                        return segment.privateInfos.isEMSGWhitelisted(evt);\n                    });\n                    const events = getEventsOutOfEMSGs(whitelistedEMSGs, context.manifestPublishTime);\n                    if (events !== undefined) {\n                        const { needsManifestRefresh, inbandEvents } = events;\n                        return {\n                            segmentType: \"media\",\n                            chunkData,\n                            chunkSize: chunkData.length,\n                            chunkInfos,\n                            chunkOffset,\n                            appendWindow,\n                            inbandEvents,\n                            protectionData,\n                            needsManifestRefresh,\n                        };\n                    }\n                }\n            }\n            return {\n                segmentType: \"media\",\n                chunkData,\n                chunkSize: chunkData.length,\n                chunkInfos,\n                chunkOffset,\n                protectionData,\n                appendWindow,\n            };\n        }\n        // we're handling an initialization segment\n        const { indexRange } = segment;\n        let segmentList;\n        if (containerType === \"webm\") {\n            segmentList = getSegmentsFromCues(chunkData, 0);\n        }\n        else if (seemsToBeMP4) {\n            segmentList = getSegmentsFromSidx(chunkData, Array.isArray(indexRange) ? indexRange[0] : 0);\n            // This is a very specific handling for streams we know have a very\n            // specific problem at Canal+: The last reference gives a truncated\n            // segment.\n            // Sadly, people on the packaging side could not fix all legacy contents.\n            // This is an easy-but-ugly fix for those.\n            // TODO Cleaner way? I tried to always check the obtained segment after\n            // a byte-range request but it leads to a lot of code.\n            if (__priv_patchLastSegmentInSidx === true &&\n                segmentList !== null &&\n                segmentList.length > 0) {\n                const lastSegment = segmentList[segmentList.length - 1];\n                if (Array.isArray(lastSegment.range)) {\n                    lastSegment.range[1] = Infinity;\n                }\n            }\n        }\n        let timescale;\n        if (seemsToBeMP4) {\n            timescale = getMDHDTimescale(chunkData);\n        }\n        else if (containerType === \"webm\") {\n            timescale = getTimeCodeScale(chunkData, 0);\n        }\n        const parsedTimescale = isNullOrUndefined(timescale) ? undefined : timescale;\n        return {\n            segmentType: \"init\",\n            initializationData: chunkData,\n            initializationDataSize: chunkData.length,\n            protectionData,\n            initTimescale: parsedTimescale,\n            segmentList: segmentList !== null && segmentList !== void 0 ? segmentList : undefined,\n        };\n    };\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport request, { fetchIsSupported } from \"../../utils/request\";\nimport warnOnce from \"../../utils/warn_once\";\nimport addQueryString from \"../utils/add_query_string\";\nimport byteRange from \"../utils/byte_range\";\nimport inferSegmentContainer from \"../utils/infer_segment_container\";\nimport constructSegmentUrl from \"./construct_segment_url\";\nimport initSegmentLoader from \"./init_segment_loader\";\nimport { addSegmentIntegrityChecks } from \"./integrity_checks\";\nimport loadChunkedSegmentData from \"./load_chunked_segment_data\";\n/**\n * Perform requests for \"text\" segments\n * @param {boolean} lowLatencyMode\n * @returns {Function}\n */\nexport default function generateTextTrackLoader({ lowLatencyMode, checkMediaSegmentIntegrity, }) {\n    return checkMediaSegmentIntegrity !== true\n        ? textTrackLoader\n        : addSegmentIntegrityChecks(textTrackLoader);\n    /**\n     * @param {Object|null} wantedCdn\n     * @param {Object} context\n     * @param {Object} options\n     * @param {Object} cancelSignal\n     * @param {Object} callbacks\n     * @returns {Promise}\n     */\n    async function textTrackLoader(wantedCdn, context, options, cancelSignal, callbacks) {\n        var _a, _b;\n        const { segment } = context;\n        const initialUrl = constructSegmentUrl(wantedCdn, segment);\n        if (initialUrl === null) {\n            return Promise.resolve({\n                resultType: \"segment-created\",\n                resultData: null,\n            });\n        }\n        if (segment.isInit) {\n            return initSegmentLoader(initialUrl, segment, options, cancelSignal, callbacks);\n        }\n        const url = ((_a = options.cmcdPayload) === null || _a === void 0 ? void 0 : _a.type) === \"query\"\n            ? addQueryString(initialUrl, options.cmcdPayload.value)\n            : initialUrl;\n        const cmcdHeaders = ((_b = options.cmcdPayload) === null || _b === void 0 ? void 0 : _b.type) === \"headers\" ? options.cmcdPayload.value : undefined;\n        let headers;\n        if (segment.range !== undefined) {\n            headers = Object.assign(Object.assign({}, cmcdHeaders), { Range: byteRange(segment.range) });\n        }\n        else if (cmcdHeaders !== undefined) {\n            headers = cmcdHeaders;\n        }\n        const containerType = inferSegmentContainer(context.type, context.mimeType);\n        const seemsToBeMP4 = containerType === \"mp4\" || containerType === undefined;\n        if (lowLatencyMode && seemsToBeMP4) {\n            if (fetchIsSupported()) {\n                return loadChunkedSegmentData(url, {\n                    headers,\n                    timeout: options.timeout,\n                    connectionTimeout: options.connectionTimeout,\n                }, callbacks, cancelSignal);\n            }\n            else {\n                warnOnce(\"DASH: Your browser does not have the fetch API. You will have \" +\n                    \"a higher chance of rebuffering when playing close to the live edge\");\n            }\n        }\n        let data;\n        if (seemsToBeMP4) {\n            data = await request({\n                url,\n                responseType: \"arraybuffer\",\n                headers,\n                timeout: options.timeout,\n                connectionTimeout: options.connectionTimeout,\n                onProgress: callbacks.onProgress,\n                cancelSignal,\n            });\n        }\n        else {\n            data = await request({\n                url,\n                responseType: \"text\",\n                headers,\n                timeout: options.timeout,\n                connectionTimeout: options.connectionTimeout,\n                onProgress: callbacks.onProgress,\n                cancelSignal,\n            });\n        }\n        return { resultType: \"segment-loaded\", resultData: data };\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { getMDHDTimescale, getSegmentsFromSidx } from \"../../parsers/containers/isobmff\";\nimport { strToUtf8, utf8ToStr } from \"../../utils/string_parsing\";\nimport getISOBMFFTimingInfos from \"../utils/get_isobmff_timing_infos\";\nimport inferSegmentContainer from \"../utils/infer_segment_container\";\nimport { getISOBMFFEmbeddedTextTrackData, getPlainTextTrackData, } from \"../utils/parse_text_track\";\n/**\n * Parse TextTrack data when it is embedded in an ISOBMFF file.\n *\n * @param {ArrayBuffer|Uint8Array|string} data - The segment data.\n * @param {boolean} isChunked - If `true`, the `data` may contain only a\n * decodable subpart of the full data in the linked segment.\n * @param {Object} context - Object describing the context of the given\n * segment's data: of which segment, `Representation`, `Adaptation`, `Period`,\n * `Manifest` it is a part of etc.\n * @param {number|undefined} initTimescale - `timescale` value - encountered\n * in this linked initialization segment (if it exists) - that may also apply\n * to that segment if no new timescale is defined in it.\n * Can be `undefined` if no timescale was defined, if it is not known, or if\n * no linked initialization segment was yet parsed.\n * @param {boolean} __priv_patchLastSegmentInSidx - Enable ugly Canal+-specific\n * fix for an issue people on the content-packaging side could not fix.\n * For more information on that, look at the code using it.\n * @returns {Object}\n */\nfunction parseISOBMFFEmbeddedTextTrack(data, isChunked, context, initTimescale, __priv_patchLastSegmentInSidx) {\n    var _a;\n    const { segment } = context;\n    const { isInit, indexRange } = segment;\n    let chunkBytes;\n    if (typeof data === \"string\") {\n        chunkBytes = strToUtf8(data);\n    }\n    else if (data instanceof Uint8Array) {\n        chunkBytes = data;\n    }\n    else {\n        chunkBytes = new Uint8Array(data);\n    }\n    if (isInit) {\n        const segmentList = getSegmentsFromSidx(chunkBytes, Array.isArray(indexRange) ? indexRange[0] : 0);\n        // This is a very specific handling for streams we know have a very\n        // specific problem at Canal+: The last reference gives a truncated\n        // segment.\n        // Sadly, people on the packaging side could not fix all legacy contents.\n        // This is an easy-but-ugly fix for those.\n        // TODO Cleaner way? I tried to always check the obtained segment after\n        // a byte-range request but it leads to a lot of code.\n        if (__priv_patchLastSegmentInSidx === true &&\n            segmentList !== null &&\n            segmentList.length > 0) {\n            const lastSegment = segmentList[segmentList.length - 1];\n            if (Array.isArray(lastSegment.range)) {\n                lastSegment.range[1] = Infinity;\n            }\n        }\n        const mdhdTimescale = getMDHDTimescale(chunkBytes);\n        return {\n            segmentType: \"init\",\n            initializationData: null,\n            initializationDataSize: 0,\n            protectionData: [],\n            initTimescale: mdhdTimescale,\n            segmentList: segmentList !== null && segmentList !== void 0 ? segmentList : undefined,\n        };\n    }\n    const chunkInfos = getISOBMFFTimingInfos(chunkBytes, isChunked, segment, initTimescale);\n    const chunkData = getISOBMFFEmbeddedTextTrackData(context, chunkBytes, chunkInfos, isChunked);\n    const chunkOffset = (_a = segment.timestampOffset) !== null && _a !== void 0 ? _a : 0;\n    return {\n        segmentType: \"media\",\n        chunkData,\n        chunkSize: chunkBytes.length,\n        chunkInfos,\n        chunkOffset,\n        protectionData: [],\n        appendWindow: [context.periodStart, context.periodEnd],\n    };\n}\n/**\n * Parse TextTrack data when it is in plain text form.\n *\n * @param {ArrayBuffer|Uint8Array|string} data - The segment data.\n * @param {boolean} isChunked - If `true`, the `data` may contain only a\n * decodable subpart of the full data in the linked segment.\n * @param {Object} context - Object describing the context of the given\n * segment's data: of which segment, `Representation`, `Adaptation`, `Period`,\n * `Manifest` it is a part of etc.\n * @returns {Object}\n */\nfunction parsePlainTextTrack(data, isChunked, context) {\n    const { periodStart, periodEnd, segment } = context;\n    const { timestampOffset = 0 } = segment;\n    if (segment.isInit) {\n        return {\n            segmentType: \"init\",\n            initializationData: null,\n            initializationDataSize: 0,\n            protectionData: [],\n            initTimescale: undefined,\n        };\n    }\n    let textTrackData;\n    let chunkSize;\n    if (typeof data !== \"string\") {\n        const bytesData = data instanceof Uint8Array ? data : new Uint8Array(data);\n        textTrackData = utf8ToStr(bytesData);\n        chunkSize = bytesData.length;\n    }\n    else {\n        textTrackData = data;\n    }\n    const chunkData = getPlainTextTrackData(context, textTrackData, isChunked);\n    return {\n        segmentType: \"media\",\n        chunkData,\n        chunkSize,\n        chunkInfos: null,\n        chunkOffset: timestampOffset,\n        protectionData: [],\n        appendWindow: [periodStart, periodEnd],\n    };\n}\n/**\n * Generate a \"segment parser\" for DASH text tracks.\n *\n * @param {Object} config\n * @returns {Function}\n */\nexport default function generateTextTrackParser({ __priv_patchLastSegmentInSidx, }) {\n    /**\n     * Parse TextTrack data.\n     * @param {Object} loadedSegment\n     * @param {Object} context\n     * @param {number|undefined} initTimescale\n     * @returns {Object}\n     */\n    return function textTrackParser(loadedSegment, context, initTimescale) {\n        var _a;\n        const { periodStart, periodEnd, segment } = context;\n        const { data, isChunked } = loadedSegment;\n        if (data === null) {\n            // No data, just return an empty placeholder object\n            return segment.isInit\n                ? {\n                    segmentType: \"init\",\n                    initializationData: null,\n                    initializationDataSize: 0,\n                    protectionData: [],\n                    initTimescale: undefined,\n                }\n                : {\n                    segmentType: \"media\",\n                    chunkData: null,\n                    chunkSize: 0,\n                    chunkInfos: null,\n                    chunkOffset: (_a = segment.timestampOffset) !== null && _a !== void 0 ? _a : 0,\n                    protectionData: [],\n                    appendWindow: [periodStart, periodEnd],\n                };\n        }\n        const containerType = inferSegmentContainer(context.type, context.mimeType);\n        // TODO take a look to check if this is an ISOBMFF/webm when undefined?\n        if (containerType === \"webm\") {\n            // TODO Handle webm containers\n            throw new Error(\"Text tracks with a WEBM container are not yet handled.\");\n        }\n        else if (containerType === \"mp4\") {\n            return parseISOBMFFEmbeddedTextTrack(data, isChunked, context, initTimescale, __priv_patchLastSegmentInSidx);\n        }\n        else {\n            return parsePlainTextTrack(data, isChunked, context);\n        }\n    };\n}\n","import request from \"../../utils/request/xhr\";\nimport addQueryString from \"../utils/add_query_string\";\nimport byteRange from \"../utils/byte_range\";\nimport constructSegmentUrl from \"./construct_segment_url\";\n/**\n * Load thumbnails for DASH content.\n * @param {Object|null} wantedCdn\n * @param {Object} thumbnail\n * @param {Object} options\n * @param {Object} cancelSignal\n * @returns {Promise}\n */\nexport async function loadThumbnail(wantedCdn, thumbnail, options, cancelSignal) {\n    var _a, _b;\n    const initialUrl = constructSegmentUrl(wantedCdn, thumbnail);\n    if (initialUrl === null) {\n        return Promise.reject(new Error(\"Cannot load thumbnail: no URL\"));\n    }\n    const url = ((_a = options.cmcdPayload) === null || _a === void 0 ? void 0 : _a.type) === \"query\"\n        ? addQueryString(initialUrl, options.cmcdPayload.value)\n        : initialUrl;\n    const cmcdHeaders = ((_b = options.cmcdPayload) === null || _b === void 0 ? void 0 : _b.type) === \"headers\" ? options.cmcdPayload.value : undefined;\n    let headers;\n    if (thumbnail.range !== undefined) {\n        headers = Object.assign(Object.assign({}, cmcdHeaders), { Range: byteRange(thumbnail.range) });\n    }\n    else if (cmcdHeaders !== undefined) {\n        headers = cmcdHeaders;\n    }\n    return request({\n        url,\n        responseType: \"arraybuffer\",\n        headers,\n        timeout: options.timeout,\n        connectionTimeout: options.connectionTimeout,\n        cancelSignal,\n    });\n}\n/**\n * Parse loaded thumbnail data into exploitable thumbnail data and metadata.\n * @param {ArrayBuffer} data - The loaded thumbnail data\n * @param {Object} context\n * @returns {Object}\n */\nexport function parseThumbnail(data, context) {\n    var _a;\n    const { thumbnailTrack, thumbnail: wantedThumbnail } = context;\n    const height = thumbnailTrack.height / thumbnailTrack.verticalTiles;\n    const width = thumbnailTrack.width / thumbnailTrack.horizontalTiles;\n    const thumbnails = [];\n    const tileDuration = (_a = thumbnailTrack.tileDuration) !== null && _a !== void 0 ? _a : (wantedThumbnail.end - wantedThumbnail.time) /\n        (thumbnailTrack.horizontalTiles * thumbnailTrack.verticalTiles);\n    let start = wantedThumbnail.time;\n    for (let row = 0; row < thumbnailTrack.verticalTiles; row++) {\n        for (let column = 0; column < thumbnailTrack.horizontalTiles; column++) {\n            thumbnails.push({\n                start,\n                end: start + tileDuration,\n                offsetX: Math.round(column * width),\n                offsetY: Math.round(row * height),\n                height: Math.floor(height),\n                width: Math.floor(width),\n            });\n            start += tileDuration;\n        }\n    }\n    return {\n        mimeType: thumbnailTrack.mimeType,\n        data,\n        thumbnails,\n    };\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../log\";\nimport { getDurationFromTrun, getTRAF } from \"../../parsers/containers/isobmff\";\nimport { parseTfrf, parseTfxd } from \"./isobmff\";\n/**\n * Try to obtain time information from the given data.\n * @param {Uint8Array} data\n * @param {boolean} isChunked\n * @param {Object} segment\n * @param {boolean} isLive\n * @returns {Object}\n */\nexport default function extractTimingsInfos(data, isChunked, initTimescale, segment, isLive) {\n    var _a;\n    const nextSegments = [];\n    let chunkInfos;\n    let tfxdSegment;\n    let tfrfSegments;\n    if (isLive) {\n        const traf = getTRAF(data);\n        if (traf !== null) {\n            tfrfSegments = parseTfrf(traf);\n            tfxdSegment = parseTfxd(traf);\n        }\n        else {\n            log.warn(\"smooth: could not find traf atom\");\n        }\n    }\n    if (tfrfSegments !== undefined) {\n        for (const tfrfSeg of tfrfSegments) {\n            nextSegments.push({\n                time: tfrfSeg.time,\n                duration: tfrfSeg.duration,\n                timescale: initTimescale,\n            });\n        }\n    }\n    if (tfxdSegment !== undefined) {\n        chunkInfos = {\n            time: tfxdSegment.time / initTimescale,\n            duration: tfxdSegment.duration / initTimescale,\n        };\n        return { nextSegments, chunkInfos, scaledSegmentTime: tfxdSegment.time };\n    }\n    if (isChunked || !segment.complete) {\n        return { nextSegments, chunkInfos: null, scaledSegmentTime: undefined };\n    }\n    const segmentDuration = segment.duration * initTimescale;\n    // we could always make a mistake when reading a container.\n    // If the estimate is too far from what the segment seems to imply, take\n    // the segment infos instead.\n    const maxDecodeTimeDelta = Math.min(initTimescale * 0.9, segmentDuration / 4);\n    const trunDuration = getDurationFromTrun(data);\n    const scaledSegmentTime = ((_a = segment.privateInfos) === null || _a === void 0 ? void 0 : _a.smoothMediaSegment) !== undefined\n        ? segment.privateInfos.smoothMediaSegment.time\n        : Math.round(segment.time * initTimescale);\n    if (trunDuration !== undefined &&\n        Math.abs(trunDuration - segmentDuration) <= maxDecodeTimeDelta) {\n        chunkInfos = { time: segment.time, duration: trunDuration / initTimescale };\n    }\n    else {\n        chunkInfos = { time: segment.time, duration: segment.duration };\n    }\n    return { nextSegments, chunkInfos, scaledSegmentTime };\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * /!\\ This file is feature-switchable.\n * It always should be imported through the `features` object.\n */\nimport SmoothPipelines from \"./pipelines\";\nexport default SmoothPipelines;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Returns `true` if the given Representation refers to segments in an MP4\n * container\n * @param {string|undefined} mimeType\n * @returns {Boolean}\n */\nexport default function isMP4EmbeddedTrack(mimeType) {\n    return typeof mimeType === \"string\" && mimeType.indexOf(\"mp4\") >= 0;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { createBoxWithChildren } from \"../../../parsers/containers/isobmff\";\nimport { createENCABox, createESDSBox, createFRMABox, createMP4ABox, createSCHMBox, createSMHDBox, createSTSDBox, createTENCBox, } from \"./create_boxes\";\nimport createInitSegment from \"./create_init_segment\";\nimport getAacesHeader from \"./get_aaces_header\";\n/**\n * Return full audio initialization segment as Uint8Array.\n * @param {Number} timescale\n * @param {Number} channelsCount\n * @param {Number} sampleSize\n * @param {Number} packetSize\n * @param {Number} sampleRate\n * @param {string} codecPrivateData\n * @param {Uint8Array} keyId - hex string representing the key Id, 32 chars.\n * eg. a800dbed49c12c4cb8e0b25643844b9b\n * @returns {Uint8Array}\n */\nexport default function createAudioInitSegment(timescale, channelsCount, sampleSize, packetSize, sampleRate, codecPrivateData, keyId) {\n    const _codecPrivateData = codecPrivateData.length === 0\n        ? getAacesHeader(2, sampleRate, channelsCount)\n        : codecPrivateData;\n    const esds = createESDSBox(1, _codecPrivateData);\n    const stsd = (() => {\n        if (keyId === undefined) {\n            const mp4a = createMP4ABox(1, channelsCount, sampleSize, packetSize, sampleRate, esds);\n            return createSTSDBox([mp4a]);\n        }\n        const tenc = createTENCBox(1, 8, keyId);\n        const schi = createBoxWithChildren(\"schi\", [tenc]);\n        const schm = createSCHMBox(\"cenc\", 65536);\n        const frma = createFRMABox(\"mp4a\");\n        const sinf = createBoxWithChildren(\"sinf\", [frma, schm, schi]);\n        const enca = createENCABox(1, channelsCount, sampleSize, packetSize, sampleRate, esds, sinf);\n        return createSTSDBox([enca]);\n    })();\n    return createInitSegment(timescale, \"audio\", stsd, createSMHDBox(), 0, 0);\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { createBox } from \"../../../parsers/containers/isobmff\";\nimport { be2toi, be4toi, concat, itobe2, itobe4, itobe8, } from \"../../../utils/byte_parsing\";\nimport { hexToBytes, strToUtf8 } from \"../../../utils/string_parsing\";\n/**\n * @param {Number} width\n * @param {Number} height\n * @param {Number} hRes - horizontal resolution, eg 72\n * @param {Number} vRes - vertical resolution, eg 72\n * @param {string} encName\n * @param {Number} colorDepth - eg 24\n * @param {Uint8Array} avcc - Uint8Array representing the avcC atom\n * @returns {Uint8Array}\n */\nfunction createAVC1Box(width, height, hRes, vRes, encName, colorDepth, avcc) {\n    return createBox(\"avc1\", concat(6, // 6 bytes reserved\n    itobe2(1), 16, // drefIdx + QuickTime reserved, zeroes\n    itobe2(width), // size 2 w\n    itobe2(height), // size 2 h\n    itobe2(hRes), 2, // reso 4 h\n    itobe2(vRes), 2 + 4, // reso 4 v + QuickTime reserved, zeroes\n    [0, 1, encName.length], // frame count (default 1)\n    strToUtf8(encName), // 1byte len + encoder name str\n    31 - encName.length, // + padding\n    itobe2(colorDepth), // color depth\n    [0xff, 0xff], // reserved ones\n    avcc));\n}\n/**\n * @param {Number} width\n * @param {Number} height\n * @param {Number} hRes - horizontal resolution, eg 72\n * @param {Number} vRes - vertical resolution, eg 72\n * @param {string} encName\n * @param {Number} colorDepth - eg 24\n * @param {Uint8Array} avcc - Uint8Array representing the avcC atom\n * @param {Uint8Array} sinf - Uint8Array representing the sinf atom\n * @returns {Uint8Array}\n */\nfunction createENCVBox(width, height, hRes, vRes, encName, colorDepth, avcc, sinf) {\n    return createBox(\"encv\", concat(6, // 6 bytes reserved\n    itobe2(1), 16, // drefIdx + QuickTime reserved, zeroes\n    itobe2(width), // size 2 w\n    itobe2(height), // size 2 h\n    itobe2(hRes), 2, // reso 4 h\n    itobe2(vRes), 2 + 4, // reso 4 v + QuickTime reserved, zeroes\n    [0, 1, encName.length], // frame count (default 1)\n    strToUtf8(encName), // 1byte len + encoder name str\n    31 - encName.length, // + padding\n    itobe2(colorDepth), // color depth\n    [0xff, 0xff], // reserved ones\n    avcc, // avcc atom,\n    sinf));\n}\n/**\n * @param {Number} drefIdx\n * @param {Number} channelsCount\n * @param {Number} sampleSize\n * @param {Number} packetSize\n * @param {Number} sampleRate\n * @param {Uint8Array} esds - Uint8Array representing the esds atom\n * @returns {Uint8Array}\n */\nfunction createMP4ABox(drefIdx, channelsCount, sampleSize, packetSize, sampleRate, esds) {\n    return createBox(\"mp4a\", concat(6, itobe2(drefIdx), 8, itobe2(channelsCount), itobe2(sampleSize), 2, itobe2(packetSize), itobe2(sampleRate), 2, esds));\n}\n/**\n * @param {Number} drefIdx\n * @param {Number} channelsCount\n * @param {Number} sampleSize\n * @param {Number} packetSize\n * @param {Number} sampleRate\n * @param {Uint8Array} esds - Uint8Array representing the esds atom\n * @param {Uint8Array} [sinf] - Uint8Array representing the sinf atom,\n * only if name == \"enca\"\n * @returns {Uint8Array}\n */\nfunction createENCABox(drefIdx, channelsCount, sampleSize, packetSize, sampleRate, esds, sinf) {\n    return createBox(\"enca\", concat(6, itobe2(drefIdx), 8, itobe2(channelsCount), itobe2(sampleSize), 2, itobe2(packetSize), itobe2(sampleRate), 2, esds, sinf));\n}\n/**\n * @param {Uint8Array} url\n * @returns {Uint8Array}\n */\nfunction createDREFBox(url) {\n    // only one description here... FIXME\n    return createBox(\"dref\", concat(7, [1], url));\n}\n/**\n * @param {string} majorBrand\n * @param {Array.<string>} brands\n * @returns {Uint8Array}\n */\nfunction createFTYPBox(majorBrand, brands) {\n    const content = concat(...[strToUtf8(majorBrand), [0, 0, 0, 1]].concat(brands.map(strToUtf8)));\n    return createBox(\"ftyp\", content);\n}\n/**\n * @param {string} schemeType - four letters (eg \"cenc\" for Common Encryption)\n * @param {Number} schemeVersion - eg 65536\n * @returns {Uint8Array}\n */\nfunction createSCHMBox(schemeType, schemeVersion) {\n    return createBox(\"schm\", concat(4, strToUtf8(schemeType), itobe4(schemeVersion)));\n}\n/**\n * Create tfdt box from a decoding time.\n * @param {number} decodeTime\n * @returns {Uint8Array}\n */\nfunction createTfdtBox(decodeTime) {\n    return createBox(\"tfdt\", concat([1, 0, 0, 0], itobe8(decodeTime)));\n}\n/**\n * @returns {Uint8Array}\n */\nfunction createVMHDBox() {\n    const arr = new Uint8Array(12);\n    arr[3] = 1; // QuickTime...\n    return createBox(\"vmhd\", arr);\n}\n/**\n * @param {Number} trackId\n * @returns {Uint8Array}\n */\nfunction createTREXBox(trackId) {\n    // default sample desc idx = 1\n    return createBox(\"trex\", concat(4, itobe4(trackId), [0, 0, 0, 1], 12));\n}\n/**\n * @param {Number} length\n * @returns {Uint8Array}\n */\nfunction createFreeBox(length) {\n    return createBox(\"free\", new Uint8Array(length - 8));\n}\n/**\n * @param {Number} stream\n * @param {string} codecPrivateData - hex string\n * @returns {Uint8Array}\n */\nfunction createESDSBox(stream, codecPrivateData) {\n    return createBox(\"esds\", concat(4, [0x03, 0x19], itobe2(stream), [0x00, 0x04, 0x11, 0x40, 0x15], 11, [0x05, 0x02], hexToBytes(codecPrivateData), [0x06, 0x01, 0x02]));\n}\n/**\n * @param {string} dataFormat - four letters (eg \"avc1\")\n * @returns {Uint8Array}\n */\nfunction createFRMABox(dataFormat) {\n    return createBox(\"frma\", strToUtf8(dataFormat));\n}\n/**\n * @param {Uint8Array} sps\n * @param {Uint8Array} pps\n * @param {Number} nalLen - NAL Unit length: 1, 2 or 4 bytes\n * eg: avcc(0x4d, 0x40, 0x0d, 4, 0xe1, \"674d400d96560c0efcb80a70505050a0\",\n * 1, \"68ef3880\")\n * @returns {Uint8Array}\n */\nfunction createAVCCBox(sps, pps, nalLen) {\n    let nal;\n    if (nalLen === 2) {\n        nal = 0x1;\n    }\n    else if (nalLen === 4) {\n        nal = 0x3;\n    }\n    else {\n        nal = 0x0;\n    }\n    // Deduce AVC Profile from SPS\n    const h264Profile = sps[1];\n    const h264CompatibleProfile = sps[2];\n    const h264Level = sps[3];\n    return createBox(\"avcC\", concat([1, h264Profile, h264CompatibleProfile, h264Level, (0x3f << 2) | nal, 0xe0 | 1], itobe2(sps.length), sps, [1], itobe2(pps.length), pps));\n}\n/**\n * @param {string} type - \"video\"/\"audio\"/\"hint\"\n * @returns {Uint8Array}\n */\nfunction createHDLRBox(type) {\n    let name;\n    let handlerName;\n    switch (type) {\n        case \"video\":\n            name = \"vide\";\n            handlerName = \"VideoHandler\";\n            break;\n        case \"audio\":\n            name = \"soun\";\n            handlerName = \"SoundHandler\";\n            break;\n        default:\n            name = \"hint\";\n            handlerName = \"\";\n            break;\n    }\n    return createBox(\"hdlr\", concat(8, strToUtf8(name), 12, strToUtf8(handlerName), 1));\n}\n/**\n * @param {number} timescale\n * @returns {Uint8Array}\n */\nfunction createMDHDBox(timescale) {\n    return createBox(\"mdhd\", concat(12, itobe4(timescale), 8));\n}\n/**\n * @param {Number} timescale\n * @param {Number} trackId\n * @returns {Uint8Array}\n */\nfunction createMVHDBox(timescale, trackId) {\n    return createBox(\"mvhd\", concat(12, itobe4(timescale), 4, [0, 1], 2, // we assume rate = 1;\n    [1, 0], 10, // we assume volume = 100%;\n    [0, 1], 14, // default matrix\n    [0, 1], 14, // default matrix\n    [64, 0, 0, 0], 26, itobe2(trackId + 1)));\n}\n/**\n * @param {Uint8Array} mfhd\n * @param {Uint8Array} tfhd\n * @param {Uint8Array} tfdt\n * @param {Uint8Array} trun\n * @returns {Uint8Array}\n */\nfunction createSAIOBox(mfhd, tfhd, tfdt, trun) {\n    return createBox(\"saio\", concat(4, [0, 0, 0, 1], // ??\n    itobe4(mfhd.length + tfhd.length + tfdt.length + trun.length + 8 + 8 + 8 + 8)));\n}\n/**\n * @param {Uint8Array} sencContent - including 8 bytes flags and entries count\n * @returns {Uint8Array}\n */\nfunction createSAIZBox(sencContent) {\n    if (sencContent.length === 0) {\n        return createBox(\"saiz\", new Uint8Array(0));\n    }\n    const flags = be4toi(sencContent, 0);\n    const entries = be4toi(sencContent, 4);\n    const arr = new Uint8Array(entries + 9);\n    arr.set(itobe4(entries), 5);\n    let i = 9;\n    let j = 8;\n    let pairsCnt;\n    let pairsLen;\n    while (j < sencContent.length) {\n        j += 8; // assuming IV is 8 bytes TODO handle 16 bytes IV\n        // if we have extradata for each entry\n        if ((flags & 0x2) === 0x2) {\n            pairsLen = 2;\n            pairsCnt = be2toi(sencContent, j);\n            j += pairsCnt * 6 + 2;\n        }\n        else {\n            pairsCnt = 0;\n            pairsLen = 0;\n        }\n        arr[i] = pairsCnt * 6 + 8 + pairsLen;\n        i++;\n    }\n    return createBox(\"saiz\", arr);\n}\n/**\n * @returns {Uint8Array}\n */\nfunction createSMHDBox() {\n    return createBox(\"smhd\", new Uint8Array(8));\n}\n/**\n * @param {Array.<Uint8Array>} reps - arrays of Uint8Array,\n * typically [avc1] or [encv, avc1]\n * @returns {Uint8Array}\n */\nfunction createSTSDBox(reps) {\n    // only one description here... FIXME\n    const arrBase = [7, [reps.length]];\n    return createBox(\"stsd\", concat(...arrBase.concat(reps)));\n}\n/**\n * @param {Number} width\n * @param {Number} height\n * @param {Number} trackId\n * @returns {Uint8Array}\n */\nfunction createTKHDBox(width, height, trackId) {\n    return createBox(\"tkhd\", concat(itobe4(1 + 2 + 4), 8, // we assume track is enabled,\n    // in media and in preview.\n    itobe4(trackId), 20, // we assume trackId = 1;\n    [1, 0, 0, 0], // we assume volume = 100%;\n    [0, 1, 0, 0], 12, // default matrix\n    [0, 1, 0, 0], 12, // default matrix\n    [64, 0, 0, 0], // ??\n    itobe2(width), 2, // width (TODO handle fixed)\n    itobe2(height), 2));\n}\n/**\n * @param {Number} algId - eg 1\n * @param {Number} ivSize - eg 8\n * @param {string} keyId - Hex KID 93789920e8d6520098577df8f2dd5546\n * @returns {Uint8Array}\n */\nfunction createTENCBox(algId, ivSize, keyId) {\n    return createBox(\"tenc\", concat(6, [algId, ivSize], keyId));\n}\nexport { createAVC1Box, createAVCCBox, createDREFBox, createENCABox, createENCVBox, createESDSBox, createFRMABox, createFTYPBox, createFreeBox, createHDLRBox, createMDHDBox, createMP4ABox, createMVHDBox, createSAIOBox, createSAIZBox, createSCHMBox, createSMHDBox, createSTSDBox, createTENCBox, createTKHDBox, createTREXBox, createTfdtBox, createVMHDBox, };\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { createBox, createBoxWithChildren } from \"../../../parsers/containers/isobmff\";\nimport { concat } from \"../../../utils/byte_parsing\";\nimport { createDREFBox, createFTYPBox, createHDLRBox, createMDHDBox, createMVHDBox, createTKHDBox, createTREXBox, } from \"./create_boxes\";\n/**\n * @param {Uint8Array} mvhd\n * @param {Uint8Array} mvex\n * @param {Uint8Array} trak\n * @returns {Array.<Uint8Array>}\n */\nfunction createMOOVBox(mvhd, mvex, trak) {\n    const children = [mvhd, mvex, trak];\n    return createBoxWithChildren(\"moov\", children);\n}\n/**\n * Create an initialization segment with the information given.\n * @param {Number} timescale\n * @param {string} type\n * @param {Uint8Array} stsd\n * @param {Uint8Array} mhd\n * @param {Number} width\n * @param {Number} height\n * @param {Array.<Object>} pssList - List of dict, example:\n * {systemId: \"DEADBEEF\", codecPrivateData: \"DEAFBEEF}\n * @returns {Uint8Array}\n */\nexport default function createInitSegment(timescale, type, stsd, mhd, width, height) {\n    const stbl = createBoxWithChildren(\"stbl\", [\n        stsd,\n        createBox(\"stts\", new Uint8Array(0x08)),\n        createBox(\"stsc\", new Uint8Array(0x08)),\n        createBox(\"stsz\", new Uint8Array(0x0c)),\n        createBox(\"stco\", new Uint8Array(0x08)),\n    ]);\n    const url = createBox(\"url \", new Uint8Array([0, 0, 0, 1]));\n    const dref = createDREFBox(url);\n    const dinf = createBoxWithChildren(\"dinf\", [dref]);\n    const minf = createBoxWithChildren(\"minf\", [mhd, dinf, stbl]);\n    const hdlr = createHDLRBox(type);\n    const mdhd = createMDHDBox(timescale); // this one is really important\n    const mdia = createBoxWithChildren(\"mdia\", [mdhd, hdlr, minf]);\n    const tkhd = createTKHDBox(width, height, 1);\n    const trak = createBoxWithChildren(\"trak\", [tkhd, mdia]);\n    const trex = createTREXBox(1);\n    const mvex = createBoxWithChildren(\"mvex\", [trex]);\n    const mvhd = createMVHDBox(timescale, 1); // in fact, we don't give a sh** about\n    // this value :O\n    const moov = createMOOVBox(mvhd, mvex, trak);\n    const ftyp = createFTYPBox(\"isom\", [\"isom\", \"iso2\", \"iso6\", \"avc1\", \"dash\"]);\n    return concat(ftyp, moov);\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { createBox, createBoxWithChildren } from \"../../../parsers/containers/isobmff\";\nimport { createSAIOBox, createSAIZBox } from \"./create_boxes\";\nexport default function createTrafBox(tfhd, tfdt, trun, mfhd, senc) {\n    const trafs = [tfhd, tfdt, trun];\n    if (senc !== undefined) {\n        trafs.push(createBox(\"senc\", senc), createSAIZBox(senc), createSAIOBox(mfhd, tfhd, tfdt, trun));\n    }\n    return createBoxWithChildren(\"traf\", trafs);\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { createBoxWithChildren } from \"../../../parsers/containers/isobmff\";\nimport { hexToBytes } from \"../../../utils/string_parsing\";\nimport { createAVC1Box, createAVCCBox, createENCVBox, createFRMABox, createSCHMBox, createSTSDBox, createTENCBox, createVMHDBox, } from \"./create_boxes\";\nimport createInitSegment from \"./create_init_segment\";\n/**\n * Return full video Init segment as Uint8Array\n * @param {Number} timescale - lowest number, this one will be set into mdhd\n * *10000 in mvhd, e.g. 1000\n * @param {Number} width\n * @param {Number} height\n * @param {Number} hRes\n * @param {Number} vRes\n * @param {Number} nalLength (1, 2 or 4)\n * @param {string} codecPrivateData\n * @param {Uint8Array} [keyId]\n * @returns {Uint8Array}\n */\nexport default function createVideoInitSegment(timescale, width, height, hRes, vRes, nalLength, codecPrivateData, keyId) {\n    const [, spsHex, ppsHex] = codecPrivateData.split(\"00000001\");\n    if (spsHex === undefined || ppsHex === undefined) {\n        throw new Error(\"Smooth: unsupported codec private data.\");\n    }\n    const sps = hexToBytes(spsHex);\n    const pps = hexToBytes(ppsHex);\n    // TODO NAL length is forced to 4\n    const avcc = createAVCCBox(sps, pps, nalLength);\n    let stsd;\n    if (keyId === undefined) {\n        const avc1 = createAVC1Box(width, height, hRes, vRes, \"AVC Coding\", 24, avcc);\n        stsd = createSTSDBox([avc1]);\n    }\n    else {\n        const tenc = createTENCBox(1, 8, keyId);\n        const schi = createBoxWithChildren(\"schi\", [tenc]);\n        const schm = createSCHMBox(\"cenc\", 65536);\n        const frma = createFRMABox(\"avc1\");\n        const sinf = createBoxWithChildren(\"sinf\", [frma, schm, schi]);\n        const encv = createENCVBox(width, height, hRes, vRes, \"AVC Coding\", 24, avcc, sinf);\n        stsd = createSTSDBox([encv]);\n    }\n    return createInitSegment(timescale, \"video\", stsd, createVMHDBox(), width, height);\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { itobe2 } from \"../../../utils/byte_parsing\";\nimport { bytesToHex } from \"../../../utils/string_parsing\";\n/**\n * Sampling frequencies defined in MPEG-4 Audio.\n * @type {Array.<Number>}\n */\nconst SAMPLING_FREQUENCIES = [\n    96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350,\n];\n/**\n * Return AAC ES Header (hexstr form)\n *\n * @param {Number} type\n *          1 = AAC Main\n *          2 = AAC LC\n *          cf http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio\n * @param {Number} frequency\n * @param {Number} chans (1 or 2)\n * @returns {string}\n */\nexport default function getAacesHeader(type, frequency, chans) {\n    const freq = SAMPLING_FREQUENCIES.indexOf(frequency); // TODO : handle Idx = 15...\n    let val;\n    val = (type & 0x3f) << 0x4;\n    val = (val | (freq & 0x1f)) << 0x4;\n    val = (val | (chans & 0x1f)) << 0x3;\n    return bytesToHex(itobe2(val));\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { getUuidContent } from \"../../../parsers/containers/isobmff\";\nimport { be4toi, be8toi } from \"../../../utils/byte_parsing\";\n/**\n * @param {Uint8Array} traf\n * @returns {Array.<Object>}\n */\nexport default function parseTfrf(traf) {\n    const tfrf = getUuidContent(traf, 0xd4807ef2, 0xca394695, 0x8e5426cb, 0x9e46a79f);\n    if (tfrf === undefined) {\n        return [];\n    }\n    const frags = [];\n    const version = tfrf[0];\n    const fragCount = tfrf[4];\n    for (let i = 0; i < fragCount; i++) {\n        let duration;\n        let time;\n        if (version === 1) {\n            time = be8toi(tfrf, i * 16 + 5);\n            duration = be8toi(tfrf, i * 16 + 5 + 8);\n        }\n        else {\n            time = be4toi(tfrf, i * 8 + 5);\n            duration = be4toi(tfrf, i * 8 + 5 + 4);\n        }\n        frags.push({\n            time,\n            duration,\n        });\n    }\n    return frags;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { getUuidContent } from \"../../../parsers/containers/isobmff\";\nimport { be8toi } from \"../../../utils/byte_parsing\";\n/**\n * @param {Uint8Array} traf\n * @returns {Object|undefined}\n */\nexport default function parseTfxd(traf) {\n    const tfxd = getUuidContent(traf, 0x6d1d9b05, 0x42d544e6, 0x80e2141d, 0xaff757b2);\n    if (tfxd === undefined) {\n        return undefined;\n    }\n    return {\n        duration: be8toi(tfxd, 12),\n        time: be8toi(tfxd, 4),\n    };\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport canPatchISOBMFFSegment from \"../../../compat/can_patch_isobmff\";\nimport { createBoxWithChildren, getBox, getBoxContent, getBoxOffsets, getUuidContent, updateBoxLength, } from \"../../../parsers/containers/isobmff\";\nimport { itobe4 } from \"../../../utils/byte_parsing\";\nimport { createFreeBox, createTfdtBox } from \"./create_boxes\";\nimport createTrafBox from \"./create_traf_box\";\n/**\n * Update ISOBMFF Segment downloaded in Smooth Streaming so it is playable on\n * the browser.\n * @param {Uint8Array} segment\n * @param {Number} decodeTime\n * @return {Uint8Array}\n */\nexport default function patchSegment(segment, decodeTime) {\n    const oldMoofOffsets = getBoxOffsets(segment, 0x6d6f6f66 /* moof */);\n    if (oldMoofOffsets === null) {\n        throw new Error(\"Smooth: Invalid ISOBMFF given\");\n    }\n    const oldMoofContent = segment.subarray(oldMoofOffsets[1], oldMoofOffsets[2]);\n    const mfhdBox = getBox(oldMoofContent, 0x6d666864 /* mfhd */);\n    const trafContent = getBoxContent(oldMoofContent, 0x74726166 /* traf */);\n    if (trafContent === null || mfhdBox === null) {\n        throw new Error(\"Smooth: Invalid ISOBMFF given\");\n    }\n    const tfhdOffsets = getBoxOffsets(trafContent, 0x74666864 /* tfhd */);\n    const oldTrunOffsets = getBoxOffsets(trafContent, 0x7472756e /* trun */);\n    if (tfhdOffsets === null || oldTrunOffsets === null) {\n        throw new Error(\"Smooth: Invalid ISOBMFF given\");\n    }\n    const tfhdBox = trafContent.subarray(tfhdOffsets[0], tfhdOffsets[2]);\n    const oldTrunBox = trafContent.subarray(oldTrunOffsets[0], oldTrunOffsets[2]);\n    // force trackId=1 since trackIds are not always reliable...\n    tfhdBox.set([0, 0, 0, 1], tfhdOffsets[1] - tfhdOffsets[0] + 4 /* version + flags */);\n    const tfdtBox = createTfdtBox(decodeTime);\n    const newTrunBox = updateTrunDataOffset(oldTrunBox, oldTrunOffsets[1] - oldTrunOffsets[0]);\n    const sencContent = getUuidContent(trafContent, 0xa2394f52, 0x5a9b4f14, 0xa2446c42, 0x7c648df4);\n    const newTrafBox = createTrafBox(tfhdBox, tfdtBox, newTrunBox, mfhdBox, sencContent);\n    const newMoof = createBoxWithChildren(\"moof\", [mfhdBox, newTrafBox]);\n    const newMoofOffsets = getBoxOffsets(newMoof, 0x6d6f6f66 /* moof */);\n    const newTrafOffsets = getBoxOffsets(newTrafBox, 0x74726166 /* traf */);\n    const newTrunOffsets = getBoxOffsets(newTrunBox, 0x7472756e /* trun */);\n    if (newMoofOffsets === null || newTrafOffsets === null || newTrunOffsets === null) {\n        throw new Error(\"Smooth: Invalid moof, trun or traf generation\");\n    }\n    /** index of the `data_offset` property from the trun box in the whole \"moof\". */\n    const indexOfTrunDataOffsetInMoof = newMoofOffsets[1] -\n        newMoofOffsets[0] +\n        mfhdBox.length +\n        /* new traf size + name */\n        (newTrafOffsets[1] - newTrafOffsets[0]) +\n        tfhdBox.length +\n        tfdtBox.length +\n        /* new trun size + name */\n        (newTrunOffsets[1] - newTrunOffsets[0]) +\n        8; /* trun version + flags + `sample_count` */\n    const oldMoofLength = oldMoofOffsets[2] - oldMoofOffsets[0];\n    const newMoofSizeDiff = newMoof.length - oldMoofLength;\n    const oldMdatOffset = getBoxOffsets(segment, 0x6d646174 /* \"mdat\" */);\n    if (oldMdatOffset === null) {\n        throw new Error(\"Smooth: Invalid ISOBMFF given\");\n    }\n    if (canPatchISOBMFFSegment() && (newMoofSizeDiff === 0 || newMoofSizeDiff <= -8)) {\n        // patch trun data_offset\n        const mdatContentOffset = oldMdatOffset[1];\n        newMoof.set(itobe4(mdatContentOffset), indexOfTrunDataOffsetInMoof);\n        segment.set(newMoof, oldMoofOffsets[0]);\n        // add \"free\" box for the remaining space\n        if (newMoofSizeDiff <= -8) {\n            segment.set(createFreeBox(-newMoofSizeDiff), newMoof.length);\n        }\n        return segment;\n    }\n    else {\n        // patch trun data_offset\n        const mdatContentOffset = oldMdatOffset[1] + newMoofSizeDiff;\n        newMoof.set(itobe4(mdatContentOffset), indexOfTrunDataOffsetInMoof);\n        const newSegment = new Uint8Array(segment.length + newMoofSizeDiff);\n        const beforeMoof = segment.subarray(0, oldMoofOffsets[0]);\n        const afterMoof = segment.subarray(oldMoofOffsets[2], segment.length);\n        newSegment.set(beforeMoof, 0);\n        newSegment.set(newMoof, beforeMoof.length);\n        newSegment.set(afterMoof, beforeMoof.length + newMoof.length);\n        return newSegment;\n    }\n}\n/**\n * Update `trun` box given or create a new one from it to add a data offset\n * flag and the corresponding space to set a data offset.\n * Do not do anything if the flag is already set.\n *\n * Note that the `oldTrunBox` given should not be mutated by this function but\n * the returned value CAN point to the exact same `Uint8Array`.\n *\n * @param {Uint8Array} oldTrunBox - The whole original trun box\n * @param {number} initialDataOffset - Offset at which the first value of the\n * \"trun\" box (the \"version\") is set.\n * @returns {Uint8Array}\n */\nfunction updateTrunDataOffset(oldTrunBox, initialDataOffset) {\n    const trunHasDataOffset = (oldTrunBox[initialDataOffset + 3 /* last flag */] & 0x01) > 0;\n    if (trunHasDataOffset) {\n        return oldTrunBox;\n    }\n    // If no data_offset is present, we create another \"trun\" with one\n    const newTrunBox = new Uint8Array(oldTrunBox.length + 4);\n    // copy size + name + version=1 + flags=3 + sample_count=4\n    newTrunBox.set(oldTrunBox.subarray(0, initialDataOffset + 8), 0);\n    // add data_offset flag\n    newTrunBox[initialDataOffset + 3] = newTrunBox[initialDataOffset + 3] | 0x01;\n    newTrunBox.set([0, 0, 0, 0], initialDataOffset + 8); // add data offset\n    // add the rest\n    newTrunBox.set(oldTrunBox.subarray(initialDataOffset + 8, oldTrunBox.length), initialDataOffset + 12);\n    return updateBoxLength(newTrunBox); // update the trun box's length\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../log\";\nimport Manifest from \"../../manifest/classes\";\nimport { getMDAT } from \"../../parsers/containers/isobmff\";\nimport createSmoothManifestParser from \"../../parsers/manifest/smooth\";\nimport request from \"../../utils/request\";\nimport { strToUtf8, utf8ToStr } from \"../../utils/string_parsing\";\nimport addQueryString from \"../utils/add_query_string\";\nimport checkISOBMFFIntegrity from \"../utils/check_isobmff_integrity\";\nimport generateManifestLoader from \"../utils/generate_manifest_loader\";\nimport extractTimingsInfos from \"./extract_timings_infos\";\nimport isMP4EmbeddedTrack from \"./is_mp4_embedded_track\";\nimport { patchSegment } from \"./isobmff\";\nimport generateSegmentLoader from \"./segment_loader\";\nimport { constructSegmentUrl } from \"./utils\";\nexport default function (transportOptions) {\n    const smoothManifestParser = createSmoothManifestParser(transportOptions);\n    const segmentLoader = generateSegmentLoader(transportOptions);\n    const manifestLoaderOptions = {\n        customManifestLoader: transportOptions.manifestLoader,\n    };\n    const manifestLoader = generateManifestLoader(manifestLoaderOptions, \"text\", null);\n    const manifestPipeline = {\n        loadManifest: manifestLoader,\n        parseManifest(manifestData, parserOptions) {\n            var _a;\n            const url = (_a = manifestData.url) !== null && _a !== void 0 ? _a : parserOptions.originalUrl;\n            const { receivedTime: manifestReceivedTime, responseData } = manifestData;\n            const documentData = typeof responseData === \"string\"\n                ? new DOMParser().parseFromString(responseData, \"text/xml\")\n                : responseData; // TODO find a way to check if Document?\n            const parserResult = smoothManifestParser(documentData, url, manifestReceivedTime);\n            const warnings = [];\n            const manifest = new Manifest(parserResult, {\n                representationFilter: transportOptions.representationFilter,\n            }, warnings);\n            return { manifest, url, warnings };\n        },\n    };\n    /**\n     * Export functions allowing to load and parse audio and video smooth\n     * segments.\n     */\n    const audioVideoPipeline = {\n        /**\n         * Load a Smooth audio/video segment.\n         * @param {Object|null} wantedCdn\n         * @param {Object} context\n         * @param {Object} loaderOptions\n         * @param {Object} cancelSignal\n         * @param {Object} callbacks\n         * @returns {Promise}\n         */\n        loadSegment(wantedCdn, context, loaderOptions, cancelSignal, callbacks) {\n            const url = constructSegmentUrl(wantedCdn, context.segment);\n            return segmentLoader(url, context, loaderOptions, cancelSignal, callbacks);\n        },\n        parseSegment(loadedSegment, context, initTimescale) {\n            var _a, _b;\n            const { segment } = context;\n            const { data, isChunked } = loadedSegment;\n            if (data === null) {\n                if (segment.isInit) {\n                    return {\n                        segmentType: \"init\",\n                        initializationData: null,\n                        initializationDataSize: 0,\n                        protectionData: [],\n                        initTimescale: undefined,\n                    };\n                }\n                return {\n                    segmentType: \"media\",\n                    chunkData: null,\n                    chunkInfos: null,\n                    chunkOffset: 0,\n                    chunkSize: 0,\n                    protectionData: [],\n                    appendWindow: [undefined, undefined],\n                };\n            }\n            const responseBuffer = data instanceof Uint8Array ? data : new Uint8Array(data);\n            if (segment.isInit) {\n                const timescale = (_b = (_a = segment.privateInfos) === null || _a === void 0 ? void 0 : _a.smoothInitSegment) === null || _b === void 0 ? void 0 : _b.timescale;\n                return {\n                    segmentType: \"init\",\n                    initializationData: data,\n                    initializationDataSize: data.byteLength,\n                    // smooth init segments are crafted by hand.\n                    // Their timescale is the one from the manifest.\n                    initTimescale: timescale,\n                    protectionData: [],\n                };\n            }\n            const timingInfos = initTimescale !== undefined\n                ? extractTimingsInfos(responseBuffer, isChunked, initTimescale, segment, context.isLive)\n                : null;\n            if (timingInfos === null ||\n                timingInfos.chunkInfos === null ||\n                timingInfos.scaledSegmentTime === undefined) {\n                throw new Error(\"Smooth Segment without time information\");\n            }\n            const { nextSegments, chunkInfos, scaledSegmentTime } = timingInfos;\n            const chunkData = patchSegment(responseBuffer, scaledSegmentTime);\n            const predictedSegments = nextSegments.length > 0 ? nextSegments : undefined;\n            return {\n                segmentType: \"media\",\n                chunkData,\n                chunkInfos,\n                chunkOffset: 0,\n                chunkSize: chunkData.length,\n                protectionData: [],\n                predictedSegments,\n                appendWindow: [undefined, undefined],\n            };\n        },\n    };\n    const textTrackPipeline = {\n        loadSegment(wantedCdn, context, loaderOptions, cancelSignal, callbacks) {\n            var _a, _b, _c, _d;\n            const { segment } = context;\n            const url = constructSegmentUrl(wantedCdn, segment);\n            if (segment.isInit || url === null) {\n                return Promise.resolve({\n                    resultType: \"segment-created\",\n                    resultData: null,\n                });\n            }\n            const isMP4 = isMP4EmbeddedTrack(context.mimeType);\n            if (!isMP4) {\n                return request({\n                    url: ((_a = loaderOptions.cmcdPayload) === null || _a === void 0 ? void 0 : _a.type) === \"query\"\n                        ? addQueryString(url, loaderOptions.cmcdPayload.value)\n                        : url,\n                    headers: ((_b = loaderOptions.cmcdPayload) === null || _b === void 0 ? void 0 : _b.type) === \"headers\"\n                        ? loaderOptions.cmcdPayload.value\n                        : undefined,\n                    responseType: \"text\",\n                    timeout: loaderOptions.timeout,\n                    connectionTimeout: loaderOptions.connectionTimeout,\n                    cancelSignal,\n                    onProgress: callbacks.onProgress,\n                }).then((data) => ({\n                    resultType: \"segment-loaded\",\n                    resultData: data,\n                }));\n            }\n            else {\n                return request({\n                    url: ((_c = loaderOptions.cmcdPayload) === null || _c === void 0 ? void 0 : _c.type) === \"query\"\n                        ? addQueryString(url, loaderOptions.cmcdPayload.value)\n                        : url,\n                    headers: ((_d = loaderOptions.cmcdPayload) === null || _d === void 0 ? void 0 : _d.type) === \"headers\"\n                        ? loaderOptions.cmcdPayload.value\n                        : undefined,\n                    responseType: \"arraybuffer\",\n                    timeout: loaderOptions.timeout,\n                    connectionTimeout: loaderOptions.connectionTimeout,\n                    cancelSignal,\n                    onProgress: callbacks.onProgress,\n                }).then((data) => {\n                    if (transportOptions.checkMediaSegmentIntegrity !== true) {\n                        return { resultType: \"segment-loaded\", resultData: data };\n                    }\n                    const dataU8 = new Uint8Array(data.responseData);\n                    checkISOBMFFIntegrity(dataU8, context.segment.isInit);\n                    return {\n                        resultType: \"segment-loaded\",\n                        resultData: Object.assign(Object.assign({}, data), { responseData: dataU8 }),\n                    };\n                });\n            }\n        },\n        parseSegment(loadedSegment, context, initTimescale) {\n            var _a;\n            const { segment, language, mimeType = \"\", codecs = \"\" } = context;\n            const isMP4 = isMP4EmbeddedTrack(context.mimeType);\n            const { data, isChunked } = loadedSegment;\n            let chunkSize;\n            if (segment.isInit) {\n                // text init segment has no use in HSS\n                return {\n                    segmentType: \"init\",\n                    initializationData: null,\n                    initializationDataSize: 0,\n                    protectionData: [],\n                    initTimescale: undefined,\n                };\n            }\n            if (data === null) {\n                return {\n                    segmentType: \"media\",\n                    chunkData: null,\n                    chunkInfos: null,\n                    chunkOffset: 0,\n                    chunkSize: 0,\n                    protectionData: [],\n                    appendWindow: [undefined, undefined],\n                };\n            }\n            let nextSegments;\n            let chunkInfos = null;\n            let segmentStart;\n            let segmentEnd;\n            let _sdData;\n            let _sdType;\n            if (isMP4) {\n                let chunkBytes;\n                if (typeof data === \"string\") {\n                    chunkBytes = strToUtf8(data);\n                }\n                else {\n                    chunkBytes = data instanceof Uint8Array ? data : new Uint8Array(data);\n                }\n                chunkSize = chunkBytes.length;\n                const timingInfos = initTimescale !== undefined\n                    ? extractTimingsInfos(chunkBytes, isChunked, initTimescale, segment, context.isLive)\n                    : null;\n                nextSegments = timingInfos === null || timingInfos === void 0 ? void 0 : timingInfos.nextSegments;\n                chunkInfos = (_a = timingInfos === null || timingInfos === void 0 ? void 0 : timingInfos.chunkInfos) !== null && _a !== void 0 ? _a : null;\n                if (chunkInfos === null) {\n                    if (isChunked) {\n                        log.warn(\"Smooth: Unavailable time data for current text track.\");\n                    }\n                    else {\n                        segmentStart = segment.time;\n                        segmentEnd = segment.end;\n                    }\n                }\n                else {\n                    segmentStart = chunkInfos.time;\n                    segmentEnd =\n                        chunkInfos.duration !== undefined\n                            ? chunkInfos.time + chunkInfos.duration\n                            : segment.end;\n                }\n                const lcCodec = codecs.toLowerCase();\n                if (mimeType === \"application/ttml+xml+mp4\" ||\n                    lcCodec === \"stpp\" ||\n                    lcCodec === \"stpp.ttml\" ||\n                    lcCodec === \"stpp.ttml.im1t\") {\n                    _sdType = \"ttml\";\n                }\n                else if (lcCodec === \"wvtt\") {\n                    _sdType = \"vtt\";\n                }\n                else {\n                    throw new Error(`could not find a text-track parser for the type ${mimeType}`);\n                }\n                const mdat = getMDAT(chunkBytes);\n                _sdData = mdat === null ? \"\" : utf8ToStr(mdat);\n            }\n            else {\n                // not MP4\n                segmentStart = segment.time;\n                segmentEnd = segment.end;\n                let chunkString;\n                if (typeof data !== \"string\") {\n                    const bytesData = data instanceof Uint8Array ? data : new Uint8Array(data);\n                    chunkSize = bytesData.length;\n                    chunkString = utf8ToStr(bytesData);\n                }\n                else {\n                    chunkString = data;\n                }\n                switch (mimeType) {\n                    case \"application/x-sami\":\n                    case \"application/smil\": // TODO SMIL should be its own format, no?\n                        _sdType = \"sami\";\n                        break;\n                    case \"application/ttml+xml\":\n                        _sdType = \"ttml\";\n                        break;\n                    case \"text/vtt\":\n                        _sdType = \"vtt\";\n                        break;\n                }\n                if (_sdType === undefined) {\n                    const lcCodec = codecs.toLowerCase();\n                    if (lcCodec === \"srt\") {\n                        _sdType = \"srt\";\n                    }\n                    else {\n                        throw new Error(`could not find a text-track parser for the type ${mimeType}`);\n                    }\n                }\n                _sdData = chunkString;\n            }\n            const predictedSegments = Array.isArray(nextSegments) && nextSegments.length > 0 ? nextSegments : undefined;\n            const chunkOffset = segmentStart !== null && segmentStart !== void 0 ? segmentStart : 0;\n            return {\n                segmentType: \"media\",\n                chunkData: {\n                    type: _sdType,\n                    data: _sdData,\n                    start: segmentStart,\n                    end: segmentEnd,\n                    language,\n                },\n                chunkSize,\n                chunkInfos,\n                chunkOffset,\n                protectionData: [],\n                predictedSegments,\n                appendWindow: [undefined, undefined],\n            };\n        },\n    };\n    return {\n        transportName: \"smooth\",\n        manifest: manifestPipeline,\n        audio: audioVideoPipeline,\n        video: audioVideoPipeline,\n        text: textTrackPipeline,\n        thumbnails: {\n            loadThumbnail: () => Promise.reject(new Error(\"Thumbnail tracks aren't implemented with smooth\")),\n            parseThumbnail: () => {\n                throw new Error(\"Thumbnail tracks aren't implemented with smooth\");\n            },\n        },\n    };\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { CustomLoaderError } from \"../../errors\";\nimport assert from \"../../utils/assert\";\nimport request from \"../../utils/request\";\nimport addQueryString from \"../utils/add_query_string\";\nimport byteRange from \"../utils/byte_range\";\nimport checkISOBMFFIntegrity from \"../utils/check_isobmff_integrity\";\nimport isMP4EmbeddedTrack from \"./is_mp4_embedded_track\";\nimport { createAudioInitSegment, createVideoInitSegment } from \"./isobmff\";\n/**\n * Segment loader triggered if there was no custom-defined one in the API.\n * @param {string} initialUrl\n * @param {Object} context\n * @param {Object} loaderOptions\n * @param {Object} callbacks\n * @param {Object} cancelSignal\n * @param {boolean} checkMediaSegmentIntegrity\n * @returns {Promise}\n */\nasync function regularSegmentLoader(initialUrl, context, callbacks, loaderOptions, cancelSignal, checkMediaSegmentIntegrity) {\n    var _a, _b;\n    const cmcdHeaders = ((_a = loaderOptions.cmcdPayload) === null || _a === void 0 ? void 0 : _a.type) === \"headers\"\n        ? loaderOptions.cmcdPayload.value\n        : undefined;\n    const range = context.segment.range;\n    let headers;\n    if (Array.isArray(range)) {\n        headers = Object.assign(Object.assign({}, cmcdHeaders), { Range: byteRange(range) });\n    }\n    else if (cmcdHeaders !== undefined) {\n        headers = cmcdHeaders;\n    }\n    const url = ((_b = loaderOptions.cmcdPayload) === null || _b === void 0 ? void 0 : _b.type) === \"query\"\n        ? addQueryString(initialUrl, loaderOptions.cmcdPayload.value)\n        : initialUrl;\n    const data = await request({\n        url,\n        responseType: \"arraybuffer\",\n        headers,\n        timeout: loaderOptions.timeout,\n        connectionTimeout: loaderOptions.connectionTimeout,\n        cancelSignal,\n        onProgress: callbacks.onProgress,\n    });\n    const isMP4 = isMP4EmbeddedTrack(context.mimeType);\n    if (!isMP4 || checkMediaSegmentIntegrity !== true) {\n        return { resultType: \"segment-loaded\", resultData: data };\n    }\n    const dataU8 = new Uint8Array(data.responseData);\n    checkISOBMFFIntegrity(dataU8, context.segment.isInit);\n    return {\n        resultType: \"segment-loaded\",\n        resultData: Object.assign(Object.assign({}, data), { responseData: dataU8 }),\n    };\n}\n/**\n * Defines the url for the request, load the right loader (custom/default\n * one).\n */\nconst generateSegmentLoader = ({ checkMediaSegmentIntegrity, segmentLoader, }) => (url, context, loaderOptions, cancelSignal, callbacks) => {\n    const { segment } = context;\n    if (segment.isInit) {\n        if (segment.privateInfos === undefined ||\n            segment.privateInfos.smoothInitSegment === undefined) {\n            throw new Error(\"Smooth: Invalid segment format\");\n        }\n        const smoothInitPrivateInfos = segment.privateInfos.smoothInitSegment;\n        let responseData;\n        const { codecPrivateData, timescale, height, width, protection = { keyId: undefined, keySystems: undefined }, } = smoothInitPrivateInfos;\n        if (codecPrivateData === undefined) {\n            throw new Error(\"Smooth: no codec private data.\");\n        }\n        switch (context.type) {\n            case \"video\": {\n                responseData = createVideoInitSegment(timescale, width !== null && width !== void 0 ? width : 0, height !== null && height !== void 0 ? height : 0, 72, 72, 4, // vRes, hRes, nal\n                codecPrivateData, protection.keyId);\n                break;\n            }\n            case \"audio\": {\n                const { channels = 0, bitsPerSample = 0, packetSize = 0, samplingRate = 0, } = smoothInitPrivateInfos;\n                responseData = createAudioInitSegment(timescale, channels, bitsPerSample, packetSize, samplingRate, codecPrivateData, protection.keyId);\n                break;\n            }\n            default:\n                if (0 /* __ENVIRONMENT__.CURRENT_ENV */ === 1 /* __ENVIRONMENT__.DEV */) {\n                    assert(false, \"responseData should have been set\");\n                }\n                responseData = new Uint8Array(0);\n        }\n        return Promise.resolve({\n            resultType: \"segment-created\",\n            resultData: responseData,\n        });\n    }\n    else if (url === null) {\n        return Promise.resolve({\n            resultType: \"segment-created\",\n            resultData: null,\n        });\n    }\n    else {\n        if (typeof segmentLoader !== \"function\") {\n            return regularSegmentLoader(url, context, callbacks, loaderOptions, cancelSignal, checkMediaSegmentIntegrity);\n        }\n        return new Promise((res, rej) => {\n            /** `true` when the custom segmentLoader should not be active anymore. */\n            let hasFinished = false;\n            /**\n             * Callback triggered when the custom segment loader has a response.\n             * @param {Object} args\n             */\n            const resolve = (_args) => {\n                if (hasFinished || cancelSignal.isCancelled()) {\n                    return;\n                }\n                hasFinished = true;\n                cancelSignal.deregister(abortCustomLoader);\n                const isMP4 = isMP4EmbeddedTrack(context.mimeType);\n                if (!isMP4 || checkMediaSegmentIntegrity !== true) {\n                    res({\n                        resultType: \"segment-loaded\",\n                        resultData: {\n                            responseData: _args.data,\n                            size: _args.size,\n                            requestDuration: _args.duration,\n                        },\n                    });\n                }\n                const dataU8 = _args.data instanceof Uint8Array ? _args.data : new Uint8Array(_args.data);\n                checkISOBMFFIntegrity(dataU8, context.segment.isInit);\n                res({\n                    resultType: \"segment-loaded\",\n                    resultData: {\n                        responseData: dataU8,\n                        size: _args.size,\n                        requestDuration: _args.duration,\n                    },\n                });\n            };\n            /**\n             * Callback triggered when the custom segment loader fails\n             * @param {*} err - The corresponding error encountered\n             */\n            const reject = (err) => {\n                var _a, _b;\n                if (hasFinished || cancelSignal.isCancelled()) {\n                    return;\n                }\n                hasFinished = true;\n                cancelSignal.deregister(abortCustomLoader);\n                // Format error and send it\n                const castedErr = err;\n                const message = (_a = castedErr === null || castedErr === void 0 ? void 0 : castedErr.message) !== null && _a !== void 0 ? _a : \"Unknown error when fetching a Smooth segment through a \" +\n                    \"custom segmentLoader.\";\n                const emittedErr = new CustomLoaderError(message, (_b = castedErr === null || castedErr === void 0 ? void 0 : castedErr.canRetry) !== null && _b !== void 0 ? _b : false, castedErr === null || castedErr === void 0 ? void 0 : castedErr.xhr);\n                rej(emittedErr);\n            };\n            const progress = (_args) => {\n                if (hasFinished || cancelSignal.isCancelled()) {\n                    return;\n                }\n                callbacks.onProgress({\n                    duration: _args.duration,\n                    size: _args.size,\n                    totalSize: _args.totalSize,\n                });\n            };\n            const fallback = () => {\n                if (hasFinished || cancelSignal.isCancelled()) {\n                    return;\n                }\n                hasFinished = true;\n                cancelSignal.deregister(abortCustomLoader);\n                regularSegmentLoader(url, context, callbacks, loaderOptions, cancelSignal, checkMediaSegmentIntegrity).then(res, rej);\n            };\n            const customCallbacks = { reject, resolve, fallback, progress };\n            let byteRanges;\n            if (context.segment.range !== undefined) {\n                byteRanges = [context.segment.range];\n                if (context.segment.indexRange !== undefined) {\n                    byteRanges.push(context.segment.indexRange);\n                }\n            }\n            const args = {\n                isInit: context.segment.isInit,\n                timeout: loaderOptions.timeout,\n                byteRanges,\n                trackType: context.type,\n                url,\n                cmcdPayload: loaderOptions.cmcdPayload,\n            };\n            const abort = segmentLoader(args, customCallbacks);\n            cancelSignal.register(abortCustomLoader);\n            /**\n             * The logic to run when the custom loader is cancelled while pending.\n             * @param {Error} err\n             */\n            function abortCustomLoader(err) {\n                if (hasFinished) {\n                    return;\n                }\n                hasFinished = true;\n                if (!hasFinished && typeof abort === \"function\") {\n                    abort();\n                }\n                rej(err);\n            }\n        });\n    }\n};\nexport default generateSegmentLoader;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { resolveURL } from \"../../utils/url-utils\";\n/**\n * Returns `true` if the given Representation refers to segments in an MP4\n * container\n * @param {Representation} representation\n * @returns {Boolean}\n */\nfunction isMP4EmbeddedTrack(representation) {\n    return (typeof representation.mimeType === \"string\" &&\n        representation.mimeType.indexOf(\"mp4\") >= 0);\n}\nfunction constructSegmentUrl(wantedCdn, segment) {\n    if (wantedCdn === null) {\n        return null;\n    }\n    if (segment.url === null) {\n        return wantedCdn.baseUrl;\n    }\n    return resolveURL(wantedCdn.baseUrl, segment.url);\n}\nexport { constructSegmentUrl, isMP4EmbeddedTrack };\n","/**\n * Add to an URL a query string corresponding to `supplementaryQueryStringData`,\n * being tuples where the first element is a query string's property name and the\n * second element is its value (or null if there's no associated value.\n *\n * If the given URL already has a query string, the new query string elements\n * will just be appended.\n * @param {string} baseUrl\n * @param {Array.<Array.<string|null>>} supplementaryQueryStringData\n * @returns {string}\n */\nexport default function addQueryString(baseUrl, supplementaryQueryStringData) {\n    if (supplementaryQueryStringData.length === 0) {\n        return baseUrl;\n    }\n    let queryStringStartingChar;\n    let urlFragment = \"\";\n    const indexOfFragment = baseUrl.indexOf(\"#\");\n    let baseUrlWithoutFragment = baseUrl;\n    if (indexOfFragment >= 0) {\n        urlFragment = baseUrl.substring(indexOfFragment);\n        baseUrlWithoutFragment = baseUrl.substring(0, indexOfFragment);\n    }\n    const indexOfQueryString = baseUrlWithoutFragment.indexOf(\"?\");\n    if (indexOfQueryString === -1) {\n        queryStringStartingChar = \"?\";\n    }\n    else if (indexOfQueryString + 1 === baseUrlWithoutFragment.length) {\n        queryStringStartingChar = \"\";\n    }\n    else {\n        queryStringStartingChar = \"&\";\n    }\n    let url = baseUrlWithoutFragment + queryStringStartingChar;\n    for (let i = 0; i < supplementaryQueryStringData.length; i++) {\n        const queryStringElt = supplementaryQueryStringData[i];\n        if (queryStringElt[1] === null) {\n            url += queryStringElt[0];\n        }\n        else {\n            url += `${queryStringElt[0]}=${queryStringElt[1]}`;\n        }\n        if (i < supplementaryQueryStringData.length - 1) {\n            url += \"&\";\n        }\n    }\n    if (urlFragment.length > 0) {\n        url += urlFragment;\n    }\n    return url;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Returns text-formatted byteRange (`bytes=$start-$end?)`\n * @param {Array.<string|Number>} arr\n * @returns {string}\n */\nexport default function byteRange([start, end]) {\n    return end === Infinity ? `bytes=${start}-` : `bytes=${start}-${end}`;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { CustomLoaderError } from \"../../errors\";\nimport getMonotonicTimeStamp from \"../../utils/monotonic_timestamp\";\nexport default function callCustomManifestLoader(customManifestLoader, fallbackManifestLoader) {\n    return (url, loaderOptions, cancelSignal) => {\n        return new Promise((res, rej) => {\n            const timeAPIsDelta = Date.now() - getMonotonicTimeStamp();\n            /** `true` when the custom segmentLoader should not be active anymore. */\n            let hasFinished = false;\n            /**\n             * Callback triggered when the custom manifest loader has a response.\n             * @param {Object} _args\n             */\n            const resolve = (_args) => {\n                if (hasFinished || cancelSignal.isCancelled()) {\n                    return;\n                }\n                hasFinished = true;\n                cancelSignal.deregister(abortCustomLoader);\n                const receivedTime = _args.receivingTime !== undefined\n                    ? _args.receivingTime - timeAPIsDelta\n                    : undefined;\n                const sendingTime = _args.sendingTime !== undefined ? _args.sendingTime - timeAPIsDelta : undefined;\n                res({\n                    responseData: _args.data,\n                    size: _args.size,\n                    requestDuration: _args.duration,\n                    url: _args.url,\n                    receivedTime,\n                    sendingTime,\n                });\n            };\n            /**\n             * Callback triggered when the custom manifest loader fails\n             * @param {*} err - The corresponding error encountered\n             */\n            const reject = (err) => {\n                var _a, _b;\n                if (hasFinished || cancelSignal.isCancelled()) {\n                    return;\n                }\n                hasFinished = true;\n                cancelSignal.deregister(abortCustomLoader);\n                // Format error and send it\n                const castedErr = err;\n                const message = (_a = castedErr === null || castedErr === void 0 ? void 0 : castedErr.message) !== null && _a !== void 0 ? _a : \"Unknown error when fetching the Manifest through a \" +\n                    \"custom manifestLoader.\";\n                const emittedErr = new CustomLoaderError(message, (_b = castedErr === null || castedErr === void 0 ? void 0 : castedErr.canRetry) !== null && _b !== void 0 ? _b : false, castedErr === null || castedErr === void 0 ? void 0 : castedErr.xhr);\n                rej(emittedErr);\n            };\n            /**\n             * Callback triggered when the custom manifest loader wants to fallback to\n             * the \"regular\" implementation\n             */\n            const fallback = () => {\n                if (hasFinished || cancelSignal.isCancelled()) {\n                    return;\n                }\n                hasFinished = true;\n                cancelSignal.deregister(abortCustomLoader);\n                fallbackManifestLoader(url, loaderOptions, cancelSignal).then(res, rej);\n            };\n            const callbacks = { reject, resolve, fallback };\n            const abort = customManifestLoader({ url, timeout: loaderOptions.timeout, cmcdPayload: loaderOptions.cmcdPayload }, callbacks);\n            cancelSignal.register(abortCustomLoader);\n            /**\n             * The logic to run when the custom loader is cancelled while pending.\n             * @param {Error} err\n             */\n            function abortCustomLoader(err) {\n                if (hasFinished) {\n                    return;\n                }\n                hasFinished = true;\n                if (typeof abort === \"function\") {\n                    abort();\n                }\n                rej(err);\n            }\n        });\n    };\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { OtherError } from \"../../errors\";\nimport { findCompleteBox } from \"../../parsers/containers/isobmff\";\n/**\n * Check if an ISOBMFF segment has all the right box needed to be decoded.\n * Throw if that's not the case.\n * @param {Uint8Array} buffer - The whole ISOBMFF segment\n * @param {boolean} isInitSegment - `true` if this is an initialization segment,\n * `false` otherwise.\n */\nexport default function checkISOBMFFIntegrity(buffer, isInitSegment) {\n    if (isInitSegment) {\n        const ftypIndex = findCompleteBox(buffer, 0x66747970 /* ftyp */);\n        if (ftypIndex < 0) {\n            throw new OtherError(\"INTEGRITY_ERROR\", \"Incomplete `ftyp` box\");\n        }\n        const moovIndex = findCompleteBox(buffer, 0x6d6f6f76 /* moov */);\n        if (moovIndex < 0) {\n            throw new OtherError(\"INTEGRITY_ERROR\", \"Incomplete `moov` box\");\n        }\n    }\n    else {\n        const moofIndex = findCompleteBox(buffer, 0x6d6f6f66 /* moof */);\n        if (moofIndex < 0) {\n            throw new OtherError(\"INTEGRITY_ERROR\", \"Incomplete `moof` box\");\n        }\n        const mdatIndex = findCompleteBox(buffer, 0x6d646174 /* mdat */);\n        if (mdatIndex < 0) {\n            throw new OtherError(\"INTEGRITY_ERROR\", \"Incomplete `mdat` box\");\n        }\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assertUnreachable } from \"../../utils/assert\";\nimport request from \"../../utils/request\";\nimport addQueryString from \"./add_query_string\";\nimport callCustomManifestLoader from \"./call_custom_manifest_loader\";\n/**\n * Manifest loader triggered if there was no custom-defined one in the API.\n * @param {string} preferredType\n * @returns {Function}\n */\nfunction generateRegularManifestLoader(preferredType) {\n    return function regularManifestLoader(initialUrl, loaderOptions, cancelSignal) {\n        var _a, _b;\n        if (initialUrl === undefined) {\n            throw new Error(\"Cannot perform HTTP(s) request. URL not known\");\n        }\n        const url = ((_a = loaderOptions.cmcdPayload) === null || _a === void 0 ? void 0 : _a.type) === \"query\"\n            ? addQueryString(initialUrl, loaderOptions.cmcdPayload.value)\n            : initialUrl;\n        const cmcdHeaders = ((_b = loaderOptions.cmcdPayload) === null || _b === void 0 ? void 0 : _b.type) === \"headers\"\n            ? loaderOptions.cmcdPayload.value\n            : undefined;\n        // What follows could be written in a single line, but TypeScript wouldn't\n        // shut up.\n        // So I wrote that instead, temporarily of course ;)\n        switch (preferredType) {\n            case \"arraybuffer\":\n                return request({\n                    url,\n                    headers: cmcdHeaders,\n                    responseType: \"arraybuffer\",\n                    timeout: loaderOptions.timeout,\n                    connectionTimeout: loaderOptions.connectionTimeout,\n                    cancelSignal,\n                });\n            case \"text\":\n                return request({\n                    url,\n                    headers: cmcdHeaders,\n                    responseType: \"text\",\n                    timeout: loaderOptions.timeout,\n                    connectionTimeout: loaderOptions.connectionTimeout,\n                    cancelSignal,\n                });\n            case \"document\":\n                return request({\n                    url,\n                    headers: cmcdHeaders,\n                    responseType: \"document\",\n                    timeout: loaderOptions.timeout,\n                    connectionTimeout: loaderOptions.connectionTimeout,\n                    cancelSignal,\n                });\n            default:\n                assertUnreachable(preferredType);\n        }\n    };\n}\n/**\n * Generate a manifest loader for the application\n * @param {Function} [customManifestLoader]\n * @param {string} preferredType\n * @returns {Function}\n */\nexport default function generateManifestLoader({ customManifestLoader }, preferredType, integrityCheck) {\n    const regularManifestLoader = generateRegularManifestLoader(preferredType);\n    const actualLoader = typeof customManifestLoader !== \"function\"\n        ? regularManifestLoader\n        : callCustomManifestLoader(customManifestLoader, regularManifestLoader);\n    return integrityCheck !== null ? integrityCheck(actualLoader) : actualLoader;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../log\";\nimport { getDurationFromTrun, getTrackFragmentDecodeTime, } from \"../../parsers/containers/isobmff\";\n/**\n * Get precize start and duration of a chunk.\n * @param {UInt8Array} buffer - An ISOBMFF container (at least a `moof` + a\n * `mdat` box.\n * @param {Boolean} isChunked - If true, the whole segment was chunked into\n * multiple parts and buffer is one of them. If false, buffer is the whole\n * segment.\n * @param {Object} segment\n * @param {number|undefined} initTimescale\n * @returns {Object}\n */\nexport default function getISOBMFFTimingInfos(buffer, isChunked, segment, initTimescale) {\n    const baseDecodeTime = getTrackFragmentDecodeTime(buffer);\n    if (baseDecodeTime === undefined || initTimescale === undefined) {\n        return null;\n    }\n    let startTime = segment.timestampOffset !== undefined\n        ? baseDecodeTime + segment.timestampOffset * initTimescale\n        : baseDecodeTime;\n    let trunDuration = getDurationFromTrun(buffer);\n    if (startTime < 0) {\n        if (trunDuration !== undefined) {\n            trunDuration += startTime; // remove from duration what comes before `0`\n        }\n        startTime = 0;\n    }\n    if (isChunked || !segment.complete) {\n        if (trunDuration === undefined) {\n            log.warn(\"DASH: Chunked segments should indicate a duration through their\" + \" trun boxes\");\n        }\n        return {\n            time: startTime / initTimescale,\n            duration: trunDuration !== undefined ? trunDuration / initTimescale : undefined,\n        };\n    }\n    let duration;\n    const segmentDuration = segment.duration * initTimescale;\n    // we could always make a mistake when reading a container.\n    // If the estimate is too far from what the segment seems to imply, take\n    // the segment infos instead.\n    const maxDecodeTimeDelta = Math.min(initTimescale * 0.9, segmentDuration / 4);\n    if (trunDuration !== undefined &&\n        Math.abs(trunDuration - segmentDuration) <= maxDecodeTimeDelta) {\n        duration = trunDuration;\n    }\n    return {\n        time: startTime / initTimescale,\n        duration: duration !== undefined ? duration / initTimescale : duration,\n    };\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Guess the type of container a segment is in based on Manifest information.\n *\n * Returns:\n *   - \"mp4\" if we can say with confidence the segment will be in an mp4 format\n *   - \"webm\" if we can say with confidence the segment will be in a webm format\n *   - `undefined` if we cannot say with confidence in which container the\n *     segment will be in.\n * @param {string} adaptationType\n * @param {string} mimeType\n * @returns {string | undefined}\n */\nexport default function inferSegmentContainer(adaptationType, mimeType) {\n    if (adaptationType === \"audio\" || adaptationType === \"video\") {\n        if (mimeType === \"video/mp4\" || mimeType === \"audio/mp4\") {\n            return \"mp4\";\n        }\n        if (mimeType === \"video/webm\" || mimeType === \"audio/webm\") {\n            return \"webm\";\n        }\n        return undefined;\n    }\n    else if (adaptationType === \"text\") {\n        return mimeType === \"application/mp4\" ? \"mp4\" : undefined;\n    }\n    return undefined;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../log\";\nimport { getMDAT } from \"../../parsers/containers/isobmff\";\nimport { utf8ToStr } from \"../../utils/string_parsing\";\n/**\n * Return plain text text track from the given ISOBMFF.\n * @param {Uint8Array} chunkBytes\n * @returns {string}\n */\nexport function extractTextTrackFromISOBMFF(chunkBytes) {\n    const mdat = getMDAT(chunkBytes);\n    return mdat === null ? \"\" : utf8ToStr(mdat);\n}\n/**\n * Returns the a string expliciting the format of a text track when that text\n * track is embedded into a ISOBMFF file.\n * @param {string|undefined} codecs\n * @returns {string}\n */\nexport function getISOBMFFTextTrackFormat(codecs) {\n    if (codecs === undefined) {\n        throw new Error(\"Cannot parse subtitles: unknown format\");\n    }\n    switch (codecs.toLowerCase()) {\n        case \"stpp\": // stpp === TTML in MP4\n        case \"stpp.ttml\":\n        case \"stpp.ttml.im1t\":\n            return \"ttml\";\n        case \"wvtt\": // wvtt === WebVTT in MP4\n            return \"vtt\";\n    }\n    throw new Error(\"The codec used for the subtitles \" + `\"${codecs}\" is not managed yet.`);\n}\n/**\n * Returns the a string expliciting the format of a text track in plain text.\n * @param {Object} representation\n * @returns {string}\n */\nexport function getPlainTextTrackFormat(codecs, mimeType) {\n    switch (mimeType) {\n        case \"application/ttml+xml\":\n            return \"ttml\";\n        case \"application/x-sami\":\n        case \"application/smil\":\n            return \"sami\";\n        case \"text/vtt\":\n            return \"vtt\";\n    }\n    if (codecs !== undefined) {\n        const codeLC = codecs.toLowerCase();\n        if (codeLC === \"srt\") {\n            return \"srt\";\n        }\n    }\n    throw new Error(`could not find a text-track parser for the type ${mimeType !== null && mimeType !== void 0 ? mimeType : \"\"}`);\n}\n/**\n * @param {Object} content\n * @param {ArrayBuffer|UInt8Array|null} chunkData\n * @param {Object|null} chunkInfos\n * @param {boolean} isChunked\n * @returns {Object|null}\n */\nexport function getISOBMFFEmbeddedTextTrackData({ segment, language, codecs, }, chunkBytes, chunkInfos, isChunked) {\n    if (segment.isInit) {\n        return null;\n    }\n    let startTime;\n    let endTime;\n    if (chunkInfos === null) {\n        if (!isChunked) {\n            log.warn(\"Transport: Unavailable time data for current text track.\");\n        }\n        else {\n            startTime = segment.time;\n            endTime = segment.end;\n        }\n    }\n    else {\n        startTime = chunkInfos.time;\n        if (chunkInfos.duration !== undefined) {\n            endTime = startTime + chunkInfos.duration;\n        }\n        else if (!isChunked && segment.complete) {\n            endTime = startTime + segment.duration;\n        }\n    }\n    const type = getISOBMFFTextTrackFormat(codecs);\n    const textData = extractTextTrackFromISOBMFF(chunkBytes);\n    return { data: textData, type, language, start: startTime, end: endTime };\n}\n/**\n * @param {Object} content\n * @param {ArrayBuffer|UInt8Array|null} chunkData\n * @param {Object|null} chunkInfos\n * @param {boolean} isChunked\n * @returns {Object|null}\n */\nexport function getPlainTextTrackData(context, textTrackData, isChunked) {\n    const { segment } = context;\n    if (segment.isInit) {\n        return null;\n    }\n    let start;\n    let end;\n    if (isChunked) {\n        log.warn(\"Transport: Unavailable time data for current text track.\");\n    }\n    else {\n        start = segment.time;\n        if (segment.complete) {\n            end = segment.time + segment.duration;\n        }\n    }\n    const type = getPlainTextTrackFormat(context.codecs, context.mimeType);\n    return { data: textTrackData, type, language: context.language, start, end };\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Check if two two arrays containing only numbers are equal.\n * @param {Array.<number>|TypedArray} arr1\n * @param {Array.<number>|TypedArray} arr2\n * @returns {Boolean}\n */\nexport default function areArraysOfNumbersEqual(arr1, arr2) {\n    if (arr1.length !== arr2.length) {\n        return false;\n    }\n    if (arr1 === arr2) {\n        return true;\n    }\n    for (let i = arr1.length - 1; i >= 0; i--) {\n        if (arr1[i] !== arr2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport arrayFind from \"./array_find\";\nimport startsWith from \"./starts_with\";\n/**\n * This function is a shortcut that helps differentiate two codecs\n * of the form \"audio/mp4;codecs=\\\"av1.40.2\\\"\".\n *\n * @param codecA\n * @param codecB\n * @returns A boolean that tell whether or not those two codecs provided are even.\n */\nfunction areCodecsCompatible(a, b) {\n    const { mimeType: mimeTypeA, codecs: codecsA } = parseCodec(a);\n    const { mimeType: mimeTypeB, codecs: codecsB } = parseCodec(b);\n    if (mimeTypeA !== mimeTypeB) {\n        return false;\n    }\n    if (codecsA === \"\" || codecsB === \"\") {\n        return false;\n    }\n    let initialPartA = codecsA.split(\".\")[0];\n    initialPartA = initialPartA === \"hev1\" ? \"hvc1\" : initialPartA;\n    let initialPartB = codecsB.split(\".\")[0];\n    initialPartB = initialPartB === \"hev1\" ? \"hvc1\" : initialPartB;\n    if (initialPartA !== initialPartB) {\n        return false;\n    }\n    return true;\n}\nconst LENGTH_OF_CODEC_PREFIX = \"codecs=\".length;\nexport function parseCodec(unparsedCodec) {\n    var _a;\n    const [mimeType, ...props] = unparsedCodec.split(\";\");\n    let codecs = (_a = arrayFind(props, (prop) => startsWith(prop, \"codecs=\"))) !== null && _a !== void 0 ? _a : \"\";\n    // remove the 'codecs=' prefix\n    codecs = codecs.substring(LENGTH_OF_CODEC_PREFIX);\n    // remove the leading and trailing quote\n    if (codecs[0] === '\"') {\n        codecs = codecs.substring(1, codecs.length - 1);\n    }\n    return { mimeType, codecs };\n}\nexport default areCodecsCompatible;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Array.prototype.find ponyfill.\n * @param {Array} arr\n * @param {Function} predicate\n * @param {*} thisArg\n * @returns {boolean}\n */\nexport default function arrayFind(arr, predicate, thisArg) {\n    // eslint-disable-next-line no-restricted-properties\n    if (typeof Array.prototype.find === \"function\") {\n        // eslint-disable-next-line no-restricted-properties\n        return arr.find(predicate, thisArg);\n    }\n    const len = arr.length >>> 0;\n    for (let i = 0; i < len; i++) {\n        const val = arr[i];\n        if (predicate.call(thisArg, val, i, arr)) {\n            return val;\n        }\n    }\n    return undefined;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Array.prototype.find ponyfill.\n * @param {Array} arr\n * @param {Function} predicate\n * @param {*} thisArg\n * @returns {boolean}\n */\nexport default function arrayFindIndex(arr, predicate, thisArg) {\n    // eslint-disable-next-line no-restricted-properties\n    if (typeof Array.prototype.findIndex === \"function\") {\n        // eslint-disable-next-line no-restricted-properties\n        return arr.findIndex(predicate, thisArg);\n    }\n    const len = arr.length >>> 0;\n    for (let i = 0; i < len; i++) {\n        if (predicate.call(thisArg, arr[i], i, arr)) {\n            return i;\n        }\n    }\n    return -1;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Array.prototype.includes ponyfill.\n * Returns ``true`` if the given array ``arr`` contains the element\n * ``searchElement``. false ``otherwise``.\n *\n * Inspired from MDN polyfill, but ponyfilled instead\n *\n * @example\n * ```js\n * arrayIncludes([1, 2, 3], 3);\n * // => true\n *\n * arrayIncludes([1, 2, 3], 7);\n * // => false\n *\n * const obj = { a: 4 };\n * arrayIncludes([obj, { b: 7 }, { a: 3 }], obj);\n * // => true\n *\n * // does not perform deep equality\n * arrayIncludes([{ a: 4 }, { b: 7 }, { a: 3 }], { a: 4 });\n * // => false\n *\n * // the third argument state the starting index. 0 if not set.\n *\n * arrayIncludes([1, 2, 3], 2, 1);\n * // => true\n *\n * arrayIncludes([1, 2, 3], 2, 2);\n * // => false\n * ```\n *\n * @param {Array} arr\n * @param {*} searchElement\n * @param {number} [fromIndex]\n * @returns {boolean}\n */\nexport default function arrayIncludes(arr, searchElement, fromIndex) {\n    // eslint-disable-next-line no-restricted-properties\n    if (typeof Array.prototype.includes === \"function\") {\n        // eslint-disable-next-line no-restricted-properties\n        return arr.includes(searchElement, fromIndex);\n    }\n    const len = arr.length >>> 0;\n    if (len === 0) {\n        return false;\n    }\n    const n = fromIndex | 0;\n    let k = n >= 0 ? Math.min(n, len - 1) : Math.max(len + n, 0);\n    const areTheSame = (x, y) => x === y ||\n        // Viva las JavaScriptas!\n        (typeof x === \"number\" && typeof y === \"number\" && isNaN(x) && isNaN(y));\n    while (k < len) {\n        if (areTheSame(arr[k], searchElement)) {\n            return true;\n        }\n        k++;\n    }\n    return false;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport isNullOrUndefined from \"./is_null_or_undefined\";\n/**\n * Error due to an abnormal assertion fails.\n *\n * This should be an internal error which is later transformed into a documented\n * (as part of the API) Error instance before being emitted to the application.\n * @class AssertionError\n * @extends Error\n */\nexport class AssertionError extends Error {\n    /**\n     * @param {string} message\n     */\n    constructor(message) {\n        super(message);\n        // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class\n        Object.setPrototypeOf(this, AssertionError.prototype);\n        this.name = \"AssertionError\";\n    }\n}\n/**\n * Throw an AssertionError if the given assertion is false.\n * @param {boolean} assertion\n * @param {string} [message] - Optional message property for the AssertionError.\n * @throws AssertionError - Throws if the assertion given is false\n */\nexport default function assert(assertion, message) {\n    if (1 /* __ENVIRONMENT__.DEV */ === 0 /* __ENVIRONMENT__.CURRENT_ENV */ &&\n        !assertion) {\n        throw new AssertionError(message === undefined ? \"invalid assertion\" : message);\n    }\n}\n/**\n * Throws if the given Object does not respect the interface.\n * @param {Object} o\n * @param {Object} iface - Contains the checked keynames of o and link them\n * to their types (obtained through the typeof operator).\n * @param {string} [name=\"object\"] - name of the _interface_\n * @throws AssertionError - The argument o given is not an object\n * @throws AssertionError - The _interface_ is not respected.\n */\nexport function assertInterface(o, iface, name = \"object\") {\n    assert(!isNullOrUndefined(o), `${name} should be an object`);\n    for (const k in iface) {\n        if (Object.prototype.hasOwnProperty.call(iface, k)) {\n            assert(typeof o[k] === iface[k], `${name} should have property ${k} as a ${iface[k]}`);\n        }\n    }\n}\n/**\n * TypeScript hack to make sure a code path is never taken.\n *\n * This can for example be used to ensure that a switch statement handle all\n * possible cases by adding a default clause calling assertUnreachable with\n * an argument (it doesn't matter which one).\n *\n * @example\n * function parseBinary(str : \"0\" | \"1\") : number {\n *   switch (str) {\n *     case \"0:\n *       return 0;\n *     case \"1\":\n *       return 1;\n *     default:\n *       // branch never taken. If it can be, TypeScript will yell at us because\n *       // its argument (here, `str`) is not of the right type.\n *       assertUnreachable(str);\n *   }\n * }\n * @param {*} _\n * @throws AssertionError - Throw an AssertionError when called. If we're\n * sufficiently strict with how we use TypeScript, this should never happen.\n */\nexport function assertUnreachable(_) {\n    throw new AssertionError(\"Unreachable path taken\");\n}\n","/*\nMIT License\nCopyright (c) 2020 Egor Nepomnyaschih\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n */\nimport log from \"../log\";\n/*\n// This constant can also be computed with the following algorithm:\nconst base64abc = [],\n  A = \"A\".charCodeAt(0),\n  a = \"a\".charCodeAt(0),\n  n = \"0\".charCodeAt(0);\nfor (let i = 0; i < 26; ++i) {\n  base64abc.push(String.fromCharCode(A + i));\n}\nfor (let i = 0; i < 26; ++i) {\n  base64abc.push(String.fromCharCode(a + i));\n}\nfor (let i = 0; i < 10; ++i) {\n  base64abc.push(String.fromCharCode(n + i));\n}\nbase64abc.push(\"+\");\nbase64abc.push(\"/\");\n */\nconst base64abc = [\n    \"A\",\n    \"B\",\n    \"C\",\n    \"D\",\n    \"E\",\n    \"F\",\n    \"G\",\n    \"H\",\n    \"I\",\n    \"J\",\n    \"K\",\n    \"L\",\n    \"M\",\n    \"N\",\n    \"O\",\n    \"P\",\n    \"Q\",\n    \"R\",\n    \"S\",\n    \"T\",\n    \"U\",\n    \"V\",\n    \"W\",\n    \"X\",\n    \"Y\",\n    \"Z\",\n    \"a\",\n    \"b\",\n    \"c\",\n    \"d\",\n    \"e\",\n    \"f\",\n    \"g\",\n    \"h\",\n    \"i\",\n    \"j\",\n    \"k\",\n    \"l\",\n    \"m\",\n    \"n\",\n    \"o\",\n    \"p\",\n    \"q\",\n    \"r\",\n    \"s\",\n    \"t\",\n    \"u\",\n    \"v\",\n    \"w\",\n    \"x\",\n    \"y\",\n    \"z\",\n    \"0\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"+\",\n    \"/\",\n];\n/*\n// This constant can also be computed with the following algorithm:\nconst l = 256, base64codes = new Uint8Array(l);\nfor (let i = 0; i < l; ++i) {\n  base64codes[i] = 255; // invalid character\n}\nbase64abc.forEach((char, index) => {\n  base64codes[char.charCodeAt(0)] = index;\n});\nbase64codes[\"=\".charCodeAt(0)] = 0; // ignored anyway, so we just need to prevent an error\n */\nconst base64codes = [\n    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n    255, 255, 255, 255, 255, 255, 255, 255, 255, 62, 255, 255, 255, 63, 52, 53, 54, 55, 56,\n    57, 58, 59, 60, 61, 255, 255, 255, 0, 255, 255, 255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,\n    11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 255, 255, 255, 255, 255,\n    255, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46,\n    47, 48, 49, 50, 51,\n];\n/**\n * Obtain the value corresponding to a base64 char code.\n * /!\\ Can throw if the char code given is invalid.\n * @param {number} charCode\n * @returns {number}\n */\nfunction getBase64Code(charCode) {\n    if (charCode >= base64codes.length) {\n        throw new Error(\"Unable to parse base64 string.\");\n    }\n    const code = base64codes[charCode];\n    if (code === 255) {\n        throw new Error(\"Unable to parse base64 string.\");\n    }\n    return code;\n}\n/**\n * Convert an array of bytes into a base64 string.\n * @param {Array.<number>|Uint8Array} bytes\n * @returns {string}\n */\nexport function bytesToBase64(bytes) {\n    let result = \"\";\n    let i;\n    const length = bytes.length;\n    for (i = 2; i < length; i += 3) {\n        result += base64abc[bytes[i - 2] >> 2];\n        result += base64abc[((bytes[i - 2] & 0x03) << 4) | (bytes[i - 1] >> 4)];\n        result += base64abc[((bytes[i - 1] & 0x0f) << 2) | (bytes[i] >> 6)];\n        result += base64abc[bytes[i] & 0x3f];\n    }\n    if (i === length + 1) {\n        // 1 octet yet to write\n        result += base64abc[bytes[i - 2] >> 2];\n        result += base64abc[(bytes[i - 2] & 0x03) << 4];\n        result += \"==\";\n    }\n    if (i === length) {\n        // 2 octets yet to write\n        result += base64abc[bytes[i - 2] >> 2];\n        result += base64abc[((bytes[i - 2] & 0x03) << 4) | (bytes[i - 1] >> 4)];\n        result += base64abc[(bytes[i - 1] & 0x0f) << 2];\n        result += \"=\";\n    }\n    return result;\n}\n/**\n * Convert a base64 string into the corresponding Uint8Array containing its\n * corresponding binary data.\n * /!\\ Can throw if an invalid base64 string was given.\n * @param {string} str\n * @returns {string}\n */\nexport function base64ToBytes(str) {\n    const paddingNeeded = str.length % 4;\n    let paddedStr = str;\n    if (paddingNeeded !== 0) {\n        log.warn(\"base64ToBytes: base64 given miss padding\");\n        // eslint-disable-next-line no-nested-ternary\n        paddedStr += paddingNeeded === 3 ? \"=\" : paddingNeeded === 2 ? \"==\" : \"===\"; // invalid, but we will catch it\n    }\n    const index = paddedStr.indexOf(\"=\");\n    if (index !== -1 && index < paddedStr.length - 2) {\n        throw new Error(\"Unable to parse base64 string.\");\n    }\n    // eslint-disable-next-line no-nested-ternary\n    const missingOctets = paddedStr.endsWith(\"==\") ? 2 : paddedStr.endsWith(\"=\") ? 1 : 0;\n    const n = paddedStr.length;\n    const result = new Uint8Array((n / 4) * 3);\n    let buffer;\n    for (let i = 0, j = 0; i < n; i += 4, j += 3) {\n        buffer =\n            (getBase64Code(paddedStr.charCodeAt(i)) << 18) |\n                (getBase64Code(paddedStr.charCodeAt(i + 1)) << 12) |\n                (getBase64Code(paddedStr.charCodeAt(i + 2)) << 6) |\n                getBase64Code(paddedStr.charCodeAt(i + 3));\n        result[j] = buffer >> 16;\n        result[j + 1] = (buffer >> 8) & 0xff;\n        result[j + 2] = buffer & 0xff;\n    }\n    return result.subarray(0, result.length - missingOctets);\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Returns a Uint8Array from the arguments given, in order:\n *   - if the next argument given is a number N set the N next bytes to 0.\n *   - else set the next bytes to the argument given.\n * @param {...(Number|Uint8Array)} args\n * @returns {Uint8Array}\n */\nfunction concat(...args) {\n    const l = args.length;\n    let i = -1;\n    let len = 0;\n    let arg;\n    while (++i < l) {\n        arg = args[i];\n        len += typeof arg === \"number\" ? arg : arg.length;\n    }\n    const arr = new Uint8Array(len);\n    let offset = 0;\n    i = -1;\n    while (++i < l) {\n        arg = args[i];\n        if (typeof arg === \"number\") {\n            offset += arg;\n        }\n        else if (arg.length > 0) {\n            arr.set(arg, offset);\n            offset += arg.length;\n        }\n    }\n    return arr;\n}\n/**\n * Translate groups of 2 big-endian bytes to Integer (from 0 up to 65535).\n * @param {Uint8Array} bytes\n * @param {Number} offset - The offset (from the start of the given array)\n * @returns {Number}\n */\nfunction be2toi(bytes, offset) {\n    return (bytes[offset + 0] << 8) + (bytes[offset + 1] << 0);\n}\n/**\n * Translate groups of 3 big-endian bytes to Integer.\n * @param {Uint8Array} bytes\n * @param {Number} offset - The offset (from the start of the given array)\n * @returns {Number}\n */\nfunction be3toi(bytes, offset) {\n    return (bytes[offset + 0] * 0x0010000 + bytes[offset + 1] * 0x0000100 + bytes[offset + 2]);\n}\n/**\n * Translate groups of 4 big-endian bytes to Integer.\n * @param {Uint8Array} bytes\n * @param {Number} offset - The offset (from the start of the given array)\n * @returns {Number}\n */\nfunction be4toi(bytes, offset) {\n    return (bytes[offset + 0] * 0x1000000 +\n        bytes[offset + 1] * 0x0010000 +\n        bytes[offset + 2] * 0x0000100 +\n        bytes[offset + 3]);\n}\n/**\n * Translate groups of 8 big-endian bytes to Integer.\n * @param {Uint8Array} bytes\n * @param {Number} offset - The offset (from the start of the given array)\n * @returns {Number}\n */\nfunction be8toi(bytes, offset) {\n    return ((bytes[offset + 0] * 0x1000000 +\n        bytes[offset + 1] * 0x0010000 +\n        bytes[offset + 2] * 0x0000100 +\n        bytes[offset + 3]) *\n        0x100000000 +\n        bytes[offset + 4] * 0x1000000 +\n        bytes[offset + 5] * 0x0010000 +\n        bytes[offset + 6] * 0x0000100 +\n        bytes[offset + 7]);\n}\n/**\n * Translate Integer (from 0 up to 65535) to a Uint8Array of length 2 of\n * the corresponding big-endian bytes.\n * @param {Number} num\n * @returns {Uint8Array}\n */\nfunction itobe2(num) {\n    return new Uint8Array([(num >>> 8) & 0xff, num & 0xff]);\n}\n/**\n * Translate Integer to a Uint8Array of length 4 of the corresponding big-endian\n * bytes.\n * @param {Number} num\n * @returns {Uint8Array}\n */\nfunction itobe4(num) {\n    return new Uint8Array([\n        (num >>> 24) & 0xff,\n        (num >>> 16) & 0xff,\n        (num >>> 8) & 0xff,\n        num & 0xff,\n    ]);\n}\n/**\n * Translate Integer to a Uint8Array of length 8 of the corresponding big-endian\n * bytes.\n * /!\\ If the top-most bytes are set, this might go over MAX_SAFE_INTEGER, thus\n * leading to a \"bad\" value.\n * @param {Number} num\n * @returns {Uint8Array}\n */\nfunction itobe8(num) {\n    const l = num % 0x100000000;\n    const h = (num - l) / 0x100000000;\n    return new Uint8Array([\n        (h >>> 24) & 0xff,\n        (h >>> 16) & 0xff,\n        (h >>> 8) & 0xff,\n        h & 0xff,\n        (l >>> 24) & 0xff,\n        (l >>> 16) & 0xff,\n        (l >>> 8) & 0xff,\n        l & 0xff,\n    ]);\n}\n/**\n * Translate groups of 2 little-endian bytes to Integer (from 0 up to 65535).\n * @param {Uint8Array} bytes\n * @param {Number} offset - The offset (from the start of the given array)\n * @returns {Number}\n */\nfunction le2toi(bytes, offset) {\n    return (bytes[offset + 0] << 0) + (bytes[offset + 1] << 8);\n}\n/**\n * Translate groups of 4 little-endian bytes to Integer.\n * @param {Uint8Array} bytes\n * @param {Number} offset - The offset (from the start of the given array)\n * @returns {Number}\n */\nfunction le4toi(bytes, offset) {\n    return (bytes[offset + 0] +\n        bytes[offset + 1] * 0x0000100 +\n        bytes[offset + 2] * 0x0010000 +\n        bytes[offset + 3] * 0x1000000);\n}\n/**\n * Translate groups of 8 little-endian bytes to Integer.\n * @param {Uint8Array} bytes\n * @param {Number} offset - The offset (from the start of the given array)\n * @returns {Number}\n */\nfunction le8toi(bytes, offset) {\n    return (bytes[offset + 0] +\n        bytes[offset + 1] * 0x0000100 +\n        bytes[offset + 2] * 0x0010000 +\n        bytes[offset + 3] * 0x1000000 +\n        (bytes[offset + 4] +\n            bytes[offset + 5] * 0x0000100 +\n            bytes[offset + 6] * 0x0010000 +\n            bytes[offset + 7] * 0x1000000) *\n            0x100000000);\n}\n/**\n * Translate Integer (from 0 up to 65535) to a Uint8Array of length 2 of\n * the corresponding little-endian bytes.\n * @param {Number} num\n * @returns {Uint8Array}\n */\nfunction itole2(num) {\n    return new Uint8Array([num & 0xff, (num >>> 8) & 0xff]);\n}\n/**\n * Translate Integer to a Uint8Array of length 4 of the corresponding\n * little-endian bytes.\n * @param {Number} num\n * @returns {Uint8Array}\n */\nfunction itole4(num) {\n    return new Uint8Array([\n        num & 0xff,\n        (num >>> 8) & 0xff,\n        (num >>> 16) & 0xff,\n        (num >>> 24) & 0xff,\n    ]);\n}\n/**\n * Check if an ArrayBuffer is equal to the bytes given.\n * @param {ArrayBuffer} buffer\n * @param {Uint8Array} bytes\n * @returns {Boolean}\n */\nfunction isABEqualBytes(buffer, bytes) {\n    const view = new DataView(buffer);\n    const len = view.byteLength;\n    if (len !== bytes.length) {\n        return false;\n    }\n    for (let i = 0; i < len; i++) {\n        if (view.getUint8(i) !== bytes[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Convert any BufferSource-typed structure into the corresponding Uint8Array.\n * @param {BufferSource} input\n * @returns {Uint8Array}\n */\nfunction toUint8Array(input) {\n    if (input instanceof Uint8Array) {\n        return input;\n    }\n    else if (input instanceof ArrayBuffer) {\n        return new Uint8Array(input);\n    }\n    else {\n        return new Uint8Array(input.buffer);\n    }\n}\nexport { concat, be2toi, be3toi, be4toi, be8toi, le2toi, le4toi, le8toi, itobe2, itobe4, itobe8, itole2, itole4, isABEqualBytes, toUint8Array, };\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport createCancellablePromise from \"./create_cancellable_promise\";\n/**\n * Wait the given `delay`, resolving the Promise when finished.\n *\n * The `cancellationSignal` given allows to cancel that timeout. In the case it\n * is triggered before the timeout ended, this function will reject the\n * corresponding `CancellationError` through the returned Promise.\n *\n * @param {number} delay - Delay to wait, in milliseconds\n * @param {Object} cancellationSignal - `CancellationSignal` allowing to abort\n * the timeout.\n * @returns {Promise} - Resolve on timeout completion, rejects on timeout\n * cancellation with the corresponding `CancellationError`.\n */\nexport default function cancellableSleep(delay, cancellationSignal) {\n    return createCancellablePromise(cancellationSignal, (res) => {\n        const timeout = setTimeout(() => res(), delay);\n        return () => clearTimeout(timeout);\n    });\n}\n","/**\n * Returns a Promise linked to a `CancellationSignal`, which will reject the\n * corresponding `CancellationError` if that signal emits before the wanted\n * task finishes (either on success or on error).\n *\n * The given callback mimicks the Promise interface with the added possibility\n * of returning a callback which will be called when and if the task is\n * cancelled before being either resolved or rejected.\n * In that case, that logic will be called just before the Promise is rejected\n * with the corresponding `CancellationError`.\n * The point of this callback is to implement aborting logic, such as for\n * example aborting a request.\n *\n * @param {Object} cancellationSignal - The `CancellationSignal` the returned\n * Promise will be linked to.\n * @param {Function} cb - The function implementing the cancellable Promise. Its\n * arguments follow Promise's semantics but it can also return a function which\n * will be called when and if `cancellationSignal` emits before either arguments\n * are called.\n * @returns {Promise} - The created Promise, which will resolve when and if the\n * first argument to `cb` is called first and reject either if the second\n * argument to `cb` is called first or if the given `CancellationSignal` emits\n * before either of the two previous conditions.\n */\nexport default function createCancellablePromise(cancellationSignal, cb) {\n    let abortingLogic;\n    return new Promise((res, rej) => {\n        if (cancellationSignal.cancellationError !== null) {\n            // If the signal was already triggered before, do not even call `cb`\n            return rej(cancellationSignal.cancellationError);\n        }\n        let hasUnregistered = false;\n        abortingLogic = cb(function onCancellablePromiseSuccess(val) {\n            cancellationSignal.deregister(onCancellablePromiseCancellation);\n            hasUnregistered = true;\n            res(val);\n        }, function onCancellablePromiseFailure(err) {\n            cancellationSignal.deregister(onCancellablePromiseCancellation);\n            hasUnregistered = true;\n            rej(err);\n        });\n        if (!hasUnregistered) {\n            cancellationSignal.register(onCancellablePromiseCancellation);\n        }\n        function onCancellablePromiseCancellation(error) {\n            if (abortingLogic !== undefined) {\n                abortingLogic();\n            }\n            rej(error);\n        }\n    });\n}\n","import globalScope from \"./global_scope\";\nimport getMonotonicTimeStamp from \"./monotonic_timestamp\";\n/**\n * Create and return a Universally Unique IDentifier (UUID) as defined by\n * RFC4122.\n * Depending on browser API availability, we may be generating an approximation\n * of what the RFC indicates instead.\n * @returns {string}\n */\nexport default function createUuid() {\n    var _a;\n    if (typeof ((_a = globalScope.crypto) === null || _a === void 0 ? void 0 : _a.randomUUID) === \"function\") {\n        return globalScope.crypto.randomUUID();\n    }\n    let ts1 = new Date().getTime();\n    let ts2 = getMonotonicTimeStamp();\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (c) {\n        let r = Math.random() * 16;\n        if (ts1 > 0) {\n            r = (ts1 + r) % 16 | 0;\n            ts1 = Math.floor(ts1 / 16);\n        }\n        else {\n            r = (ts2 + r) % 16 | 0;\n            ts2 = Math.floor(ts2 / 16);\n        }\n        return (c === \"x\" ? r : (r & 0x3) | 0x8).toString(16);\n    });\n}\n","import objectAssign from \"./object_assign\";\n/**\n * Check if an item is an object\n * @param item\n * @returns {boolean}\n */\nfunction isObject(item) {\n    return (item !== null &&\n        item !== undefined &&\n        !Array.isArray(item) &&\n        typeof item === \"object\");\n}\n/**\n * Deeply merge nested objects\n * @param target\n * @param sources\n * @returns output : merged object\n */\nexport default function deepMerge(target, ...sources) {\n    if (sources.length === 0) {\n        return target;\n    }\n    const source = sources.shift();\n    if (isObject(target) && isObject(source)) {\n        for (const key in source) {\n            if (isObject(source[key])) {\n                let newTarget = target[key];\n                if (newTarget === undefined) {\n                    newTarget = {};\n                    target[key] = newTarget;\n                }\n                deepMerge(newTarget, source[key]);\n            }\n            else {\n                objectAssign(target, { [key]: source[key] });\n            }\n        }\n    }\n    return deepMerge(target, ...sources);\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport isNullOrUndefined from \"./is_null_or_undefined\";\n/**\n * Simple but fully type-safe EventEmitter implementation.\n * @class EventEmitter\n */\nexport default class EventEmitter {\n    constructor() {\n        this._listeners = {};\n    }\n    /**\n     * Register a new callback for an event.\n     *\n     * @param {string} evt - The event to register a callback to\n     * @param {Function} fn - The callback to call as that event is triggered.\n     * The callback will take as argument the eventual payload of the event\n     * (single argument).\n     * @param {Object | undefined} cancellationSignal - When that signal emits,\n     * the event listener is automatically removed.\n     */\n    addEventListener(evt, fn, cancellationSignal) {\n        const listeners = this._listeners[evt];\n        if (!Array.isArray(listeners)) {\n            this._listeners[evt] = [fn];\n        }\n        else {\n            listeners.push(fn);\n        }\n        if (cancellationSignal !== undefined) {\n            cancellationSignal.register(() => {\n                this.removeEventListener(evt, fn);\n            });\n        }\n    }\n    /**\n     * Unregister callbacks linked to events.\n     * @param {string} [evt] - The event for which the callback[s] should be\n     * unregistered. Set it to null or undefined to remove all callbacks\n     * currently registered (for any event).\n     * @param {Function} [fn] - The callback to unregister. If set to null\n     * or undefined while the evt argument is set, all callbacks linked to that\n     * event will be unregistered.\n     */\n    removeEventListener(evt, fn) {\n        if (isNullOrUndefined(evt)) {\n            this._listeners = {};\n            return;\n        }\n        const listeners = this._listeners[evt];\n        if (!Array.isArray(listeners)) {\n            return;\n        }\n        if (isNullOrUndefined(fn)) {\n            delete this._listeners[evt];\n            return;\n        }\n        const index = listeners.indexOf(fn);\n        if (index !== -1) {\n            listeners.splice(index, 1);\n        }\n        if (listeners.length === 0) {\n            delete this._listeners[evt];\n        }\n    }\n    /**\n     * Trigger every registered callbacks for a given event\n     * @param {string} evt - The event to trigger\n     * @param {*} arg - The eventual payload for that event. All triggered\n     * callbacks will recieve this payload as argument.\n     */\n    trigger(evt, arg) {\n        const listeners = this._listeners[evt];\n        if (!Array.isArray(listeners)) {\n            return;\n        }\n        listeners.slice().forEach((listener) => {\n            try {\n                listener(arg);\n            }\n            catch (e) {\n                if (0 /* __ENVIRONMENT__.CURRENT_ENV */ === 1 /* __ENVIRONMENT__.DEV */) {\n                    throw e instanceof Error ? e : new Error(\"EventEmitter: listener error\");\n                }\n                // Cannot use our logger here sadly because our logger is an `EventEmitter`\n                // itself.\n                // eslint-disable-next-line no-console\n                console.error(\"RxPlayer: EventEmitter error\", e instanceof Error ? e : null);\n            }\n        });\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Map each element using a mapping function, then flat the result into\n * a new array.\n * @param {Array.<*>} originalArray\n * @param {Function} fn\n */\nexport default function flatMap(originalArray, fn) {\n    if (typeof Array.prototype.flatMap === \"function\") {\n        return originalArray.flatMap(fn);\n    }\n    return originalArray.reduce((acc, arg) => {\n        const r = fn(arg);\n        if (Array.isArray(r)) {\n            acc.push(...r);\n            return acc;\n        }\n        acc.push(r);\n        return acc;\n    }, []);\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst FUZZ_FACTOR = 0.3;\n/**\n * Perform \"fuzzing\" on the delay given.\n * @param {Number} retryDelay\n * @returns {Number}\n */\nexport default function getFuzzedDelay(retryDelay) {\n    const fuzzingFactor = (Math.random() * 2 - 1) * FUZZ_FACTOR;\n    return retryDelay * (fuzzingFactor + 1); // Max 1.3 Min 0.7\n}\n","import isNode from \"./is_node\";\nimport isWorker from \"./is_worker\";\n/**\n * The current environment's global object, written in such a way to maximize\n * compatibility.\n *\n * Though the RxPlayer should theoretically not be runnable in NodeJS, we still\n * had to support it for some applications implementing server-side rendering.\n */\nlet globalScope;\nif (isWorker) {\n    globalScope = self;\n}\nelse if (isNode) {\n    globalScope = global;\n}\nelse {\n    globalScope = window;\n}\nexport default globalScope;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Convert given buffer to a 32bit integer hash\n *\n * This algorithm is the same one that Java `String.hashCode()` one which\n * is a fast hashing function adapted to short ASCII strings.\n * This consequently might not be the most adapted to buffers of various length\n * containing a various amount of data but still has the advantage of being\n * fast.\n *\n * As this function is used in persistent MediaKeySession storage, we probably\n * should keep this function somewhere as long as we want to support\n * MediaKeySessions persisted in old versions of the RxPlayer.\n *\n * @param {Array.<number>|TypedArray} buffer\n * @returns {number}\n */\nexport default function hashBuffer(buffer) {\n    let hash = 0;\n    let char;\n    for (let i = 0; i < buffer.length; i++) {\n        char = buffer[i];\n        hash = (hash << 5) - hash + char;\n        hash = hash & hash; // Convert to 32bit integer\n    }\n    return hash;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Creates an ID generator which generates a number containing an incremented\n * number each time you call it.\n * @returns {Function}\n */\nexport default function idGenerator() {\n    let prefix = \"\";\n    let currId = -1;\n    return function generateNewId() {\n        currId++;\n        if (currId >= Number.MAX_SAFE_INTEGER) {\n            prefix += \"0\";\n            currId = 0;\n        }\n        return prefix + String(currId);\n    };\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport isWorker from \"./is_worker\";\n/** `true` if we're currently in a Node.JS environment. */\nconst isNode = typeof window === \"undefined\" && !isWorker;\nexport default isNode;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @param {*} x\n * @returns {string}\n */\nexport default function isNonEmptyString(x) {\n    return typeof x === \"string\" && x.length > 0;\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Returns true if the argument given is either null or undefined.\n * This function was added to have a clearer alternative to `== null` which is\n * not always understood by newcomers to the code, and which can be overused when\n * only one of the possibility can arise.\n * @param {*} x\n * @returns {boolean}\n */\nexport default function isNullOrUndefined(x) {\n    return x === null || x === undefined;\n}\n","/**\n * `true` if the current code is running in a WebWorker.\n */\nexport default typeof WorkerGlobalScope !== \"undefined\" &&\n    self instanceof WorkerGlobalScope;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Translate ISO 639-1 language codes into ISO 639-3 ones.\n */\nconst ISO_MAP_1_TO_3 = {\n    aa: \"aar\", // Afar\n    ab: \"abk\", // Abkhazian\n    ae: \"ave\", // Avestan\n    af: \"afr\", // Afrikaans\n    ak: \"aka\", // Akan\n    am: \"amh\", // Amharic\n    an: \"arg\", // Aragonese\n    ar: \"ara\", // Arabic\n    as: \"asm\", // Assamese\n    av: \"ava\", // Avaric\n    ay: \"aym\", // Aymara\n    az: \"aze\", // Azerbaijani\n    ba: \"bak\", // Bashkir\n    be: \"bel\", // Belarusian\n    bg: \"bul\", // Bulgarian\n    bi: \"bis\", // Bislama\n    bm: \"bam\", // Bambara\n    bn: \"ben\", // Bengali\n    bo: \"bod\", // Tibetan\n    br: \"bre\", // Breton\n    bs: \"bos\", // Bosnian\n    ca: \"cat\", // Catalan, Valencian\n    ce: \"che\", // Chechen\n    ch: \"cha\", // Chamorro\n    co: \"cos\", // Corsican\n    cr: \"cre\", // Cree\n    cs: \"ces\", // Czech\n    cu: \"chu\", // Church Slavic, Church Slavonic, Old Church Slavonic,\n    // Old Slavonic, Old Bulgarian\n    cv: \"chv\", // Chuvash\n    cy: \"cym\", // Welsh\n    da: \"dan\", // Danish\n    de: \"deu\", // German\n    dv: \"div\", // Divehi, Dhivehi, Maldivian\n    dz: \"dzo\", // Dzongkha\n    ee: \"ewe\", // Ewe\n    el: \"ell\", // Greek (modern)\n    en: \"eng\", // English\n    eo: \"epo\", // Esperanto\n    es: \"spa\", // Spanish, Castilian\n    et: \"est\", // Estonian\n    eu: \"eus\", // Basque\n    fa: \"fas\", // Persian\n    ff: \"ful\", // Fulah\n    fi: \"fin\", // Finnish\n    fj: \"fij\", // Fijian\n    fo: \"fao\", // Faroese\n    fr: \"fra\", // French\n    fy: \"fry\", // Western Frisian\n    ga: \"gle\", // Irish\n    gd: \"gla\", // Gaelic, Scottish Gaelic\n    gl: \"glg\", // Galician\n    gn: \"grn\", // Guaran\n    gu: \"guj\", // Gujarati\n    gv: \"glv\", // Manx\n    ha: \"hau\", // Hausa\n    he: \"heb\", // Hebrew (modern)\n    hi: \"hin\", // Hindi\n    ho: \"hmo\", // Hiri Motu\n    hr: \"hrv\", // Croatian\n    ht: \"hat\", // Haitian, Haitian Creole\n    hu: \"hun\", // Hungarian\n    hy: \"hye\", // Armenian\n    hz: \"her\", // Herero\n    ia: \"ina\", // Interlingua\n    id: \"ind\", // Indonesian\n    ie: \"ile\", // Interlingue\n    ig: \"ibo\", // Igbo\n    ii: \"iii\", // Sichuan Yi, Nuosu\n    ik: \"ipk\", // Inupiaq\n    io: \"ido\", // Ido\n    is: \"isl\", // Icelandic\n    it: \"ita\", // Italian\n    iu: \"iku\", // Inuktitut\n    ja: \"jpn\", // Japanese\n    jv: \"jav\", // Javanese\n    ka: \"kat\", // Georgian\n    kg: \"kon\", // Kongo\n    ki: \"kik\", // Kikuyu, Gikuyu\n    kj: \"kua\", // Kuanyama, Kwanyama\n    kk: \"kaz\", // Kazakh\n    kl: \"kal\", // Kalaallisut, Greenlandic\n    km: \"khm\", // Central Khmer\n    kn: \"kan\", // Kannada\n    ko: \"kor\", // Korean\n    kr: \"kau\", // Kanuri\n    ks: \"kas\", // Kashmiri\n    ku: \"kur\", // Kurdish\n    kv: \"kom\", // Komi\n    kw: \"cor\", // Cornish\n    ky: \"kir\", // Kirghiz, Kyrgyz\n    la: \"lat\", // Latin\n    lb: \"ltz\", // Luxembourgish, Letzeburgesch\n    lg: \"lug\", // Ganda\n    li: \"lim\", // Limburgan, Limburger, Limburgish\n    ln: \"lin\", // Lingala\n    lo: \"lao\", // Lao\n    lt: \"lit\", // Lithuanian\n    lu: \"lub\", // Luba-Katanga\n    lv: \"lav\", // Latvian\n    mg: \"mlg\", // Malagasy\n    mh: \"mah\", // Marshallese\n    mi: \"mri\", // Maori\n    mk: \"mkd\", // Macedonian\n    ml: \"mal\", // Malayalam\n    mn: \"mon\", // Mongolian\n    mr: \"mar\", // Marathi\n    ms: \"msa\", // Malay\n    mt: \"mlt\", // Maltese\n    my: \"mya\", // Burmese\n    na: \"nau\", // Nauru\n    nb: \"nob\", // Norwegian Bokml\n    nd: \"nde\", // North Ndebele\n    ne: \"nep\", // Nepali\n    ng: \"ndo\", // Ndonga\n    nl: \"nld\", // Dutch, Flemish\n    nn: \"nno\", // Norwegian Nynorsk\n    no: \"nor\", // Norwegian\n    nr: \"nbl\", // South Ndebele\n    nv: \"nav\", // Navajo, Navaho\n    ny: \"nya\", // Chichewa, Chewa, Nyanja\n    oc: \"oci\", // Occitan\n    oj: \"oji\", // Ojibwa\n    om: \"orm\", // Oromo\n    or: \"ori\", // Oriya\n    os: \"oss\", // Ossetian, Ossetic\n    pa: \"pan\", // Panjabi, Punjabi\n    pi: \"pli\", // Pali\n    pl: \"pol\", // Polish\n    ps: \"pus\", // Pashto, Pushto\n    pt: \"por\", // Portuguese\n    qu: \"que\", // Quechua\n    rm: \"roh\", // Romansh\n    rn: \"run\", // Rundi\n    ro: \"ron\", // Romanian, Moldavian, Moldovan\n    ru: \"rus\", // Russian\n    rw: \"kin\", // Kinyarwanda\n    sa: \"san\", // Sanskrit\n    sc: \"srd\", // Sardinian\n    sd: \"snd\", // Sindhi\n    se: \"sme\", // Northern Sami\n    sg: \"sag\", // Sango\n    si: \"sin\", // Sinhala, Sinhalese\n    sk: \"slk\", // Slovak\n    sl: \"slv\", // Slovenian\n    sm: \"smo\", // Samoan\n    sn: \"sna\", // Shona\n    so: \"som\", // Somali\n    sq: \"sqi\", // Albanian\n    sr: \"srp\", // Serbian\n    ss: \"ssw\", // Swati\n    st: \"sot\", // Southern Sotho\n    su: \"sun\", // Sundanese\n    sv: \"swe\", // Swedish\n    sw: \"swa\", // Swahili\n    ta: \"tam\", // Tamil\n    te: \"tel\", // Telugu\n    tg: \"tgk\", // Tajik\n    th: \"tha\", // Thai\n    ti: \"tir\", // Tigrinya\n    tk: \"tuk\", // Turkmen\n    tl: \"tgl\", // Tagalog\n    tn: \"tsn\", // Tswana\n    to: \"ton\", // Tonga (Tonga Islands)\n    tr: \"tur\", // Turkish\n    ts: \"tso\", // Tsonga\n    tt: \"tat\", // Tatar\n    tw: \"twi\", // Twi\n    ty: \"tah\", // Tahitian\n    ug: \"uig\", // Uighur, Uyghur\n    uk: \"ukr\", // Ukrainian\n    ur: \"urd\", // Urdu\n    uz: \"uzb\", // Uzbek\n    ve: \"ven\", // Venda\n    vi: \"vie\", // Vietnamese\n    vo: \"vol\", // Volapk\n    wa: \"wln\", // Walloon\n    wo: \"wol\", // Wolof\n    xh: \"xho\", // Xhosa\n    yi: \"yid\", // Yiddish\n    yo: \"yor\", // Yoruba\n    za: \"zha\", // Zhuang, Chuang\n    zh: \"zho\", // Chinese\n    zu: \"zul\", // Zulu\n};\nexport default ISO_MAP_1_TO_3;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Translate ISO 639-2 synonyms to their ISO 639-3 counterparts.\n */\nconst ISO_MAP_2_TO_3 = {\n    alb: \"sqi\", // Albanian\n    arm: \"hye\", // Armenian\n    baq: \"eus\", // Basque\n    bur: \"mya\", // Burmese\n    chi: \"zho\", // Chinese\n    cze: \"ces\", // Czech\n    dut: \"nld\", // Dutch; Flemish\n    fre: \"fra\", // French\n    geo: \"kat\", // Georgian\n    ger: \"deu\", // German\n    gre: \"ell\", // Modern Greek (1453)\n    ice: \"isl\", // Icelandic\n    mac: \"mkd\", // Macedonian\n    mao: \"mri\", // Maori\n    may: \"msa\", // Malay\n    per: \"fas\", // Persian\n    slo: \"slk\", // Slovak\n    rum: \"ron\", // Moldovan\n    tib: \"bod\", // Tibetan\n    wel: \"cym\", // Welsh\n};\nexport default ISO_MAP_2_TO_3;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport normalizeLanguage, { normalizeAudioTrack, normalizeTextTrack } from \"./normalize\";\nexport default normalizeLanguage;\nexport { normalizeAudioTrack, normalizeTextTrack };\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport isNonEmptyString from \"../is_non_empty_string\";\nimport isNullOrUndefined from \"../is_null_or_undefined\";\nimport ISO_MAP_1_TO_3 from \"./ISO_639-1_to_ISO_639-3\";\nimport ISO_MAP_2_TO_3 from \"./ISO_639-2_to_ISO_639-3\";\n/**\n * Normalize language given.\n * Basically:\n *   - converts it to lowercase.\n *   - normalize \"base\" (what is before the possible first \"-\") to an ISO639-3\n *     compatible string.\n * @param {string} _language\n * @returns {string}\n */\nfunction normalizeLanguage(_language) {\n    if (isNullOrUndefined(_language) || _language === \"\") {\n        /**\n         * \"und\" is a special value in ISO 639-3 that stands for \"undetermined language\".\n         */\n        return \"und\";\n    }\n    const fields = (\"\" + _language).toLowerCase().split(\"-\");\n    const base = fields[0];\n    const normalizedBase = normalizeBase(base);\n    if (isNonEmptyString(normalizedBase)) {\n        return normalizedBase;\n    }\n    return _language;\n}\n/**\n * Normalize language into an ISO639-3 format.\n * Returns undefined if it failed to do so\n * @param {string} base\n * @returns {string}\n */\nfunction normalizeBase(base) {\n    let result;\n    switch (base.length) {\n        case 2:\n            result = ISO_MAP_1_TO_3[base];\n            break;\n        case 3:\n            result = ISO_MAP_2_TO_3[base];\n            break;\n    }\n    return result;\n}\n/**\n * Normalize text track from a user given input into an object\n * with three properties:\n *   - language {string}: The language the user gave us\n *   - normalized {string}: An attempt to normalize the language into an\n *     ISO 639-3 code\n *   - closedCaption {Boolean}: Whether the track is a closed caption track\n * @param {Object|string|null|undefined} _language\n * @returns {Object|null|undefined}\n */\nfunction normalizeTextTrack(_language) {\n    if (!isNullOrUndefined(_language)) {\n        let language;\n        let closedCaption = false;\n        if (typeof _language === \"string\") {\n            language = _language;\n        }\n        else {\n            language = _language.language;\n            if (_language.closedCaption === true) {\n                closedCaption = true;\n            }\n        }\n        return { language, closedCaption, normalized: normalizeLanguage(language) };\n    }\n    return _language;\n}\n/**\n * Normalize audio track from a user given input into an object\n * with the following properties:\n *   - language {string}: The language the user gave us\n *   - normalized {string}: An attempt to normalize the language into an\n *     ISO 639-3 code\n *   - audioDescription {Boolean}: Whether the track is a closed caption track\n *   - isDub {Boolean|undefined}: if true, this is a dub.\n * @param {Object|string|null|undefined} _language\n * @returns {Object|null|undefined}\n */\nfunction normalizeAudioTrack(_language) {\n    if (isNullOrUndefined(_language)) {\n        return _language;\n    }\n    if (typeof _language === \"string\") {\n        return {\n            language: _language,\n            audioDescription: false,\n            normalized: normalizeLanguage(_language),\n        };\n    }\n    const normalized = {\n        language: _language.language,\n        audioDescription: _language.audioDescription === true,\n        normalized: normalizeLanguage(normalizeLanguage(_language.language)),\n    };\n    if (_language.isDub === true) {\n        normalized.isDub = true;\n    }\n    return normalized;\n}\nexport default normalizeLanguage;\nexport { normalizeAudioTrack, normalizeTextTrack };\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport EventEmitter from \"./event_emitter\";\nimport getMonotonicTimeStamp from \"./monotonic_timestamp\";\nimport noop from \"./noop\";\nconst DEFAULT_LOG_LEVEL = \"NONE\";\n/**\n * Logger implementation.\n * @class Logger\n */\nexport default class Logger extends EventEmitter {\n    constructor() {\n        super();\n        this.error = noop;\n        this.warn = noop;\n        this.info = noop;\n        this.debug = noop;\n        this._levels = { NONE: 0, ERROR: 1, WARNING: 2, INFO: 3, DEBUG: 4 };\n        this._currentFormat = \"standard\";\n        this._currentLevel = DEFAULT_LOG_LEVEL;\n    }\n    /**\n     * Update the logger's level to increase or decrease its verbosity, to change\n     * its format with a newly set one, or to update its logging function.\n     * @param {string} levelStr - One of the [upper-case] logger level. If the\n     * given level is not valid, it will default to `\"NONE\"`.\n     * @param {function|undefined} [logFn] - Optional logger function which will\n     * be called with logs (with the corresponding upper-case logger level as\n     * first argument).\n     * Can be omited to just rely on regular logging functions.\n     */\n    setLevel(levelStr, format, logFn) {\n        let level;\n        const foundLevel = this._levels[levelStr];\n        if (typeof foundLevel === \"number\") {\n            level = foundLevel;\n            this._currentLevel = levelStr;\n        }\n        else {\n            // not found\n            level = 0;\n            this._currentLevel = \"NONE\";\n        }\n        let actualFormat;\n        if (format === \"standard\" || format === \"full\") {\n            actualFormat = format;\n        }\n        else {\n            actualFormat = \"standard\";\n        }\n        if (actualFormat === \"full\" && actualFormat !== this._currentFormat) {\n            // Add the current Date so we can see at which time logs are displayed\n            const now = getMonotonicTimeStamp();\n            // eslint-disable-next-line no-console\n            console.log(String(now.toFixed(2)), \"[Init]\", `Local-Date: ${Date.now()}`);\n        }\n        this._currentFormat = actualFormat;\n        const generateLogFn = this._currentFormat === \"full\"\n            ? (namespace, consoleFn) => {\n                return (...args) => {\n                    const now = getMonotonicTimeStamp();\n                    return consoleFn(String(now.toFixed(2)), `[${namespace}]`, ...args);\n                };\n            }\n            : (_namespace, consoleFn) => consoleFn;\n        if (logFn === undefined) {\n            /* eslint-disable no-console */\n            this.error =\n                level >= this._levels.ERROR\n                    ? generateLogFn(\"error\", console.error.bind(console))\n                    : noop;\n            this.warn =\n                level >= this._levels.WARNING\n                    ? generateLogFn(\"warn\", console.warn.bind(console))\n                    : noop;\n            this.info =\n                level >= this._levels.INFO\n                    ? generateLogFn(\"info\", console.info.bind(console))\n                    : noop;\n            this.debug =\n                level >= this._levels.DEBUG\n                    ? generateLogFn(\"log\", console.log.bind(console))\n                    : noop;\n            /* eslint-enable no-console */\n        }\n        else {\n            const produceLogFn = (logLevel) => {\n                return level >= this._levels[logLevel]\n                    ? (...args) => {\n                        return logFn(logLevel, args);\n                    }\n                    : noop;\n            };\n            this.error = produceLogFn(\"ERROR\");\n            this.warn = produceLogFn(\"WARNING\");\n            this.info = produceLogFn(\"INFO\");\n            this.debug = produceLogFn(\"DEBUG\");\n        }\n        this.trigger(\"onLogLevelChange\", {\n            level: this._currentLevel,\n            format: this._currentFormat,\n        });\n    }\n    /**\n     * Get the last set logger level, as an upper-case string value.\n     * @returns {string}\n     */\n    getLevel() {\n        return this._currentLevel;\n    }\n    /**\n     * Get the last set logger's log format.\n     * @returns {string}\n     */\n    getFormat() {\n        return this._currentFormat;\n    }\n    /**\n     * Returns `true` if the currently set level includes logs of the level given\n     * in argument.\n     * @param {string} logLevel\n     * @returns {boolean}\n     */\n    hasLevel(logLevel) {\n        return this._levels[logLevel] >= this._levels[this._currentLevel];\n    }\n}\n","import SharedReference from \"./reference\";\n/**\n * Time difference of the monotonic clock indicated by `performance.now` with\n * the main thread environment (i.e. amount of time to add to the worker's clock\n * to obtain the main clock - from the worker-side).\n */\nconst mainThreadTimestampDiff = new SharedReference(0);\nexport function scaleTimestamp({ date, timestamp }) {\n    const delta = date - timestamp;\n    const diffCurrentEnv = typeof performance !== \"undefined\"\n        ? // eslint-disable-next-line no-restricted-properties\n            Date.now() - performance.now()\n        : 0;\n    mainThreadTimestampDiff.setValueIfChanged(diffCurrentEnv - delta);\n}\n/**\n * Provide a \"monotonically-raising timestamp\". That is, a timestamp that is\n * guaranteed to keep raising at the same speed of 1000 milliseconds per second\n * (unlike for example `Date.now()` which may not have the same behavior if the\n * system's clock is updated, whether it is due to NTP, the user updating the\n * clock, daylight saving time, leap seconds, or someone deciding that\n * datekeeping rules have to be changed).\n *\n * This function is useful when what you want to do is just time comparaison, in\n * which case going through `Date` objects would both be unnecessary and\n * affected by the aforementioned issues.\n *\n * Also, by updating `mainThreadTimestampDiff`, you can ensure that WebWorkers\n * provide a monotonic timestamp synchronized with the main thread.\n * @returns {number}\n */\nconst getMonotonicTimeStamp = typeof performance !== \"undefined\"\n    ? // eslint-disable-next-line no-restricted-properties\n        () => performance.now() + mainThreadTimestampDiff.getValue()\n    : () => Date.now() + mainThreadTimestampDiff.getValue();\nexport default getMonotonicTimeStamp;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Do nothing (but do it well).\n *\n * Having this definition here allow to use the same reference each time a noop\n * is needed.\n * Also, it allows to avoid telling eslint to ignore empty blocks everywhere.\n */\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport default function () { }\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Very simple implementation of Object.assign.\n * Should be sufficient for all use-cases here.\n *\n * Does not support symbols, but this should not be a problem as browsers\n * supporting symbols generally support Object.assign;\n *\n * @param {Object} target\n * @param {Array.<Object>} ...sources\n * @returns {Object}\n */\nfunction objectAssign(target, ...sources) {\n    if (target === null || target === undefined) {\n        throw new TypeError(\"Cannot convert undefined or null to object\");\n    }\n    // eslint-disable-next-line  @typescript-eslint/no-unsafe-assignment\n    const to = Object(target);\n    for (const source of sources) {\n        for (const key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n                to[key] = source[key];\n            }\n        }\n    }\n    return to;\n}\n// eslint-disable-next-line no-restricted-properties\nexport default typeof Object.assign === \"function\"\n    ? // eslint-disable-next-line no-restricted-properties\n        Object.assign\n    : objectAssign;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @param {Object|Array} o\n * @returns {Array.<*>}\n */\nfunction objectValues(o) {\n    return Object.keys(o).map((k) => o[k]);\n}\n// eslint-disable-next-line no-restricted-properties\nexport default typeof Object.values === \"function\" ? Object.values : objectValues;\nexport { objectValues };\n","export default typeof queueMicrotask === \"function\"\n    ? queueMicrotask\n    : function queueMicrotaskPonyfill(cb) {\n        Promise.resolve().then(cb, () => cb());\n    };\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * This file contains functions helping with TimeRanges management.\n *\n * For simplicity/performance reasons, many of those work with a simplified\n * \"Range\" object, which is an object with two keys:\n *   - start {Number}\n *   - end {Number}\n *\n * Those two corresponds to what is returned by the start and end methods of a\n * TimeRanges Object.\n *\n * You can convert from TimeRanges to Range object(s) with the getRange/\n * convertToRanges methods.\n */\n// Factor for rounding errors\nconst EPSILON = 1 / 60;\n/**\n * Check equality with a tolerance of EPSILON.\n * Used for various functions with this sort of tolerance regarding the\n * start/end of contiguous ranges.\n * @param {Number} a\n * @param {Number} b\n * @returns {Boolean}\n */\nfunction nearlyEqual(a, b) {\n    return Math.abs(a - b) < EPSILON;\n}\n/**\n * Construct a new range which will have, as start/end, the min/max\n * of both the range given, and the given bitrate.\n * @param {Object} range1\n * @param {Object} range2\n * @returns {Object}\n */\nfunction createRangeUnion(range1, range2) {\n    const start = Math.min(range1.start, range2.start);\n    const end = Math.max(range1.end, range2.end);\n    return { start, end };\n}\n/**\n * Clean array ranges from \"empty\" ranges.\n * That is, range objects which have their start equal to their end.\n * /!\\ Mutate the array of ranges.\n * @param {Array<Object>} ranges\n * @returns {Array<Object>}\n */\nfunction removeEmptyRanges(ranges) {\n    for (let index = 0; index < ranges.length; index++) {\n        const range = ranges[index];\n        if (range.start === range.end) {\n            ranges.splice(index--, 1);\n        }\n    }\n    return ranges;\n}\n/**\n * /!\\ Mutate the array of ranges.\n * @param {Array<Object>} ranges\n * @returns {Array<Object>}\n */\nfunction mergeContiguousRanges(ranges) {\n    for (let index = 1; index < ranges.length; index++) {\n        const prevRange = ranges[index - 1];\n        const currRange = ranges[index];\n        if (areRangesNearlyContiguous(prevRange, currRange)) {\n            const unionRange = createRangeUnion(prevRange, currRange);\n            ranges.splice(--index, 2, unionRange);\n        }\n    }\n    return ranges;\n}\n/**\n * True if range1 is considered _after_ range2.\n * @param {Object} range1\n * @param {Object} range2\n * @returns {Boolean}\n */\nfunction isAfter(range1, range2) {\n    return range1.start >= range2.end;\n}\n/**\n * True if range1 is considered _before_ range2.\n * @param {Object} range1\n * @param {Object} range2\n * @returns {Boolean}\n */\nfunction isBefore(range1, range2) {\n    return range1.end <= range2.start;\n}\n/**\n * Returns true if the time given can be considered as part of any of the given\n * ranges.\n * @param {Array.<Object>} ranges\n * @param {number} time\n * @returns {boolean}\n */\nfunction isTimeInRanges(ranges, time) {\n    for (let i = 0; i < ranges.length; i++) {\n        if (isTimeInRange(ranges[i], time)) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Returns true if the time given can be considered as part of the given range.\n * @param {Object} range1\n * @param {Number} Time\n * @returns {Boolean}\n */\nfunction isTimeInRange({ start, end }, time) {\n    return start <= time && time < end;\n}\n/**\n * Returns true if the two ranges given are overlapping.\n * @param {Object} range1\n * @param {Object} range2\n * @returns {Boolean}\n */\nfunction areRangesOverlapping(range1, range2) {\n    return (isTimeInRange(range1, range2.start) ||\n        (range1.start < range2.end && range2.end < range1.end) ||\n        isTimeInRange(range2, range1.start));\n}\n/**\n * Returns true if the two ranges given can be considered contiguous.\n * @param {Object} range1\n * @param {Object} range2\n * @returns {Boolean}\n */\nfunction areRangesNearlyContiguous(range1, range2) {\n    return nearlyEqual(range2.start, range1.end) || nearlyEqual(range2.end, range1.start);\n}\n/**\n * Convert from a TimeRanges object to an array of Ranges.\n * @param {TimeRanges} timeRanges\n * @returns {Array.<Object>}\n */\nfunction convertToRanges(timeRanges) {\n    const ranges = [];\n    for (let i = 0; i < timeRanges.length; i++) {\n        ranges.push({ start: timeRanges.start(i), end: timeRanges.end(i) });\n    }\n    return ranges;\n}\n/**\n * Get range object of a specific time in a TimeRanges object.\n * @param {TimeRanges} timeRanges\n * @returns {Object}\n */\nfunction getBufferedTimeRange(timeRanges, time) {\n    for (let i = timeRanges.length - 1; i >= 0; i--) {\n        const start = timeRanges.start(i);\n        if (time >= start) {\n            const end = timeRanges.end(i);\n            if (time < end) {\n                return { start, end };\n            }\n        }\n    }\n    return null;\n}\n/**\n * Get range object of a specific time in a `IRange` object.\n * @param {Array.<Object>} ranges\n * @returns {Object}\n */\nfunction getRange(ranges, time) {\n    for (let i = ranges.length - 1; i >= 0; i--) {\n        const start = ranges[i].start;\n        if (time >= start) {\n            const end = ranges[i].end;\n            if (time < end) {\n                return ranges[i];\n            }\n        }\n    }\n    return null;\n}\n/**\n * Get gap from a specific time until the start of the next Range.\n * @param {TimeRanges} timeRanges\n * @param {Number} time\n * @returns {Number}\n */\nfunction getNextBufferedTimeRangeGap(timeRanges, time) {\n    const len = timeRanges.length;\n    for (let i = 0; i < len; i++) {\n        const start = timeRanges.start(i);\n        if (time < start) {\n            return start - time;\n        }\n    }\n    return Infinity;\n}\n/**\n * @param {TimeRanges} timeRanges\n * @param {Number} time\n * @returns {Object} - Object with two properties:\n *   - outerRanges {Array.<Object>}: every ranges which does not contain the\n *     given time.\n *   - innerRange {Object|null}: the range which contain the given time.\n */\nfunction getInnerAndOuterRangesFromBufferedTimeRanges(timeRanges, time) {\n    let innerRange = null;\n    const outerRanges = [];\n    for (let i = 0; i < timeRanges.length; i++) {\n        const start = timeRanges.start(i);\n        const end = timeRanges.end(i);\n        if (time < start || time >= end) {\n            outerRanges.push({ start, end });\n        }\n        else {\n            innerRange = { start, end };\n        }\n    }\n    return { outerRanges, innerRange };\n}\n/**\n * @param {Array.<Object>} ranges\n * @param {Number} time\n * @returns {Object} - Object with two properties:\n *   - outerRanges {Array.<Object>}: every ranges which does not contain the\n *     given time.\n *   - innerRange {Object|null}: the range which contain the given time.\n */\nfunction getInnerAndOuterRanges(ranges, time) {\n    let innerRange = null;\n    const outerRanges = [];\n    for (let i = 0; i < ranges.length; i++) {\n        const start = ranges[i].start;\n        const end = ranges[i].end;\n        if (time < start || time >= end) {\n            outerRanges.push({ start, end });\n        }\n        else {\n            innerRange = { start, end };\n        }\n    }\n    return { outerRanges, innerRange };\n}\n/**\n * Get \"size\" (difference between end and start) of the TimeRange containing the\n * given time. 0 if the range is not found.\n * @param {TimeRanges} timeRanges\n * @param {Number} currentTime\n * @returns {Number}\n */\nfunction getSizeOfBufferedTimeRange(timeRanges, currentTime) {\n    const range = getBufferedTimeRange(timeRanges, currentTime);\n    return range !== null ? range.end - range.start : 0;\n}\n/**\n * Get \"currently played\" (difference between time given and start) of the\n * range containing the given time. 0 if the range is not found.\n * @param {TimeRanges} timeRanges\n * @param {Number} currentTime\n * @returns {Number}\n */\nfunction getPlayedSizeOfBufferedTimeRange(timeRanges, currentTime) {\n    const range = getBufferedTimeRange(timeRanges, currentTime);\n    return range !== null ? currentTime - range.start : 0;\n}\n/**\n * Get \"left to play\" (difference between end and time given) of the range\n * containing the given time. Infinity if the range is not found.\n * @param {TimeRanges} timeRanges\n * @param {Number} currentTime\n * @returns {Number}\n */\nfunction getLeftSizeOfBufferedTimeRange(timeRanges, currentTime) {\n    const range = getBufferedTimeRange(timeRanges, currentTime);\n    return range !== null ? range.end - currentTime : Infinity;\n}\n/**\n * Get \"size\" (difference between end and start) of the range containing the\n * given time. 0 if the range is not found.\n * @param {Array.<Object>} ranges\n * @param {Number} currentTime\n * @returns {Number}\n */\nfunction getSizeOfRange(ranges, currentTime) {\n    const range = getRange(ranges, currentTime);\n    return range !== null ? range.end - range.start : 0;\n}\n/**\n * Get \"currently played\" (difference between time given and start) of the\n * range containing the given time. 0 if the range is not found.\n * @param {Array.<Object>} ranges\n * @param {Number} currentTime\n * @returns {Number}\n */\nfunction getPlayedSizeOfRange(ranges, currentTime) {\n    const range = getRange(ranges, currentTime);\n    return range !== null ? currentTime - range.start : 0;\n}\n/**\n * Get \"left to play\" (difference between end and time given) of the range\n * containing the given time. Infinity if the range is not found.\n * @param {Array.<Object>} ranges\n * @param {Number} currentTime\n * @returns {Number}\n */\nfunction getLeftSizeOfRange(ranges, currentTime) {\n    const range = getRange(ranges, currentTime);\n    return range !== null ? range.end - currentTime : Infinity;\n}\n/**\n * Insert a range object into an array of ranges objects, at the right place.\n * /!\\ Mutate the array of ranges.\n * @param {Array.<Object>} ranges\n * @param {Object} rangeToAddArg\n * @returns {Array.<Object>}\n */\nfunction insertInto(ranges, rangeToAddArg) {\n    if (rangeToAddArg.start === rangeToAddArg.end) {\n        return ranges;\n    }\n    let rangeToAdd = rangeToAddArg;\n    // For each present range check if we need to:\n    // - In case we are overlapping or contiguous:\n    //   - if added range has the same bitrate as the overlapped or\n    //     contiguous one, we can merge themcurrentRange\n    //   - if added range has a different bitrate we need to insert it\n    //     in place\n    // - Need to insert in place, we we are completely, not overlapping\n    //   and not contiguous in between two ranges.\n    let index = 0;\n    for (; index < ranges.length; index++) {\n        const range = ranges[index];\n        const overlapping = areRangesOverlapping(rangeToAdd, range);\n        const contiguous = areRangesNearlyContiguous(rangeToAdd, range);\n        // We assume ranges are ordered and two ranges can not be\n        // completely overlapping.\n        if (overlapping || contiguous) {\n            rangeToAdd = createRangeUnion(rangeToAdd, range);\n            ranges.splice(index--, 1);\n        }\n        else {\n            // Check the case for which there is no more to do\n            if (index === 0) {\n                if (isBefore(rangeToAdd, ranges[0])) {\n                    // First index, and we are completely before that range (and\n                    // not contiguous, nor overlapping). We just need to be\n                    // inserted here.\n                    break;\n                }\n            }\n            else {\n                if (isBefore(ranges[index - 1], rangeToAdd) && isBefore(rangeToAdd, range)) {\n                    // We are exactly after the current previous range, and\n                    // before the current range, while not overlapping with none\n                    // of them. Insert here.\n                    break;\n                }\n            }\n        }\n    }\n    // Now that we are sure we don't overlap with any range, just add it.\n    ranges.splice(index, 0, rangeToAdd);\n    return mergeContiguousRanges(removeEmptyRanges(ranges));\n}\n/**\n * Returns range, from a range objects array overlapping with a range given\n * in argument. null if none is found.\n * @param {Object} range\n * @param {Array.<Object>} ranges\n * @returns {Array.<Object>}\n */\nfunction findOverlappingRanges(range, ranges) {\n    const resultingRanges = [];\n    for (let i = 0; i < ranges.length; i++) {\n        if (areRangesOverlapping(range, ranges[i])) {\n            resultingRanges.push(ranges[i]);\n        }\n    }\n    return resultingRanges;\n}\n/**\n * Returns only the intersection between the two ranges, from the first\n * ranges argument given.\n * @param {Array.<Range>} ranges1\n * @param {Array.<Range>} ranges2\n * @returns {Array.<Range>}\n */\nfunction keepRangeIntersection(ranges1, ranges2) {\n    const result = [];\n    for (let i = 0; i < ranges1.length; i++) {\n        const range = ranges1[i];\n        const overlappingRanges = findOverlappingRanges(range, ranges2);\n        if (overlappingRanges.length > 0) {\n            for (let j = 0; j < overlappingRanges.length; j++) {\n                const overlappingRange = overlappingRanges[j];\n                result.push({\n                    start: Math.max(range.start, overlappingRange.start),\n                    end: Math.min(range.end, overlappingRange.end),\n                });\n            }\n        }\n    }\n    return result;\n}\n/**\n * Exclude from the `baseRanges` everything that is in `rangesToExclude`.\n * Example:\n *\n * Let's say we have the following base ranges:\n *       |==========|        |===============| |======|    |==========|\n *\n * From which we want to \"exclude\" the following ranges:\n *          |=========| |==|        |===|  |=====|\n *\n * We will obtain the first ranges from which we remove the second ranges:\n * -----------------------------------------------------------------------\n *       |==========|        |===============| |======|    |==========|\n *          |=========| |==|        |===|  |=====|\n * _______________________________________________________________________\n *                                     |\n *                                     |\n *                                     V\n * -----------------------------------------------------------------------\n *       |==|                |======|   |==|     |====|    |==========|\n * -----------------------------------------------------------------------\n *\n * @param {Array.<Object} baseRanges\n * @param {Array.<Object} rangesToExclude\n * @return {Array.<Object>}\n */\nfunction excludeFromRanges(baseRanges, rangesToExclude) {\n    const result = [];\n    // For every range in `baseRanges`, find overlapping ranges with\n    // `rangesToExclude` and remove them.\n    for (let i = 0; i < baseRanges.length; i++) {\n        const range = baseRanges[i];\n        const intersections = [];\n        const overlappingRanges = findOverlappingRanges(range, rangesToExclude);\n        if (overlappingRanges.length > 0) {\n            for (let j = 0; j < overlappingRanges.length; j++) {\n                const overlappingRange = overlappingRanges[j];\n                intersections.push({\n                    start: Math.max(range.start, overlappingRange.start),\n                    end: Math.min(range.end, overlappingRange.end),\n                });\n            }\n        }\n        if (intersections.length === 0) {\n            result.push(range);\n        }\n        else {\n            let lastStart = range.start;\n            for (let j = 0; j < intersections.length; j++) {\n                if (intersections[j].start > lastStart) {\n                    result.push({ start: lastStart, end: intersections[j].start });\n                }\n                lastStart = intersections[j].end;\n            }\n            if (lastStart < range.end) {\n                result.push({ start: lastStart, end: range.end });\n            }\n        }\n    }\n    return result;\n}\n/**\n * Returns `true` if the given `time` is available in the TimeRanges object\n * given.\n * Returns `false` otherwise.\n * @param {TimeRanges} ranges\n * @param {Number} time\n * @returns {boolean}\n */\nfunction isTimeInTimeRanges(ranges, time) {\n    for (let i = 0; i < ranges.length; i++) {\n        if (ranges.start(i) <= time && time < ranges.end(i)) {\n            return true;\n        }\n    }\n    return false;\n}\nexport { convertToRanges, excludeFromRanges, getInnerAndOuterRangesFromBufferedTimeRanges, getInnerAndOuterRanges, getLeftSizeOfRange, getNextBufferedTimeRangeGap, getSizeOfBufferedTimeRange, getPlayedSizeOfBufferedTimeRange, getLeftSizeOfBufferedTimeRange, getPlayedSizeOfRange, getBufferedTimeRange, getRange, getSizeOfRange, insertInto, isAfter, isBefore, isTimeInTimeRanges, isTimeInRange, isTimeInRanges, keepRangeIntersection, mergeContiguousRanges, removeEmptyRanges, };\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport arrayFindIndex from \"./array_find_index\";\nimport noop from \"./noop\";\n/**\n * A value behind a shared reference, meaning that any update to its value from\n * anywhere can be retrieved from any other parts of the code in possession of\n * the same `SharedReference`.\n *\n * @example\n * ```ts\n * const myVal = 1;\n * const myRef : SharedReference<number> = new SharedReference(1);\n *\n * function setValTo2(num : number) {\n *   num = 2;\n * }\n *\n * function setRefTo2(num : SharedReference<number>) {\n *   num.setValue(2);\n * }\n *\n * setValTo2(myVal);\n * console.log(myVal); // output: 1\n *\n * myRef.onUpdate((val) => {\n *   console.log(val); // outputs first synchronously `1`, then `2`\n * }, { emitCurrentValue: true });\n *\n * setRefTo2(myRef);\n * console.log(myRef.getValue()); // output: 2\n *\n * myRef.listen((val) => {\n *   console.log(val); // outputs only `2`\n * }, { emitCurrentValue: true });\n * ```\n *\n * This type was added because we found that the usage of an explicit type for\n * those use cases makes the intent of the corresponding code clearer.\n */\nclass SharedReference {\n    /**\n     * Create a `SharedReference` object encapsulating the mutable `initialValue`\n     * value of type T.\n     * @param {*} initialValue\n     * @param {Object|undefined} [cancelSignal] - If set, the created shared\n     * reference will be automatically \"finished\" once that signal emits.\n     * Finished references won't be able to update their value anymore, and will\n     * also automatically have their listeners (callbacks linked to value change)\n     * removed - as they cannot be triggered anymore, thus providing a security\n     * against memory leaks.\n     */\n    constructor(initialValue, cancelSignal) {\n        this._value = initialValue;\n        this._listeners = [];\n        this._isFinished = false;\n        this._onFinishCbs = [];\n        if (cancelSignal !== undefined) {\n            this._deregisterCancellation = cancelSignal.register(() => this.finish());\n        }\n    }\n    /**\n     * Returns the current value of this shared reference.\n     * @returns {*}\n     */\n    getValue() {\n        return this._value;\n    }\n    /**\n     * Update the value of this shared reference.\n     * @param {*} newVal\n     */\n    setValue(newVal) {\n        if (this._isFinished) {\n            if (0 /* __ENVIRONMENT__.CURRENT_ENV */ === 1 /* __ENVIRONMENT__.DEV */) {\n                // eslint-disable-next-line no-console\n                console.error(\"Finished shared references cannot be updated\");\n            }\n            return;\n        }\n        this._value = newVal;\n        if (this._listeners.length === 0) {\n            return;\n        }\n        const clonedCbs = this._listeners.slice();\n        for (const cbObj of clonedCbs) {\n            try {\n                if (!cbObj.hasBeenCleared) {\n                    cbObj.trigger(newVal, cbObj.complete);\n                }\n            }\n            catch (_) {\n                /* nothing */\n            }\n        }\n    }\n    /**\n     * Update the value of this shared reference only if the value changed.\n     *\n     * Note that this function only performs a strict equality reference through\n     * the \"===\" operator. Different objects that are structurally the same will\n     * thus be considered different.\n     * @param {*} newVal\n     */\n    setValueIfChanged(newVal) {\n        if (newVal !== this._value) {\n            this.setValue(newVal);\n        }\n    }\n    /**\n     * Allows to register a callback to be called each time the value inside the\n     * reference is updated.\n     * @param {Function} cb - Callback to be called each time the reference is\n     * updated. Takes as first argument its new value and in second argument a\n     * callback allowing to unregister the callback.\n     * @param {Object} params\n     * @param {Object} params.clearSignal - Allows to provide a CancellationSignal\n     * which will unregister the callback when it emits.\n     * @param {boolean|undefined} [params.emitCurrentValue] - If `true`, the\n     * callback will also be immediately called with the current value.\n     */\n    onUpdate(cb, params) {\n        const unlisten = () => {\n            if (params.clearSignal !== undefined) {\n                params.clearSignal.deregister(unlisten);\n            }\n            if (cbObj.hasBeenCleared) {\n                return;\n            }\n            cbObj.hasBeenCleared = true;\n            const indexOf = this._listeners.indexOf(cbObj);\n            if (indexOf >= 0) {\n                this._listeners.splice(indexOf, 1);\n            }\n        };\n        const cbObj = { trigger: cb, complete: unlisten, hasBeenCleared: false };\n        this._listeners.push(cbObj);\n        if (params.emitCurrentValue === true) {\n            cb(this._value, unlisten);\n        }\n        if (this._isFinished || cbObj.hasBeenCleared) {\n            unlisten();\n            return;\n        }\n        params.clearSignal.register(unlisten);\n    }\n    /**\n     * Variant of `onUpdate` which will only call the callback once, once the\n     * value inside the reference is different from `undefined`.\n     * The callback is called synchronously if the value already isn't set to\n     * `undefined`.\n     *\n     * This method can be used as a lighter weight alternative to `onUpdate` when\n     * just waiting that the stored value becomes defined.\n     * As such, it is an explicit equivalent to something like:\n     * ```js\n     * myReference.onUpdate((newVal, stopListening) => {\n     *  if (newVal !== undefined) {\n     *    stopListening();\n     *\n     *    // ... do the logic\n     *  }\n     * }, { emitCurrentValue: true });\n     * ```\n     * @param {Function} cb - Callback to be called each time the reference is\n     * updated. Takes the new value in argument.\n     * @param {Object} params\n     * @param {Object} params.clearSignal - Allows to provide a\n     * CancellationSignal which will unregister the callback when it emits.\n     */\n    waitUntilDefined(cb, params) {\n        this.onUpdate((val, stopListening) => {\n            if (val !== undefined) {\n                stopListening();\n                cb(this._value);\n            }\n        }, { clearSignal: params.clearSignal, emitCurrentValue: true });\n    }\n    /**\n     * Allows to register a callback for when the Shared Reference is \"finished\".\n     *\n     * This function is mostly there for implementing operators on the shared\n     * reference and isn't meant to be used by regular code, hence it being\n     * prefixed by `_`.\n     * @param {Function} cb - Callback to be called once the reference is\n     * finished.\n     * @param {Object} onFinishCancelSignal - Allows to provide a\n     * CancellationSignal which will unregister the callback when it emits.\n     */\n    _onFinished(cb, onFinishCancelSignal) {\n        if (onFinishCancelSignal.isCancelled()) {\n            return noop;\n        }\n        const cleanUp = () => {\n            const indexOf = arrayFindIndex(this._onFinishCbs, (x) => x.trigger === trigger);\n            if (indexOf >= 0) {\n                this._onFinishCbs[indexOf].hasBeenCleared = true;\n                this._onFinishCbs.splice(indexOf, 1);\n            }\n        };\n        const trigger = () => {\n            cleanUp();\n            cb();\n        };\n        const deregisterCancellation = onFinishCancelSignal.register(cleanUp);\n        this._onFinishCbs.push({ trigger, hasBeenCleared: false });\n        return deregisterCancellation;\n    }\n    /**\n     * Indicate that no new values will be emitted.\n     * Allows to automatically free all listeners linked to this reference.\n     */\n    finish() {\n        if (this._deregisterCancellation !== undefined) {\n            this._deregisterCancellation();\n        }\n        this._isFinished = true;\n        const clonedCbs = this._listeners.slice();\n        for (const cbObj of clonedCbs) {\n            try {\n                if (!cbObj.hasBeenCleared) {\n                    cbObj.complete();\n                    cbObj.hasBeenCleared = true;\n                }\n            }\n            catch (_) {\n                /* nothing */\n            }\n        }\n        this._listeners.length = 0;\n        if (this._onFinishCbs.length > 0) {\n            const clonedFinishedCbs = this._onFinishCbs.slice();\n            for (const cbObj of clonedFinishedCbs) {\n                try {\n                    if (!cbObj.hasBeenCleared) {\n                        cbObj.trigger();\n                        cbObj.hasBeenCleared = true;\n                    }\n                }\n                catch (_) {\n                    /* nothing */\n                }\n            }\n            this._onFinishCbs.length = 0;\n        }\n    }\n}\n/**\n * Create a new `SharedReference` based on another one by mapping over its\n * referenced value each time it is updated and finishing once it finishes.\n * @param {Object} originalRef - The Original `SharedReference` you wish to map\n * over.\n * @param {Function} mappingFn - The mapping function which will receives\n * `originalRef`'s value and outputs this new reference's value.\n * @param {Object} cancellationSignal - Optionally, a `CancellationSignal` which\n * will finish that reference when it emits.\n * @returns {Object} - The new, mapped, reference.\n */\nexport function createMappedReference(originalRef, mappingFn, cancellationSignal) {\n    const newRef = new SharedReference(mappingFn(originalRef.getValue()), cancellationSignal);\n    originalRef.onUpdate(function mapOriginalReference(x) {\n        newRef.setValue(mappingFn(x));\n    }, { clearSignal: cancellationSignal });\n    originalRef._onFinished(() => {\n        newRef.finish();\n    }, cancellationSignal);\n    return newRef;\n}\nexport default SharedReference;\n","/*\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../log\";\nimport globalScope from \"../global_scope\";\nimport isNullOrUndefined from \"../is_null_or_undefined\";\nimport getMonotonicTimeStamp from \"../monotonic_timestamp\";\nimport RequestError, { RequestErrorTypes } from \"./request_error\";\nconst _Headers = typeof Headers === \"function\" ? Headers : null;\nconst _AbortController = typeof AbortController === \"function\" ? AbortController : null;\nexport default function fetchRequest(options) {\n    var _a, _b;\n    let headers;\n    if (!isNullOrUndefined(options.headers)) {\n        if (isNullOrUndefined(_Headers)) {\n            headers = options.headers;\n        }\n        else {\n            headers = new _Headers();\n            const headerNames = Object.keys(options.headers);\n            for (let i = 0; i < headerNames.length; i++) {\n                const headerName = headerNames[i];\n                headers.append(headerName, options.headers[headerName]);\n            }\n        }\n    }\n    log.debug(\"Fetch: Called with URL\", options.url);\n    let cancellation = null;\n    let isTimedOut = false;\n    let isConnectionTimedOut = false;\n    const sendingTime = getMonotonicTimeStamp();\n    const abortController = !isNullOrUndefined(_AbortController)\n        ? new _AbortController()\n        : null;\n    /**\n     * Abort current fetchRequest by triggering AbortController signal.\n     * @returns {void}\n     */\n    function abortFetch() {\n        if (isNullOrUndefined(abortController)) {\n            log.warn(\"Fetch: AbortController API not available.\");\n            return;\n        }\n        abortController.abort();\n    }\n    let timeoutId;\n    if (options.timeout !== undefined) {\n        timeoutId = setTimeout(() => {\n            isTimedOut = true;\n            if (connectionTimeoutId !== undefined) {\n                clearTimeout(connectionTimeoutId);\n            }\n            abortFetch();\n        }, options.timeout);\n    }\n    let connectionTimeoutId;\n    if (options.connectionTimeout !== undefined) {\n        connectionTimeoutId = setTimeout(() => {\n            isConnectionTimedOut = true;\n            if (timeoutId !== undefined) {\n                clearTimeout(timeoutId);\n            }\n            abortFetch();\n        }, options.connectionTimeout);\n    }\n    const deregisterCancelLstnr = options.cancelSignal.register(function abortRequest(err) {\n        cancellation = err;\n        abortFetch();\n    });\n    const fetchOpts = { method: \"GET\" };\n    if (headers !== undefined) {\n        fetchOpts.headers = headers;\n    }\n    fetchOpts.signal = !isNullOrUndefined(abortController) ? abortController.signal : null;\n    if (log.hasLevel(\"DEBUG\")) {\n        let logLine = \"FETCH: Sending GET \" + options.url;\n        if (options.timeout !== undefined) {\n            logLine += \" to=\" + String(options.timeout / 1000);\n        }\n        if (options.connectionTimeout !== undefined) {\n            logLine += \" cto=\" + String(options.connectionTimeout / 1000);\n        }\n        if (((_a = options.headers) === null || _a === void 0 ? void 0 : _a.Range) !== undefined) {\n            logLine += \" Range=\" + ((_b = options.headers) === null || _b === void 0 ? void 0 : _b.Range);\n        }\n        log.debug(logLine);\n    }\n    return fetch(options.url, fetchOpts)\n        .then((response) => {\n        if (connectionTimeoutId !== undefined) {\n            clearTimeout(connectionTimeoutId);\n        }\n        if (response.status >= 300) {\n            log.warn(\"Fetch: Request HTTP Error\", response.status, response.url);\n            throw new RequestError(response.url, response.status, RequestErrorTypes.ERROR_HTTP_CODE);\n        }\n        if (isNullOrUndefined(response.body)) {\n            throw new RequestError(response.url, response.status, RequestErrorTypes.PARSE_ERROR);\n        }\n        const contentLengthHeader = response.headers.get(\"Content-Length\");\n        const contentLength = !isNullOrUndefined(contentLengthHeader) && !isNaN(+contentLengthHeader)\n            ? +contentLengthHeader\n            : undefined;\n        const reader = response.body.getReader();\n        let size = 0;\n        return readBufferAndSendEvents();\n        async function readBufferAndSendEvents() {\n            const data = await reader.read();\n            if (!data.done && !isNullOrUndefined(data.value)) {\n                size += data.value.byteLength;\n                const currentTime = getMonotonicTimeStamp();\n                const dataInfo = {\n                    url: response.url,\n                    currentTime,\n                    duration: currentTime - sendingTime,\n                    sendingTime,\n                    chunkSize: data.value.byteLength,\n                    chunk: data.value.buffer,\n                    size,\n                    totalSize: contentLength,\n                };\n                options.onData(dataInfo);\n                return readBufferAndSendEvents();\n            }\n            else if (data.done) {\n                if (timeoutId !== undefined) {\n                    clearTimeout(timeoutId);\n                }\n                deregisterCancelLstnr();\n                const receivedTime = getMonotonicTimeStamp();\n                const requestDuration = receivedTime - sendingTime;\n                return {\n                    requestDuration,\n                    receivedTime,\n                    sendingTime,\n                    size,\n                    status: response.status,\n                    url: response.url,\n                };\n            }\n            return readBufferAndSendEvents();\n        }\n    })\n        .catch((err) => {\n        if (cancellation !== null) {\n            throw cancellation;\n        }\n        deregisterCancelLstnr();\n        if (isTimedOut) {\n            log.warn(\"Fetch: Request timed out.\");\n            throw new RequestError(options.url, 0, RequestErrorTypes.TIMEOUT);\n        }\n        else if (isConnectionTimedOut) {\n            log.warn(\"Fetch: Request connection timed out.\");\n            throw new RequestError(options.url, 0, RequestErrorTypes.TIMEOUT);\n        }\n        else if (err instanceof RequestError) {\n            throw err;\n        }\n        log.warn(\"Fetch: Request Error\", err instanceof Error ? err.toString() : \"\");\n        throw new RequestError(options.url, 0, RequestErrorTypes.ERROR_EVENT);\n    });\n}\n/**\n * Returns true if fetch should be supported in the current browser.\n * @return {boolean}\n */\nexport function fetchIsSupported() {\n    return (typeof globalScope.fetch === \"function\" &&\n        !isNullOrUndefined(_AbortController) &&\n        !isNullOrUndefined(_Headers));\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport fetchRequest, { fetchIsSupported } from \"./fetch\";\nimport RequestError, { RequestErrorTypes } from \"./request_error\";\nimport xhr from \"./xhr\";\nexport default xhr;\nexport { fetchIsSupported, fetchRequest, xhr, RequestError, RequestErrorTypes };\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Internal Error used when doing requests through fetch / XHRs.\n *\n * It is not part of the API, as such it is only a temporary error which is\n * later converted to another Error instance (e.g. NETWORK_ERROR).\n *\n * @class RequestError\n * @extends Error\n */\nexport default class RequestError extends Error {\n    /**\n     * @param {string} url\n     * @param {number} status\n     * @param {string} type\n     */\n    constructor(url, status, type) {\n        let message;\n        switch (type) {\n            case \"TIMEOUT\":\n                message = \"The request timed out\";\n                break;\n            case \"ERROR_EVENT\":\n                message = \"An error prevented the request to be performed successfully\";\n                break;\n            case \"PARSE_ERROR\":\n                message = \"An error happened while formatting the response data\";\n                break;\n            case \"ERROR_HTTP_CODE\":\n                message =\n                    \"An HTTP status code indicating failure was received: \" + String(status);\n                break;\n        }\n        super(message);\n        // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class\n        Object.setPrototypeOf(this, RequestError.prototype);\n        this.name = \"RequestError\";\n        this.url = url;\n        this.status = status;\n        this.type = type;\n    }\n    serialize() {\n        return { url: this.url, status: this.status, type: this.type };\n    }\n}\nconst RequestErrorTypes = {\n    TIMEOUT: \"TIMEOUT\",\n    ERROR_EVENT: \"ERROR_EVENT\",\n    ERROR_HTTP_CODE: \"ERROR_HTTP_CODE\",\n    PARSE_ERROR: \"PARSE_ERROR\",\n};\nexport { RequestErrorTypes };\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../../log\";\nimport isNonEmptyString from \"../is_non_empty_string\";\nimport isNullOrUndefined from \"../is_null_or_undefined\";\nimport getMonotonicTimeStamp from \"../monotonic_timestamp\";\nimport RequestError, { RequestErrorTypes } from \"./request_error\";\nconst DEFAULT_RESPONSE_TYPE = \"json\";\nexport default function request(options) {\n    const requestOptions = {\n        url: options.url,\n        headers: options.headers,\n        responseType: isNullOrUndefined(options.responseType)\n            ? DEFAULT_RESPONSE_TYPE\n            : options.responseType,\n        timeout: options.timeout,\n        connectionTimeout: options.connectionTimeout,\n    };\n    return new Promise((resolve, reject) => {\n        const { onProgress, cancelSignal } = options;\n        const { url, headers, responseType, timeout, connectionTimeout } = requestOptions;\n        const xhr = new XMLHttpRequest();\n        xhr.open(\"GET\", url, true);\n        let timeoutId;\n        if (timeout !== undefined) {\n            xhr.timeout = timeout;\n            // We've seen on some browser (mainly on some LG TVs), that `xhr.timeout`\n            // was either not supported or did not function properly despite the\n            // browser being recent enough to support it.\n            // That's why we also start a manual timeout. We do this a little later\n            // than the \"native one\" performed on the xhr assuming that the latter\n            // is more precise, it might also be more efficient.\n            timeoutId = setTimeout(() => {\n                clearCancellingProcess();\n                reject(new RequestError(url, xhr.status, RequestErrorTypes.TIMEOUT));\n            }, timeout + 3000);\n        }\n        let connectionTimeoutId;\n        if (connectionTimeout !== undefined) {\n            connectionTimeoutId = setTimeout(() => {\n                clearCancellingProcess();\n                if (xhr.readyState !== XMLHttpRequest.DONE) {\n                    xhr.abort();\n                }\n                reject(new RequestError(url, xhr.status, RequestErrorTypes.TIMEOUT));\n            }, connectionTimeout);\n        }\n        xhr.responseType = responseType;\n        if (xhr.responseType === \"document\") {\n            xhr.overrideMimeType(\"text/xml\");\n        }\n        if (!isNullOrUndefined(headers)) {\n            const _headers = headers;\n            for (const key in _headers) {\n                if (Object.prototype.hasOwnProperty.call(_headers, key)) {\n                    xhr.setRequestHeader(key, _headers[key]);\n                }\n            }\n        }\n        const sendingTime = getMonotonicTimeStamp();\n        // Handle request cancellation\n        let deregisterCancellationListener = null;\n        if (cancelSignal !== undefined) {\n            deregisterCancellationListener = cancelSignal.register(function abortRequest(err) {\n                clearCancellingProcess();\n                if (xhr.readyState !== XMLHttpRequest.DONE) {\n                    xhr.abort();\n                }\n                reject(err);\n            });\n            if (cancelSignal.isCancelled()) {\n                return;\n            }\n        }\n        xhr.onerror = function onXHRError() {\n            clearCancellingProcess();\n            reject(new RequestError(url, xhr.status, RequestErrorTypes.ERROR_EVENT));\n        };\n        xhr.ontimeout = function onXHRTimeout() {\n            clearCancellingProcess();\n            reject(new RequestError(url, xhr.status, RequestErrorTypes.TIMEOUT));\n        };\n        if (connectionTimeout !== undefined) {\n            xhr.onreadystatechange = function clearConnectionTimeout() {\n                if (xhr.readyState >= XMLHttpRequest.HEADERS_RECEIVED) {\n                    clearTimeout(connectionTimeoutId);\n                }\n            };\n        }\n        if (onProgress !== undefined) {\n            xhr.onprogress = function onXHRProgress(event) {\n                const currentTime = getMonotonicTimeStamp();\n                onProgress({\n                    url,\n                    duration: currentTime - sendingTime,\n                    sendingTime,\n                    currentTime,\n                    size: event.loaded,\n                    totalSize: event.total,\n                });\n            };\n        }\n        xhr.onload = function onXHRLoad(event) {\n            if (xhr.readyState === XMLHttpRequest.DONE) {\n                clearCancellingProcess();\n                if (xhr.status >= 200 && xhr.status < 300) {\n                    const receivedTime = getMonotonicTimeStamp();\n                    const totalSize = xhr.response instanceof ArrayBuffer ? xhr.response.byteLength : event.total;\n                    const status = xhr.status;\n                    const loadedResponseType = xhr.responseType;\n                    const _url = isNonEmptyString(xhr.responseURL) ? xhr.responseURL : url;\n                    let responseData;\n                    if (loadedResponseType === \"json\") {\n                        // IE bug where response is string with responseType json\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                        responseData =\n                            typeof xhr.response === \"object\"\n                                ? xhr.response\n                                : toJSONForIE(xhr.responseText);\n                    }\n                    else {\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                        responseData = xhr.response;\n                    }\n                    if (isNullOrUndefined(responseData)) {\n                        reject(new RequestError(url, xhr.status, RequestErrorTypes.PARSE_ERROR));\n                        return;\n                    }\n                    resolve({\n                        status,\n                        url: _url,\n                        responseType: loadedResponseType,\n                        sendingTime,\n                        receivedTime,\n                        requestDuration: receivedTime - sendingTime,\n                        size: totalSize,\n                        responseData,\n                    });\n                }\n                else {\n                    reject(new RequestError(url, xhr.status, RequestErrorTypes.ERROR_HTTP_CODE));\n                }\n            }\n        };\n        if (log.hasLevel(\"DEBUG\")) {\n            let logLine = \"XHR: Sending GET \" + url;\n            if (options.responseType !== undefined) {\n                logLine += \" type=\" + options.responseType;\n            }\n            if (timeout !== undefined) {\n                logLine += \" to=\" + String(timeout / 1000);\n            }\n            if (connectionTimeout !== undefined) {\n                logLine += \" cto=\" + String(connectionTimeout / 1000);\n            }\n            if ((headers === null || headers === void 0 ? void 0 : headers.Range) !== undefined) {\n                logLine += \" Range=\" + (headers === null || headers === void 0 ? void 0 : headers.Range);\n            }\n            log.debug(logLine);\n        }\n        xhr.send();\n        /**\n         * Clear resources and timers created to handle cancellation and timeouts.\n         */\n        function clearCancellingProcess() {\n            if (timeoutId !== undefined) {\n                clearTimeout(timeoutId);\n            }\n            if (connectionTimeoutId !== undefined) {\n                clearTimeout(connectionTimeoutId);\n            }\n            if (deregisterCancellationListener !== null) {\n                deregisterCancellationListener();\n            }\n        }\n    });\n}\n/**\n * @param {string} data\n * @returns {Object|null}\n */\nfunction toJSONForIE(data) {\n    try {\n        return JSON.parse(data);\n    }\n    catch (_e) {\n        return null;\n    }\n}\n","import getFuzzedDelay from \"./get_fuzzed_delay\";\nimport isNullOrUndefined from \"./is_null_or_undefined\";\nimport sleep from \"./sleep\";\n/**\n * Retry the given Promise (if it rejects) with an exponential\n * backoff.\n * The backoff behavior can be tweaked through the options given.\n *\n * @param {Function} runProm\n * @param {Object} options - Configuration object.\n * This object contains the following properties:\n *\n *   - retryDelay {Number} - The initial delay, in ms.\n *     This delay will be fuzzed to fall under the range +-30% each time a new\n *     retry is done.\n *     Then, this delay will be multiplied by 2^(n-1), n being the counter of\n *     retry we performed (beginning at 1 for the first retry).\n *\n *   - totalRetry {Number} - The amount of time we should retry. 0\n *     means no retry, 1 means a single retry, Infinity means infinite retry\n *     etc.\n *     If the Promise still rejects after this number of retry, the error will\n *     be throwed through the returned Promise.\n *\n *   - shouldRetry {Function|undefined} -  Function which will receive the\n *     error each time it fails, and should return a boolean. If this boolean\n *     is false, the error will be directly thrown (without anymore retry).\n *\n *   - onRetry {Function|undefined} - Function which will be triggered at\n *     each retry. Will receive two arguments:\n *       1. The error\n *       2. The current retry count, beginning at 1 for the first retry\n *\n * @param {Object} cancelSignal\n * @returns {Promise}\n * TODO Take errorSelector out. Should probably be entirely managed in the\n * calling code via a catch (much simpler to use and to understand).\n */\nexport default function retryPromiseWithBackoff(runProm, options, cancelSignal) {\n    const { baseDelay, maxDelay, totalRetry, shouldRetry, onRetry } = options;\n    let retryCount = 0;\n    return iterate();\n    async function iterate() {\n        if (cancelSignal.cancellationError !== null) {\n            throw cancelSignal.cancellationError;\n        }\n        try {\n            const res = await runProm();\n            return res;\n        }\n        catch (error) {\n            if (cancelSignal.cancellationError !== null) {\n                throw cancelSignal.cancellationError;\n            }\n            if ((!isNullOrUndefined(shouldRetry) && !shouldRetry(error)) ||\n                retryCount++ >= totalRetry) {\n                throw error;\n            }\n            if (typeof onRetry === \"function\") {\n                onRetry(error, retryCount);\n            }\n            const delay = getRetryDelay(baseDelay, retryCount, maxDelay);\n            await sleep(delay);\n            const res = iterate();\n            return res;\n        }\n    }\n}\n/**\n * Get the delay that should be applied to the following retry, it depends on the base delay\n * and is increaser for with the retry count. The result is ceiled by the maxDelay.\n * @param baseDelay delay after wich the first request is retried after a failure\n * @param retryCount count of retries\n * @param maxDelay maximum delay\n * @returns the delay that should be applied to the following retry\n */\nexport function getRetryDelay(baseDelay, retryCount, maxDelay) {\n    const delay = baseDelay * Math.pow(2, retryCount - 1);\n    const fuzzedDelay = getFuzzedDelay(delay);\n    return Math.min(fuzzedDelay, maxDelay);\n}\n","/**\n * Convert a setTimeout to a Promise.\n *\n * You can use it to have a much more readable blocking code with async/await\n * in some asynchronous tests.\n *\n * @param {number} timeInMs\n * @returns {Promise}\n */\nexport default function sleep(timeInMs) {\n    return new Promise((res) => {\n        setTimeout(res, timeInMs);\n    });\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @param {Uint8Array} arr - The Uint8Array you want to slice\n * @param {number} start - The starting byte index from the beginning\n * @param {number} end -     Byte index before which to end slicing.\n * If end is unspecified, the new ArrayBuffer contains all bytes from begin to\n * the end of this ArrayBuffer. If negative, it will make the Byte index begin\n * from the last Byte.\n * @returns {Uint8Array}\n */\nfunction arraySlice(arr, start, end) {\n    return new Uint8Array(Array.prototype.slice.call(arr, start, end));\n}\n/**\n * @param {Uint8Array} arr - The Uint8Array you want to slice\n * @param {number} start - The starting byte index from the beginning\n * @param {number} end -     Byte index before which to end slicing.\n * If end is unspecified, the new ArrayBuffer contains all bytes from begin to\n * the end of this ArrayBuffer. If negative, it will make the Byte index begin\n * from the last Byte.\n * @returns {Uint8Array}\n */\nfunction uint8ArraySlice(arr, start, end) {\n    return arr.slice(start, end);\n}\nexport default typeof Uint8Array.prototype.slice === \"function\"\n    ? uint8ArraySlice\n    : arraySlice;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport arrayFind from \"./array_find\";\nimport arrayIncludes from \"./array_includes\";\n/**\n * Creates an Array automatically sorted with the sorting function given to the\n * constructor when the add method is called.\n *\n * @example\n * ```js\n * const sortedList = new SortedList((a, b) => a.start - b.start);\n * const element1 = { start: 20 };\n * const element2 = { start: 10 };\n * const element3 = { start: 15 };\n *\n * sortedList.add(element1, element2);\n * console.log(sortedList.unwrap());\n * // -> [{ start: 10 }, { start : 20 }]\n *\n * sortedList.add(element3);\n * console.log(sortedList.unwrap());\n * // -> [{ start: 10 }, { start : 15 }, { start: 20 }]\n *\n * sortedList.removeElement(element2);\n * // -> [{ start: 10 }, { start: 15 }]\n * ```\n * @class SortedList\n */\nexport default class SortedList {\n    /**\n     * @param {Function} sortingFunction\n     */\n    constructor(sortingFunction) {\n        this._array = [];\n        this._sortingFn = sortingFunction;\n    }\n    /**\n     * Add a new element to the List at the right place for the List to stay\n     * sorted.\n     *\n     * /!\\ The added Element will share the same reference than the given\n     * argument, any mutation on your part can lead to an un-sorted SortedList.\n     * You can still re-force the sorting to happen by calling forceSort.\n     * @param {...*} elements\n     */\n    add(...elements) {\n        elements.sort(this._sortingFn);\n        let j = 0;\n        for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            let inserted = false;\n            while (!inserted && j < this._array.length) {\n                if (this._sortingFn(element, this._array[j]) < 0) {\n                    this._array.splice(j, 0, element);\n                    inserted = true;\n                }\n                else {\n                    j++;\n                }\n            }\n            if (!inserted) {\n                this._array.push(element);\n            }\n        }\n    }\n    /**\n     * Returns the current length of the list.\n     * @returns {number}\n     */\n    length() {\n        return this._array.length;\n    }\n    /**\n     * Returns the nth element. Throws if the index does not exist.\n     *\n     * /!\\ The returned Element shares the same reference with what is used\n     * internally, any mutation on your part can lead to an un-sorted SortedList.\n     * You can still re-force the sorting to happen by calling forceSort.\n     * @throws Error - Throws if the given index is negative or superior to the\n     * array's length.\n     * @param {number} index\n     * @returns {*}\n     */\n    get(index) {\n        if (index < 0 || index >= this._array.length) {\n            throw new Error(\"Invalid index.\");\n        }\n        return this._array[index];\n    }\n    toArray() {\n        return this._array.slice();\n    }\n    /**\n     * Find the first element corresponding to the given predicate.\n     *\n     * /!\\ The returned element shares the same reference with what is used\n     * internally, any mutation on your part can lead to an un-sorted SortedList.\n     * You can still re-force the sorting to happen by calling forceSort.\n     * @param {Function} fn\n     * @returns {*}\n     */\n    findFirst(fn) {\n        return arrayFind(this._array, fn);\n    }\n    /**\n     * Returns true if the List contains the given element.\n     * @param {*} element\n     * @returns {Boolean}\n     */\n    has(element) {\n        return arrayIncludes(this._array, element);\n    }\n    /**\n     * Remove the first occurence of the given element.\n     * Returns the index of the removed element. Undefined if not found.\n     * @returns {number|undefined}\n     */\n    removeElement(element) {\n        const indexOf = this._array.indexOf(element);\n        if (indexOf >= 0) {\n            this._array.splice(indexOf, 1);\n            return indexOf;\n        }\n        return undefined;\n    }\n    /**\n     * Returns the first element.\n     *\n     * /!\\ The returned Element shares the same reference with what is used\n     * internally, any mutation on your part can lead to an un-sorted SortedList.\n     * You can still re-force the sorting to happen by calling forceSort.\n     * @returns {*}\n     */\n    head() {\n        return this._array[0];\n    }\n    /**\n     * Returns the last element.\n     *\n     * /!\\ The returned Element shares the same reference with what is used\n     * internally, any mutation on your part can lead to an un-sorted SortedList.\n     * You can still re-force the sorting to happen by calling forceSort.\n     * @returns {*}\n     */\n    last() {\n        return this._array[this._array.length - 1];\n    }\n    /**\n     * Remove the first element.\n     * Returns the element removed or undefined if no element were removed.\n     * @returns {*}\n     */\n    shift() {\n        return this._array.shift();\n    }\n    /**\n     * Remove the last element.\n     * Returns the element removed or undefined if no element were removed.\n     * @returns {*}\n     */\n    pop() {\n        return this._array.pop();\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * String.prototype.startsWith ponyfill.\n * Indicates Whether a string starts with another substring.\n *\n * Inspired from MDN polyfill, but ponyfilled instead.\n * @param {string} completeString\n * @param {string} searchString\n * @param {number} [position]\n * @returns {boolean}\n */\nexport default function startsWith(completeString, searchString, position) {\n    // eslint-disable-next-line no-restricted-properties\n    if (typeof String.prototype.startsWith === \"function\") {\n        // eslint-disable-next-line no-restricted-properties\n        return completeString.startsWith(searchString, position);\n    }\n    const initialPosition = typeof position === \"number\" ? Math.max(position, 0) : 0;\n    return (completeString.substring(initialPosition, initialPosition + searchString.length) ===\n        searchString);\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../log\";\nimport assert from \"./assert\";\nimport globalScope from \"./global_scope\";\nconst hasTextDecoder = typeof globalScope === \"object\" && typeof globalScope.TextDecoder === \"function\";\nconst hasTextEncoder = typeof globalScope === \"object\" && typeof globalScope.TextEncoder === \"function\";\n/**\n * Convert a string to an Uint8Array containing the corresponding UTF-16 code\n * units in little-endian.\n * @param {string} str\n * @returns {Uint8Array}\n */\nfunction strToUtf16LE(str) {\n    const buffer = new ArrayBuffer(str.length * 2);\n    const res = new Uint8Array(buffer);\n    for (let i = 0; i < res.length; i += 2) {\n        const value = str.charCodeAt(i / 2);\n        res[i] = value & 0xff;\n        res[i + 1] = (value >> 8) & 0xff;\n    }\n    return res;\n}\n/**\n * Convert a string to an Uint8Array containing the corresponding UTF-16 code\n * units in big-endian.\n * @param {string} str\n * @returns {Uint8Array}\n */\nfunction strToBeUtf16(str) {\n    const buffer = new ArrayBuffer(str.length * 2);\n    const res = new Uint8Array(buffer);\n    for (let i = 0; i < res.length; i += 2) {\n        const value = str.charCodeAt(i / 2);\n        res[i + 1] = value & 0xff;\n        res[i] = (value >> 8) & 0xff;\n    }\n    return res;\n}\n/**\n * Construct string from the little-endian UTF-16 code units given.\n * @param {Uint8Array} bytes\n * @returns {string}\n */\nfunction utf16LEToStr(bytes) {\n    if (hasTextDecoder) {\n        try {\n            // instanciation throws if the encoding is unsupported\n            const decoder = new TextDecoder(\"utf-16le\");\n            return decoder.decode(bytes);\n        }\n        catch (e) {\n            const err = e instanceof Error ? e : \"\";\n            log.warn(\"Utils: could not use TextDecoder to parse UTF-16LE, \" +\n                \"fallbacking to another implementation\", err);\n        }\n    }\n    let str = \"\";\n    for (let i = 0; i < bytes.length; i += 2) {\n        str += String.fromCharCode((bytes[i + 1] << 8) + bytes[i]);\n    }\n    return str;\n}\n/**\n * Construct string from the little-endian UTF-16 code units given.\n * @param {Uint8Array} bytes\n * @returns {string}\n */\nfunction beUtf16ToStr(bytes) {\n    if (hasTextDecoder) {\n        try {\n            // instanciation throws if the encoding is unsupported\n            const decoder = new TextDecoder(\"utf-16be\");\n            return decoder.decode(bytes);\n        }\n        catch (e) {\n            const err = e instanceof Error ? e : \"\";\n            log.warn(\"Utils: could not use TextDecoder to parse UTF-16BE, \" +\n                \"fallbacking to another implementation\", err);\n        }\n    }\n    let str = \"\";\n    for (let i = 0; i < bytes.length; i += 2) {\n        str += String.fromCharCode((bytes[i] << 8) + bytes[i + 1]);\n    }\n    return str;\n}\n/**\n * Convert a string to an Uint8Array containing the corresponding UTF-8 code\n * units.\n * @param {string} str\n * @returns {Uint8Array}\n */\nfunction strToUtf8(str) {\n    if (hasTextEncoder) {\n        try {\n            const encoder = new TextEncoder();\n            return encoder.encode(str);\n        }\n        catch (e) {\n            const err = e instanceof Error ? e : \"\";\n            log.warn(\"Utils: could not use TextEncoder to encode string into UTF-8, \" +\n                \"fallbacking to another implementation\", err);\n        }\n    }\n    // http://stackoverflow.com/a/13691499 provides an ugly but functional solution.\n    // (Note you have to dig deeper to understand it but I have more faith in\n    // stackoverflow not going down in the future so I leave that link.)\n    // Briefly said, `utf8Str` will contain a version of `str` where every\n    // non-ASCII characters will be replaced by an escape sequence of the\n    // corresponding representation of those characters in UTF-8.\n    // It does sound weird and unnecessarily complicated, but it works!\n    //\n    // Here is actually what happens with more words. We will rely on two browser\n    // APIs:\n    //\n    //   - `encodeURIComponent` will take a string and convert the non-ASCII\n    //     characters in it into the percent-encoded version of the corresponding\n    //     UTF-8 bytes\n    //     Example: encodeURIComponent(\"\") => 0xC3 0xA9 => `\"%C3%A9\"`\n    //\n    //   - `unescape` unescapes (so far so good) a percent-encoded string. But it\n    //     does it in a really simple way: percent-encoded byte by percent-encoded\n    //     byte into the corresponding extended ASCII representation on 8 bits.\n    //     As a result, we end-up with a string which actually contains instead of\n    //     each of its original characters, the UTF-8 code units (8 bits) of\n    //     those characters.\n    //     Let's take our previous `\"\" => \"%C3%A9\"` example. Here we would get:\n    //     unecape(\"%C3%A9\") => \"\\u00c3\\u00a9\" === \"\" (in extended ASCII)\n    //\n    // By iterating on the resulting string, we will then be able to generate a\n    // Uint8Array containing the UTF-8 representation of that original string, by\n    // just calling the charCodeAt API on it.\n    let utf8Str;\n    const pcStr = encodeURIComponent(str);\n    // As \"unescape\" is a deprecated function we want to declare a fallback in the\n    // case a browser decide to not implement it.\n    if (typeof unescape === \"function\") {\n        utf8Str = unescape(pcStr);\n    }\n    else {\n        // Let's implement a simple unescape function (got to admit it was for the challenge)\n        // http://ecma-international.org/ecma-262/9.0/#sec-unescape-string\n        const isHexChar = /[0-9a-fA-F]/;\n        const pcStrLen = pcStr.length;\n        utf8Str = \"\";\n        for (let i = 0; i < pcStr.length; i++) {\n            let wasPercentEncoded = false;\n            if (pcStr[i] === \"%\") {\n                if (i <= pcStrLen - 6 &&\n                    pcStr[i + 1] === \"u\" &&\n                    isHexChar.test(pcStr[i + 2]) &&\n                    isHexChar.test(pcStr[i + 3]) &&\n                    isHexChar.test(pcStr[i + 4]) &&\n                    isHexChar.test(pcStr[i + 5])) {\n                    const charCode = parseInt(pcStr.substring(i + 1, i + 6), 16);\n                    utf8Str += String.fromCharCode(charCode);\n                    wasPercentEncoded = true;\n                    i += 5; // Skip the next 5 chars\n                }\n                else if (i <= pcStrLen - 3 &&\n                    isHexChar.test(pcStr[i + 1]) &&\n                    isHexChar.test(pcStr[i + 2])) {\n                    const charCode = parseInt(pcStr.substring(i + 1, i + 3), 16);\n                    utf8Str += String.fromCharCode(charCode);\n                    wasPercentEncoded = true;\n                    i += 2; // Skip the next 2 chars\n                }\n            }\n            if (!wasPercentEncoded) {\n                utf8Str += pcStr[i];\n            }\n        }\n    }\n    // Now let's just build our array from every other bytes of that string's\n    // UTF-16 representation\n    const res = new Uint8Array(utf8Str.length);\n    for (let i = 0; i < utf8Str.length; i++) {\n        res[i] = utf8Str.charCodeAt(i) & 0xff; // first byte should be 0x00 anyway\n    }\n    return res;\n}\n/**\n * Creates a new string from the given array of char codes.\n * @param {Uint8Array} args\n * @returns {string}\n */\nfunction stringFromCharCodes(args) {\n    const max = 16000;\n    let ret = \"\";\n    for (let i = 0; i < args.length; i += max) {\n        const subArray = args.subarray(i, i + max);\n        // NOTE: ugly I know, but TS is problematic here (you can try)\n        ret += String.fromCharCode.apply(null, subArray);\n    }\n    return ret;\n}\n/**\n * Transform an integer into an hexadecimal string of the given length, padded\n * to the left with `0` if needed.\n * @example\n * ```\n * intToHex(5, 4); // => \"0005\"\n * intToHex(5, 2); // => \"05\"\n * intToHex(10, 1); // => \"a\"\n * intToHex(268, 3); // => \"10c\"\n * intToHex(4584, 6) // => \"0011e8\"\n * intToHex(123456, 4); // => \"1e240\" (we do nothing when going over 4 chars)\n * ```\n * @param {number} num\n * @param {number} size\n * @returns {string}\n */\nfunction intToHex(num, size) {\n    const toStr = num.toString(16);\n    return toStr.length >= size\n        ? toStr\n        : new Array(size - toStr.length + 1).join(\"0\") + toStr;\n}\n/**\n * Creates a string from the given Uint8Array containing utf-8 code units.\n * @param {Uint8Array} bytes\n * @returns {string}\n */\nfunction utf8ToStr(data) {\n    if (hasTextDecoder) {\n        try {\n            // TextDecoder use UTF-8 by default\n            const decoder = new TextDecoder();\n            return decoder.decode(data);\n        }\n        catch (e) {\n            const err = e instanceof Error ? e : \"\";\n            log.warn(\"Utils: could not use TextDecoder to parse UTF-8, \" +\n                \"fallbacking to another implementation\", err);\n        }\n    }\n    let uint8 = data;\n    // If present, strip off the UTF-8 BOM.\n    if (uint8[0] === 0xef && uint8[1] === 0xbb && uint8[2] === 0xbf) {\n        uint8 = uint8.subarray(3);\n    }\n    // We're basically doing strToUtf8 in reverse.\n    // You can look at that other function for the whole story.\n    // Generate string containing escaped UTF-8 code units\n    const utf8Str = stringFromCharCodes(uint8);\n    let escaped;\n    if (typeof escape === \"function\") {\n        // Transform UTF-8 escape sequence into percent-encoded escape sequences.\n        escaped = escape(utf8Str);\n    }\n    else {\n        // Let's implement a simple escape function\n        // http://ecma-international.org/ecma-262/9.0/#sec-escape-string\n        const nonEscapedChar = /[A-Za-z0-9*_+-./]/;\n        escaped = \"\";\n        for (let i = 0; i < utf8Str.length; i++) {\n            if (nonEscapedChar.test(utf8Str[i])) {\n                escaped += utf8Str[i];\n            }\n            else {\n                const charCode = utf8Str.charCodeAt(i);\n                escaped +=\n                    charCode >= 256 ? \"%u\" + intToHex(charCode, 4) : \"%\" + intToHex(charCode, 2);\n            }\n        }\n    }\n    // Decode the percent-encoded UTF-8 string into the proper JS string.\n    // Example: \"g#%E3%82%AC\" -> \"g#\"\n    return decodeURIComponent(escaped);\n}\n/**\n * Convert hex codes in a string form into the corresponding bytes.\n * @param {string} str\n * @returns {Uint8Array}\n * @throws TypeError - str.length is odd\n */\nfunction hexToBytes(str) {\n    const len = str.length;\n    const arr = new Uint8Array(len / 2);\n    for (let i = 0, j = 0; i < len; i += 2, j++) {\n        arr[j] = parseInt(str.substring(i, i + 2), 16) & 0xff;\n    }\n    return arr;\n}\n/**\n * Convert bytes into the corresponding hex string, with the possibility\n * to add a separator.\n * @param {Uint8Array} bytes\n * @param {string} [sep=\"\"] - separator. Separate each two hex character.\n * @returns {string}\n */\nfunction bytesToHex(bytes, sep = \"\") {\n    let hex = \"\";\n    for (let i = 0; i < bytes.byteLength; i++) {\n        hex += (bytes[i] >>> 4).toString(16);\n        hex += (bytes[i] & 0xf).toString(16);\n        if (sep.length > 0 && i < bytes.byteLength - 1) {\n            hex += sep;\n        }\n    }\n    return hex;\n}\n/**\n * Convert little-endian GUID into big-endian UUID.\n * @param {Uint8Array} guid\n * @returns {Uint8Array} - uuid\n * @throws AssertionError - The guid length is not 16\n */\nfunction guidToUuid(guid) {\n    assert(guid.length === 16, \"GUID length should be 16\");\n    const p1A = guid[0];\n    const p1B = guid[1];\n    const p1C = guid[2];\n    const p1D = guid[3];\n    const p2A = guid[4];\n    const p2B = guid[5];\n    const p3A = guid[6];\n    const p3B = guid[7];\n    const uuid = new Uint8Array(16);\n    // swapping byte endian on 4 bytes\n    // [1, 2, 3, 4] => [4, 3, 2, 1]\n    uuid[0] = p1D;\n    uuid[1] = p1C;\n    uuid[2] = p1B;\n    uuid[3] = p1A;\n    // swapping byte endian on 2 bytes\n    // [5, 6] => [6, 5]\n    uuid[4] = p2B;\n    uuid[5] = p2A;\n    // swapping byte endian on 2 bytes\n    // [7, 8] => [8, 7]\n    uuid[6] = p3B;\n    uuid[7] = p3A;\n    uuid.set(guid.subarray(8, 16), 8);\n    return uuid;\n}\n/**\n * Decode string from bytes (UTF-8).\n * Keeps reading until it reaches a byte that equals to zero.\n * @param {Uint8Array} buffer\n * @param {number} offset\n * @returns {Object}\n */\nfunction readNullTerminatedString(buffer, offset) {\n    let position = offset;\n    while (position < buffer.length) {\n        const value = buffer[position];\n        if (value === 0) {\n            break;\n        }\n        position += 1;\n    }\n    const bytes = buffer.subarray(offset, position);\n    return { end: position + 1, string: utf8ToStr(bytes) };\n}\nexport { bytesToHex, hexToBytes, strToUtf8, utf8ToStr, strToUtf16LE, utf16LEToStr, strToBeUtf16, beUtf16ToStr, guidToUuid, readNullTerminatedString, };\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport noop from \"./noop\";\nconst SyncOrAsync = {\n    /**\n     * Create the synchronous variant of an `ISyncOrAsyncValue`.\n     * @param {*} val\n     * @returns {Object}\n     */\n    createSync(val) {\n        return {\n            syncValue: val,\n            getValueAsAsync() {\n                return Promise.resolve(val);\n            },\n        };\n    },\n    /**\n     * Create the asynchronous variant of an `ISyncOrAsyncValue`.\n     * @param {Promise} val\n     * @returns {Object}\n     */\n    createAsync(val) {\n        let ret = null;\n        val.then((resolved) => {\n            ret = resolved;\n        }, noop);\n        return {\n            get syncValue() {\n                return ret;\n            },\n            getValueAsAsync() {\n                return val;\n            },\n        };\n    },\n};\nexport default SyncOrAsync;\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport log from \"../log\";\nimport assert from \"./assert\";\nimport noop from \"./noop\";\n/**\n * Class facilitating asynchronous task cancellation.\n *\n * This class can be used to notify some code running an asynchronous task (for\n * example, a request) that is should abort what it is doing (for example, abort\n * a request when it isn't needed anymore).\n *\n * To do that, the code which might ask for cancellation have to create a new\n * `TaskCanceller`:\n * ```js\n * const canceller = new TaskCanceller();\n * ```\n *\n * And has to provide its associated `CancellationSignal` to the code running\n * the asynchronous task:\n * ```js\n * runAsyncTask(canceller.signal);\n * ```\n *\n * In the asynchronous task, the signal can be listened to (see documentation\n * on `CancellationSignal` for more information):\n * ```js\n * function runAsyncTask(cancellationSignal) {\n *  // Let's say this function returns a Promise (this is not mandatory however)\n *  return Promise((resolve, reject) => {\n *    // In this example, we'll even catch the case where an asynchronous task\n *    // was already cancelled before being called.\n *    // This ensure that no code will run if that's the case.\n *    if (cancellationSignal.isCancelled) {\n *      // Here we're rejecting the CancellationError to notify the caller that\n *      // this error was due to the task being aborted.\n *      reject(cancellationSignal.cancellationError);\n *      return;\n *    }\n *\n *    // Example:\n *    // performing asynchronous task and registering callbacks on success/failure.\n *    const myCancellableTask = doSomeAsyncTasks()\n *      .onFinished(onTaskFinished);\n *      .onFailed(onTaskFailed);\n *\n *    // Run a callback when/if the corresponding `TaskCanceller` was triggered.\n *    // Run immediately if the TaskCanceller was already triggered.\n *    const deregisterSignal = cancellationSignal.register(onCancellation);\n *\n *    // Callback called on cancellation (if this task was cancelled while the\n *    // cancellationSignal's listener is still registered).\n *    // The `error` in argument is linked to that cancellation. It is usually\n *    // expected that the same Error instance is used when rejecting Promises.\n *    function onCancellation(error : CancellationError) {\n *      // abort asynchronous task\n *      myCancellableTask.cancel();\n *\n *      // In this example, reject the current pending Promise\n *      reject(CancellationError);\n *    }\n *\n *    // Callback called after the asynchronous task has finished with success.\n *    function onTaskFinished() {\n *      // Stop listening to the cancellationSignal\n *      deregisterSignal();\n *\n *      // Resolve the Promise\n *      resolve();\n *    }\n *\n *    // Callback called after the asynchronous task has finished with failure.\n *    function onTaskFailed(someError : Error) {\n *      // Stop listening to the cancellationSignal\n *      deregisterSignal();\n *\n *      // Resolve the Promise\n *      reject(error);\n *    }\n *  });\n * }\n * ```\n *\n * The code asking for cancellation can then trigger a cancellation at any time\n * (even before the signal was given) and listen to possible CancellationErrors\n * to know when it was cancelled.\n * ```js\n * const canceller = new TaskCanceller();\n *\n * runAsyncTask(canceller.signal)\n *   .then(() => { console.log(\"Task succeeded!\"); )\n *   .catch((err) => {\n *      if (TaskCanceller.isCancellationError(err)) {\n *        console.log(\"Task cancelled!\");\n *      } else {\n *        console.log(\"Task failed:\", err);\n *      }\n *   });\n * canceller.cancel(); // Cancel the task, calling registered callbacks\n * ```\n * @class TaskCanceller\n */\nexport default class TaskCanceller {\n    /**\n     * Creates a new `TaskCanceller`, with its own `CancellationSignal` created\n     * as its `signal` provide.\n     * You can then pass this property to async task you wish to be cancellable.\n     */\n    constructor() {\n        const [trigger, register] = createCancellationFunctions();\n        this._isUsed = false;\n        this._trigger = trigger;\n        this.signal = new CancellationSignal(register);\n    }\n    /**\n     * Returns `true` if this `TaskCanceller` has already been triggered.\n     * `false` otherwise.\n     */\n    isUsed() {\n        return this._isUsed;\n    }\n    /**\n     * Bind this `TaskCanceller` to a `CancellationSignal`, so the former\n     * is automatically cancelled when the latter is triggered.\n     *\n     * Note that this call registers a callback on the given signal, until either\n     * the current `TaskCanceller` is cancelled or until this given\n     * `CancellationSignal` is triggered.\n     * To avoid leaking memory, the returned callback allow to undo this link.\n     * It should be called if/when that link is not needed anymore, such as when\n     * there is no need for this `TaskCanceller` anymore.\n     *\n     * @param {Object} signal\n     * @returns {Function}\n     */\n    linkToSignal(signal) {\n        const unregister = signal.register(() => {\n            this.cancel();\n        });\n        this.signal.register(unregister);\n        return unregister;\n    }\n    /**\n     * \"Trigger\" the `TaskCanceller`, notify through its associated\n     * `CancellationSignal` (its `signal` property) that a task should be aborted.\n     *\n     * Once called the `TaskCanceller` is permanently triggered.\n     *\n     * An optional CancellationError can be given in argument for when this\n     * cancellation is actually triggered as a chain reaction from a previous\n     * cancellation.\n     * @param {Error} [srcError]\n     */\n    cancel(srcError) {\n        if (this._isUsed) {\n            return;\n        }\n        this._isUsed = true;\n        const cancellationError = srcError !== null && srcError !== void 0 ? srcError : new CancellationError();\n        this._trigger(cancellationError);\n    }\n    /**\n     * Check that the `error` in argument is a `CancellationError`, most likely\n     * meaning that the linked error is due to a task aborted via a\n     * `CancellationSignal`.\n     * @param {*} error\n     * @returns {boolean}\n     */\n    static isCancellationError(error) {\n        return error instanceof CancellationError;\n    }\n}\n/**\n * Signal allowing to be notified when the linked task needs to be aborted.\n * @class\n */\nexport class CancellationSignal {\n    /**\n     * Creates a new CancellationSignal.\n     * /!\\ Note: Only a `TaskCanceller` is supposed to be able to create one.\n     * @param {Function} registerToSource - Function called when the task is\n     * cancelled.\n     */\n    constructor(registerToSource) {\n        this._isCancelled = false;\n        this.cancellationError = null;\n        this._listeners = [];\n        registerToSource((cancellationError) => {\n            this.cancellationError = cancellationError;\n            this._isCancelled = true;\n            while (this._listeners.length > 0) {\n                try {\n                    const listener = this._listeners.pop();\n                    listener === null || listener === void 0 ? void 0 : listener(cancellationError);\n                }\n                catch (err) {\n                    log.error(\"Error while calling clean up listener\", err instanceof Error ? err.toString() : \"Unknown error\");\n                }\n            }\n        });\n    }\n    /**\n     * Returns `true` when the cancellation order was already triggered, meaning\n     * that the linked task needs to be aborted.\n     * @returns boolean\n     */\n    isCancelled() {\n        return this._isCancelled;\n    }\n    /**\n     * Registers a function that will be called when/if the current task is\n     * cancelled.\n     *\n     * Multiple calls to `register` can be performed to register multiple\n     * callbacks on cancellation associated to the same `CancellationSignal`.\n     *\n     * @param {Function} fn - This function should perform all logic allowing to\n     * abort everything the task is doing.\n     *\n     * It takes in argument the `CancellationError` which was created when the\n     * task was aborted.\n     * You can use this error to notify callers that the task has been aborted,\n     * for example through a rejected Promise.\n     *\n     * @return {Function} - Removes that cancellation listener. You can call this\n     * once you don't want the callback to be triggered anymore (e.g. after the\n     * task succeeded or failed).\n     * You don't need to call that function when cancellation has already been\n     * performed.\n     */\n    register(fn) {\n        if (this._isCancelled) {\n            assert(this.cancellationError !== null);\n            fn(this.cancellationError);\n            return noop;\n        }\n        this._listeners.push(fn);\n        return () => this.deregister(fn);\n    }\n    /**\n     * De-register a function registered through the `register` function.\n     * Do nothing if that function wasn't registered.\n     *\n     * You can call this method when using the return value of `register` is not\n     * practical.\n     * @param {Function} fn\n     */\n    deregister(fn) {\n        for (let i = this._listeners.length - 1; i >= 0; i--) {\n            if (this._listeners[i] === fn) {\n                this._listeners.splice(i, 1);\n            }\n        }\n    }\n}\n/**\n * Error created when a task is cancelled.\n * @class CancellationError\n * @extends Error\n */\nexport class CancellationError extends Error {\n    constructor() {\n        const message = \"This task was cancelled.\";\n        super(message);\n        // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class\n        Object.setPrototypeOf(this, CancellationError.prototype);\n        this.name = \"CancellationError\";\n    }\n}\n/**\n * Helper function allowing communication between a `TaskCanceller` and a\n * `CancellationSignal`.\n * @returns {Array.<Function>}\n */\nfunction createCancellationFunctions() {\n    let listener = noop;\n    return [\n        function trigger(error) {\n            listener(error);\n        },\n        function register(newListener) {\n            listener = newListener;\n        },\n    ];\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport isNonEmptyString from \"./is_non_empty_string\";\nimport startsWith from \"./starts_with\";\n// Scheme part of an url (e.g. \"http://\").\nconst schemeRe = /^(?:[a-z]+:)?\\/\\//i;\n/**\n * Match the different components of an URL.\n *\n *     foo://example.com:8042/over/there?name=ferret#nose\n       \\_/   \\______________/\\_________/ \\_________/ \\__/\n        |           |            |            |        |\n      scheme     authority       path        query   fragment\n * 1st match is the scheme: (e.g. \"foo://\")\n * 2nd match is the authority (e.g \"example.com:8042\")\n * 3rd match is the path (e.g \"/over/there\")\n * 4th match is the query params (e.g \"name=ferret\")\n * 5th match is the fragment (e.g \"nose\")\n * */\nconst urlComponentRegex = /^(?:([^:/?#]+):)?(?:\\/\\/([^/?#]*))?([^?#]*)(?:\\?([^#]*))?(?:#(.*))?$/;\n/**\n * In a given URL, find the index at which the filename begins.\n * That is, this function finds the index of the last `/` character and returns\n * the index after it, returning the length of the whole URL if no `/` was found\n * after the scheme (i.e. in `http://`, the slashes are not considered).\n * @param {string} url\n * @returns {number}\n */\nfunction getFilenameIndexInUrl(url) {\n    const indexOfLastSlash = url.lastIndexOf(\"/\");\n    if (indexOfLastSlash < 0) {\n        return url.length;\n    }\n    if (schemeRe.test(url)) {\n        const firstSlashIndex = url.indexOf(\"/\");\n        if (firstSlashIndex >= 0 && indexOfLastSlash === firstSlashIndex + 1) {\n            // The \"/\" detected is actually the one from the protocol part of the URL\n            // (\"https://\")\n            return url.length;\n        }\n    }\n    const indexOfQuestionMark = url.indexOf(\"?\");\n    if (indexOfQuestionMark >= 0 && indexOfQuestionMark < indexOfLastSlash) {\n        // There are query parameters. Let's ignore them and re-run the logic\n        // without\n        return getFilenameIndexInUrl(url.substring(0, indexOfQuestionMark));\n    }\n    return indexOfLastSlash + 1;\n}\n/**\n * Take two URLs and try to construct a relative URL for the second (`newUrl`)\n * relative to the first (`baseUrl`).\n *\n * Returns `null` if they appear to be on different domains, depend on\n * different schemes or if we don't have enough information to compute the\n * relative URL.\n * @param {string} baseUrl\n * @param {string} newUrl\n * @returns {string}\n */\nfunction getRelativeUrl(baseUrl, newUrl) {\n    const baseParts = parseURL(baseUrl);\n    const newParts = parseURL(newUrl);\n    if (baseParts.scheme !== newParts.scheme ||\n        baseParts.authority !== newParts.authority) {\n        return null;\n    }\n    if (\n    // if base and new path are mixed between absolute and relative path, return null\n    (baseParts.path[0] !== undefined &&\n        baseParts.path[0] !== \"/\" &&\n        newParts.path[0] === \"/\") ||\n        (newParts.path[0] !== undefined &&\n            newParts.path[0] !== \"/\" &&\n            baseParts.path[0] === \"/\")) {\n        return null;\n    }\n    const baseNormalizedPath = removeDotSegment(baseParts.path);\n    const newNormalizedPath = removeDotSegment(newParts.path);\n    let relativePath;\n    if (baseNormalizedPath === newNormalizedPath) {\n        relativePath = \"\";\n    }\n    else {\n        const basePathSplitted = baseNormalizedPath.split(\"/\");\n        // remove everything after the last trailing /\n        basePathSplitted.pop();\n        const newPathSplitted = newNormalizedPath.split(\"/\");\n        while (basePathSplitted.length > 0 &&\n            newPathSplitted.length > 0 &&\n            basePathSplitted[0] === newPathSplitted[0]) {\n            basePathSplitted.shift();\n            newPathSplitted.shift();\n        }\n        while (basePathSplitted.length > 0) {\n            basePathSplitted.shift();\n            newPathSplitted.unshift(\"..\");\n        }\n        let pathJoined = newPathSplitted.join(\"/\");\n        if (pathJoined.endsWith(\"../\") || pathJoined.endsWith(\"./\")) {\n            pathJoined = pathJoined.slice(0, pathJoined.length - 1);\n        }\n        relativePath = pathJoined === \"\" ? \".\" : pathJoined;\n    }\n    let result = relativePath;\n    if (relativePath === \"\" && newParts.query === baseParts.query) {\n        // path and query is the same, we don't need to rewrite it\n    }\n    else if (isNonEmptyString(newParts.query)) {\n        result += \"?\";\n        result += newParts.query;\n    }\n    if (isNonEmptyString(newParts.fragment)) {\n        result += \"#\";\n        result += newParts.fragment;\n    }\n    return result;\n}\n/**\n * Resolve the output URL from the baseURL and the relative reference as\n * specified by RFC 3986 section 5.\n * @param base\n * @param relative\n * @see https://datatracker.ietf.org/doc/html/rfc3986#section-5\n * @example base: http://example.com | relative: /b/c | output: http://example.com/b/c\n * @returns the resolved url\n */\nfunction _resolveURL(base, relative) {\n    const baseParts = parseURL(base);\n    const relativeParts = parseURL(relative);\n    if (isNonEmptyString(relativeParts.scheme)) {\n        return formatURL(relativeParts);\n    }\n    const target = {\n        scheme: baseParts.scheme,\n        authority: baseParts.authority,\n        path: \"\",\n        query: relativeParts.query,\n        fragment: relativeParts.fragment,\n    };\n    if (isNonEmptyString(relativeParts.authority)) {\n        target.authority = relativeParts.authority;\n        target.path = removeDotSegment(relativeParts.path);\n        return formatURL(target);\n    }\n    if (relativeParts.path === \"\") {\n        target.path = baseParts.path;\n        if (!isNonEmptyString(relativeParts.query)) {\n            target.query = baseParts.query;\n        }\n    }\n    else {\n        if (startsWith(relativeParts.path, \"/\")) {\n            // path is absolute\n            target.path = removeDotSegment(relativeParts.path);\n        }\n        else {\n            // path is relative\n            target.path = removeDotSegment(mergePaths(baseParts, relativeParts.path));\n        }\n    }\n    return formatURL(target);\n}\n/**\n * Cache to store already parsed URLs to avoid unnecessary computation when parsing the same URL again.\n */\nconst parsedUrlCache = new Map();\n/**\n * Sets the maximum number of entries allowed in the parsedUrlCache map.\n * This limit helps prevent excessive memory usage. The value is arbitrary.\n */\nconst MAX_URL_CACHE_ENTRIES = 200;\n/**\n * Parses a URL into its components.\n * @param {string} url - The URL to parse.\n * @returns {IParsedURL} The parsed URL components.\n */\nfunction parseURL(url) {\n    var _a, _b, _c, _d, _e;\n    if (parsedUrlCache.has(url)) {\n        return parsedUrlCache.get(url);\n    }\n    const matches = url.match(urlComponentRegex);\n    let parsed;\n    if (matches === null) {\n        parsed = {\n            scheme: \"\",\n            authority: \"\",\n            path: \"\",\n            query: \"\",\n            fragment: \"\",\n        };\n    }\n    else {\n        parsed = {\n            scheme: (_a = matches[1]) !== null && _a !== void 0 ? _a : \"\",\n            authority: (_b = matches[2]) !== null && _b !== void 0 ? _b : \"\",\n            path: (_c = matches[3]) !== null && _c !== void 0 ? _c : \"\",\n            query: (_d = matches[4]) !== null && _d !== void 0 ? _d : \"\",\n            fragment: (_e = matches[5]) !== null && _e !== void 0 ? _e : \"\",\n        };\n    }\n    if (parsedUrlCache.size >= MAX_URL_CACHE_ENTRIES) {\n        parsedUrlCache.clear();\n    }\n    parsedUrlCache.set(url, parsed);\n    return parsed;\n}\n/**\n * Formats a parsed URL into a string.\n * @param {IParsedURL} parts - The parsed URL components.\n * @returns {string} The formatted URL string.\n */\nfunction formatURL(parts) {\n    let url = \"\";\n    if (isNonEmptyString(parts.scheme)) {\n        url += parts.scheme + \":\";\n    }\n    if (isNonEmptyString(parts.authority)) {\n        url += \"//\" + parts.authority;\n    }\n    url += parts.path;\n    if (isNonEmptyString(parts.query)) {\n        url += \"?\" + parts.query;\n    }\n    if (isNonEmptyString(parts.fragment)) {\n        url += \"#\" + parts.fragment;\n    }\n    return url;\n}\n/**\n * Removes \".\" and \"..\" from the URL path, as described by the algorithm\n * in RFC 3986 Section 5.2.4. Remove Dot Segments\n * @param {string} path - The URL path\n * @see https://datatracker.ietf.org/doc/html/rfc3986#section-5.2.4\n * @returns The path with dot segments removed.\n * @example \"/baz/booz/../biz\" => \"/baz/biz\"\n */\nfunction removeDotSegment(path) {\n    const segments = path.split(/(?=\\/)/);\n    const output = [];\n    for (let i = 0; i < segments.length; i++) {\n        const segment = segments[i];\n        if (segment === \"..\" || segment === \".\" || segment === \"\") {\n            continue;\n        }\n        if (segment === \"/..\") {\n            output.pop();\n            // if it's last segment push a trailing \"/\"\n            if (i === segments.length - 1) {\n                output.push(\"/\");\n            }\n            continue;\n        }\n        if (segment === \"/.\") {\n            // if it's last segment push a trailing \"/\"\n            if (i === segments.length - 1) {\n                output.push(\"/\");\n            }\n            continue;\n        }\n        output.push(segment);\n    }\n    return output.join(\"\");\n}\n/**\n * Merges a base URL path with a relative URL path, as described by\n * the algorithm merge paths in RFC 3986 Section 5.2.3. Merge Paths\n * @param {IParsedURL} baseParts - The parsed base URL components.\n * @param {string} relativePath - The relative URL path.\n * @returns {string} The merged URL path.\n * @see https://datatracker.ietf.org/doc/html/rfc3986#section-5.2.3\n */\nfunction mergePaths(baseParts, relativePath) {\n    if (isNonEmptyString(baseParts.authority) && baseParts.path === \"\") {\n        return \"/\" + relativePath;\n    }\n    const basePath = baseParts.path;\n    return basePath.substring(0, basePath.lastIndexOf(\"/\") + 1) + relativePath;\n}\n/**\n * Resolves multiple URL segments using the RFC 3986 URL resolution algorithm.\n *\n * This function takes a variable number of URL segments and resolves them\n * sequentially according to the RFC 3986 URL resolution algorithm.\n * First argument is the base URL.\n * Empty string arguments are ignored.\n *\n * @param {...(string|undefined)} args - The URL segments to resolve.\n * @returns {string} The resolved URL as a string.\n */\nfunction resolveURL(...args) {\n    var _a, _b, _c;\n    const filteredArgs = args.filter((val) => val !== \"\");\n    const len = filteredArgs.length;\n    if (len === 0) {\n        return \"\";\n    }\n    if (len === 1) {\n        return (_a = filteredArgs[0]) !== null && _a !== void 0 ? _a : \"\";\n    }\n    else {\n        const basePart = (_b = filteredArgs[0]) !== null && _b !== void 0 ? _b : \"\";\n        const relativeParts = (_c = filteredArgs[1]) !== null && _c !== void 0 ? _c : \"\";\n        const resolvedURL = _resolveURL(basePart, relativeParts);\n        const remainingArgs = filteredArgs.slice(2);\n        return resolveURL(resolvedURL, ...remainingArgs);\n    }\n}\nexport { getFilenameIndexInUrl, getRelativeUrl, resolveURL };\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport arrayIncludes from \"./array_includes\";\nconst WARNED_MESSAGES = [];\n/**\n * Perform a console.warn only once in the application lifetime.\n *\n * Useful for deprecated messages, for example.\n *\n * @param {string} message\n */\nexport default function warnOnce(message) {\n    if (!arrayIncludes(WARNED_MESSAGES, message)) {\n        // eslint-disable-next-line no-console\n        console.warn(message);\n        WARNED_MESSAGES.push(message);\n    }\n}\n","/**\n * Copyright 2015 CANAL+ Group\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Memoize Function results linked to an object, through a WeakMap.\n *\n * @example\n * ```js\n * // Initialize the WeakMapMemory with its logic:\n * const memory = new WeakMapMemory(arg => {\n *   console.log(\"side-effect\");\n *   return [arg.a, arg.b];\n * });\n *\n * const obj = { a: 1, b: 2 };\n *\n * // first time obj is given: call the function, save the result and return it:\n * const arr1 = memory.get(obj);\n * // >  \"side-effect\"\n * // <- [1, 2]\n *\n * // nth time obj is given, returns the saved result without calling the\n * // function:\n * const arr2 = memory.get(obj);\n * // <- [1, 2]\n *\n * // both of these use the same object, so the result is also the exact same\n * // one\n * console.log(arr1 === arr2); // => true\n *\n * // /!\\ with a new object however:\n * const obj2 = { a: 1, b: 2 };\n *\n * const arr3 = memory.get(obj2);\n * // >  \"side-effect\"\n * // <- [1, 2]\n *\n * console.log(arr1 === arr3); // => false\n * ```\n * @class WeakMapMemory\n */\nexport default class WeakMapMemory {\n    /**\n     * @param {Function}\n     */\n    constructor(fn) {\n        this._weakMap = new WeakMap();\n        this._fn = fn;\n    }\n    /**\n     * @param {Object} obj\n     * @returns {*}\n     */\n    get(obj) {\n        const fromMemory = this._weakMap.get(obj);\n        if (fromMemory === undefined) {\n            const newElement = this._fn(obj);\n            this._weakMap.set(obj, newElement);\n            return newElement;\n        }\n        else {\n            return fromMemory;\n        }\n    }\n    /**\n     * @param {Object} obj\n     */\n    destroy(obj) {\n        this._weakMap.delete(obj);\n    }\n}\n","/**\n * Force function output to be wrapped in a Promise instance, which also rejects\n * if the function call threw.\n * @param {Function} val\n * @returns {Promise}\n */\nexport default function wrapInPromise(val) {\n    try {\n        const ret = val();\n        if (typeof ret === \"object\" &&\n            ret !== null &&\n            typeof ret.then === \"function\") {\n            return ret;\n        }\n        else {\n            return Promise.resolve(ret);\n        }\n    }\n    catch (err) {\n        return Promise.reject(err);\n    }\n}\n","export default {\r\n    PLAYER_VERSION: 'player-version',\r\n    uiButton: {\r\n        RESTART: 'restart',\r\n        REWIND: 'rewind',\r\n        PLAYPAUSE: 'play-pause',\r\n        FARWARD: 'fast-forward',\r\n        STOP: 'stop'\r\n    },\r\n    videoPos: {\r\n        PROGRESSBAR: 'progress',\r\n        CURRENTTIME: '.current-time',\r\n        DURATION: '.end-time'\r\n    },\r\n    uiVolumn: {\r\n        PROGRESSBAR: 'volume',\r\n        VOLUMN: 'mute'\r\n    },\r\n    quality: {\r\n        PLAYBACKSPEED: 'playback-speed',\r\n        SUBTITLE_TRACKS: 'subtitle-list',\r\n        VIDEO_TRACKS: 'video-list',\r\n        AUDIO_TRACKS: 'audio-list',\r\n        VIDEO_QUALITY_LIST: 'video-resolution-quality',\r\n        AUDIO_QUALITY_LIST: 'audio-resolution-quality',\r\n    },\r\n    LOG_LEVEL: \"debug\"\r\n}","const appEvents = {\r\n  // Basic events\r\n  CURRENT_STATE: \"playerState\",\r\n  ERROR: \"error\",\r\n  WARNING: \"warning\",\r\n  POSITION_UPDATE: \"playerCurrentPosition\",\r\n\r\n  // Track selection events\r\n  AUDIO_TRACKLIST: \"audioList\",\r\n  VIDEO_TRACKLIST: \"videoList\",\r\n  SUBTITLE_TRACKS: \"subtitleList\",\r\n};\r\n\r\nexport default appEvents;\r\n","const appState = {\r\n    LOADING: 'LOADING',\r\n    LOADED: 'LOADED',\r\n    PLAYING: 'PLAYING',\r\n    PAUSED: 'PAUSED',\r\n    BUFFERING: \"BUFFERING\",\r\n    SEEKING: 'SEEKING',\r\n    STOPPED: 'STOPPED',\r\n}\r\n\r\nexport default appState;","import OTTMediaPlayer from './rxplayer/player';\r\n\r\nexport { OTTMediaPlayer };\r\n\r\n","// https://developers.canal-plus.com/rx-player/versions/4.3.0/doc/api/Player_Errors.html\r\n\r\nconst playerErrorType = {\r\n    NETWORK_ERROR: \"NETWORK_ERROR\",\r\n    MEDIA_ERROR: \"MEDIA_ERROR\",\r\n    ENCRYPTED_MEDIA_ERROR: \"ENCRYPTED_MEDIA_ERROR\",\r\n    OTHER_ERROR: \"OTHER_ERROR\"\r\n};\r\n\r\nconst ErrorCodeType = {\r\n    NETWORK_ERR_TYPE: \"PIPELINE_LOAD_ERROR\",\r\n\r\n    MEDIA_ERR_TYPE: \"BUFFER_APPEND_ERROR\"\r\n                | \"BUFFER_FULL_ERROR\"\r\n                | \"BUFFER_TYPE_UNKNOWN\"\r\n                | \"MANIFEST_INCOMPATIBLE_CODECS_ERROR\"\r\n                | \"MANIFEST_PARSE_ERROR\"\r\n                | \"MANIFEST_UPDATE_ERROR\"\r\n                | \"MANIFEST_UNSUPPORTED_ADAPTATION_TYPE\"\r\n                | \"MEDIA_ERR_ABORTED\"\r\n                | \"MEDIA_ERR_BLOCKED_AUTOPLAY\"\r\n                | \"MEDIA_ERR_PLAY_NOT_ALLOWED\"\r\n                | \"MEDIA_ERR_NOT_LOADED_METADATA\"\r\n                | \"MEDIA_ERR_DECODE\"\r\n                | \"MEDIA_ERR_NETWORK\"\r\n                | \"MEDIA_ERR_SRC_NOT_SUPPORTED\"\r\n                | \"MEDIA_ERR_UNKNOWN\"\r\n                | \"MEDIA_KEYS_NOT_SUPPORTED\"\r\n                | \"MEDIA_SOURCE_NOT_SUPPORTED\"\r\n                | \"MEDIA_STARTING_TIME_NOT_FOUND\"\r\n                | \"MEDIA_TIME_BEFORE_MANIFEST\"\r\n                | \"MEDIA_TIME_AFTER_MANIFEST\"\r\n                | \"MEDIA_TIME_NOT_FOUND\"\r\n                | \"NO_PLAYABLE_REPRESENTATION\"\r\n                | \"DISCONTINUITY_ENCOUNTERED\",\r\n\r\n    ENCRYPTED_MEDIA_ERR_TYPE: \"INCOMPATIBLE_KEYSYSTEMS\"\r\n                | \"INVALID_ENCRYPTED_EVENT\"\r\n                | \"INVALID_KEY_SYSTEM\"\r\n                | \"KEY_ERROR\"\r\n                | \"KEY_GENERATE_REQUEST_ERROR\"\r\n                | \"KEY_LOAD_ERROR\"\r\n                | \"KEY_LOAD_TIMEOUT\"\r\n                | \"KEY_STATUS_CHANGE_ERROR\"\r\n                | \"KEY_UPDATE_ERROR\"\r\n                | \"CREATE_MEDIA_KEYS_ERROR\"\r\n                | \"MEDIA_KEYS_ATTACHMENT_ERROR\"\r\n                | \"LICENSE_SERVER_CERTIFICATE_ERROR\"\r\n                | \"MEDIA_IS_ENCRYPTED_ERROR\"\r\n                | \"MULTIPLE_SESSIONS_SAME_INIT_DATA\",\r\n\r\n    OTHER_ERR_TYPE: \"PIPELINE_LOAD_ERROR\"\r\n                | \"PIPELINE_PARSE_ERROR\"\r\n                | \"INTEGRITY_ERROR\"\r\n                | \"NONE\"\r\n};\r\n\r\nexport {playerErrorType, ErrorCodeType};\r\n","// https://developers.canal-plus.com/rx-player/versions/4.3.0/doc/api/Player_Events.html\r\n\r\nconst playerEvents = {\r\n    // Basic events\r\n    PLAYER_STATE_CHANGE: \"playerStateChange\", // Emit the current state of the player, every time it changes\r\n    ERROR: \"error\",  // Triggered when a fatal error happened.\r\n    WARNING: \"warning\", // Triggered each time a minor error happened.\r\n    POSITION_UPDATE: \"positionUpdate\", // Emit information about the current position at most every seconds \r\n    PLAY: \"play\", // Emitted when videoElement is no longer considered paused.\r\n    PAUSE: \"pause\", // Emitted when videoElement is now considered paused.\r\n    SEEKING: \"seeking\", // Emitted when a \"seek\" operation (to \"move\"/\"skip\" to another position) begins\r\n    SEEKED: \"seeked\", // Emitted when a \"seek\" operation (to \"move\"/\"skip\" to another position) on the currently loaded content has finished\r\n\r\n    // Track selection events\r\n    AUDIO_TRACK_LIST: \"availableAudioTracksChange\", // Triggered when the currently available audio tracks might have changed (e.g.: at the beginning of the content, when period changes...) \r\n    VIDEO_TRACK_LIST: \"availableVideoTracksChange\", // Triggered when the currently available video tracks might change (e.g.: at the beginning of the content, when period changes...) \r\n    TEXT_TRACK_LIST: \"availableTextTracksChange\", // Triggered when the currently available text tracks might change (e.g.: at the beginning of the content, when period changes...)\r\n    AUDIO_TRACK_CHANGE: \"audioTrackChange\", // Information about the current audio track, each time it changes for the currently-playing Period\r\n    VIDEO_TRACK_CHANGE: \"videoTrackChange\", // Information about the current video track, each time it changes for the currently-playing Period.\r\n    TEST_TRACK_CHANGE: \"textTrackChange\", // Information about the current text track, each time it changes for the currently-playing Period.\r\n\r\n    // Representation selection events\r\n    VIDEO_FRAME_CHANGE: \"videoRepresentationChange\", // Emitted when the current video Representation being considered by the RxPlayer changes.\r\n    AUDIO_FRAME_CHANGE: \"audioRepresentationChange\", // Emitted when the current audio Representation being considered by the RxPlayer changes.\r\n    REPRESENTATIONLISTUPDATE: \"representationListUpdate\", // Event triggered if the list of available Representation linked to the currently-chosen video, audio or text track for any Period \r\n    BROKENREPRESENTATIONSLOCK: \"brokenRepresentationsLock\", // Fairly rare event triggered if representations locked through Representations selection API such as lockVideoRepresentations or lockAudioRepresentations all became unplayable (most likely linked to encryption reasons), in which case, the RxPlayer \"broke\" that lock, i.e. it decided to remove that lock and play all Representations instead.\r\n\r\n    // Playback information\r\n    PERIODCHANGE: \"periodChange\", // Triggered when the current Period being seen changes.\r\n    PERIOD_LIST: \"newAvailablePeriods\", // This event is triggered when one or multiple new Periods start to be considered by the RxPlayer in the current content.\r\n    TRACKUPDATE: \"trackUpdate\", // Event triggered if a video, audio or text track chosen for any Period is changed by the RxPlayer.\r\n\r\n    // Inband events\r\n    INBANDEVENTS: \"inbandEvents\", // Event triggered when the player encounters inband events in the stream. These events are included in the loaded and parsed chunks, and are often used to carry content metadata.\r\n    STREAMEVENT: \"streamEvent\", // Event triggered when the player enters the time boundaries of a \"stream event\".\r\n    STREAMEVENTSKIP: \"streamEventSkip\", // Event triggered when the player skipped the time boundaries of a \"stream event\" (you can refer to the streamEvent event for a definition of what a \"stream event\" is).\r\n\r\n    // Volume events\r\n    VOLUME_CHANGE: \"volumeChange\" // Notify about a change of audio volume and/or of muted status.\r\n};\r\n\r\nexport default playerEvents;\r\n","// https://developers.canal-plus.com/rx-player/versions/4.3.0/doc/api/Player_States.html\r\n\r\nconst playerState = {\r\n    STOPPED: 'STOPPED',\r\n    LOADING: 'LOADING',\r\n    LOADED: 'LOADED',\r\n    PLAYING: 'PLAYING',\r\n    PAUSED: 'PAUSED',\r\n    BUFFERING: \"BUFFERING\",\r\n    FREEZING: 'FREEZING',\r\n    SEEKING: 'SEEKING',\r\n    ENDED: 'ENDED',\r\n    RELOADING: 'RELOADING',\r\n}\r\n\r\nexport default playerState;","// node_modules/rx-player/src/main_thread/api/public_api.ts\r\nimport RxPlayer from 'rx-player';\r\n\r\nimport playerEvents from './const/playerEvents';\r\nimport playerState from './const/playerStates';\r\nimport { playerErrorType, ErrorCodeType } from './const/playerError';\r\nimport appEvents from '../../const/appEvents';\r\nimport Logger from '../../utils/logger';\r\n\r\nRxPlayer.LogFormat = 'full'; // \"standard\", \"full\"\r\nRxPlayer.LogLevel = 'NONE'; // \"NONE\", \"ERROR\", \"WARNING\", \"INFO\", \"DEBUG\"\r\n\r\nclass RxMediaPlayer {\r\n    constructor(manifestUrl, playerConfig = {}, drmConfig = null) {\r\n        this.tag = `RxPlayer-${RxPlayer.version}`;\r\n        this.logger = new Logger(this.tag);\r\n        this.uiEvents = appEvents || appEvents?.default;\r\n        // Player Config\r\n        this.manifestUrl = manifestUrl;\r\n        this.playerConfig = playerConfig;\r\n        this.drmConfig = drmConfig;\r\n        // Player Info\r\n        this.player = null;\r\n        this.customEvent = new EventTarget();\r\n    }\r\n\r\n    initialize() {\r\n        if (!this.playerConfig.videoElement) {\r\n            throw new Error(\"videoElement must be provided in playerConfig\");\r\n        }\r\n        this.player = new RxPlayer(this.playerConfig);\r\n    }\r\n\r\n    load() {\r\n        if (!this.player) {\r\n            throw new Error(\"Player not initialized. Call initialize() first.\");\r\n        }\r\n        this.bindEvents();\r\n        const loadOptions = {\r\n            url: this.manifestUrl,\r\n            transport: \"dash\",\r\n            autoPlay: true,\r\n        };\r\n        if (this.drmConfig) {\r\n            loadOptions.drmOptions = this.configureDRM(this.drmConfig);\r\n        }\r\n        try {\r\n            const loadResult = this.player.loadVideo(loadOptions);\r\n            if (loadResult && typeof loadResult.catch === 'function') {\r\n                loadResult.catch((error) => {\r\n                    this.logger.error('Error loading video:', error);\r\n                });\r\n            }\r\n        } catch (error) {\r\n            this.logger.error('Error loading video:', error);\r\n        }\r\n    }\r\n\r\n    configureDRM(drmConfig) {\r\n        const drmOptions = {};\r\n\r\n        if (drmConfig.clearkey) {\r\n            // Handle ClearKey DRM\r\n            const clearkeyStr = drmConfig.clearkey;\r\n            const [kid, key] = clearkeyStr.split('=');\r\n            drmOptions.clearkey = {\r\n                fallbackKeyIds: [kid],\r\n                fallbackKeys: [key]\r\n            };\r\n        }\r\n\r\n        if (drmConfig.widevine) {\r\n            // Handle Widevine DRM\r\n            drmOptions.widevine = {\r\n                licenseServerUrl: drmConfig.widevine.licenseServerUrl,\r\n                serverCertificateUrl: drmConfig.widevine.serverCertificateUrl,\r\n                httpRequestHeaders: drmConfig.widevine.httpRequestHeaders || {}\r\n            };\r\n        }\r\n\r\n        if (drmConfig.playready) {\r\n            // Handle PlayReady DRM\r\n            drmOptions.playready = {\r\n                licenseServerUrl: drmConfig.playready.licenseServerUrl,\r\n                httpRequestHeaders: drmConfig.playready.httpRequestHeaders || {}\r\n            };\r\n        }\r\n\r\n        if (drmConfig.fairplay) {\r\n            // Handle FairPlay DRM\r\n            drmOptions.fairplay = {\r\n                licenseServerUrl: drmConfig.fairplay.licenseServerUrl,\r\n                serverCertificateUrl: drmConfig.fairplay.serverCertificateUrl,\r\n                httpRequestHeaders: drmConfig.fairplay.httpRequestHeaders || {}\r\n            };\r\n        }\r\n        // Add other DRM types as needed\r\n        return drmOptions;\r\n    }\r\n\r\n    // Player Events\r\n    handlePlayerStateChange(state) {\r\n        this.logger.warn('Player State: ' + state);\r\n        this.dispatchEvent(new CustomEvent(this.uiEvents.CURRENT_STATE, { detail: state }));\r\n        switch (state) {\r\n            case playerState.LOADING:\r\n                this.logger.debug(\"A new content is currently loading\");\r\n                break;\r\n            case playerState.LOADED:\r\n                this.logger.debug(\"The new content is loaded and ready to be played\");\r\n                break;\r\n            case playerState.PLAYING:\r\n                this.logger.debug(\"The player is currently playing\");\r\n                break;\r\n            case playerState.PAUSED:\r\n                this.logger.debug(\"The player is currently paused\");\r\n                break;\r\n            case playerState.BUFFERING:\r\n                this.logger.debug(\"The player is paused while buffering new data\");\r\n                break;\r\n            case playerState.FREEZING:\r\n                this.logger.debug(\"The player is frozen\");\r\n                break;\r\n            case playerState.SEEKING:\r\n                this.logger.debug(\"The player is still seeking, waiting for new data\");\r\n                break;\r\n            case playerState.STOPPED:\r\n                this.logger.debug(\"No content is/will be playing\");\r\n                break;\r\n            case playerState.ENDED:\r\n                this.logger.debug(\"The player has reached the end of the content.\");\r\n                break;\r\n            case playerState.RELOADING:\r\n                this.logger.debug(\"The player is currently reloading the content\");\r\n                break;\r\n            default:\r\n                this.logger.debug(\"Unknown state:\", state);\r\n                break;\r\n        }\r\n    }\r\n\r\n    handleError(error) { // error = { type, code, message, fatal }\r\n        this.logger.error('RxPlayer error:', error);\r\n        this.dispatchEvent(new CustomEvent(this.uiEvents.ERROR, { detail: error }));\r\n        // Categorize error based on type or code\r\n        if (error && error.type) {\r\n            switch (error.type) {\r\n                case playerErrorType.NETWORK_ERROR:\r\n                    this.logger.error('Network error occurred:', error.message);\r\n                    break;\r\n                case playerErrorType.MEDIA_ERROR:\r\n                    this.logger.error('Media error occurred:', error.message);\r\n                    break;\r\n                case playerErrorType.ENCRYPTED_MEDIA_ERROR:\r\n                    this.logger.error('DRM error occurred:', error.message);\r\n                    break;\r\n                case playerErrorType.OTHER_ERROR:\r\n                    this.logger.error('OTHER Error happened', error.message)\r\n                default:\r\n                    this.logger.error('Unknown error:', error.message);\r\n            }\r\n        } else {\r\n            this.logger.error('Player error: ' + error.message);\r\n        }\r\n    }\r\n\r\n    handleWarning(warning) {\r\n        this.dispatchEvent(new CustomEvent(this.uiEvents.WARNING, { detail: warning }));\r\n    }\r\n\r\n    handlePositionChange(obj) {\r\n        // obj = { position, duration, bufferGap, playbackRate, liveGap, maximumPosition, wallClockTime }\r\n        this.dispatchEvent(new CustomEvent(this.uiEvents.POSITION_UPDATE, { detail: obj }));\r\n    }\r\n\r\n    handlePlay() {\r\n        this.logger.info('hanldePlay Trigger ...');\r\n    }\r\n    handlePause() {\r\n        this.logger.info('handlePause Trigger ...')\r\n    }\r\n    handleSeeking() {\r\n        this.logger.warn('Seeking Playback .... ');\r\n    }\r\n    handleSeeked() {\r\n        this.logger.info('Seek Complete');\r\n    }\r\n    getAudioTrackList(arr) {\r\n        this.logger.info('BM: audioList:', JSON.stringify(arr));\r\n        this.dispatchEvent(new CustomEvent(this.uiEvents.AUDIO_TRACKLIST, { detail: arr && arr.length ? arr[0].representations : null }));\r\n    }\r\n    getVideoTrackList(arr) {\r\n        this.logger.info('BM: videoList:', playerEvents.VIDEO_TRACK_LIST, JSON.stringify(arr));\r\n        this.dispatchEvent(new CustomEvent(this.uiEvents.VIDEO_TRACKLIST, { detail: arr && arr.length ? arr[0].representations : null }));\r\n    }\r\n    getTextTrackList(arr) {\r\n        // this.logger.info('subtitleList:', this.uiEvents.VIDEO_TRACKLIST, JSON.stringify(arr));\r\n        this.dispatchEvent(new CustomEvent(this.uiEvents.VIDEO_TRACKLIST, { detail: arr && arr.length ? arr[0].representations : null }));\r\n    }\r\n    handleAudioTrackChange(obj) {\r\n        this.logger.info('Current Audio: ', JSON.stringify(obj));\r\n        // this.dispatchEvent(new CustomEvent(this.uiEvents.AUDIO_TRACKLIST, { detail: obj && obj.representations ? obj.representations : null }));\r\n    }\r\n    handleVideoTrackChange(obj) {\r\n        this.logger.info('BM: Current Video: ', playerEvents.VIDEO_TRACK_CHANGE, JSON.stringify(obj));\r\n        // this.dispatchEvent(new CustomEvent(this.uiEvents.VIDEO_TRACKLIST, { detail: obj && obj.representations ? obj.representations : null }));\r\n    }\r\n    handleTextTrackChange(obj) {\r\n        this.logger.info('Current Subtitle: ', JSON.stringify(obj));\r\n        // this.dispatchEvent(new CustomEvent(this.uiEvents.TEXT_TRACKLIST, { detail: obj && obj.representations ? obj.representations : null }));\r\n    }\r\n    handleVideoRepresentationChange(obj) {\r\n        this.logger.info('Current Video Representation: ', JSON.stringify(obj));\r\n    }\r\n    handleAudioRepresentationChange(obj) {\r\n        this.logger.info('Current Audio Representation: ', JSON.stringify(obj));\r\n    }\r\n    getPeriodList(obj) {\r\n        this.logger.info('Period List: ', JSON.stringify(obj));\r\n    }\r\n    handleVolumnChange(obj) {\r\n        this.logger.info('Volumn Info: ', JSON.stringify(obj));\r\n    }\r\n\r\n    dispatchEvent(event) {\r\n        if (this.player && Object.values(this.uiEvents).includes(event.type)) {\r\n            this.customEvent.dispatchEvent(event);\r\n        }\r\n    }\r\n\r\n    addEventListener(eventType, callback) {\r\n        if (this.player) {\r\n            if (Object.values(this.uiEvents).includes(eventType)) {\r\n                this.customEvent.addEventListener(eventType, callback);\r\n            } else {\r\n                this.player.addEventListener(eventType, callback);\r\n            }\r\n        }\r\n    }\r\n\r\n    removeEventListener(eventType, callback) {\r\n        if (this.player) {\r\n            if (Object.values(this.uiEvents).includes(eventType)) {\r\n                this.customEvent.removeEventListener(eventType, callback);\r\n            } else {\r\n                this.player.removeEventListener(eventType, callback);\r\n            }\r\n        }\r\n    }\r\n\r\n    bindEvents() {\r\n        // Basic Events\r\n        this.addEventListener(playerEvents.PLAYER_STATE_CHANGE, this.handlePlayerStateChange.bind(this));\r\n        this.addEventListener(playerEvents.ERROR, this.handleError.bind(this));\r\n        this.addEventListener(playerEvents.WARNING, this.handleWarning.bind(this));\r\n        this.addEventListener(playerEvents.POSITION_UPDATE, this.handlePositionChange.bind(this));\r\n        this.addEventListener(playerEvents.PLAY, this.handlePlay.bind(this));\r\n        this.addEventListener(playerEvents.PAUSE, this.handlePause.bind(this));\r\n        this.addEventListener(playerEvents.SEEKING, this.handleSeeking.bind(this));\r\n        this.addEventListener(playerEvents.SEEKED, this.handleSeeked.bind(this));\r\n        // Track selection events\r\n        this.addEventListener(playerEvents.AUDIO_TRACK_LIST, this.getAudioTrackList.bind(this));\r\n        this.addEventListener(playerEvents.VIDEO_TRACK_LIST, this.getVideoTrackList.bind(this));\r\n        this.addEventListener(playerEvents.TEXT_TRACK_LIST, this.getTextTrackList.bind(this));\r\n        this.addEventListener(playerEvents.AUDIO_TRACK_CHANGE, this.handleAudioTrackChange.bind(this));\r\n        this.addEventListener(playerEvents.VIDEO_TRACK_CHANGE, this.handleVideoTrackChange.bind(this));\r\n        this.addEventListener(playerEvents.TEST_TRACK_CHANGE, this.handleTextTrackChange.bind(this));\r\n        // Representation selection events\r\n        this.addEventListener(playerEvents.VIDEO_FRAME_CHANGE, this.handleVideoRepresentationChange.bind(this));\r\n        this.addEventListener(playerEvents.AUDIO_FRAME_CHANGE, this.handleAudioRepresentationChange.bind(this));\r\n        // Playback Information\r\n        this.addEventListener(playerEvents.PERIOD_LIST, this.getPeriodList.bind(this));\r\n        // this.addEventListener(playerEvents.STREAM_EVENTS, this.handleStreamEvent),\r\n        // this.addEventListener(playerEvents.STREAM_SKIP, this.handleStreamSkip),\r\n        this.addEventListener(playerEvents.VOLUME_CHANGE, this.handleVolumnChange.bind(this));\r\n    }\r\n\r\n    destroyEvents() {\r\n        // Basic Events\r\n        this.removeEventListener(playerEvents.PLAYER_STATE_CHANGE, this.handlePlayerStateChange.bind(this));\r\n        this.removeEventListener(playerEvents.ERROR, this.handleError.bind(this));\r\n        this.removeEventListener(playerEvents.WARNING, this.handleWarning.bind(this));\r\n        this.removeEventListener(playerEvents.POSITION_UPDATE, this.handlePositionChange.bind(this));\r\n        this.removeEventListener(playerEvents.PLAY, this.handlePlay.bind(this));\r\n        this.removeEventListener(playerEvents.PAUSE, this.handlePause.bind(this));\r\n        this.removeEventListener(playerEvents.SEEKING, this.handleSeeking.bind(this));\r\n        this.removeEventListener(playerEvents.SEEKED, this.handleSeeked.bind(this));\r\n        // Track selection events\r\n        this.removeEventListener(playerEvents.AUDIO_TRACK_LIST, this.getAudioTrackList.bind(this));\r\n        this.removeEventListener(playerEvents.VIDEO_TRACK_LIST, this.getVideoTrackList.bind(this));\r\n        this.removeEventListener(playerEvents.TEXT_TRACK_LIST, this.getTextTrackList.bind(this));\r\n        this.removeEventListener(playerEvents.AUDIO_TRACK_CHANGE, this.handleAudioTrackChange.bind(this));\r\n        this.removeEventListener(playerEvents.VIDEO_TRACK_CHANGE, this.handleVideoTrackChange.bind(this));\r\n        this.removeEventListener(playerEvents.TEST_TRACK_CHANGE, this.handleTextTrackChange.bind(this));\r\n        // Representation selection events\r\n        this.removeEventListener(playerEvents.VIDEO_FRAME_CHANGE, this.handleVideoRepresentationChange.bind(this));\r\n        this.removeEventListener(playerEvents.AUDIO_FRAME_CHANGE, this.handleAudioRepresentationChange.bind(this));\r\n        // Playback Information\r\n        this.removeEventListener(playerEvents.PERIOD_LIST, this.getPeriodList.bind(this));\r\n        // this.removeEventListener(playerEvents.STREAM_EVENTS, this.handleStreamEvent),\r\n        // this.removeEventListener(playerEvents.STREAM_SKIP, this.handleStreamSkip),\r\n        this.removeEventListener(playerEvents.VOLUME_CHANGE, this.handleVolumnChange.bind(this));\r\n    }\r\n\r\n    // Public API Methods\r\n    getVersion() {\r\n        return `RxPlayer:${RxPlayer.version}`;\r\n    }\r\n    \r\n    play() {\r\n        if (this.player) {\r\n            this.player.play();\r\n        }\r\n    }\r\n\r\n    pause() {\r\n        if (this.player) {\r\n            this.player.pause();\r\n        }\r\n    }\r\n\r\n    resume() {\r\n        if (this.player) {\r\n            this.player.play();\r\n        }\r\n    }\r\n\r\n    stop() {\r\n        if (this.player) {\r\n            this.player.stop();\r\n        }\r\n    }\r\n\r\n    seek(position) {\r\n        if (this.player) {\r\n            return this.player.seekTo(position);\r\n        }\r\n    }\r\n\r\n    position() {\r\n        if (this.player) {\r\n            return this.player.getPosition();\r\n        }\r\n        return null;\r\n    }\r\n\r\n    volume() {\r\n        if (this.player) {\r\n            return this.player.getVolume();\r\n        }\r\n    }\r\n\r\n    mute() {\r\n        if (this.player) {\r\n            this.player.mute();\r\n        }\r\n    }\r\n\r\n    unmute() {\r\n        if (this.player) {\r\n            this.player.unMute();\r\n        }\r\n    }\r\n\r\n    isPaused() {\r\n        if (this.player) {\r\n            return this.player.isPaused();\r\n        }\r\n    }\r\n\r\n    isMute() {\r\n        if (this.player) {\r\n            return this.player.isMute();\r\n        }\r\n    }\r\n\r\n    isBuffering() {\r\n        if (this.player) {\r\n            return this.player.isBuffering();\r\n        }\r\n    }\r\n\r\n    setVolume(volume = 0.5) {\r\n        if (this.player) {\r\n            return this.player.setVolume(volume && volume > 1 ? volume % 1 : volume);\r\n        }\r\n    }\r\n\r\n    getWallClockTime() {\r\n        if (this.player) {\r\n            return this.player.getWallClockTime();\r\n        }\r\n        return null;\r\n    }\r\n\r\n    setPlaybackRate(rate = 1) {\r\n        if (this.player) {\r\n            this.player.setPlaybackRate(rate);\r\n        } else if(!this.player.areTrickModeTracksEnabled()) {\r\n            this.logger.warn(\"playback is not active for change the playbackRate\");\r\n        }\r\n    }\r\n\r\n    setVideoTrack(obj) {\r\n        if (this.player && obj && obj.id) {\r\n            this.logger.info(\"BM: Trying to set videoTrack: \", JSON.stringify(obj));\r\n            const videoTracks = this.player.getAvailableVideoTracks(); \r\n            this.logger.info(\"BM: Available tracks:\", JSON.stringify(videoTracks));\r\n\r\n            this.player.setVideoTrack(videoTracks[0].id);\r\n        }\r\n    }\r\n\r\n    setVideoResolution(obj) {\r\n        if(this.player && obj && obj.id) {\r\n            this.logger.info(\"BM: Trying to set videoTrack Resolution: \", JSON.stringify(obj));\r\n\r\n            this.player.setVideoResolution(obj.id);\r\n        }\r\n    }\r\n\r\n    setAudioTrack(obj) {\r\n        if(this.player && obj && obj.id) {\r\n            this.logger.info(\"BM: Trying to set audioTrack: \", JSON.stringify(obj));\r\n            this.player.setAudioTrack(obj.id);\r\n        }\r\n    }\r\n\r\n    setAudioResolution(obj) {\r\n        if(this.player && obj && obj.id) {\r\n            this.logger.info(\"BM: Trying to set audioTrack Resolution: \", JSON.stringify(obj));\r\n            this.player.setAudioResolution(obj.id);\r\n        }\r\n    }\r\n\r\n    setSubtitle(obj) {\r\n        if(this.player && obj && obj.id) {\r\n            this.player.setTextTrack(obj.id);\r\n        }\r\n    }\r\n\r\n    getMinimumPosition() {\r\n        if (this.player) {\r\n            return this.player.getMinimumPosition();\r\n        }\r\n        return null;\r\n    }\r\n\r\n    getMaximumPosition() {\r\n        if (this.player) {\r\n            return this.player.getMaximumPosition();\r\n        }\r\n        return null;\r\n    }\r\n\r\n    getLivePosition() {\r\n        if (this.player) {\r\n            return this.player.getLivePosition();\r\n        }\r\n        return null;\r\n    }\r\n\r\n    duration() {\r\n        if (this.player) {\r\n            return this.player.getMediaDuration();\r\n        }\r\n        return null;\r\n    }\r\n\r\n    getError() {\r\n        if (this.player) {\r\n            return this.player.getError();\r\n        }\r\n        return null;\r\n    }\r\n\r\n    getVideoElement() {\r\n        if (this.player) {\r\n            return this.player.getVideoElement();\r\n        }\r\n        return null;\r\n    }\r\n\r\n    getAvailablePeriods() {\r\n        if (this.player) {\r\n            return this.player.getAvailablePeriods();\r\n        }\r\n        return null;\r\n    }\r\n\r\n    getCurrentPeriod() {\r\n        if (this.player) {\r\n            return this.player.getCurrentPeriod();\r\n        }\r\n        return null;\r\n    }\r\n\r\n    dispose() {\r\n        if (this.player) {\r\n            this.player.dispose();\r\n            this.player = null;\r\n        }\r\n    }\r\n\r\n    reload(options) {\r\n        if (this.player) {\r\n            return this.player.reload(options);\r\n        }\r\n    }\r\n}\r\n\r\nexport default RxMediaPlayer;\r\n","import appConfig from '../const/appConfig'\r\nclass Logger {\r\n  constructor(tag = '') {\r\n    this.tag = `[${tag}] `;\r\n  }\r\n\r\n  error(...text) {\r\n    this.log(Logger.level.error, text);\r\n  }\r\n  warn(...text) {\r\n    this.log(Logger.level.warn, text);\r\n  }\r\n  info(...text) {\r\n    this.log(Logger.level.info, text);\r\n  }\r\n  debug(...text) {\r\n    this.log(Logger.level.debug, text);\r\n  }\r\n\r\n  log(type, ...text) {\r\n    if (Logger.levelKey[type] > Logger.levelKey[appConfig.LOG_LEVEL]) return;\r\n    const msg = this.tag + (text[0] && text[0].length ? text[0].join(' ') : '');\r\n    switch (type) {\r\n      case Logger.level.error:\r\n        console.error(msg);\r\n        break;\r\n      case Logger.level.warn:\r\n        console.warn(msg);\r\n        break;\r\n      case Logger.level.info:\r\n        console.info(msg);\r\n        break;\r\n      case Logger.level.debug:\r\n        console.debug(msg);\r\n        break;\r\n      default:\r\n        console.log(msg);\r\n    }\r\n  }\r\n}\r\n\r\nLogger.level = {\r\n  none: 'none',\r\n  error: 'error',\r\n  warn: 'warn',\r\n  info: 'info',\r\n  debug: 'debug'\r\n};\r\n\r\nLogger.levelKey = {\r\n  none: 0,\r\n  error: 1,\r\n  warn: 2,\r\n  info: 3,\r\n  debug: 4\r\n};\r\n\r\nexport default Logger;\r\n","import appConfig from '../const/appConfig'\r\n\r\nclass Utils {\r\n    static uiControls(htmlDom) {\r\n        return {\r\n            PLAYER_VERSION: htmlDom.getElementById(appConfig.PLAYER_VERSION),\r\n\r\n            RESTART_BTN:    htmlDom.getElementById(appConfig.uiButton.RESTART),\r\n            REWIND_BTN:     htmlDom.getElementById(appConfig.uiButton.REWIND),\r\n            PLAYPAUSE_BTN:  htmlDom.getElementById(appConfig.uiButton.PLAYPAUSE),\r\n            FARWARD_BTN:    htmlDom.getElementById(appConfig.uiButton.FARWARD),\r\n            STOP_BTN:       htmlDom.getElementById(appConfig.uiButton.STOP),\r\n            \r\n            VIDEO_SEEKBAR:  htmlDom.getElementById(appConfig.videoPos.PROGRESSBAR),\r\n            STARTTIME:      htmlDom.querySelector(appConfig.videoPos.CURRENTTIME),\r\n            ENDTIME:        htmlDom.querySelector(appConfig.videoPos.DURATION),\r\n            \r\n            VOLUME_BAR:     htmlDom.getElementById(appConfig.uiVolumn.PROGRESSBAR),\r\n            VOLUME_BTN:     htmlDom.getElementById(appConfig.uiVolumn.VOLUMN),\r\n\r\n            PLAYBACK_SPEED: htmlDom.getElementById(appConfig.quality.PLAYBACKSPEED),\r\n            SUBTITLE_TRACKS:htmlDom.getElementById(appConfig.quality.SUBTITLE_TRACKS),\r\n\r\n            VIDEO_TRACKS:   htmlDom.getElementById(appConfig.quality.VIDEO_TRACKS),\r\n            AUDIO_TRACKS:   htmlDom.getElementById(appConfig.quality.AUDIO_TRACKS),\r\n            VIDEO_RESOLUTION_LIST: htmlDom.getElementById(appConfig.quality.VIDEO_QUALITY_LIST),\r\n            AUDIO_RESOLUTION_LIST: htmlDom.getElementById(appConfig.quality.AUDIO_QUALITY_LIST),\r\n        }\r\n    }\r\n\r\n    static formatTime(seconds) {\r\n        const hrs = Math.floor(seconds / 3600);\r\n        const mins = Math.floor((seconds % 3600) / 60);\r\n        const secs = Math.floor(seconds % 60);\r\n        return [hrs, mins, secs]\r\n            .map((v) => v < 10 ? '0' + v : v)\r\n            .join(':');\r\n    }\r\n\r\n    static seekBarPercent(currentTime, duration) {\r\n        return Number(((currentTime / duration) * 100).toFixed(2));\r\n    }\r\n\r\n    static seekBarPercentToTime(progressBarVal = 0, duration) {\r\n        return (progressBarVal / 100) * duration;\r\n    }\r\n\r\n    static bitrateToQuality(bitrate) {\r\n        if (bitrate >= 4000000) return '1080p';\r\n        if (bitrate >= 2500000) return '720p';\r\n        if (bitrate >= 1000000) return '480p';\r\n        if (bitrate >= 500000) return '360p';\r\n        if (bitrate >= 250000) return '240p';\r\n        return '144p';\r\n    }\r\n\r\n    static bitrateToMbps(bitrate) {\r\n        return `${(bitrate / 1000000).toFixed(2)} Mbps`;\r\n    }\r\n    static bitrateToKbps(bitrate) {\r\n        return `${(bitrate / 1000).toFixed(2)} Kbps`;\r\n    }\r\n    static isSafari() {\r\n        return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\r\n    }\r\n}\r\n\r\nexport default Utils;\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import '../css/style.css';\r\nimport mediaList from '../config/assetInfo';\r\nimport { OTTMediaPlayer } from './solutions';\r\nimport Utils from './utils/utils';\r\nimport appConfig from './const/appConfig';\r\nimport appEvents from './const/appEvents';\r\nimport Logger from './utils/logger';\r\nimport appState from './const/appState';\r\n\r\nclass App {\r\n    constructor() {\r\n        this.tag = `App`;\r\n        this.logger = new Logger(this.tag);\r\n        this.assetSelect = document.getElementById('asset-select');\r\n        this.populateAssetSelect();\r\n        this.loadSelectedStream(mediaList.dash[0])\r\n    }\r\n\r\n    loadSelectedStream(selectedStreamInfo = null) {\r\n        this.stream = selectedStreamInfo ? selectedStreamInfo : this.stream;\r\n        this.manifestUrl = this.stream.manifestURL;\r\n        this.drmConfig = this.stream.drmOptions || null;\r\n        this.playerConfig = {\r\n            videoElement: document.getElementById('video')\r\n        };\r\n\r\n        // Initialize the player\r\n        this.myPlayer = new OTTMediaPlayer(this.manifestUrl, this.playerConfig, this.drmConfig);\r\n        // UI Player Inputs\r\n        this.uiButtons = Utils.uiControls(document);\r\n        this.updatePlayerInfo(this.myPlayer.getVersion());\r\n        // Load the player\r\n        this.myPlayer.initialize();\r\n        this.myPlayer.load();\r\n        \r\n        this.bindEvents();\r\n    }\r\n\r\n    updatePlayerInfo(playerVersion) {\r\n        this.uiButtons.PLAYER_VERSION.textContent = playerVersion;\r\n        const playerVersionLink = this.uiButtons.PLAYER_VERSION.closest('a');\r\n        if (playerVersionLink) {\r\n            playerVersionLink.href = \"https://developers.canal-plus.com/rx-player/versions/4.3.0/doc/api/Overview.html\";\r\n            playerVersionLink.title = \"View RxPlayer Documentation\";\r\n        }\r\n    }\r\n\r\n    populateAssetSelect() {\r\n        // Clear existing options\r\n        this.assetSelect.innerHTML = '';\r\n        const mediaInfo = Utils.isSafari() ? mediaList.hls : mediaList.dash;\r\n\r\n        mediaInfo.forEach((asset, index) => {\r\n            const option = document.createElement('option');\r\n            option.value = `dash-${index}`;\r\n            option.text = `DASH - ${asset.title || asset.manifestURL}`;\r\n            if (index === 0) option.selected = true; // Select the first DASH asset by default\r\n            this.assetSelect.appendChild(option);\r\n        });\r\n    }\r\n\r\n    bindEvents() {\r\n        // Player Controls Buttons\r\n        this.uiButtons.RESTART_BTN.addEventListener('click', () => this.resetPlayback());\r\n        this.uiButtons.REWIND_BTN.addEventListener('click', () => this.rewind());\r\n        this.uiButtons.PLAYPAUSE_BTN.addEventListener('click', () => this.togglePlayPause());\r\n        this.uiButtons.FARWARD_BTN.addEventListener('click', () => this.fastForward());\r\n        this.uiButtons.STOP_BTN.addEventListener('click', () => this.stopPlayback());\r\n        this.uiButtons.PLAYBACK_SPEED.addEventListener('change', () => this.changePlaybackSpeed());\r\n        // Volumn Buttons\r\n        this.uiButtons.VOLUME_BAR.addEventListener('input', () => this.changeVolume());\r\n        this.uiButtons.VOLUME_BTN.addEventListener('click', () => this.toggleMute());\r\n        // Video-Audio Quality & speed\r\n        this.uiButtons.VIDEO_TRACKS.addEventListener('change', () => this.changeVideoType());\r\n        this.uiButtons.AUDIO_TRACKS.addEventListener('change', () => this.changeAudioType());\r\n        this.uiButtons.VIDEO_RESOLUTION_LIST.addEventListener('change', () => this.changeVideoResolution());\r\n        this.uiButtons.AUDIO_RESOLUTION_LIST.addEventListener('change', () => this.changeAudioResolution());\r\n        this.uiButtons.SUBTITLE_TRACKS.addEventListener('change', () => this.changeSubtitleTrack());\r\n        // Player Position & SeekBar\r\n        this.uiButtons.VIDEO_SEEKBAR.addEventListener('input', () => this.seekVideo());\r\n        // Asset Selection\r\n        this.assetSelect.addEventListener('change', () => this.changeAsset());\r\n\r\n        // Listen to custom appEvents from Solution Player class\r\n        this.myPlayer.customEvent.addEventListener(appEvents.POSITION_UPDATE, (event) => this.updateProgress(event.detail));\r\n        this.myPlayer.customEvent.addEventListener(appEvents.AUDIO_TRACKLIST, (event) => this.updateDropdowns(appConfig.quality.AUDIO_QUALITY_LIST, event.detail));\r\n        this.myPlayer.customEvent.addEventListener(appEvents.VIDEO_TRACKLIST, (event) => this.updateDropdowns(appConfig.quality.VIDEO_QUALITY_LIST, event.detail));\r\n        this.myPlayer.customEvent.addEventListener(appEvents.SUBTITLE_TRACKS, (event) => this.updateDropdowns(appConfig.quality.SUBTITLE_TRACKS, event.detail));\r\n\r\n        this.myPlayer.customEvent.addEventListener(appEvents.CURRENT_STATE, (event) => this.checkState(event.detail));\r\n        this.myPlayer.customEvent.addEventListener(appEvents.ERROR, (event) => {\r\n            console.error('xx: Custom Event - Player Error:', event);\r\n        });\r\n        this.myPlayer.customEvent.addEventListener(appEvents.WARNING, (event) => {\r\n            console.warn('xx: Custom Event - Player Warning:', event);\r\n        });\r\n    }\r\n\r\n    destroy() {\r\n        if(this.player) {\r\n            this.player.destroy();\r\n        }\r\n    }\r\n\r\n    togglePlayPause() {\r\n        this.myPlayer.isPaused() ? this.myPlayer.play() : this.myPlayer.pause();\r\n        this.updateButtonStates(appConfig.uiButton.PLAYPAUSE);\r\n    }\r\n\r\n    changeVolume() {\r\n        this.myPlayer.setVolume(parseFloat(this.uiButtons.VOLUME_BAR.value));\r\n        this.updateButtonStates(appConfig.uiVolumn.VOLUMN);\r\n    }\r\n\r\n    toggleMute() {\r\n        this.myPlayer.isMute() ? this.myPlayer.unmute() : this.myPlayer.mute();\r\n        this.updateButtonStates(appConfig.uiVolumn.VOLUMN);\r\n    }\r\n\r\n    resetPlayback() {\r\n        this.myPlayer.seek(0);\r\n        this.uiButtons.VIDEO_SEEKBAR.value = 0;\r\n        // Reset CSS variable for progress fill\r\n        this.uiButtons.VIDEO_SEEKBAR.style.setProperty('--progress', '0%');\r\n        this.myPlayer.play();\r\n        this.updateButtonStates(appConfig.uiButton.PLAYPAUSE);\r\n    }\r\n\r\n    rewind() {\r\n        const currentTime = this.myPlayer.position();\r\n        this.myPlayer.seek(Math.max(0, currentTime - 10));\r\n    }\r\n\r\n    fastForward() {\r\n        const currentTime = this.myPlayer.position();\r\n        const duration = this.myPlayer.duration();\r\n        this.myPlayer.seek(Math.min(duration, currentTime + 10));\r\n    }\r\n\r\n    stopPlayback() {\r\n        this.myPlayer.stop();\r\n        this.updateButtonStates(appConfig.uiButton.PLAYPAUSE);\r\n    }\r\n\r\n    changePlaybackSpeed() {\r\n        const speed = this.uiButtons.PLAYBACK_SPEED.value ? parseFloat(this.uiButtons.PLAYBACK_SPEED.value) : 1;\r\n        this.myPlayer.setPlaybackRate(speed);\r\n    }\r\n\r\n    changeVideoType() {\r\n        this.logger.info(`BM: Audio quality changed to ${this.uiButtons.VIDEO_TRACKS.value}`);\r\n        // Implement actual video quality change logic if supported by player\r\n        this.myPlayer.setVideoTrack({id: this.uiButtons.VIDEO_TRACKS.value});\r\n    }\r\n\r\n    changeVideoResolution() {\r\n        this.logger.info(`Video resolution quality changed to ${this.uiButtons.VIDEO_RESOLUTION_LIST.value}`);\r\n        this.player.setVideoResolution({id: this.uiButtons.VIDEO_RESOLUTION_LIST.value});   \r\n    }\r\n    \r\n    changeAudioType() {\r\n        this.logger.info(`Audio quality changed to ${this.uiButtons.AUDIO_TRACKS.value}`);\r\n        // Implement actual audio quality change logic if supported by player\r\n        this.myPlayer.setAudioTrack({id: this.uiButtons.AUDIO_TRACKS.value});\r\n    }\r\n\r\n    changeAudioResolution() {\r\n        this.logger.info(`Audio resolution quality changed to ${this.uiButtons.AUDIO_RESOLUTION_LIST.value}`);\r\n        this.player.setAudioResolution({id: this.uiButtons.AUDIO_RESOLUTION_LIST.value});\r\n    }\r\n\r\n    changeSubtitleTrack() {\r\n        this.logger.info(`Subtitle quality changed to ${this.uiButtons.SUBTITLE_TRACKS.value}`);\r\n        // Implement actual audio quality change logic if supported by player\r\n        this.myPlayer.setSubtitle({id: this.uiButtons.SUBTITLE_TRACKS.value});\r\n    }\r\n\r\n\r\n    updateProgress(obj = { position: 0, duration: 0 }) {\r\n        if (obj && obj.position !== undefined && obj.duration !== undefined) {\r\n            this.uiButtons.STARTTIME.textContent = Utils.formatTime(obj.position);\r\n            this.uiButtons.ENDTIME.textContent = Utils.formatTime(obj.duration);\r\n\r\n            if (obj.duration > 0) {\r\n                const progressPercent = Utils.seekBarPercent(obj.position, obj.duration);\r\n                this.uiButtons.VIDEO_SEEKBAR.value = progressPercent;\r\n                // Update CSS variable for red progress fill\r\n                this.uiButtons.VIDEO_SEEKBAR.style.setProperty('--progress', progressPercent + '%');\r\n            }\r\n        }\r\n    }\r\n\r\n    seekVideo() {\r\n        const duration = this.myPlayer.duration();\r\n        if (duration > 0) {\r\n            const seekTime = Utils.seekBarPercentToTime(this.uiButtons.VIDEO_SEEKBAR.value, duration);\r\n            this.myPlayer.seek(seekTime);\r\n        }\r\n    }\r\n\r\n    checkState(state) {\r\n        this.logger.info('Player State Changed to:', state);\r\n        switch (state) {\r\n            case appState.LOADING:\r\n            case appState.BUFFERING:\r\n                // TODO: Show loading spinner\r\n                break;\r\n            case appState.LOADED:\r\n                // TODO: Hide Loading spinner\r\n                break;\r\n            case appState.PLAYING:\r\n            case appState.PAUSED:\r\n                this.updateButtonStates(appConfig.uiButton.PLAYPAUSE);\r\n                break;\r\n            case appState.SEEKING:\r\n                this.updateButtonStates(appConfig.uiButton.PLAYPAUSE);\r\n                break;\r\n            case appState.STOPPED:\r\n                this.uiButtons.VIDEO_SEEKBAR.value = 0;\r\n                // Reset CSS variable for progress fill\r\n                this.uiButtons.VIDEO_SEEKBAR.style.setProperty('--progress', '0%');\r\n                this.uiButtons.STARTTIME.textContent = '00:00';\r\n                this.uiButtons.ENDTIME.textContent = '00:00';\r\n                this.updateButtonStates(appConfig.uiButton.PLAYPAUSE);\r\n                break;\r\n            default:\r\n                this.logger.error('Trigger Invalid App State: ', state);\r\n                break;\r\n        }\r\n    }\r\n\r\n    updateDropdowns(dropdownType, trackList) {\r\n        let uiDropDownItem = null;\r\n        switch (dropdownType) {\r\n            case appConfig.quality.VIDEO_TRACKS:\r\n                uiDropDownItem = this.uiButtons.VIDEO_TRACKS;\r\n                break;\r\n            case appConfig.quality.AUDIO_TRACKS:\r\n                uiDropDownItem = this.uiButtons.AUDIO_TRACKS;\r\n                break;\r\n            case appConfig.quality.VIDEO_QUALITY_LIST:\r\n                uiDropDownItem = this.uiButtons.VIDEO_RESOLUTION_LIST;\r\n                break;\r\n            case appConfig.quality.AUDIO_QUALITY_LIST:\r\n                uiDropDownItem = this.uiButtons.AUDIO_RESOLUTION_LIST;\r\n                break;\r\n            case appConfig.quality.SUBTITLE_TRACKS:\r\n                uiDropDownItem = this.uiButtons.SUBTITLE_TRACKS;\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n\r\n        if(uiDropDownItem) {\r\n            if (trackList && trackList.length) {\r\n                uiDropDownItem.hidden = false;\r\n                uiDropDownItem.innerHTML = '';\r\n                trackList.forEach((track, index) => {\r\n                    const option = document.createElement('option');\r\n                    option.value = track.id;\r\n                    option.text = `${Utils.bitrateToMbps(track.bitrate)} - ${track.codec}`;\r\n                    uiDropDownItem.appendChild(option);\r\n                });\r\n            } else {\r\n                uiDropDownItem.hidden = true;\r\n                uiDropDownItem.innerHTML = '';\r\n                const option = document.createElement('option');\r\n                option.text = `No Video List`;\r\n                uiDropDownItem.appendChild(option);\r\n                this.logger.error('No Video list avaliable');\r\n            }\r\n        } else {\r\n            this.logger.error('Invalid dropdown type specified:', dropdownType);\r\n        }\r\n    }\r\n\r\n    updateButtonStates(buttonType) {\r\n        switch (buttonType) {\r\n            case appConfig.uiButton.PLAYPAUSE:\r\n                this.uiButtons.PLAYPAUSE_BTN.querySelector('i').classList.remove(this.myPlayer.isPaused() ? 'fa-pause' : 'fa-play');\r\n                this.uiButtons.PLAYPAUSE_BTN.querySelector('i').classList.add(this.myPlayer.isPaused() ? 'fa-play' : 'fa-pause');\r\n                break;\r\n            case appConfig.uiVolumn.VOLUMN:\r\n                this.uiButtons.VOLUME_BTN.querySelector('i').classList.remove(this.myPlayer.isMute() ? 'fa-volume-up' : 'fa-volume-mute');\r\n                this.uiButtons.VOLUME_BTN.querySelector('i').classList.add(this.myPlayer.isMute() ? 'fa-volume-mute' : 'fa-volume-up');\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n\r\n    changeAsset() {\r\n        const selectedValue = this.assetSelect.value;\r\n        if (!selectedValue) return;\r\n\r\n        const [type, indexStr] = selectedValue.split('-');\r\n        const index = parseInt(indexStr, 10);\r\n        const mediaInfo = Utils.isSafari() ? mediaList.hls : mediaList.dash;\r\n        this.stream = mediaInfo[index];\r\n\r\n        if (!this.stream) {\r\n            console.warn('Unknown asset type selected:', type);\r\n            return;\r\n        }\r\n        if(this.player) {\r\n            this.player.stop();\r\n            this.destroy();\r\n        }\r\n        setTimeout(() => {\r\n            this.loadSelectedStream()\r\n        }, 2000);\r\n    }\r\n}\r\n\r\ndocument.addEventListener('DOMContentLoaded', () => {\r\n    new App();\r\n\r\n    // Sidebar toggle button functionality\r\n    const toggleSidebar = document.getElementById('toggle-sidebar');\r\n    const container = document.querySelector('.container');\r\n\r\n    setupSidebarToggle(toggleSidebar, container);\r\n\r\n    // Seekbar tooltip functionality\r\n    const progressSlider = document.getElementById('progress');\r\n    const tooltip = document.getElementById('progress-tooltip');\r\n\r\n    updateSeekbarTooltip(progressSlider, tooltip);\r\n\r\n    // Toggle icon functionality\r\n    const toggleIcons = document.querySelectorAll('.toggle-icon');\r\n\r\n    toggleIcons.forEach(icon => {\r\n        icon.addEventListener('click', () => {\r\n            const isChecked = icon.dataset.checked === 'true';\r\n            if (isChecked) {\r\n                icon.className = 'fa fa-eye-slash toggle-icon';\r\n                icon.dataset.checked = 'false';\r\n            } else {\r\n                icon.className = 'fa fa-eye toggle-icon';\r\n                icon.dataset.checked = 'true';\r\n            }\r\n        });\r\n    });\r\n});\r\n\r\nfunction updateSeekbarTooltip(progressSlider, tooltip) {\r\n    function updateTooltip() {\r\n        const value = progressSlider.value;\r\n        const percentage = value + '%';\r\n        tooltip.textContent = percentage;\r\n\r\n        // Update progress bar fill\r\n        progressSlider.style.setProperty('--progress', percentage);\r\n\r\n        // Position the tooltip\r\n        const sliderRect = progressSlider.getBoundingClientRect();\r\n        const sliderWidth = sliderRect.width;\r\n        const thumbPosition = (value / 100) * sliderWidth;\r\n        tooltip.style.left = thumbPosition + 'px';\r\n    }\r\n\r\n    progressSlider.addEventListener('input', () => {\r\n        updateTooltip();\r\n        tooltip.style.opacity = '1';\r\n    });\r\n\r\n    progressSlider.addEventListener('mouseover', () => {\r\n        updateTooltip();\r\n        tooltip.style.opacity = '1';\r\n    });\r\n\r\n    progressSlider.addEventListener('mouseout', () => {\r\n        tooltip.style.opacity = '0';\r\n    });\r\n\r\n    // Initial update\r\n    updateTooltip();\r\n}\r\n\r\nfunction setupSidebarToggle(toggleSidebar, container) {\r\n    toggleSidebar.addEventListener('click', () => {\r\n        container.classList.toggle('left-hidden');\r\n    });\r\n}\r\n\r\n"],"names":["mediaInfo","title","manifestURL","drmOptions","PlayReady","laURL","priority","requestHeaderKey","WideVine","clearkey","hls","url","PLAYER_VERSION","uiButton","RESTART","REWIND","PLAYPAUSE","FARWARD","STOP","videoPos","PROGRESSBAR","CURRENTTIME","DURATION","uiVolumn","VOLUMN","quality","PLAYBACKSPEED","SUBTITLE_TRACKS","VIDEO_TRACKS","AUDIO_TRACKS","VIDEO_QUALITY_LIST","AUDIO_QUALITY_LIST","LOG_LEVEL","appEvents","CURRENT_STATE","ERROR","WARNING","POSITION_UPDATE","AUDIO_TRACKLIST","VIDEO_TRACKLIST","appState","LOADING","LOADED","PLAYING","PAUSED","BUFFERING","SEEKING","STOPPED","OTTMediaPlayer","playerErrorType","NETWORK_ERROR","MEDIA_ERROR","ENCRYPTED_MEDIA_ERROR","OTHER_ERROR","ErrorCodeType","NETWORK_ERR_TYPE","MEDIA_ERR_TYPE","ENCRYPTED_MEDIA_ERR_TYPE","OTHER_ERR_TYPE","playerEvents","PLAYER_STATE_CHANGE","PLAY","PAUSE","SEEKED","AUDIO_TRACK_LIST","VIDEO_TRACK_LIST","TEXT_TRACK_LIST","AUDIO_TRACK_CHANGE","VIDEO_TRACK_CHANGE","TEST_TRACK_CHANGE","VIDEO_FRAME_CHANGE","AUDIO_FRAME_CHANGE","REPRESENTATIONLISTUPDATE","BROKENREPRESENTATIONSLOCK","PERIODCHANGE","PERIOD_LIST","TRACKUPDATE","INBANDEVENTS","STREAMEVENT","STREAMEVENTSKIP","VOLUME_CHANGE","playerState","FREEZING","ENDED","RELOADING","RxPlayer","Logger","LogFormat","LogLevel","RxMediaPlayer","manifestUrl","playerConfig","arguments","length","undefined","drmConfig","_classCallCheck","tag","concat","version","logger","uiEvents","player","customEvent","EventTarget","_createClass","key","value","initialize","videoElement","Error","load","_this","bindEvents","loadOptions","transport","autoPlay","configureDRM","loadResult","loadVideo","error","clearkeyStr","_clearkeyStr$split","split","_clearkeyStr$split2","_slicedToArray","kid","fallbackKeyIds","fallbackKeys","widevine","licenseServerUrl","serverCertificateUrl","httpRequestHeaders","playready","fairplay","handlePlayerStateChange","state","warn","dispatchEvent","CustomEvent","detail","debug","handleError","type","message","handleWarning","warning","handlePositionChange","obj","handlePlay","info","handlePause","handleSeeking","handleSeeked","getAudioTrackList","arr","JSON","stringify","representations","getVideoTrackList","getTextTrackList","handleAudioTrackChange","handleVideoTrackChange","handleTextTrackChange","handleVideoRepresentationChange","handleAudioRepresentationChange","getPeriodList","handleVolumnChange","event","Object","values","includes","addEventListener","eventType","callback","removeEventListener","bind","destroyEvents","getVersion","play","pause","resume","stop","seek","position","seekTo","getPosition","volume","getVolume","mute","unmute","unMute","isPaused","isMute","isBuffering","setVolume","getWallClockTime","setPlaybackRate","rate","areTrickModeTracksEnabled","setVideoTrack","id","videoTracks","getAvailableVideoTracks","setVideoResolution","setAudioTrack","setAudioResolution","setSubtitle","setTextTrack","getMinimumPosition","getMaximumPosition","getLivePosition","duration","getMediaDuration","getError","getVideoElement","getAvailablePeriods","getCurrentPeriod","dispose","reload","options","appConfig","_len","text","Array","_key","log","level","_len2","_key2","_len3","_key3","_len4","_key4","levelKey","_len5","_key5","msg","join","console","none","Utils","uiControls","htmlDom","getElementById","RESTART_BTN","REWIND_BTN","PLAYPAUSE_BTN","FARWARD_BTN","STOP_BTN","VIDEO_SEEKBAR","STARTTIME","querySelector","ENDTIME","VOLUME_BAR","VOLUME_BTN","PLAYBACK_SPEED","VIDEO_RESOLUTION_LIST","AUDIO_RESOLUTION_LIST","formatTime","seconds","hrs","Math","floor","mins","secs","map","v","seekBarPercent","currentTime","Number","toFixed","seekBarPercentToTime","progressBarVal","bitrateToQuality","bitrate","bitrateToMbps","bitrateToKbps","isSafari","test","navigator","userAgent","mediaList","App","assetSelect","document","populateAssetSelect","loadSelectedStream","dash","selectedStreamInfo","stream","myPlayer","uiButtons","updatePlayerInfo","playerVersion","textContent","playerVersionLink","closest","href","innerHTML","forEach","asset","index","option","createElement","selected","appendChild","_this2","resetPlayback","rewind","togglePlayPause","fastForward","stopPlayback","changePlaybackSpeed","changeVolume","toggleMute","changeVideoType","changeAudioType","changeVideoResolution","changeAudioResolution","changeSubtitleTrack","seekVideo","changeAsset","updateProgress","updateDropdowns","checkState","destroy","updateButtonStates","parseFloat","style","setProperty","max","min","speed","progressPercent","seekTime","dropdownType","trackList","uiDropDownItem","hidden","track","codec","buttonType","classList","remove","add","_this3","selectedValue","_selectedValue$split","_selectedValue$split2","indexStr","parseInt","setTimeout","toggleSidebar","container","setupSidebarToggle","progressSlider","tooltip","updateSeekbarTooltip","toggleIcons","querySelectorAll","icon","isChecked","dataset","checked","className","updateTooltip","percentage","sliderRect","getBoundingClientRect","sliderWidth","width","thumbPosition","left","opacity","toggle"],"sourceRoot":""}